<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Ceph 命令注册及执行流程 | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文系统分析了Ceph命令行接口的两种类型：Local Commands（本地命令）和Monitor Commands（监控器命令）。Local Commands通过各组件（MON&#x2F;MGR&#x2F;OSD&#x2F;MDS）的admin socket注册和执行，详细阐述了各组件命令注册的具体函数调用链路及初始化流程。Monitor Commands则通过Monitor处理，包含Monitor自身命令和Manager"><meta property="og:type" content="article"><meta property="og:title" content="Ceph 命令注册及执行流程"><meta property="og:url" content="https://bugwz.com/2025/12/06/ceph-cmd-register-exec/index.html"><meta property="og:site_name" content="咕咕"><meta property="og:description" content="本文系统分析了Ceph命令行接口的两种类型：Local Commands（本地命令）和Monitor Commands（监控器命令）。Local Commands通过各组件（MON&#x2F;MGR&#x2F;OSD&#x2F;MDS）的admin socket注册和执行，详细阐述了各组件命令注册的具体函数调用链路及初始化流程。Monitor Commands则通过Monitor处理，包含Monitor自身命令和Manager"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bugwz.com/assets/images/bg/ceph.webp"><meta property="article:published_time" content="2025-12-05T16:00:00.000Z"><meta property="article:modified_time" content="2026-01-28T14:54:30.213Z"><meta property="article:author" content="bugwz"><meta property="article:tag" content="Ceph"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bugwz.com/assets/images/bg/ceph.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ceph 命令注册及执行流程",
  "url": "https://bugwz.com/2025/12/06/ceph-cmd-register-exec/",
  "image": "https://bugwz.com/assets/images/bg/ceph.webp",
  "datePublished": "2025-12-05T16:00:00.000Z",
  "dateModified": "2026-01-28T14:54:30.213Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2025/12/06/ceph-cmd-register-exec/index.html"><link rel="preconnect"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><noscript><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"></noscript><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:500,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Ceph 命令注册及执行流程",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/self/github-dark.css" media="print" onload='this.media="all"'><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">137</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/assets/images/bg/ceph.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">Ceph 命令注册及执行流程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Ceph 命令注册及执行流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-05T16:00:00.000Z" title="发表于 2025-12-06 00:00:00">2025-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-28T14:54:30.213Z" title="更新于 2026-01-28 22:54:30">2026-01-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.7k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>本文的内容基于 Ceph <a target="_blank" rel="noopener" href="https://github.com/ceph/ceph/tree/v20.2.0">v20.2.0</a> 版本进行分析。</p><p>分析 <code>ceph -h</code> 的输出信息可以看到，其支持两种类型的命令，分别是 <strong>Local Commands</strong> 和 <strong>Monitor Commands</strong>。其中 <strong>Local Commands</strong> 比较典型的就是 <code>ceph daemon {type.id|path} &lt;cmd&gt;</code> 命令，用于直接和本地组件的 socket 进行通信，执行一些命令。而 <strong>Monitor Commands</strong> 则是将相关命令发送给 Monitor，有些是由 Monitor 自身处理该命令并返回，也有一些只是经由 Monitor 中转给其他组件执行（比如 <code>ceph tell osd.0 *</code> 等命令）。</p><ul><li>对于 <strong>Local Commands</strong>，我们分析每个组件（MON&#x2F;MGR&#x2F;OSD&#x2F;MDS）的 admin socket 命令的注册和执行流程；</li><li>对于 <strong>Monitor Commands</strong>，我们分析</li></ul><h1 id="二、Local-Commands-分析"><a href="#二、Local-Commands-分析" class="headerlink" title="二、Local Commands 分析"></a>二、Local Commands 分析</h1><p>对于本地的命令，我们仅分析每个组件的 admin socket 的命令注册和执行的流程。注意：虽然 <code>ceph daemon {type.id|path} &lt;cmd&gt;</code> 和 <code>ceph tell &lt;type.id&gt; &lt;args&gt;...</code> 可以达到相同的效果，但是两个命令的执行链路并不相同。</p><h2 id="2-1、命令注册流程"><a href="#2-1、命令注册流程" class="headerlink" title="2.1、命令注册流程"></a>2.1、命令注册流程</h2><ul><li>所有注册的命令存储在 AdminSocket 类的成员变量 hooks 中，其类型为 std::multimap&lt;std::string, hook_info, std::less&lt;&gt;&gt;；</li><li>所有 admin socket 命令都是通过执行 AdminSocket::register_command 函数注册的，注册时允许重复 key ，但是要求相同命令的 desc 要不同；</li><li>之后通过调用 common_init_finish 和 AdminSocket::init 函数来初始化对应的 Unix Socket；</li><li>AdminSocket::init 函数内部会启动一个 admin_socket 的线程来接受和处理 socket 请求，对应的线程入口函数为 AdminSocket::entry ；</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AdminSocket::register_command</span><span class="hljs-params">(std::string_view cmddesc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  AdminSocketHook *hook,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  std::string_view help)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> ret;<br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">l</span><span class="hljs-params">(lock)</span></span>;<br>  string prefix = <span class="hljs-built_in">cmddesc_get_prefix</span>(cmddesc);<br>  <span class="hljs-keyword">auto</span> i = hooks.<span class="hljs-built_in">find</span>(prefix);<br>  <span class="hljs-keyword">if</span> (i != hooks.<span class="hljs-built_in">cend</span>() &amp;&amp;<br>      i-&gt;second.desc == cmddesc)<br>  &#123;<br>    <span class="hljs-built_in">ldout</span>(m_cct, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;register_command &quot;</span> &lt;&lt; prefix<br>                    &lt;&lt; <span class="hljs-string">&quot; cmddesc &quot;</span> &lt;&lt; cmddesc &lt;&lt; <span class="hljs-string">&quot; hook &quot;</span> &lt;&lt; hook<br>                    &lt;&lt; <span class="hljs-string">&quot; EEXIST&quot;</span> &lt;&lt; dendl;<br>    ret = -EEXIST;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">ldout</span>(m_cct, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;register_command &quot;</span> &lt;&lt; prefix &lt;&lt; <span class="hljs-string">&quot; hook &quot;</span> &lt;&lt; hook<br>                    &lt;&lt; dendl;<br>    hooks.<span class="hljs-built_in">emplace_hint</span>(i,<br>                       std::piecewise_construct,<br>                       std::forward_as_tuple(prefix),<br>                       std::forward_as_tuple(hook, cmddesc, help));<br>    ret = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-1、MON"><a href="#2-1-1、MON" class="headerlink" title="2.1.1、MON"></a>2.1.1、MON</h3><p>monitor 服务的启动服务入口为 <code>src/ceph_mon.cc</code> 文件。</p><p><strong>注册命令的函数:</strong></p><ul><li><strong>CephContext::CephContext 构造函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>config</code> 等命令，注意其中有些命令的 help 字段内容为空，当使用客户端获取可执行的命令，这些命令并不会在命令列表中展示，但是仍然可以被执行；</li><li><strong>MempoolObs::MempoolObs 构造函数</strong> : 其中仅注册了一个 <code>dump_mempools</code> 命令；</li><li><strong>AdminSocket::init 函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>version</code>，<code>git_version</code>， <code>help</code> 等命令，其中 <code>help</code> 命令在输出可用命令时会过滤每个已注册命令的 help 字段，如果为空则不输出对应的命令；</li><li><strong>AsyncMessenger::AsyncMessenger 构造函数</strong> : 其中仅注册了一个 <code>messenger dump</code> 命令；</li><li><strong>Monitor::preinit 函数</strong> : 其中注册了大量的使用 COMMAND_WITH_FLAG 宏定义的带有 FLAG(TELL) 的命令；</li></ul><p><strong>注册命令的函数调用链路:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">+ main -&gt; global_init -&gt; global_pre_init -&gt; common_preinit -&gt; CephContext::CephContext -&gt; register_command<br>+ CephContext::CephContext -&gt; MempoolObs::MempoolObs -&gt; register_command<br>+ main -&gt; common_init_finish -&gt; CephContext::start_service_thread -&gt; AdminSocket::init -&gt; register_command<br>+ main -&gt; Messenger::create -&gt; AsyncMessenger::AsyncMessenger -&gt; register_command<br>+ main -&gt; Monitor::preinit -&gt; register_command<br></code></pre></td></tr></table></figure><p><strong>注册命令的函数调用链路示意图:</strong></p><pre><code class="hljs mermaid">graph TD
    %% 定义样式
    classDef outerNode fill:#e1f5fe,stroke:#01579b,stroke-width:1px
    classDef middleNode fill:#fff3e0,stroke:#e65100,stroke-width:1px
    classDef finalNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px

    %% 主入口节点
    main[main]:::outerNode

    %% 最长的中间链路（居中）
    main --&gt; global_init[global_init]:::middleNode
    global_init --&gt; global_pre_init[global_pre_init]:::middleNode
    global_pre_init --&gt; common_preinit[common_preinit]:::middleNode
    common_preinit --&gt; CephContext_CephContext[CephContext::CephContext]:::middleNode
    CephContext_CephContext --&gt; register_command1[register_command]:::finalNode

    %% 从CephContext::CephContext分叉的链路
    CephContext_CephContext --&gt; MempoolObs_MempoolObs[MempoolObs::MempoolObs]:::middleNode
    MempoolObs_MempoolObs --&gt; register_command2[register_command]:::finalNode

    %% 从main分叉的较短链路（右侧）
    main --&gt; common_init_finish[common_init_finish]:::middleNode
    common_init_finish --&gt; CephContext_start_service_thread[CephContext::start_service_thread]:::middleNode
    CephContext_start_service_thread --&gt; AdminSocket_init[AdminSocket::init]:::middleNode
    AdminSocket_init --&gt; register_command3[register_command]:::finalNode

    %% 从main分叉的较短链路（左侧）
    main --&gt; Messenger_create[Messenger::create]:::middleNode
    Messenger_create --&gt; AsyncMessenger_AsyncMessenger[AsyncMessenger::AsyncMessenger]:::middleNode
    AsyncMessenger_AsyncMessenger --&gt; register_command4[register_command]:::finalNode

    %% 从main分叉的最短链路（最左侧）
    main --&gt; Monitor_preinit[Monitor::preinit]:::middleNode
    Monitor_preinit --&gt; register_command5[register_command]:::finalNode

    %% 对齐所有最终节点
    register_command1
    register_command2
    register_command3
    register_command4
    register_command5</code></pre><p><strong>相关代码:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> FLAG</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> COMMAND</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> COMMAND_WITH_FLAG</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLAG(f) (MonCommand::FLAG_##f)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND(parsesig, helptext, modulename, req_perms) \</span><br><span class="hljs-meta">  &#123;parsesig, helptext, modulename, req_perms, FLAG(NONE)&#125;,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMAND_WITH_FLAG(parsesig, helptext, modulename, req_perms, flags) \</span><br><span class="hljs-meta">  &#123;parsesig, helptext, modulename, req_perms, flags&#125;,</span><br>MonCommand mon_commands[] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mon/MonCommands.h&gt;</span></span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> COMMAND</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> COMMAND_WITH_FLAG</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2、MGR"><a href="#2-1-2、MGR" class="headerlink" title="2.1.2、MGR"></a>2.1.2、MGR</h3><p>manager 服务的启动服务入口为 <code>src/ceph_mgr.cc</code> 文件。</p><p><strong>注册命令的函数:</strong></p><ul><li><strong>CephContext::CephContext 构造函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>config</code> 等命令，注意其中有些命令的 help 字段内容为空，当使用客户端获取可执行的命令，这些命令并不会在命令列表中展示，但是仍然可以被执行；</li><li><strong>MempoolObs::MempoolObs 构造函数</strong> : 其中仅注册了一个 <code>dump_mempools</code> 命令；</li><li><strong>AdminSocket::init 函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>version</code>，<code>git_version</code>， <code>help</code> 等命令，其中 <code>help</code> 命令在输出可用命令时会过滤每个已注册命令的 help 字段，如果为空则不输出对应的命令；</li><li><strong>AsyncMessenger::AsyncMessenger 构造函数</strong> : 其中仅注册了一个 <code>messenger dump</code> 命令；</li><li><strong>MgrStandby::init 函数</strong> : 其中仅注册了一个 <code>status</code> 命令；</li><li><strong>MonClient::init 函数</strong> : 其中仅注册了一个 <code>rotate-key</code> 命令；</li><li><strong>Objecter::init 函数</strong> : 其中仅注册了一个 <code>objecter_requests</code> 命令；</li><li><strong>Mgr::init 函数</strong> : 其中仅注册了一个 <code>mgr_status</code> 命令；</li><li><strong>DaemonServer::init 函数</strong> : 其中注册了一些使用 <code>dump_</code> 为前缀的命令；</li><li><strong>ClusterState::final_init 函数</strong> : 其中仅注册了一个 <code>dump_osd_network</code> 命令；</li></ul><p><strong>注册命令的函数调用链路:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">+ main -&gt; global_init -&gt; global_pre_init -&gt; common_preinit -&gt; CephContext::CephContext -&gt; register_command<br>+ CephContext::CephContext -&gt; MempoolObs::MempoolObs -&gt; register_command<br>+ main -&gt; common_init_finish -&gt; CephContext::start_service_thread -&gt; AdminSocket::init -&gt; register_command<br>+ main -&gt; MgrStandby::MgrStandby -&gt; Messenger::create -&gt; AsyncMessenger::AsyncMessenger -&gt; register_command<br>+ main -&gt; MgrStandby::init -&gt; register_command<br>+ MgrStandby::init -&gt; MonClient::init -&gt; register_command<br>+ MgrStandby::init -&gt; Objecter::init -&gt; register_command<br>+ MgrStandby::init -&gt; Finisher::start -执行创建线程逻辑-&gt; Finisher::finisher_thread_entry -执行另一个线程中调用 Mgr::background_init 函数添加的 Mgr::init 函数-&gt; Mgr::init<br>+ Mgr::init -&gt; register_command<br>+ Mgr::init -&gt; DaemonServer::init -&gt; register_command<br>+ Mgr::init -&gt; ClusterState::final_init -&gt; register_command<br></code></pre></td></tr></table></figure><p><strong>注册命令的函数调用链路示意图:</strong></p><pre><code class="hljs mermaid">graph TD
    %% 定义样式
    classDef outerNode fill:#e1f5fe,stroke:#01579b,stroke-width:1px
    classDef middleNode fill:#fff3e0,stroke:#e65100,stroke-width:1px
    classDef finalNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px
    
    %% 最外层节点
    main[&quot;main&quot;]:::outerNode
    
    %% 中间节点
    global_init[&quot;global_init&quot;]:::middleNode
    global_pre_init[&quot;global_pre_init&quot;]:::middleNode
    common_preinit[&quot;common_preinit&quot;]:::middleNode
    CephContext_CephContext1[&quot;CephContext::CephContext&quot;]:::middleNode
    MempoolObs_MempoolObs[&quot;MempoolObs::MempoolObs&quot;]:::middleNode
    common_init_finish[&quot;common_init_finish&quot;]:::middleNode
    CephContext_start_service_thread[&quot;CephContext::start_service_thread&quot;]:::middleNode
    AdminSocket_init[&quot;AdminSocket::init&quot;]:::middleNode
    MgrStandby_MgrStandby[&quot;MgrStandby::MgrStandby&quot;]:::middleNode
    Messenger_create[&quot;Messenger::create&quot;]:::middleNode
    AsyncMessenger_AsyncMessenger[&quot;AsyncMessenger::AsyncMessenger&quot;]:::middleNode
    MgrStandby_init[&quot;MgrStandby::init&quot;]:::middleNode
    MonClient_init[&quot;MonClient::init&quot;]:::middleNode
    Objecter_init[&quot;Objecter::init&quot;]:::middleNode
    Finisher_start[&quot;Finisher::start&quot;]:::middleNode
    Finisher_finisher_thread_entry[&quot;Finisher::finisher_thread_entry&quot;]:::middleNode
    Mgr_init[&quot;Mgr::init&quot;]:::middleNode
    DaemonServer_init[&quot;DaemonServer::init&quot;]:::middleNode
    ClusterState_final_init[&quot;ClusterState::final_init&quot;]:::middleNode
    
    %% 最终节点
    register_command[&quot;register_command&quot;]:::finalNode
    
    %% 最长链路（中间）
    main --&gt; global_init
    global_init --&gt; global_pre_init
    global_pre_init --&gt; common_preinit
    common_preinit --&gt; CephContext_CephContext1
    CephContext_CephContext1 --&gt; register_command
    
    %% 左侧较短链路
    main --&gt; common_init_finish
    common_init_finish --&gt; CephContext_start_service_thread
    CephContext_start_service_thread --&gt; AdminSocket_init
    AdminSocket_init --&gt; register_command
    
    main --&gt; MgrStandby_MgrStandby
    MgrStandby_MgrStandby --&gt; Messenger_create
    Messenger_create --&gt; AsyncMessenger_AsyncMessenger
    AsyncMessenger_AsyncMessenger --&gt; register_command
    
    %% 右侧较短链路
    main --&gt; MgrStandby_init
    MgrStandby_init --&gt; register_command
    
    MgrStandby_init --&gt; MonClient_init
    MonClient_init --&gt; register_command
    
    MgrStandby_init --&gt; Objecter_init
    Objecter_init --&gt; register_command
    
    %% 带执行信息的链路
    MgrStandby_init --&gt; Finisher_start
    Finisher_start -- &quot;执行创建线程逻辑&quot; --&gt; Finisher_finisher_thread_entry
    Finisher_finisher_thread_entry -- &quot;执行另一个线程中调用 Mgr::background_init 函数添加的 Mgr::init 函数&quot; --&gt; Mgr_init
    
    %% Mgr_init 相关链路
    Mgr_init --&gt; register_command
    Mgr_init --&gt; DaemonServer_init
    DaemonServer_init --&gt; register_command
    Mgr_init --&gt; ClusterState_final_init
    ClusterState_final_init --&gt; register_command
    
    %% CephContext_CephContext1 的另一个分支
    CephContext_CephContext1 --&gt; MempoolObs_MempoolObs
    MempoolObs_MempoolObs --&gt; register_command</code></pre><p><strong>Mgr::init 相关流程:</strong></p><ol><li>Manager 给 Monitor 发送订阅 <code>mgrmap</code> 的消息；</li><li>Monitor 给 Manager 回复 <code>mgrmap</code> 的订阅消息；</li><li>Manager 收到 Monitor 的消息后，调用 <code>MgrStandby::handle_mgr_map</code> 函数处理消息，必要时通过创建 <code>Mgr</code> 对象并交由 <code>finisher</code> 线程执行 <code>Mgr::init</code> 操作。</li></ol><h3 id="2-1-3、OSD"><a href="#2-1-3、OSD" class="headerlink" title="2.1.3、OSD"></a>2.1.3、OSD</h3><p>osd 服务的启动服务入口为 <code>src/ceph_osd.cc</code> 文件。</p><p><strong>注册命令的函数:</strong></p><ul><li><strong>CephContext::CephContext 构造函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>config</code> 等命令，注意其中有些命令的 help 字段内容为空，当使用客户端获取可执行的命令，这些命令并不会在命令列表中展示，但是仍然可以被执行；</li><li><strong>MempoolObs::MempoolObs 构造函数</strong> : 其中仅注册了一个 <code>dump_mempools</code> 命令；</li><li><strong>AdminSocket::init 函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>version</code>，<code>git_version</code>， <code>help</code> 等命令，其中 <code>help</code> 命令在输出可用命令时会过滤每个已注册命令的 help 字段，如果为空则不输出对应的命令；</li><li><strong>AsyncMessenger::AsyncMessenger 构造函数</strong> : 其中仅注册了一个 <code>messenger dump</code> 命令；</li><li><strong>MonClient::init 函数</strong> : 其中仅注册了一个 <code>rotate-key</code> 命令；</li><li><strong>BlueStore::SocketHook::create 函数</strong> : 其中注册了 <code>bluestore bluefs device info</code> , <code>bluefs stats</code> 等命令；</li><li><strong>BlueStore::BlueStore::SocketHook 构造函数</strong> : 其中注册了 <code>bluestore collections</code> , <code>bluestore list</code> 等命令；</li><li><strong>AllocatorBase::SocketHook::SocketHook 构造函数</strong> : 其中注册了 <code>bluestore allocator dump block</code> 等后缀为 <code>block</code> 的命令；</li><li><strong>OSD::final_init 函数</strong> : 其中注册了大量的命令；</li><li><strong>Objecter::init 函数</strong> : 其中仅注册了一个 <code>objecter_requests</code> 命令；</li></ul><p><strong>注册命令的函数调用链路:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">+ main -&gt; global_init -&gt; global_pre_init -&gt; common_preinit -&gt; CephContext::CephContext -&gt; register_command<br>+ CephContext::CephContext -&gt; MempoolObs::MempoolObs -&gt; register_command<br>+ main -&gt; common_init_finish -&gt; CephContext::start_service_thread -&gt; AdminSocket::init -&gt; register_command<br>+ main -&gt; OSD::init -&gt; MonClient::init -&gt; register_command<br>+ main -&gt; OSD::final_init -&gt; register_command<br>+ main -&gt; OSD::mkfs -&gt; BlueStore::mkfs -&gt; BlueStore::_open_db -&gt; BlueStore::_prepare_db_environment -&gt; BlueStore::_open_bluefs -&gt; BlueStore::_minimal_open_bluefs -&gt; BlueFS::BlueFS -&gt; BlueFS::SocketHook::create -&gt; register_command<br>+ main -&gt; ObjectStore::create -&gt; BlueStore::BlueStore -&gt; BlueStore::BlueStore::SocketHook -&gt; register_command<br>+ main -&gt; OSD::init -&gt; BlueStore::mount -&gt; BlueStore::_mount -&gt; BlueStore::_open_db_and_around -&gt; BlueStore::_init_alloc -&gt; BlueStore::_create_alloc -&gt; Allocator::create -创建对象时执行父类的构造函数-&gt; AllocatorBase::AllocatorBase -&gt; AllocatorBase::SocketHook::SocketHook -&gt; register_command<br>+ main -&gt; OSD::OSD -&gt; OSDService::OSDService -&gt; Objecter::init -&gt; register_command<br></code></pre></td></tr></table></figure><p><strong>注册命令的函数调用链路示意图:</strong></p><pre><code class="hljs mermaid">graph TD
    %% 最外层节点
    main[&quot;main&quot;]:::outer
    
    %% 第一层调用
    main --&gt; global_init[&quot;global_init&quot;]
    main --&gt; common_init_finish[&quot;common_init_finish&quot;]
    main --&gt; OSD_init[&quot;OSD::init&quot;]
    main --&gt; OSD_final_init[&quot;OSD::final_init&quot;]
    main --&gt; OSD_mkfs[&quot;OSD::mkfs&quot;]
    main --&gt; ObjectStore_create[&quot;ObjectStore::create&quot;]
    main --&gt; OSD_OSD[&quot;OSD::OSD&quot;]
    
    %% global_init 分支
    global_init --&gt; global_pre_init[&quot;global_pre_init&quot;]
    global_pre_init --&gt; common_preinit[&quot;common_preinit&quot;]
    common_preinit --&gt; CephContext_CephContext[&quot;CephContext::CephContext&quot;]
    CephContext_CephContext --&gt; register_command_1[&quot;register_command&quot;]
    CephContext_CephContext --&gt; MempoolObs_MempoolObs[&quot;MempoolObs::MempoolObs&quot;]
    MempoolObs_MempoolObs --&gt; register_command_2[&quot;register_command&quot;]
    
    %% common_init_finish 分支
    common_init_finish --&gt; CephContext_start_service_thread[&quot;CephContext::start_service_thread&quot;]
    CephContext_start_service_thread --&gt; AdminSocket_init[&quot;AdminSocket::init&quot;]
    AdminSocket_init --&gt; register_command_3[&quot;register_command&quot;]
    
    %% OSD::init 分支（第一个）
    OSD_init --&gt; MonClient_init[&quot;MonClient::init&quot;]
    MonClient_init --&gt; register_command_4[&quot;register_command&quot;]
    
    %% OSD::init 分支（第二个）
    OSD_init --&gt; BlueStore_mount[&quot;BlueStore::mount&quot;]
    BlueStore_mount --&gt; BlueStore_mount_inner[&quot;BlueStore::_mount&quot;]
    BlueStore_mount_inner --&gt; BlueStore_open_db_and_around[&quot;BlueStore::_open_db_and_around&quot;]
    BlueStore_open_db_and_around --&gt; BlueStore_init_alloc[&quot;BlueStore::_init_alloc&quot;]
    BlueStore_init_alloc --&gt; BlueStore_create_alloc[&quot;BlueStore::_create_alloc&quot;]
    BlueStore_create_alloc --&gt; Allocator_create[&quot;Allocator::create&quot;]
    Allocator_create -- &quot;创建对象时执行父类的构造函数&quot; --&gt; AllocatorBase_AllocatorBase[&quot;AllocatorBase::AllocatorBase&quot;]
    AllocatorBase_AllocatorBase --&gt; AllocatorBase_SocketHook_SocketHook[&quot;AllocatorBase::SocketHook::SocketHook&quot;]
    AllocatorBase_SocketHook_SocketHook --&gt; register_command_8[&quot;register_command&quot;]
    
    %% OSD::final_init 分支
    OSD_final_init --&gt; register_command_5[&quot;register_command&quot;]
    
    %% OSD::mkfs 分支（最长链路）
    OSD_mkfs --&gt; BlueStore_mkfs[&quot;BlueStore::mkfs&quot;]
    BlueStore_mkfs --&gt; BlueStore_open_db[&quot;BlueStore::_open_db&quot;]
    BlueStore_open_db --&gt; BlueStore_prepare_db_environment[&quot;BlueStore::_prepare_db_environment&quot;]
    BlueStore_prepare_db_environment --&gt; BlueStore_open_bluefs[&quot;BlueStore::_open_bluefs&quot;]
    BlueStore_open_bluefs --&gt; BlueStore_minimal_open_bluefs[&quot;BlueStore::_minimal_open_bluefs&quot;]
    BlueStore_minimal_open_bluefs --&gt; BlueFS_BlueFS[&quot;BlueFS::BlueFS&quot;]
    BlueFS_BlueFS --&gt; BlueFS_SocketHook_create[&quot;BlueFS::SocketHook::create&quot;]
    BlueFS_SocketHook_create --&gt; register_command_6[&quot;register_command&quot;]
    
    %% ObjectStore::create 分支
    ObjectStore_create --&gt; BlueStore_BlueStore[&quot;BlueStore::BlueStore&quot;]
    BlueStore_BlueStore --&gt; BlueStore_BlueStore_SocketHook[&quot;BlueStore::BlueStore::SocketHook&quot;]
    BlueStore_BlueStore_SocketHook --&gt; register_command_7[&quot;register_command&quot;]
    
    %% OSD::OSD 分支
    OSD_OSD --&gt; OSDService_OSDService[&quot;OSDService::OSDService&quot;]
    OSDService_OSDService --&gt; Objecter_init[&quot;Objecter::init&quot;]
    Objecter_init --&gt; register_command_9[&quot;register_command&quot;]
    
    %% 样式定义
    classDef outer fill:#e1f5fe,stroke:#01579b,stroke-width:1px
    classDef inner fill:#fff3e0,stroke:#e65100,stroke-width:1px
    classDef final fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px

    %% 节点分类
    class main outer
    class register_command_1,register_command_2,register_command_3,register_command_4,register_command_5,register_command_6,register_command_7,register_command_8,register_command_9 final
    class global_init,common_init_finish,OSD_init,OSD_final_init,OSD_mkfs,ObjectStore_create,OSD_OSD,global_pre_init,common_preinit,CephContext_CephContext,MempoolObs_MempoolObs,CephContext_start_service_thread,AdminSocket_init,MonClient_init,BlueStore_mount,BlueStore_mount_inner,BlueStore_open_db_and_around,BlueStore_init_alloc,BlueStore_create_alloc,Allocator_create,AllocatorBase_AllocatorBase,AllocatorBase_SocketHook_SocketHook,BlueStore_mkfs,BlueStore_open_db,BlueStore_prepare_db_environment,BlueStore_open_bluefs,BlueStore_minimal_open_bluefs,BlueFS_BlueFS,BlueFS_SocketHook_create,BlueStore_BlueStore,BlueStore_BlueStore_SocketHook,OSDService_OSDService,Objecter_init inner</code></pre><h3 id="2-1-4、MDS"><a href="#2-1-4、MDS" class="headerlink" title="2.1.4、MDS"></a>2.1.4、MDS</h3><p>mds 服务的启动服务入口为 <code>src/ceph_mds.cc</code> 文件。</p><p><strong>注册命令的函数:</strong></p><ul><li><strong>CephContext::CephContext 构造函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>config</code> 等命令，注意其中有些命令的 help 字段内容为空，当使用客户端获取可执行的命令，这些命令并不会在命令列表中展示，但是仍然可以被执行；</li><li><strong>MempoolObs::MempoolObs 构造函数</strong> : 其中仅注册了一个 <code>dump_mempools</code> 命令；</li><li><strong>AdminSocket::init 函数</strong> : 内部注册了一些各组件通用的命令，比如 <code>version</code>，<code>git_version</code>， <code>help</code> 等命令，其中 <code>help</code> 命令在输出可用命令时会过滤每个已注册命令的 help 字段，如果为空则不输出对应的命令；</li><li><strong>AsyncMessenger::AsyncMessenger 构造函数</strong> : 其中仅注册了一个 <code>messenger dump</code> 命令；</li><li><strong>MonClient::init 函数</strong> : 其中仅注册了一个 <code>rotate-key</code> 命令；</li><li><strong>MDSDaemon::set_up_admin_socket 函数</strong> : 其中注册了大量的命令；</li><li><strong>Objecter::init 函数</strong> : 其中仅注册了一个 <code>objecter_requests</code> 命令；</li></ul><p><strong>注册命令的函数调用链路:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">+ main -&gt; global_init -&gt; global_pre_init -&gt; common_preinit -&gt; CephContext::CephContext -&gt; register_command<br>+ CephContext::CephContext -&gt; MempoolObs::MempoolObs -&gt; register_command<br>+ main -&gt; common_init_finish -&gt; CephContext::start_service_thread -&gt; AdminSocket::init -&gt; register_command<br>+ main -&gt; Messenger::create -&gt; AsyncMessenger::AsyncMessenger -&gt; register_command<br>+ main -&gt; MDSDaemon::init -&gt; MonClient::init -&gt; register_command<br>+ main -&gt; MDSDaemon::init -&gt; MDSDaemon::set_up_admin_socket -&gt; register_command<br>+ main -&gt; MDSDaemon::init -&gt; Messenger::add_dispatcher_head - Messenger::ready(纯虚函数) -&gt; AsyncMessenger::ready -&gt; DispatchQueue::start - 创建 dispatch_thread 线程-&gt; DispatchQueue::entry -&gt;  Messenger::ms_deliver_dispatch -&gt; MDSDaemon::ms_dispatch2 -&gt; MDSDaemon::handle_core_message - 处理CEPH_MSG_MDS_MAP消息-&gt; MDSDaemon::handle_mds_map - 创建MDSRankDispatcher对象-&gt; MDSRankDispatcher::init -&gt; Objecter::init -&gt; register_command<br></code></pre></td></tr></table></figure><p><strong>注册命令的函数调用链路示意图:</strong></p><pre><code class="hljs mermaid">graph TB
    %% 定义样式
    classDef outerNode fill:#e1f5f5,stroke:#01579b,stroke-width:1px
    classDef middleNode fill:#fff3e0,stroke:#e65100,stroke-width:1px
    classDef finalNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px
    
    %% 最外层节点
    main[&quot;main&quot;]:::outerNode
    
    %% 中间节点
    global_init[&quot;global_init&quot;]:::middleNode
    global_pre_init[&quot;global_pre_init&quot;]:::middleNode
    common_preinit[&quot;common_preinit&quot;]:::middleNode
    CephContext_Ctor[&quot;CephContext::CephContext&quot;]:::middleNode
    MempoolObs_Ctor[&quot;MempoolObs::MempoolObs&quot;]:::middleNode
    common_init_finish[&quot;common_init_finish&quot;]:::middleNode
    CephContext_start_service[&quot;CephContext::start_service_thread&quot;]:::middleNode
    AdminSocket_init[&quot;AdminSocket::init&quot;]:::middleNode
    Messenger_create[&quot;Messenger::create&quot;]:::middleNode
    AsyncMessenger_Ctor[&quot;AsyncMessenger::AsyncMessenger&quot;]:::middleNode
    MDSDaemon_init[&quot;MDSDaemon::init&quot;]:::middleNode
    MonClient_init[&quot;MonClient::init&quot;]:::middleNode
    MDSDaemon_set_up_admin[&quot;MDSDaemon::set_up_admin_socket&quot;]:::middleNode
    Messenger_add_dispatcher[&quot;Messenger::add_dispatcher_head&quot;]:::middleNode
    Messenger_ready[&quot;Messenger::ready(纯虚函数)&quot;]:::middleNode
    AsyncMessenger_ready[&quot;AsyncMessenger::ready&quot;]:::middleNode
    DispatchQueue_start[&quot;DispatchQueue::start&quot;]:::middleNode
    create_dispatch_thread[&quot;创建 dispatch_thread 线程&quot;]:::middleNode
    DispatchQueue_entry[&quot;DispatchQueue::entry&quot;]:::middleNode
    Messenger_deliver[&quot;Messenger::ms_deliver_dispatch&quot;]:::middleNode
    MDSDaemon_dispatch2[&quot;MDSDaemon::ms_dispatch2&quot;]:::middleNode
    MDSDaemon_handle_core[&quot;MDSDaemon::handle_core_message&quot;]:::middleNode
    handle_mds_map[&quot;MDSDaemon::handle_mds_map&quot;]:::middleNode
    create_MDSRankDispatcher[&quot;创建MDSRankDispatcher对象&quot;]:::middleNode
    MDSRankDispatcher_init[&quot;MDSRankDispatcher::init&quot;]:::middleNode
    Objecter_init[&quot;Objecter::init&quot;]:::middleNode
    
    %% 最终节点
    register_command[&quot;register_command&quot;]:::finalNode
    
    %% 调用关系 - 主要长链路（中间）
    main --&gt; global_init
    global_init --&gt; global_pre_init
    global_pre_init --&gt; common_preinit
    common_preinit --&gt; CephContext_Ctor
    CephContext_Ctor --&gt; register_command
    
    %% 左侧较短链路
    main --&gt; common_init_finish
    common_init_finish --&gt; CephContext_start_service
    CephContext_start_service --&gt; AdminSocket_init
    AdminSocket_init --&gt; register_command
    
    main --&gt; Messenger_create
    Messenger_create --&gt; AsyncMessenger_Ctor
    AsyncMessenger_Ctor --&gt; register_command
    
    %% 右侧较短链路
    main --&gt; MDSDaemon_init
    MDSDaemon_init --&gt; MonClient_init
    MonClient_init --&gt; register_command
    
    MDSDaemon_init --&gt; MDSDaemon_set_up_admin
    MDSDaemon_set_up_admin --&gt; register_command
    
    %% 中间最长链路（继续）
    MDSDaemon_init --&gt; Messenger_add_dispatcher
    Messenger_add_dispatcher --&gt; Messenger_ready
    Messenger_ready --&gt; AsyncMessenger_ready
    AsyncMessenger_ready --&gt; DispatchQueue_start
    DispatchQueue_start --&gt; create_dispatch_thread
    create_dispatch_thread --&gt; DispatchQueue_entry
    DispatchQueue_entry --&gt; Messenger_deliver
    Messenger_deliver --&gt; MDSDaemon_dispatch2
    MDSDaemon_dispatch2 --&gt; MDSDaemon_handle_core
    MDSDaemon_handle_core --&gt; handle_mds_map
    handle_mds_map --&gt; create_MDSRankDispatcher
    create_MDSRankDispatcher --&gt; MDSRankDispatcher_init
    MDSRankDispatcher_init --&gt; Objecter_init
    Objecter_init --&gt; register_command
    
    %% 额外的调用关系
    CephContext_Ctor --&gt; MempoolObs_Ctor
    MempoolObs_Ctor --&gt; register_command
    
    %% 添加注释说明
    linkStyle 0,1,2,3 stroke:#01579b,stroke-width:1px
    linkStyle 4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 stroke:#e65100,stroke-width:1px</code></pre><h2 id="2-2、命令执行流程"><a href="#2-2、命令执行流程" class="headerlink" title="2.2、命令执行流程"></a>2.2、命令执行流程</h2><h3 id="2-2-1、admin-socket-初始化流程"><a href="#2-2-1、admin-socket-初始化流程" class="headerlink" title="2.2.1、admin socket 初始化流程"></a>2.2.1、admin socket 初始化流程</h3><p>MON&#x2F;MGR&#x2F;OSD&#x2F;MDS 等组件 admin socket 的命令执行流程基本一致。大致就是创建对应的 Unix Socket 以及对应的处理线程，然后等待接受命令并执行。</p><p><strong>执行流程:</strong></p><ul><li>函数调用链路: main -&gt; common_init_finish -&gt; CephContext::start_service_thread -&gt; AdminSocket::init；</li><li>其中，AdminSocket::init 函数内部创建 Unix Socket ，并启动 AdminSocket::entry 线程（线程名为 admin_socket）；</li><li>之后 common_init_finish 函数在调用 CephContext::start_service_thread 函数之后，再根据需要调整对应 Unix Socket 的 owner 和 mode ；</li></ul><p><strong>初始化流程示意图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant main as main函数
    participant common as common_init_finish
    participant ceph as CephContext::start_service_thread
    participant admin as AdminSocket::init
    participant socket as Unix Socket
    participant thread as admin_socket线程

    Note over main,thread: Admin Socket 初始化时序

    main-&gt;&gt;common: 调用
    activate common

    common-&gt;&gt;ceph: start_service_thread()
    activate ceph

    ceph-&gt;&gt;admin: init()
    activate admin

    admin-&gt;&gt;socket: 创建Unix Socket
    activate socket
    socket--&gt;&gt;admin: Socket创建成功
    deactivate socket

    admin-&gt;&gt;thread: 启动AdminSocket::entry线程
    activate thread

    admin--&gt;&gt;ceph: 返回
    deactivate admin

    ceph--&gt;&gt;common: 返回
    deactivate ceph

    %% common_init_finish内部继续执行权限调整
    Note over common: common_init_finish内部继续执行
    common-&gt;&gt;common: 调整Socket owner
    common-&gt;&gt;common: 调整Socket mode
    Note over common: 权限调整完成

    %% 线程开始工作（与权限调整并行）
    thread-&gt;&gt;thread: 等待接受命令并执行
    Note over thread: 线程持续运行

    common--&gt;&gt;main: 返回
    deactivate common

    Note over main,thread: 初始化完成，等待命令</code></pre><h3 id="2-2-2、接收并执行命令流程"><a href="#2-2-2、接收并执行命令流程" class="headerlink" title="2.2.2、接收并执行命令流程"></a>2.2.2、接收并执行命令流程</h3><p>我们可以在 AdminSocket::entry 函数中看到使用 poll 同时监听了两个文件描述符：<code>m_sock_fd</code>（对外服务的Unix域套接字，接受客户端连接），<code>m_wakeup_rd_fd</code>（管道或eventfd的读端，用于内部线程间通信，触发 do_tell_queue 处理）。两者有不同的执行链路。</p><p><strong>两个fd的对比:</strong></p><table><thead><tr><th align="center">特性</th><th align="center">m_sock_fd (外部路径)</th><th align="center">m_wakeup_rd_fd (内部路径)</th></tr></thead><tbody><tr><td align="center"><strong>触发源</strong></td><td align="center">外部管理工具</td><td align="center">Ceph内部组件线程</td></tr><tr><td align="center"><strong>协议</strong></td><td align="center">asok协议(JSON&#x2F;二进制)</td><td align="center">内部消息协议(MCommand等)</td></tr><tr><td align="center"><strong>执行模式</strong></td><td align="center">同步等待结果</td><td align="center">异步回调</td></tr><tr><td align="center"><strong>响应方式</strong></td><td align="center">通过同一socket返回</td><td align="center">通过原消息连接返回</td></tr><tr><td align="center"><strong>主要用途</strong></td><td align="center">运维管理、监控</td><td align="center">集群内部控制、状态同步</td></tr><tr><td align="center"><strong>处理函数</strong></td><td align="center">do_accept()</td><td align="center">do_tell_queue()</td></tr><tr><td align="center"><strong>队列机制</strong></td><td align="center">无队列，直接处理</td><td align="center">使用 tell_queue 缓冲</td></tr></tbody></table><p><strong>m_sock_fd - 外部客户端请求处理时序图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 外部客户端&lt;br/&gt;(ceph daemon)
    participant Socket as Unix Socket&lt;br/&gt;(/var/run/ceph/*.asok)
    participant AdminSocket as AdminSocket::entry()
    participant do_accept as do_accept()
    participant ExecCmd as execute_command&lt;br/&gt;(同步版本)
    participant Hook as 命令钩子&lt;br/&gt;(hook-&gt;call_async)
    participant Formatter as 格式化器

    Note over Client,Formatter: 外部请求处理流程

    Client-&gt;&gt;Socket: 1. connect() 建立连接
    AdminSocket-&gt;&gt;AdminSocket: 2. poll() 检测到m_sock_fd有POLLIN事件
    AdminSocket-&gt;&gt;do_accept: 3. 调用do_accept()

    do_accept-&gt;&gt;Socket: 4. accept() 接受连接
    Socket--&gt;&gt;do_accept: 5. 返回connection_fd

    Client-&gt;&gt;do_accept: 6. 发送命令数据&lt;br/&gt;(JSON或旧协议)

    loop 读取完整命令
        do_accept-&gt;&gt;do_accept: 7. safe_recv() 逐字节读取
        alt 遇到终止符(\n或\0)
            do_accept-&gt;&gt;do_accept: 8. 构建命令字符串c
        else 缓冲区溢出
            do_accept-&gt;&gt;Socket: 关闭连接并返回错误
        end
    end

    do_accept-&gt;&gt;ExecCmd: 9. 调用execute_command(c)

    ExecCmd-&gt;&gt;ExecCmd: 10. 创建锁/条件变量&lt;br/&gt;等待异步完成
    ExecCmd-&gt;&gt;Hook: 11. 异步调用hook-&gt;call_async()

    Hook-&gt;&gt;Hook: 12. 执行实际命令逻辑
    Hook--&gt;&gt;ExecCmd: 13. 回调返回结果(rval, err, out)
    ExecCmd--&gt;&gt;do_accept: 14. 返回执行结果

    do_accept-&gt;&gt;Formatter: 15. 格式化错误信息(如果需要)

    do_accept-&gt;&gt;Client: 16. 发送响应长度(htonl(out.length()))
    do_accept-&gt;&gt;Client: 17. 发送响应数据(out.send_fd())
    do_accept-&gt;&gt;Socket: 18. closesocket(connection_fd)

    Client-&gt;&gt;Client: 19. 解析并显示结果</code></pre><p><strong>m_wakeup_rd_fd - 内部线程唤醒处理时序图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant Internal as 内部线程&lt;br/&gt;(如OSD线程)
    participant Queue as tell_queue&lt;br/&gt;tell_legacy_queue
    participant WakePipe as 唤醒管道&lt;br/&gt;(pipe/eventfd)
    participant AdminSocket as AdminSocket::entry()
    participant do_tell_queue as do_tell_queue()
    participant ExecCmd as execute_command&lt;br/&gt;(异步版本)
    participant Hook as 命令钩子&lt;br/&gt;(hook-&gt;call_async)
    participant Reply as 回复消息构造

    Note over Internal,Reply: 内部唤醒处理流程

    Internal-&gt;&gt;Queue: 1. 获取tell_lock锁
    Internal-&gt;&gt;Queue: 2. 将MCommand/MMonCommand&lt;br/&gt;放入对应队列
    Internal-&gt;&gt;Queue: 3. 释放tell_lock锁

    Internal-&gt;&gt;WakePipe: 4. 向m_wakeup_wr_fd写入1字节

    AdminSocket-&gt;&gt;AdminSocket: 5. poll() 检测到m_wakeup_rd_fd有POLLIN事件

    AdminSocket-&gt;&gt;WakePipe: 6. safe_recv() 读取唤醒字节
    AdminSocket-&gt;&gt;do_tell_queue: 7. 调用do_tell_queue()

    do_tell_queue-&gt;&gt;Queue: 8. 获取tell_lock锁
    do_tell_queue-&gt;&gt;Queue: 9. 交换队列内容到局部变量
    do_tell_queue-&gt;&gt;Queue: 10. 释放tell_lock锁

    loop 处理每个队列中的消息
        do_tell_queue-&gt;&gt;ExecCmd: 11. 调用execute_command(异步版本)

        ExecCmd-&gt;&gt;Hook: 12. 异步调用hook-&gt;call_async()
        Hook-&gt;&gt;Hook: 13. 执行实际命令逻辑

        Hook--&gt;&gt;ExecCmd: 14. 回调返回结果(rval, err, outbl)
        ExecCmd--&gt;&gt;do_tell_queue: 15. 在回调中构造回复消息

        alt MCommand类型
            do_tell_queue-&gt;&gt;Reply: 16. 创建MCommandReply
        else MMonCommand类型
            do_tell_queue-&gt;&gt;Reply: 17. 创建MMonCommandAck
        end

        do_tell_queue-&gt;&gt;Internal: 18. 通过原连接发送回复消息&lt;br/&gt;(m-&gt;get_connection()-&gt;send_message())
    end

    Note over AdminSocket: 处理完成后继续poll()等待</code></pre><h1 id="三、Monitor-Commands-分析"><a href="#三、Monitor-Commands-分析" class="headerlink" title="三、Monitor Commands 分析"></a>三、Monitor Commands 分析</h1><h2 id="3-1、命令注册流程"><a href="#3-1、命令注册流程" class="headerlink" title="3.1、命令注册流程"></a>3.1、命令注册流程</h2><p>当执行 <code>ceph -h</code> 命令后，其实是向 Monitor 发送了 <code>get_command_descriptions</code> 命令， 对应的处理函数为 Monitor::handle_command ，相关的处理代码如下。可以看到其中含有了 <strong>mon 的 leader_mon_commands</strong> 和 <strong>mgr 的一些命令</strong>。</p><p><strong>因此 Monitor Commands 包含两部分:</strong></p><ul><li><strong>Monitor 相关的命令</strong>: 其中包括操作 Ceph 集群的各种类型的命令；</li><li><strong>Manager 上报的命令</strong>: Manager 通过与 Monitor 进行通信，上报的关于 Manager 自身以及其内部启用的 Python 模块的命令；</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (prefix == <span class="hljs-string">&quot;get_command_descriptions&quot;</span>)<br>&#123;<br>  bufferlist rdata;<br>  Formatter *f = Formatter::<span class="hljs-built_in">create</span>(<span class="hljs-string">&quot;json&quot;</span>);<br><br>  std::vector&lt;MonCommand&gt; commands = <span class="hljs-built_in">static_cast</span>&lt;MgrMonitor *&gt;(<br>                                          paxos_service[PAXOS_MGR].<span class="hljs-built_in">get</span>())<br>                                          -&gt;<span class="hljs-built_in">get_command_descs</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : leader_mon_commands)<br>  &#123;<br>    commands.<span class="hljs-built_in">push_back</span>(c);<br>  &#125;<br><br>  <span class="hljs-keyword">auto</span> features = m-&gt;<span class="hljs-built_in">get_connection</span>()-&gt;<span class="hljs-built_in">get_features</span>();<br>  format_command_descriptions(commands, f, features, &amp;rdata);<br>  <span class="hljs-keyword">delete</span> f;<br>  <span class="hljs-built_in">reply_command</span>(op, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, rdata, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-1、Monitor-相关的命令"><a href="#3-1-1、Monitor-相关的命令" class="headerlink" title="3.1.1、Monitor 相关的命令"></a>3.1.1、Monitor 相关的命令</h3><p><strong>leader_mon_commands 的设置流程:</strong></p><ol><li>Monitor::Monitor 构造函数内部，使用 src&#x2F;mon&#x2F;MonCommands.h 中定义组合而成的 mon_commands 变量，来设置 leader_mon_commands 变量（这个地方的含义是，在选举完成前，我们暂时接受所有命令。这仅意味着在选举期间我们不会以 EINVAL 错误拒绝命令；任何真正重要的命令都会等待我们获得法定人数等条件满足后，重新尝试（并重新验证）。</li><li>当 Monitor 赢得选举的时候，使用 Monitor::set_leader_commands 函数来设置 leader_mon_commands 变量；</li></ol><h3 id="3-1-2、Manager-上报的命令"><a href="#3-1-2、Manager-上报的命令" class="headerlink" title="3.1.2、Manager 上报的命令"></a>3.1.2、Manager 上报的命令</h3><p><strong>Mgr 向 Mon 发送命令描述信息的两个触发方式:</strong></p><ul><li><strong>主动触发:</strong><ul><li>介绍: 当 mgr 初始化的时候就会向 mon 发送 MSG_MGR_BEACON 类型的消息（其中包含 mgr 和 py_module_registry 的命令信息） ；</li><li>函数调用链路: MgrStandby::init -&gt; MgrStandby::tick -&gt; MgrStandby::send_beacon -发送 MSG_MGR_BEACON 类型的消息-&gt; mon ；</li></ul></li><li><strong>被动触发:</strong><ul><li>介绍: 当 mgr 收到 MSG_MGR_MAP 类型的消息后，会向 mon 发送 MSG_MGR_BEACON 类型的消息；</li><li>函数调用链路: MgrStandby::ms_dispatch2 -收到 MSG_MGR_MAP 消息-&gt; MgrStandby::handle_mgr_map -&gt; MgrStandby::send_beacon -发送 MSG_MGR_BEACON 类型的消息-&gt; mon ；</li></ul></li></ul><p><strong>Manager 主动向 Monitor 注册命令描述信息的流程示意图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant MgrStandby
    participant Monitor
    participant MgrMonitor
    participant Paxos
    participant Storage

    %% 触发路径
    Note over MgrStandby: 触发条件
    MgrStandby-&gt;&gt;MgrStandby: send_beacon()
    MgrStandby-&gt;&gt;Monitor: MSG_MGR_BEACON
    Note over MgrStandby,Monitor: 消息包含command_descs命令信息

    %% Monitor接收解析
    Monitor-&gt;&gt;Monitor: decode_message()
    Note over Monitor: 解析出MMgrBeacon.command_descs

    %% 准备阶段
    Monitor-&gt;&gt;MgrMonitor: prepare_beacon()
    MgrMonitor-&gt;&gt;MgrMonitor: get_command_descs()
    Note over MgrMonitor: command_descs → pending_command_descs

    %% 写入存储
    MgrMonitor-&gt;&gt;Storage: 事务写入command_descs_prefix
    Note over MgrMonitor: 包含command_descs信息
    Note over MgrMonitor: 添加C_Committed回调

    %% 提交刷新
    Note over MgrMonitor: C_Committed::finish()
    MgrMonitor-&gt;&gt;Paxos: commit_finish()
    Paxos-&gt;&gt;Monitor: refresh_from_paxos()
    Monitor-&gt;&gt;MgrMonitor: update_from_paxos()
    MgrMonitor-&gt;&gt;Storage: 读取command_descs_prefix
    Storage--&gt;&gt;MgrMonitor: command_descs数据</code></pre><h2 id="3-2、命令执行流程"><a href="#3-2、命令执行流程" class="headerlink" title="3.2、命令执行流程"></a>3.2、命令执行流程</h2><h3 id="3-2-1、Client-侧执行流程"><a href="#3-2-1、Client-侧执行流程" class="headerlink" title="3.2.1、Client 侧执行流程"></a>3.2.1、Client 侧执行流程</h3><p><strong>函数调用链路:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">main()<br>├── parse_cmdargs()                          <span class="hljs-comment"># 解析命令行参数</span><br>├── maybe_daemon_command()                   <span class="hljs-comment"># 检查是否为守护进程命令</span><br>├── rados.Rados().connect()                  <span class="hljs-comment"># 连接集群</span><br>├── json_command(<span class="hljs-string">&#x27;get_command_descriptions&#x27;</span>) <span class="hljs-comment"># 获取命令签名</span><br>├── parse_json_funcsigs()                    <span class="hljs-comment"># 解析签名</span><br>└── new_style_command()<br>    └── do_command()<br>        └── validate_command()               <span class="hljs-comment"># 关键：命令验证和匹配</span><br>            ├── 遍历所有命令签名<br>            ├── 计算匹配得分<br>            ├── 记录最佳匹配<br>            └── 返回验证后的参数字典<br>        └── json_command()                   <span class="hljs-comment"># 发送请求到monitor</span><br></code></pre></td></tr></table></figure><p><strong>validate_command 函数执行流程:</strong></p><ul><li><strong>评分筛选阶段</strong>: 从所有命令签名中筛选出与输入参数最匹配的候选命令；<ul><li>匹配度计算: 使用 matchnum() 计算匹配度（支持部分匹配）；</li><li>完全匹配优先: 完全匹配的命令获得额外 0.5 加分；</li><li>分数阈值: 只保留达到当前最高分的命令；</li><li>多候选收集: 相同分数的命令都保留</li></ul></li><li><strong>排序阶段</strong>: 对候选命令进行排序，优化后续验证效率；<ul><li>评分函数: grade() 计算命令的必需参数总数；</li><li>排序规则：按必需参数数量升序排列；</li></ul></li><li><strong>精确验证阶段</strong>: 对排序后的候选命令进行精确验证，找到真正匹配的命令；<ul><li>顺序尝试: 按排序顺序逐一验证；</li><li>短路优化: 一旦验证成功立即退出循环；</li></ul></li><li><strong>结果处理阶段</strong>: 根据验证结果提供反馈并返回最终结果；<ul><li>成功情况: 返回解析后的参数字典；</li><li>失败情况: 命令找到但参数错误（显示具体错误和命令帮助）， 完全无匹配：显示最接近的10个命令（过滤废弃&#x2F;隐藏命令）；</li></ul></li></ul><p><strong>validate_command 函数执行流程示意图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant VC as validate_command
    participant M as matchnum
    participant V as validate
    participant S as 系统输出

    U-&gt;&gt;VC: 调用(sigdict, args, verbose)

    Note over VC: 阶段1: 评分筛选
    loop 遍历sigdict中每个cmd
        VC-&gt;&gt;M: matchnum(args, sig, partial=True)
        M--&gt;&gt;VC: 返回分数matched
        VC-&gt;&gt;M: matchnum(args, sig, partial=False)
        M--&gt;&gt;VC: 返回完全匹配分数
        alt 完全匹配奖励
            VC-&gt;&gt;VC: matched += 0.5
        end
        alt 更新最佳匹配
            VC-&gt;&gt;VC: 更新best_match_cnt和bestcmds
        end
        alt verbose模式
            VC-&gt;&gt;S: 输出&quot;better match: X &gt; Y: command&quot;
        end
    end

    Note over VC: 阶段2: 排序
    VC-&gt;&gt;VC: 按必需参数数量排序bestcmds
    alt verbose模式
        VC-&gt;&gt;S: 输出&quot;bestcmds_sorted:&quot;和列表
    end

    Note over VC: 阶段3: 精确验证
    loop 遍历bestcmds_sorted
        VC-&gt;&gt;V: validate(args, sig, flags)
        alt 验证成功
            V--&gt;&gt;VC: 返回valid_dict
            VC-&gt;&gt;VC: found = cmd, break循环
        else 验证失败
            V--xVC: 抛出异常
            alt ArgumentPrefix异常
                VC-&gt;&gt;VC: 继续尝试下一个
            else ArgumentMissing异常
                VC-&gt;&gt;VC: 记录ex, 如果只有一个候选则found=cmd
                VC-&gt;&gt;VC: break循环
            else ArgumentTooFew异常
                VC-&gt;&gt;VC: verbose时输出提示,继续尝试
            else ArgumentError异常
                VC-&gt;&gt;VC: 记录ex, found = cmd
                VC-&gt;&gt;VC: break循环
            end
        end
    end

    Note over VC: 阶段4: 结果处理
    alt found不为空
        alt valid_dict不为空
            VC--&gt;&gt;U: 返回valid_dict
        else
            VC-&gt;&gt;S: 输出&quot;Invalid command:&quot;和ex
            VC-&gt;&gt;S: 输出命令帮助
            VC--&gt;&gt;U: 返回空字典
        end
    else
        VC-&gt;&gt;VC: 过滤已弃用/隐藏命令
        VC-&gt;&gt;VC: 限制最多10个建议
            VC-&gt;&gt;S: no valid command found. Closest matches:
        loop 遍历bestcmds
            VC-&gt;&gt;S: 输出命令签名
        end
        VC--&gt;&gt;U: 返回空字典
    end</code></pre><p><strong>matchnum 函数执行流程:</strong></p><ul><li>从左到右扫描用户输入；</li><li>按模板顺序尝试匹配每个参数；</li><li>必需参数是关卡：失败就结束，成功就加分；</li><li>可选参数是通道：失败就跳过，成功就通过。注意：如果可选参数匹配失败了，则下一次匹配的时候还会匹配当前命令的这个参数（因为把匹配失败的当前参数又放回了队列头部），相当于实现非贪婪匹配机制（可选参数失败时回退，让其他规则尝试）；</li><li>最后返回：成功闯过了多少必需参数关卡，就返回多少数值；</li></ul><h3 id="3-2-2、Server-侧执行流程"><a href="#3-2-2、Server-侧执行流程" class="headerlink" title="3.2.2、Server 侧执行流程"></a>3.2.2、Server 侧执行流程</h3><p><strong>执行流程详解:</strong></p><ul><li><strong>基础验证</strong> :<ul><li><strong>命令类型断言</strong> : 确保请求是命令类型；</li><li><strong>FSID 校验</strong> : 验证消息中的集群 FSID 与当前 Monitor 的集群 ID 匹配，防止跨集群操作；</li><li><strong>会话检查</strong> : 确保命令来自一个已建立的客户端会话，丢弃“游离”消息；</li><li><strong>命令非空检查</strong> : 确保命令内容不为空；</li></ul></li><li><strong>命令解析与验证</strong> :<ul><li><strong>JSON 解析</strong> : 将客户端发送的 JSON 格式命令字符串解析为内部的 cmdmap（命令参数映射）；</li><li><strong>提取前缀</strong> : 从 cmdmap 中获取命令的 prefix（例如 “osd dump”, “status”）， prefix 是命令的唯一标识符；</li><li><strong>特殊命令处理</strong> : “get_command_descriptions” 命令用于获取所有支持的命令描述，直接在此处理并返回；</li></ul></li><li><strong>命令查找与兼容性检查</strong><ul><li><strong>模块提取</strong> : 从 prefix 中提取第一个单词作为命令模块（如 osd, mds, mon）；</li><li><strong>三层命令查找</strong> :<ul><li>Leader 命令集 (leader_mon_commands) : 集群领导者支持的所有命令；</li><li>Mgr 命令集 (mgrmon()-&gt;get_command_descs()) : 由 Ceph Manager 模块管理的命令；</li><li>本地命令集 (get_local_commands) : 当前 Monitor 实例支持的命令（考虑特性兼容性）；</li></ul></li><li><strong>领导者&#x2F;追随者逻辑处理</strong> : 如果当前 Monitor 不是领导者，则通常可以转发命令给领导者，但是如果执行的命令不在本地命令集中且命令不允许转发或者与领导者的命令不兼容，则不转发并返回错误；</li></ul></li><li><strong>权限与审计</strong> :<ul><li><strong>废弃命令检查</strong> : 拒绝执行已废弃或过时的命令；</li><li><strong>权限验证 (_allowed_command)</strong>: 基于客户端的会话、身份（entity_name，如 client.admin）和能力（Capabilities）验证其是否有权执行该命令，涉及 ‘w’（写）或 ‘x’（执行）权限的命令被视为“读写命令”；</li><li><strong>审计日志</strong> : 所有命令（除少数配置命令外）都会被记录到审计日志 (audit_clog) 中，区分读写操作的日志级别；</li></ul></li><li><strong>命令路由与分发</strong> : 这是函数的主体，根据 prefix 或 module 将命令分发给对应的 Monitor 子服务 或直接处理；<ul><li><strong>代理到 Manager</strong> : 如果命令标记为 is_mgr()，则代理给 mgr_client 执行，并设有字节数配额防止过载；</li><li><strong>分发给专用监视器</strong> : 执行对应的 PaxosService::dispatch 函数；<ul><li>mdsmon() : 处理 mds 或 fs 相关命令；</li><li>osdmon() : 处理 osd、pg map、pg repeer 命令；</li><li>configmon() : 处理 config 配置命令；</li><li>monmon() : 处理大部分 mon 命令（除明确列出的几个）；</li><li>healthmon() : 处理 health 子命令；</li><li>authmon() : 处理 auth 认证和授权命令；</li><li>logmon() : 处理 log 日志命令；</li><li>kvmon() : 处理 config-key 键值存储命令；</li><li>mgrmon() : 处理 mgr 管理器命令；</li><li>nvmegwmon() : 处理 nvme-gw 网关命令；</li></ul></li><li><strong>Monitor 自身处理的命令</strong> ：一系列核心的、跨模块的或状态查询命令由 Monitor 类直接处理；这是函数中 else if 链最长的部分，包括：<ul><li>fsid : 返回集群 FSID；</li><li>mon scrub : 启动 Monitor 存储区清理；</li><li>time-sync-status : 返回集群时间同步状态；</li><li>status &#x2F; health &#x2F; df : 返回集群状态、健康详情或使用情况；</li><li>report : 生成包含集群各方面信息的详细报告；</li><li>node ls : 列出各种类型的守护进程节点；</li><li>features : 列出集群中激活的特性；</li><li>mon metadata &#x2F; versions &#x2F; count-metadata : 查询 Monitor 元数据或版本信息；</li><li>quorum_status : 返回仲裁状态；</li><li>mon ok-to-stop &#x2F; ok-to-add-offline &#x2F; ok-to-rm : 安全性地检查 Monitor 节点操作；</li><li>version &#x2F; versions : 返回 Ceph 版本信息；</li></ul></li></ul></li></ul><p><strong>简要执行流程图:</strong></p><pre><code class="hljs mermaid">sequenceDiagram
    participant C as Client
    participant M as Monitor
    participant L as Leader
    participant S as SubService

    C-&gt;&gt;M: MMonCommand 请求

    Note over M: 1. 基础验证
    M-&gt;&gt;M: FSID/会话/命令检查

    Note over M: 2. 命令解析
    M-&gt;&gt;M: 解析JSON，提取prefix

    alt 特殊命令
        M-&gt;&gt;C: 直接返回
    end

    Note over M: 3. 领导者检查
    alt M不是领导者
        M-&gt;&gt;L: 转发请求
        L-&gt;&gt;C: 处理并返回
    end

    Note over M: 4. 权限检查
    M-&gt;&gt;M: 权限验证

    Note over M: 5. 命令分发
    alt Mgr命令
        M-&gt;&gt;M: 代理到Manager
    else 模块命令
        M-&gt;&gt;S: 分发到子服务
        S-&gt;&gt;M: 返回结果
    else Monitor命令
        M-&gt;&gt;M: 直接处理
    end

    M-&gt;&gt;C: 返回结果</code></pre></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2025/12/06/ceph-cmd-register-exec/">https://bugwz.com/2025/12/06/ceph-cmd-register-exec/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Ceph/">Ceph</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/ceph.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/25/proxyassistant/" title="ProxyAssistant - 强大的浏览器代理管理扩展"><img class="cover" src="/assets/images/bg/proxyassistant.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ProxyAssistant - 强大的浏览器代理管理扩展</div></div><div class="info-2"><div class="info-item-1">ProxyAssistant 是一款功能强大的浏览器代理管理扩展，支持 Chrome、Firefox、Edge 等多款浏览器，支持多场景管理，帮助用户轻松配置和切换网络代理。作为一款开源的浏览器扩展，ProxyAssistant 凭借其丰富的功能特性、优秀的用户体验和完善的多语言支持，已成为众多用户管理网络代理的首选工具。 一、项目概述1.1、项目简介ProxyAssistant 诞生于对高效代理管理工具的需求。作为一款现代化的浏览器扩展，它采用了最新的 Manifest V3 规范，充分利用了现代浏览器提供的各种 API，为用户提供了一个界面美观、功能完善、操作便捷的代理管理解决方案。项目采用原生 JavaScript 和 jQuery 开发，是一款成熟稳定的代理管理工具。 该扩展的核心设计理念是”简单易用，功能强大”。无论是需要频繁切换不同代理服务器的用户，还是需要为不同网站配置不同代理规则的高级用户，ProxyAssistant 都能满足其需求。同时，项目完全开源，采用 MIT 许可证，任何人都可以自由使用、修改和分发。 项目地址：https://github.com/bu...</div></div></div></a><a class="pagination-related" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表"><img class="cover" src="/assets/images/bg/ceph.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ceph 和 LinuxKernel 版本时间对照表</div></div><div class="info-2"><div class="info-item-1">本文提供了一份详细的Ceph、Ceph-client与Linux内核版本对应关系表，涵盖了从2015年至今的月度发布记录。内容包含各版本的具体发布时间、GitHub链接以及三个组件的时间轴甘特图，旨在帮助用户快速查询和规划Ceph部署时所需的内核兼容性。 一、版本时间对照1.1、版本时间对照表 Month ceph ceph-client linux 2011-07 v3.0 2011-10 v3.1 2012-01 v3.2 2012-03 v3.3 2012-05 v3.4 2012-07 v3.5 2012-10 v3.6 2012-12 v3.7 2013-02 v3.8 2013-04 v3.9 2013-07 v3.10 2013-09 v3.11 2013-11 v3.12 2014-01 v3.13 2014-03 v3.14 2014-06 v3.15 2014-08 v3.16 2014-10 v3.17 2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/05/01/ceph-cmd/" title="Ceph 常用命令汇总"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-01</div><div class="info-item-2">Ceph 常用命令汇总</div></div><div class="info-2"><div class="info-item-1">一、常用命令1.1、Pool# 查看 poolceph osd pool ls detail# 创建 poolceph osd pool create testpool 32 32ceph osd pool set testpool pg_autoscale_mode off# 调整 pool pg/pgp , 并关闭自动调整ceph osd pool set testpool pg_num 32ceph osd pool set testpool pgp_num 32ceph osd pool set testpool pg_autoscale_mode off# 设置 pool 最小副本ceph osd pool set testpool min_size 1ceph osd pool set testpool size 1 --yes-i-really-mean-it# 移除 poolceph tell mon.\* injectargs &#x27;--mon-allow-pool-delete=true&#x27;ceph osd pool delete testpoo...</div></div></div></a><a class="pagination-related" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-09</div><div class="info-item-2">CephFS Inode 编号的申请与释放</div></div><div class="info-2"><div class="info-item-1">一、Inode 编号介绍1.1、编号规则在 CephFS 中 MDS 负责管理所有的 Inode 信息。CephFS 本身支持 多MDS 策略，为了避免多MDS 分配的 Inode 出现冲突，所以 MDS 在分配 Inode 的时候需要使用 RankID 来区分 Inode 的范围。每个 MDS 中限制 Inode 分配范围的函数为 InoTable::reset_state ，每个 MDS 中负责的 Inode 范围为：[(rank+1) &lt;&lt; 40, ((rank+1) &lt;&lt; 40)) ，即从 (rank+1) &lt;&lt; 40 开始的连续 1 &lt;&lt; 40 个 Inode 。 MDSRank 起始Inode编号(十进制) 起始Inode编号(十六进制) 结束Inode编号(十六进制) 管辖的Inode数量 0 1,099,511,627,776 0x10000000000 0x1FFFFFFFFF 1,099,511,627,776 1 2,199,023,255,552 0x20000000000 0x2FFFFFF...</div></div></div></a><a class="pagination-related" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">Ceph Crimson 设计实现深入解析</div></div><div class="info-2"><div class="info-item-1">Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。 以下分析基于 v19.2.1 进行分析。 一、架构对比Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD ...</div></div></div></a><a class="pagination-related" href="/2024/03/05/ceph-csi/" title="Ceph CSI 对接 K8S 指南"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="info-item-2">Ceph CSI 对接 K8S 指南</div></div><div class="info-2"><div class="info-item-1">一、介绍1.1、Ceph CSI 介绍Ceph CSI 插件实现了支持 CSI 的容器编排器 (CO) 与 Ceph 集群之间的接口。它们支持动态配置 Ceph 卷并将其附加到工作负载。项目地址: https://github.com/ceph/ceph-csi 。该仓库包含用于 RBD、CephFS 和 Kubernetes sidecar 部署 YAML 的 Ceph 容器存储接口 (CSI) 驱动程序，以支持 CSI 功能：provisioner、attacher、resizer、driver-registrar 和 snapper。 本文基于 Ceph CSI v3.14.1 版本进行测试。 Ceph CSI 驱动与测试过的 Kubernetes 版本信息表: (参考 known-to-work-co-platforms) Ceph CSI 版本 Kubernetes 版本 v3.14.1 v1.30、v1.31、v1.32 v3.14.0 v1.30、v1.31、v1.32 v3.13.1 v1.29、v1.30、v1.31 v3.13.0 v1...</div></div></div></a><a class="pagination-related" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-08</div><div class="info-item-2">Ceph 和 LinuxKernel 版本时间对照表</div></div><div class="info-2"><div class="info-item-1">本文提供了一份详细的Ceph、Ceph-client与Linux内核版本对应关系表，涵盖了从2015年至今的月度发布记录。内容包含各版本的具体发布时间、GitHub链接以及三个组件的时间轴甘特图，旨在帮助用户快速查询和规划Ceph部署时所需的内核兼容性。 一、版本时间对照1.1、版本时间对照表 Month ceph ceph-client linux 2011-07 v3.0 2011-10 v3.1 2012-01 v3.2 2012-03 v3.3 2012-05 v3.4 2012-07 v3.5 2012-10 v3.6 2012-12 v3.7 2013-02 v3.8 2013-04 v3.9 2013-07 v3.10 2013-09 v3.11 2013-11 v3.12 2014-01 v3.13 2014-03 v3.14 2014-06 v3.15 2014-08 v3.16 2014-10 v3.17 2...</div></div></div></a><a class="pagination-related" href="/2024/12/01/cephfs-samba/" title="CephFS 对接 Samba 使用教程"><img class="cover" src="/assets/images/bg/ceph.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-01</div><div class="info-item-2">CephFS 对接 Samba 使用教程</div></div><div class="info-2"><div class="info-item-1">一、Samba 介绍Samba 是一款基于 GNU 通用公共许可证的自由软件，Samba 项目是软件自由保护协会 (Software Freedom Conservancy) 的成员。自 1992 年以来，Samba 一直为所有使用 SMB&#x2F;CIFS 协议的客户端（例如所有版本的 DOS 和 Windows、OS&#x2F;2、Linux 以及许多其他系统）提供安全、稳定且快速的文件和打印服务。 Samba 项目源码位于 https://git.samba.org/samba.git , 镜像代码仓库地址为 https://github.com/samba-team/samba 。 1.1、二进制包安装部署我们的机器环境为 CentOS 8.5.2111 ， 受限于系统版本较老，导致最终安装版本为 Samba 4.19.4 。以下操作基于这些环境进行。 由于安装的 Samba 软件默认缺少 vfs_ceph 的相关库，所以在测试的时候无法测试一些使用场景，因此在实际部署测试的时候并不会使用该版本进行测试，而是会采用编译安装的版本进行测试。 1.1.1、环境初始化相关命令...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">137</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Local-Commands-%E5%88%86%E6%9E%90"><span class="toc-text">二、Local Commands 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.1、命令注册流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E3%80%81MON"><span class="toc-text">2.1.1、MON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E3%80%81MGR"><span class="toc-text">2.1.2、MGR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E3%80%81OSD"><span class="toc-text">2.1.3、OSD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4%E3%80%81MDS"><span class="toc-text">2.1.4、MDS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2、命令执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E3%80%81admin-socket-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2.1、admin socket 初始化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E3%80%81%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2.2、接收并执行命令流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Monitor-Commands-%E5%88%86%E6%9E%90"><span class="toc-text">三、Monitor Commands 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.1、命令注册流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81Monitor-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">3.1.1、Monitor 相关的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81Manager-%E4%B8%8A%E6%8A%A5%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">3.1.2、Manager 上报的命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.2、命令执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81Client-%E4%BE%A7%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.2.1、Client 侧执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81Server-%E4%BE%A7%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.2.2、Server 侧执行流程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/25/proxyassistant/" title="ProxyAssistant - 强大的浏览器代理管理扩展"><img src="/assets/images/bg/proxyassistant.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="ProxyAssistant - 强大的浏览器代理管理扩展"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/25/proxyassistant/" title="ProxyAssistant - 强大的浏览器代理管理扩展">ProxyAssistant - 强大的浏览器代理管理扩展</a><time datetime="2026-01-24T16:00:00.000Z" title="发表于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/06/ceph-cmd-register-exec/" title="Ceph 命令注册及执行流程"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph 命令注册及执行流程"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/12/06/ceph-cmd-register-exec/" title="Ceph 命令注册及执行流程">Ceph 命令注册及执行流程</a><time datetime="2025-12-05T16:00:00.000Z" title="发表于 2025-12-06 00:00:00">2025-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph 和 LinuxKernel 版本时间对照表"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表">Ceph 和 LinuxKernel 版本时间对照表</a><time datetime="2025-11-07T16:00:00.000Z" title="发表于 2025-11-08 00:00:00">2025-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="CephFS Inode 编号的申请与释放"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放">CephFS Inode 编号的申请与释放</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph Crimson 设计实现深入解析"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/assets/images/bg/ceph.webp)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2026 By bugwz</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const e=e=>{const t=(e=>{if(!e)return null;const t=e.trim().split(/[\s,]+/).map(e=>Number(e));return 4!==t.length||t.some(e=>Number.isNaN(e))?null:t})(e.getAttribute("viewBox"));if(t)return t;try{const t=e.getBBox();if(t&&t.width&&t.height)return[t.x,t.y,t.width,t.height]}catch(e){}const n=Number(e.getAttribute("width"))||0,i=Number(e.getAttribute("height"))||0;return n>0&&i>0?[0,0,n,i]:[0,0,100,100]},t=(e,t)=>{e.setAttribute("viewBox",`${t[0]} ${t[1]} ${t[2]} ${t[3]}`)},n=(e,t,n)=>Math.max(t,Math.min(n,e)),i=({source:e,initViewBox:t})=>{const n=(()=>{if("string"==typeof e){const t=document.createElement("template");t.innerHTML=e.trim();const n=t.content.querySelector("svg");return n?n.cloneNode(!0):null}return e&&"function"==typeof e.cloneNode?e.cloneNode(!0):null})();if(!n)return;t&&4===t.length&&n.setAttribute("viewBox",t.join(" ")),n.getAttribute("xmlns")||n.setAttribute("xmlns","http://www.w3.org/2000/svg"),!n.getAttribute("xmlns:xlink")&&n.outerHTML.includes("xlink:")&&n.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");const i="dark"===document.documentElement.getAttribute("data-theme"),r=getComputedStyle(document.body).backgroundColor||(i?"#1e1e1e":"#ffffff");n.style.background||(n.style.background=r);const o=(new XMLSerializer).serializeToString(n),a=new Blob([o],{type:"image/svg+xml;charset=utf-8"}),s=URL.createObjectURL(a);window.open(s,"_blank","noopener"),setTimeout(()=>URL.revokeObjectURL(s),3e4)},r=(e,t,n,i)=>{const r=e[2]*t,o=e[3]*t;return[n-(n-e[0])*t,i-(i-e[1])*t,r,o]},o=i=>{const o=i.querySelector("svg");if(!o)return;const a=e(o);if(i.__mermaidInitViewBox=a,i.__mermaidCurViewBox=a.slice(),t(o,a),i.__mermaidGestureBound)return;i.__mermaidGestureBound=!0;const s=(t,n)=>{const r=o.getBoundingClientRect(),a=i.__mermaidCurViewBox||e(o);return{x:a[0]+(t-r.left)*(a[2]/r.width),y:a[1]+(n-r.top)*(a[3]/r.height),rect:r,vb:a}},d={pointers:new Map,startVb:null,startDist:0,startCenter:null},m=e=>{e=(e=>{const t=i.__mermaidInitViewBox||e,r=.1*t[2],o=10*t[2],a=.1*t[3],s=10*t[3];return e[2]=n(e[2],r,o),e[3]=n(e[3],a,s),e})(e),i.__mermaidCurViewBox=e,t(o,e)},c=e=>{d.pointers.delete(e.pointerId),0===d.pointers.size?(d.startVb=null,d.startDist=0,d.startCenter=null,i.__mermaidLastSinglePointer=null):1===d.pointers.size&&(i.__mermaidLastSinglePointer=[...d.pointers.values()][0])};o.addEventListener("pointerdown",t=>{if(!i.__mermaidLocked&&("mouse"!==t.pointerType||0===t.button))if(o.setPointerCapture(t.pointerId),d.pointers.set(t.pointerId,{x:t.clientX,y:t.clientY}),1===d.pointers.size)d.startVb=(i.__mermaidCurViewBox||e(o)).slice();else if(2===d.pointers.size){const t=[...d.pointers.values()],n=t[0].x-t[1].x,r=t[0].y-t[1].y;d.startDist=Math.hypot(n,r),d.startVb=(i.__mermaidCurViewBox||e(o)).slice(),d.startCenter={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2}}}),o.addEventListener("pointermove",t=>{if(!i.__mermaidLocked&&d.pointers.has(t.pointerId)){if(d.pointers.set(t.pointerId,{x:t.clientX,y:t.clientY}),1===d.pointers.size&&d.startVb){const n=[...d.pointers.values()][0],r=(t.clientX,t.movementX,t.clientY,t.movementY,i.__mermaidLastSinglePointer||n),a=n.x-r.x,c=n.y-r.y;i.__mermaidLastSinglePointer=n;const{rect:l}=s(n.x,n.y),u=(i.__mermaidCurViewBox||e(o)).slice(),p=a*(u[2]/l.width),_=c*(u[3]/l.height);return void m([u[0]-p,u[1]-_,u[2],u[3]])}if(2===d.pointers.size&&d.startVb&&d.startDist>0){const e=[...d.pointers.values()],t=e[0].x-e[1].x,n=e[0].y-e[1].y,i=Math.hypot(t,n);if(!i)return;const o=d.startDist/i,a={x:(e[0].x+e[1].x)/2,y:(e[0].y+e[1].y)/2},c=s(a.x,a.y),l=c.x,u=c.y,p=r(d.startVb,o,l,u);m(p)}}}),o.addEventListener("pointerup",c),o.addEventListener("pointercancel",c),o.addEventListener("wheel",t=>{if(i.__mermaidLocked)return;t.preventDefault();const n=t.deltaY>0?1.1:.9,{x:a,y:d}=s(t.clientX,t.clientY),c=(i.__mermaidCurViewBox||e(o)).slice();m(r(c,n,a,d))},{passive:!1}),o.addEventListener("dblclick",()=>{if(i.__mermaidLocked)return;const e=i.__mermaidInitViewBox;e&&(i.__mermaidCurViewBox=e.slice(),t(o,e))})},a=e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,n)=>{const r=e.firstElementChild,a=e.querySelector("svg");a&&a.remove(),e.__mermaidGestureBound=!1;const s=r.dataset.config?JSON.parse(r.dataset.config):{};s.theme||(s.theme=t);const d=`mermaid-${n}`,m=`%%{init: ${JSON.stringify(s)}}%%\n`+r.textContent,c=mermaid.render(d,m),l=t=>{r.insertAdjacentHTML("afterend",t),o(e),e.__mermaidOriginalSvg=t,(e=>{const t=e.__mermaidOriginalSvg;let n=e.querySelector(".mermaid-open-btn");n||(n=document.createElement("button"),n.type="button",n.className="mermaid-open-btn",e.appendChild(n)),n.innerHTML='<i class="fa fa-search fa-fw" aria-hidden="true"></i>',n.__mermaidViewerBound||(n.addEventListener("click",n=>{n.preventDefault(),n.stopPropagation();const r=t||e.querySelector("svg");if(!r)return;const o=e.__mermaidInitViewBox;i({source:r,initViewBox:o})}),n.__mermaidViewerBound=!0);let r=e.querySelector(".mermaid-lock-btn");if(!r){r=document.createElement("button"),r.type="button",r.className="mermaid-lock-btn",r.title="Click to unlock interaction",e.appendChild(r);const t=t=>{r.innerHTML=t?'<i class="fa fa-lock fa-fw" aria-hidden="true"></i>':'<i class="fa fa-unlock fa-fw" aria-hidden="true"></i>',r.classList.toggle("locked",t),r.classList.toggle("unlocked",!t),e.__mermaidLocked=t,e.style.setProperty("--mermaid-interaction",t?"none":"auto")};t(!0),r.__mermaidLockBound||(r.addEventListener("click",n=>{n.preventDefault(),n.stopPropagation(),t(!e.__mermaidLocked)}),r.__mermaidLockBound=!0)}})(e)};"string"==typeof c?l(c):c.then(({svg:e})=>l(e))})},s=()=>{(()=>{const e=document.querySelectorAll("pre > code.mermaid");0!==e.length&&e.forEach(e=>{const t=document.createElement("pre");t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent;const n=document.createElement("div");n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)})})();const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>a(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",s,"mermaid"),window.pjax?s():document.addEventListener("DOMContentLoaded",s)})()</script><script>(()=>{const t="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=null,n=t=>{const e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.textContent=t)},i=(i,o)=>{t&&(window.shuoshuoComment.destroyGitalk=()=>{i.children.length&&(i.innerHTML="",i.classList.add("no-comment"))});new Gitalk({clientID:"6af3be16b94cec39bcf6",clientSecret:"ff79d2c5b817fe837ad43a1d9f8e0dd68190ceb5",repo:"bugwz.github.io",owner:"bugwz",admin:["bugwz"],updateCountCallback:n,...e,id:t?o:"18b0ec69086974f9d0d73879950eac1b"}).render("gitalk-container")},o=async(t,e)=>{"function"==typeof Gitalk||(await btf.getCSS("/pluginsSrc/gitalk/dist/gitalk.css"),await btf.getScript("/pluginsSrc/gitalk/dist/gitalk.min.js")),i(t,e)};t?window.shuoshuoComment={loadComment:o}:o()})()</script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="/pluginsSrc/@docsearch/css/dist/style.css"/><script src="/pluginsSrc/@docsearch/js/dist/umd/index.js"></script><script>(()=>{docsearch(Object.assign({appId:"PFB3WGSSCO",apiKey:"3e9cd446e41d93f2f130b91698b699f7",indexName:"bugwz",container:"#docsearch",placeholder:"请输入要搜索的内容"},{maxResultsPerGroup:10}));const e=()=>{document.querySelector(".DocSearch-Button").click()},c=()=>{btf.addEventListenerPjax(document.querySelector("#search-button > .search"),"click",e)};c(),window.addEventListener("pjax:complete",c)})()</script></div></div></body></html>