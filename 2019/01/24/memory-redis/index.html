<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Redis的Memory命令讲解 | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Memory 指令是 Redis4.0 版本更新的特性，可用于详细的分析内存的使用情况，内存使用诊断，内存碎片回收等工作"><meta property="og:type" content="article"><meta property="og:title" content="Redis的Memory命令讲解"><meta property="og:url" content="https://bugwz.com/2019/01/24/memory-redis/index.html"><meta property="og:site_name" content="咕咕"><meta property="og:description" content="Memory 指令是 Redis4.0 版本更新的特性，可用于详细的分析内存的使用情况，内存使用诊断，内存碎片回收等工作"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bugwz.com/assets/images/bg/redis.jpg"><meta property="article:published_time" content="2019-01-23T16:00:00.000Z"><meta property="article:modified_time" content="2025-12-16T13:38:47.394Z"><meta property="article:author" content="bugwz"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bugwz.com/assets/images/bg/redis.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis的Memory命令讲解",
  "url": "https://bugwz.com/2019/01/24/memory-redis/",
  "image": "https://bugwz.com/assets/images/bg/redis.jpg",
  "datePublished": "2019-01-23T16:00:00.000Z",
  "dateModified": "2025-12-16T13:38:47.394Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="preload" as="script" href="/js/utils.js"><link rel="preload" as="script" href="/js/main.js"><link rel="canonical" href="https://bugwz.com/2019/01/24/memory-redis/index.html"><link rel="preconnect"/><link rel="preload" as="style" href="/css/index.css" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/css/index.css"></noscript><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><noscript><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"></noscript><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:500,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Redis的Memory命令讲解",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/self/github-dark.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar-256.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">135</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/assets/images/bg/redis.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis的Memory命令讲解</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis的Memory命令讲解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-23T16:00:00.000Z" title="发表于 2019-01-24 00:00:00">2019-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-16T13:38:47.394Z" title="更新于 2025-12-16 21:38:47">2025-12-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p><code>Memory</code>指令是Redis4.0版本更新的特性，可用于详细的分析内存的使用情况，内存使用诊断，内存碎片回收等工作；</p><p>可以通过<code>memory help</code>指令打印出<code>memory</code>指令的信息，详细信息如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">1) MEMORY &lt;subcommand&gt; arg arg ... arg. Subcommands are:<br>2) DOCTOR - Return memory problems reports.<br>3) MALLOC-STATS -- Return internal statistics report from the memory allocator.<br>4) PURGE -- Attempt to purge dirty pages <span class="hljs-keyword">for</span> reclamation by the allocator.<br>5) STATS -- Return information about the memory usage of the server.<br>6) USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] -- Return memory <span class="hljs-keyword">in</span> bytes used by &lt;key&gt; and its value. Nested values are sampled up to &lt;count&gt; <span class="hljs-built_in">times</span> (default: 5).<br></code></pre></td></tr></table></figure><p>具体的指令相关解释为：</p><ul><li><code>MEMORY DOCKER</code>：返回内存问题报告；</li><li><code>MEMORY MALLOC-STATS</code>：从内存分配器返回内部统计信息报告；</li><li><code>MEMORY PURGE</code>：尝试通过分配器清除脏页以进行回收；</li><li><code>MEMORY STATS</code>：返回有关服务器内存使用情况的信息；</li><li><code>MEMORY USAGE key [SAMPLES count]</code>：返回 key 使用的字节数及其值， 嵌套值最多采样 count 次（默认值：5）；</li></ul><h2 id="二、具体的指令解析"><a href="#二、具体的指令解析" class="headerlink" title="二、具体的指令解析"></a>二、具体的指令解析</h2><h3 id="2-1、MEMORY-DOCKER"><a href="#2-1、MEMORY-DOCKER" class="headerlink" title="2.1、MEMORY DOCKER"></a>2.1、MEMORY DOCKER</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">memory doctor<br></code></pre></td></tr></table></figure><p>该指令主要列举条件判断，满足条件的给出检查结果和建议，主要包含以下几点，满足其中一点，就给出诊断结果和建议，检测报告会提示所有检测出的问题，检测结构主要为一下几种情况：</p><ul><li><code>无异常</code>：并没有检测出问题；</li><li><code>空实例/内存占用小</code>：示例实际分配内存小于5M，无法进一步进行检测（代码：<code>mh-&gt;total_allocated &lt; (1024*1024*5)</code>）；</li><li><code>历史内存与当前内存比例过大</code>：redis自启动以来分配的内存峰值&#x2F;当前的内存大小结果大于 1.5（代码：<code>((float)mh-&gt;peak_allocated / mh-&gt;total_allocated) &gt; 1.5</code>）；</li><li><code>内存碎片率</code>：内存碎片率大于1.4（代码：<code>mh-&gt;fragmentation &gt; 1.4</code>）；</li><li><code>一般客户端单实例内存</code>：非从库客户端的单实例内存占用大于200KB（代码：<code>mh-&gt;clients_normal / numclients &gt; (1024*200)</code>）；</li><li><code>从库客户端单实例内存</code>：在有从库的前提下，从库客户端的单实例内存占用大于10M（代码：<code>numslaves &gt; 0 &amp;&amp; mh-&gt;clients_slaves / numslaves &gt; (1024*1024*10)</code>）；</li></ul><p><strong>执行结果示例：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Sam, I detected a few issues <span class="hljs-keyword">in</span> this Redis instance memory implants:<br><br> * High fragmentation: This instance has a memory fragmentation greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the <span class="hljs-built_in">sum</span> of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check <span class="hljs-keyword">if</span> there is a peak memory entry above <span class="hljs-keyword">in</span> the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, <span class="hljs-keyword">then</span> there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is <span class="hljs-string">&quot;jemalloc-3.2.0&quot;</span>.<br><br>I<span class="hljs-string">&#x27;m here to keep you safe, Sam. I want to help you.</span><br></code></pre></td></tr></table></figure><h3 id="2-2、MEMORY-MALLOC-STATS"><a href="#2-2、MEMORY-MALLOC-STATS" class="headerlink" title="2.2、MEMORY MALLOC-STATS"></a>2.2、MEMORY MALLOC-STATS</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">memory malloc-stats<br></code></pre></td></tr></table></figure><p>打印内存分配器状态，只在使用jemalloc时有用；</p><p><strong>执行结果示例：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">___ Begin jemalloc statistics ___<br>Version: 3.2.0-0-g87499f6748ebe4817571e817e9f680ccb5bf54a9<br>Assertions disabled<br>Run-<span class="hljs-keyword">time</span> option settings:<br>  opt.abort: <span class="hljs-literal">false</span><br>  opt.lg_chunk: 22<br>  opt.dss: <span class="hljs-string">&quot;secondary&quot;</span><br>  opt.narenas: 128<br>  opt.lg_dirty_mult: 3<br>  opt.stats_print: <span class="hljs-literal">false</span><br>  opt.junk: <span class="hljs-literal">false</span><br>  opt.quarantine: 0<br>  opt.redzone: <span class="hljs-literal">false</span><br>  opt.zero: <span class="hljs-literal">false</span><br>  opt.tcache: <span class="hljs-literal">true</span><br>  opt.lg_tcache_max: 15<br>CPUs: 32<br>Arenas: 128<br>Pointer size: 8<br>Quantum size: 16<br>Page size: 4096<br>Min active:dirty page ratio per arena: 8:1<br>Maximum thread-cached size class: 32768<br>Chunk size: 4194304 (2^22)<br>Allocated: 5948968, active: 6402048, mapped: 20971520<br>Current active ceiling: 12582912<br>chunks: nchunks   highchunks    curchunks<br>              5            5            5<br>huge: nmalloc      ndalloc    allocated<br>            0            0            0<br><br>Merged arenas stats:<br>assigned threads: 2<br>dss allocation precedence: N/A<br>dirty pages: 1563:0 active:dirty, 5 sweeps, 4 madvises, 386 purged<br>            allocated      nmalloc      ndalloc    nrequests<br>small:         501288        12362         1272       283989<br>large:        5447680           12            4           14<br>total:        5948968        12374         1276       284003<br>active:       6402048<br>mapped:      12582912<br>bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns<br>            0     8  501   1           40          109          104          100            3            6            1            0            1<br>            1    16  252   1       164336        10372          101       282735          114            9           41            0           41<br>            2    32  126   1        14432          604          153          751           25           10            5            7            4<br>            3    48   84   1         1200           99           74          181            4            9            1            0            1<br>            4    64   63   1          640           80           70           56            4            6            1            0            1<br>            5    80   50   1         1760           80           58           23            5            6            1            0            1<br>            6    96   84   2         8544          119           30           94            7            7            2            0            2<br>            7   112   72   2          448           80           76            6            3            6            1            0            1<br>            8   128   63   2          768           76           70           19            6            9            1            0            1<br>[9..10]<br>           11   224   72   4          448           78           76            2            3            6            3            0            1<br>           12   256   63   4          768           72           69            6            4            6            4            0            1<br>[13..14]<br>           15   448   63   7        28224           63            0            0            1            0            1            0            1<br>           16   512   63   8         1536           69           66            4            3            5            3            0            1<br>           17   640   51   8            0           51           51            1            1            3            1            0            0<br>           18   768   47   9          768           47           46            1            1            3            1            0            1<br>           19   896   45  10        40320           45            0            0            1            0            1            0            1<br>           20  1024   63  16         1024           67           66            4            3            6            2            0            1<br>[21]<br>           22  1536   42  16            0           47           47            2            2            5            2            0            0<br>           23  1792   38  17        68096           38            0            0            1            0            1            0            1<br>           24  2048   65  33        10240           69           64            2            2            4            1            0            1<br>           25  2560   52  33        17920           58           51            2            2            3            1            0            1<br>[26]<br>           27  3584   39  35       139776           39            0            0            1            0            1            0            1<br>large:   size pages      nmalloc      ndalloc    nrequests      curruns<br>[1]<br>         8192     2            5            3            7            2<br>[1]<br>        16384     4            2            0            2            2<br>[3]<br>        32768     8            2            0            2            2<br>[292]<br>      1232896   301            1            0            1            1<br>[30]<br>      1359872   332            1            1            1            0<br>[668]<br>      4100096  1001            1            0            1            1<br>[17]<br><br>arenas[0]:<br>assigned threads: 1<br>dss allocation precedence: disabled<br>dirty pages: 1554:0 active:dirty, 3 sweeps, 4 madvises, 386 purged<br>            allocated      nmalloc      ndalloc    nrequests<br>small:         498088        12262         1272       283989<br>large:        5414912           11            4           13<br>total:        5913000        12273         1276       284002<br>active:       6365184<br>mapped:       8388608<br>bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns<br>            0     8  501   1           40          109          104          100            3            6            1            0            1<br>            1    16  252   1       164336        10372          101       282735          114            9           41            0           41<br>            2    32  126   1        11232          504          153          751           24           10            4            7            3<br>            3    48   84   1         1200           99           74          181            4            9            1            0            1<br>            4    64   63   1          640           80           70           56            4            6            1            0            1<br>            5    80   50   1         1760           80           58           23            5            6            1            0            1<br>            6    96   84   2         8544          119           30           94            7            7            2            0            2<br>            7   112   72   2          448           80           76            6            3            6            1            0            1<br>            8   128   63   2          768           76           70           19            6            9            1            0            1<br>[9..10]<br>           11   224   72   4          448           78           76            2            3            6            3            0            1<br>           12   256   63   4          768           72           69            6            4            6            4            0            1<br>[13..14]<br>           15   448   63   7        28224           63            0            0            1            0            1            0            1<br>           16   512   63   8         1536           69           66            4            3            5            3            0            1<br>           17   640   51   8            0           51           51            1            1            3            1            0            0<br>           18   768   47   9          768           47           46            1            1            3            1            0            1<br>           19   896   45  10        40320           45            0            0            1            0            1            0            1<br>           20  1024   63  16         1024           67           66            4            3            6            2            0            1<br>[21]<br>           22  1536   42  16            0           47           47            2            2            5            2            0            0<br>           23  1792   38  17        68096           38            0            0            1            0            1            0            1<br>           24  2048   65  33        10240           69           64            2            2            4            1            0            1<br>           25  2560   52  33        17920           58           51            2            2            3            1            0            1<br>[26]<br>           27  3584   39  35       139776           39            0            0            1            0            1            0            1<br>large:   size pages      nmalloc      ndalloc    nrequests      curruns<br>[1]<br>         8192     2            5            3            7            2<br>[1]<br>        16384     4            2            0            2            2<br>[3]<br>        32768     8            1            0            1            1<br>[292]<br>      1232896   301            1            0            1            1<br>[30]<br>      1359872   332            1            1            1            0<br>[668]<br>      4100096  1001            1            0            1            1<br>[17]<br><br>arenas[1]:<br>assigned threads: 1<br>dss allocation precedence: disabled<br>dirty pages: 9:0 active:dirty, 2 sweeps, 0 madvises, 0 purged<br>            allocated      nmalloc      ndalloc    nrequests<br>small:           3200          100            0            0<br>large:          32768            1            0            1<br>total:          35968          101            0            1<br>active:         36864<br>mapped:       4194304<br>bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns<br>[0..1]<br>            2    32  126   1         3200          100            0            0            1            0            1            0            1<br>[3..27]<br>large:   size pages      nmalloc      ndalloc    nrequests      curruns<br>[7]<br>        32768     8            1            0            1            1<br>[1010]<br>--- End jemalloc statistics ---<br></code></pre></td></tr></table></figure><p>执行结果说明：无，待补充</p><h3 id="2-3、MEMORY-PURGE"><a href="#2-3、MEMORY-PURGE" class="headerlink" title="2.3、MEMORY PURGE"></a>2.3、MEMORY PURGE</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">memory purge<br></code></pre></td></tr></table></figure><p>该指令通过调用<code>jemalloc</code>的内部命令尽量把<code>redis</code>进程占用但未有效使用内存释放，即常说的内存碎片释放给操作系统（只适用于使用jemalloc作为allocator的实例）；</p><h3 id="2-4、MEMORY-STATS"><a href="#2-4、MEMORY-STATS" class="headerlink" title="2.4、MEMORY STATS"></a>2.4、MEMORY STATS</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">memory stats<br></code></pre></td></tr></table></figure><p>在 redis 4.0 之前，只能通过<code>info memory</code>查看redis实例的内存大体使用状况，而无法了解内存的具体使用细节，比如<code>expire的消耗</code>，<code>client output buffer</code>, <code>query buffer</code>等是很难直观显示的。该指令能够展现<code>redis</code>内部内存使用细节；</p><p><strong>执行结果示例及对应参数解析：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"> 1) <span class="hljs-string">&quot;peak.allocated&quot;</span> <span class="hljs-comment"># redis从启动来，allocator分配的内存峰值</span><br> 2) (<span class="hljs-built_in">integer</span>) 2290242368<br> 3) <span class="hljs-string">&quot;total.allocated&quot;</span> <span class="hljs-comment"># allocator分配当前内存字节数</span><br> 4) (<span class="hljs-built_in">integer</span>) 2290241776<br> 5) <span class="hljs-string">&quot;startup.allocated&quot;</span> <span class="hljs-comment"># redis启动完成使用的内存字节数</span><br> 6) (<span class="hljs-built_in">integer</span>) 6315320<br> 7) <span class="hljs-string">&quot;clients.normal&quot;</span> <span class="hljs-comment"># 所有一般客户端消耗内存节字数,即所有flag为N的客户端内存使用</span><br> 8) (<span class="hljs-built_in">integer</span>) 150754<br> 9) <span class="hljs-string">&quot;aof.buffer&quot;</span> <span class="hljs-comment"># aof buffer使用内存字节数，一般较小，在aof rewrite时会变得较大</span><br>10) (<span class="hljs-built_in">integer</span>) 0<br>11) <span class="hljs-string">&quot;lua.caches&quot;</span> <span class="hljs-comment"># 所有lua脚本占用的内存节字数</span><br>12) (<span class="hljs-built_in">integer</span>) 0<br>13) <span class="hljs-string">&quot;db.0&quot;</span><br>14) 1) <span class="hljs-string">&quot;overhead.hashtable.main&quot;</span> <span class="hljs-comment"># 对应db的所有key的hash表总的内存节字数</span><br>    2) (<span class="hljs-built_in">integer</span>) 680720488<br>    3) <span class="hljs-string">&quot;overhead.hashtable.expires&quot;</span> <span class="hljs-comment"># 对应db的过期key的hash表总的内存节字数</span><br>    4) (<span class="hljs-built_in">integer</span>) 416<br>15) <span class="hljs-string">&quot;overhead.total&quot;</span> <span class="hljs-comment"># redis总的分配的内存的字节数</span><br>16) (<span class="hljs-built_in">integer</span>) 687186978<br>17) <span class="hljs-string">&quot;keys.count&quot;</span> <span class="hljs-comment"># 整个实例key的个数，相同于dbsize返回值</span><br>18) (<span class="hljs-built_in">integer</span>) 13662569<br>19) <span class="hljs-string">&quot;keys.bytes-per-key&quot;</span> <span class="hljs-comment"># 每个key平均占用字节数；把overhead也均摊到每个key上</span><br>20) (<span class="hljs-built_in">integer</span>) 167<br>21) <span class="hljs-string">&quot;dataset.bytes&quot;</span> <span class="hljs-comment"># 表示redis数据集占用的内存容量，即分配的内存总量减去 overhead.total</span><br>22) (<span class="hljs-built_in">integer</span>) 1603054798<br>23) <span class="hljs-string">&quot;dataset.percentage&quot;</span> <span class="hljs-comment"># 表示redis数据占用内存占总内存分配的百分比</span><br>24) <span class="hljs-string">&quot;70.188545227050781&quot;</span><br>25) <span class="hljs-string">&quot;peak.percentage&quot;</span> <span class="hljs-comment"># 当前内存使用量在峰值时的占比</span><br>26) <span class="hljs-string">&quot;99.999977111816406&quot;</span><br>27) <span class="hljs-string">&quot;allocator.allocated&quot;</span> <span class="hljs-comment"># 该参数不同与 total.allocated, 它计算所有分配的内存大小（不仅仅是使用zmalloc分配的）</span><br>28) (<span class="hljs-built_in">integer</span>) 2291632296<br>29) <span class="hljs-string">&quot;allocator.active&quot;</span> <span class="hljs-comment"># 与常驻内存allocator.resident不同，这不包括jemalloc申请的还未使用的内存</span><br>30) (<span class="hljs-built_in">integer</span>) 2293006336<br>31) <span class="hljs-string">&quot;allocator.resident&quot;</span> <span class="hljs-comment"># 与RSS不同，这不包括来自共享库和其他非堆映射的RSS</span><br>32) (<span class="hljs-built_in">integer</span>) 2340564992<br>33) <span class="hljs-string">&quot;allocator-fragmentation.ratio&quot;</span> <span class="hljs-comment"># 等于 allocator.active / allocator.allocated</span><br>34) <span class="hljs-string">&quot;1.0005995035171509&quot;</span><br>35) <span class="hljs-string">&quot;allocator-fragmentation.bytes&quot;</span> <span class="hljs-comment"># 等于 allocator.active - allocator.allocated</span><br>36) (<span class="hljs-built_in">integer</span>) 1374040<br>37) <span class="hljs-string">&quot;allocator-rss.ratio&quot;</span> <span class="hljs-comment"># 等于 allocator.resident / allocator.active</span><br>38) <span class="hljs-string">&quot;1.0207407474517822&quot;</span><br>39) <span class="hljs-string">&quot;allocator-rss.bytes&quot;</span> <span class="hljs-comment"># 等于 allocator.resident - allocator.active</span><br>40) (<span class="hljs-built_in">integer</span>) 47558656<br>41) <span class="hljs-string">&quot;rss-overhead.ratio&quot;</span> <span class="hljs-comment"># 等于 RSS / allocator.resident</span><br>42) <span class="hljs-string">&quot;0.99930697679519653&quot;</span><br>43) <span class="hljs-string">&quot;rss-overhead.bytes&quot;</span> <span class="hljs-comment"># 等于 RSS - allocator.resident</span><br>44) (<span class="hljs-built_in">integer</span>) -1622016<br>45) <span class="hljs-string">&quot;fragmentation&quot;</span> <span class="hljs-comment"># 等于 RSS / total.allocated</span><br>46) <span class="hljs-string">&quot;1.0212923288345337&quot;</span><br>47) <span class="hljs-string">&quot;fragmentation.bytes&quot;</span> <span class="hljs-comment"># 等于 RSS - total.allocated</span><br>48) (<span class="hljs-built_in">integer</span>) 48763208<br></code></pre></td></tr></table></figure><h3 id="2-5、MEMORY-USAGE-key-SAMPLES-count"><a href="#2-5、MEMORY-USAGE-key-SAMPLES-count" class="headerlink" title="2.5、MEMORY USAGE key [SAMPLES count]"></a>2.5、MEMORY USAGE key [SAMPLES count]</h3><p><strong>使用方式</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 针对全部key</span><br>memory usage k1<br><span class="hljs-comment"># 针对编码使用 REDIS_ENCODING_HT 和 REDIS_ENCODING_SKIPLIST 的另一种方式</span><br><span class="hljs-comment"># 采样10个元素近似估算整个value的实际内存占用</span><br>memory usage tk samples 10<br><br></code></pre></td></tr></table></figure><p><strong>其他特点：</strong></p><ul><li>只计算value对应的内存估计值，key不存在返回nil；</li><li>如果key存在过期，不包含Key Expire的内存占用；</li><li>对于编码类型为<code>REDIS_ENCODING_HT</code>和<code>REDIS_ENCODING_SKIPLIST</code>，usage子命令采用类似<code>LRU SAMPLES</code>的抽样方式，默认抽样5个元素求平均 X 元数个数 得出实际内存占用，计算结果是近似值，当面可以指定抽样的SAMPLES个数；</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2019/01/24/memory-redis/">https://bugwz.com/2019/01/24/memory-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/redis.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/01/13/tcl-first/" title="TCL语言入门"><img class="cover" src="/assets/images/bg/tcl.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCL语言入门</div></div><div class="info-2"><div class="info-item-1">一、简述Tcl是一种很通用的脚本语言，它几乎在所有的平台上都可以释运行，一条TCL的命令串包含若干条命令，命令使用换行符或分号来隔开；而每一条命令包含若干个域(field)，域使用空白（空格或TAB）来隔开——第一个域是命令的名字，其它的域是该命令的参数。 二、基本语法2.1、注释注释在调试的过程中轻常碰到。TCL语言的注释符号是 # ，加在每一行的最前面。 2.2、脚本、命令、单词一个TCL 脚本 可以包含一个或多个 命令 。 命令 之间必须用换行符或分号隔开，推荐使用换行符分开。下面就是一个合法的TCL 脚本 ，它由两个赋值 命令 组成； set a 1set b 2 TCL的每一个 命令 包含一个或几个 单词，第一个单词代表命令名，另外的单词则是这个命令的参数，单词之间必须用 空格 或 TAB键 隔开。上面代码中的 set ， a ， 1 分别是三个单词。 TCL解释器对一个 命令 的求值过程分为两部分：分析和执行； 在分析阶段，TCL 解释器运用规则把 命令 分成一个个独立的单词，同时进行必要的 置换(substitution) ； 在执行阶段，TCL...</div></div></div></a><a class="pagination-related" href="/2019/07/01/leaky-and-token-bucket/" title="漏桶与令牌桶速率限制算法"><img class="cover" src="/assets/images/bg/speed-limit.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">漏桶与令牌桶速率限制算法</div></div><div class="info-2"><div class="info-item-1">一、漏桶算法漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。示意图如下所示： 1.1、算法过程 数据包入队列：数据包按照一定的顺序存储入用于临时存储的缓存队列（数据桶）中； 数据包等待或溢出：数据包在缓存队列（数据桶）中等待一段时间，或者如果此时缓存队列（数据桶）已经达到存储的上限，数据包溢出（被丢弃）； 数据包出队列：将缓存队列（数据桶）中的数据包按照固定的速率依次出队列并进行处理； 1.2、特点 优点： 能够强行限制数据的传输速率； 保证严格的延迟界限； 缺点： 对突发性的流量缺乏处理效率； 1.3、相关项目 Nginx中关于漏桶的设计与实现：ngx_http_limit_req_module...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/05/21/codis-slots-rebalance/" title="Codis的Slots-Rebalance算法"><img class="cover" src="/assets/images/bg/redis.jpg" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-21</div><div class="info-item-2">Codis的Slots-Rebalance算法</div></div><div class="info-2"><div class="info-item-1">Codis 实现了另一种的 Redis 集群方案。在该方案中为了能够实现类似于 RedisCluster 的横向扩缩容的能力，Codis 内部实现了一种 Slot-Rebalance 的算法，该算法中所有的 key 都被哈希到 1024 个 slots 上，在每个 slots 分配均匀的前提下，如果一个分片中的 slots 过多，该分片中存储的 key 的数量也就越多，该分片对应的负载也就越大，在扩缩容之后为了保证集群中各分片的负载均衡，需要调整分片的 slots...</div></div></div></a><a class="pagination-related" href="/2019/01/12/localtime/" title="localtime函数死锁分析"><img class="cover" src="/assets/images/bg/deadlock.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-12</div><div class="info-item-2">localtime函数死锁分析</div></div><div class="info-2"><div class="info-item-1">一、简介前段时间，线上的redis实例出现了一些异常的情况，具体变现就是bgsave子进程hang住了，从而引发了后续的很多问题，通过排查最终发现是localtime相关函数引起的，这里做一下总结记录。 C 库函数 *struct tm *localtime(const time_t timer) 作用是根据本地时区信息将 time 函数获取的 UTC 时间调整为为本地时间，并将具体的时间信息填充到tm结构体之中； 二、详细介绍由于localtime函数的具体底层实现的缘由，在某些场景下会触发localtime函数导致的死锁问题，这里详细的分析原因以及后续的处理方案； 2.1 底层实现分析localtime函数底层的调用栈信息为： localtime() =&gt; __tz_convert() localtime 函数的底层代码实现（代码位于./time/localtime.c）： /* Return the `struct tm&#x27; representation of *T in local time. */struct tm *localtime...</div></div></div></a><a class="pagination-related" href="/2022/12/31/redis-az-sync/" title="Redis异地多活方案杂谈"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-31</div><div class="info-item-2">Redis异地多活方案杂谈</div></div><div class="info-2"><div class="info-item-1">Redis 的异地多活是一种跨地域容灾、并提供低延迟访问的部署方案。业界提供了很多的构建思路，这里将对比一下这里方案，并详细介绍一下业界的设计与实现。 一、简介二、思考2.1、Redis异地多活的定位在使用 Redis 的异地多活部署方案之前，为了提供 Redis 集群的高可用，我们也会提供跨地域主从的部署方式，通过这种方式我们也能实现地域级别的容灾能力。考虑到业务在使用 Redis 前的关注点一般是：性能、延迟、可用性以及数据一致性，我们将通过这四个关键点来对比一下这两种方案的不同： 性能（高性能， QPS ）： 跨地域主从：跨地域写性能较差，本地域读性能较好； 异地多活：本地域读写性能较好； 延迟（低延迟， Avg ， P99 等）： 跨地域主从：跨地域写延迟交高，本地域读延迟较低； 异地多活：本地域读写延迟较低； 可用性（高可用）： 跨地域主从：集群间的容灾切换，存在主从切换的瞬时访问问题，满足高可用需求； 异地多活：集群内的主从故障切换，满足高可用需求； 数据一致性： 跨地域主从：提供 Redis...</div></div></div></a><a class="pagination-related" href="/2019/09/06/redis-cluster-slots-num/" title="为什么RedisCluster采用16384个槽位?"><img class="cover" src="/assets/images/bg/redis.jpg" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-06</div><div class="info-item-2">为什么RedisCluster采用16384个槽位?</div></div><div class="info-2"><div class="info-item-1">一、引言RedisCluster目前使用的计算slot槽位的算法为CRC16，该算法本身会产生的hash值的大小为16bit，因此该算法可以产生2^16=65536个不同的值，取值范围为0～65535之间，从下面的代码中我们看到，目前限制的slot槽位的个数为16384（相关的代码为crc16(key+s+1,e-s-1) &amp; 0x3FFF）； /* We have 16384 hash slots. The hash slot of a given key is obtained * as the least significant 14 bits of the crc16 of the key. * * However if the key contains the &#123;...&#125; pattern, only the part between * &#123; and &#125; is hashed. This may be useful in the future to force certain * keys to be in the same...</div></div></div></a><a class="pagination-related" href="/2020/05/02/redismodule-ratelimit/" title="RedisModule剖析 - RateLimit"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-02</div><div class="info-item-2">RedisModule剖析 - RateLimit</div></div><div class="info-2"><div class="info-item-1">RateLimit 是一款基于 Go的限速库 golang.org&#x2F;x&#x2F;time&#x2F;rate （基于 令牌桶 ） 实现的针对于 key 的限速模块，该模块并非直接拦截 Redis 中关于特定 key 的操作指令，而是每次在需要执行操作指令之前，先发送一个判断命令（该模块提供的特殊命令），通过这种方式来实现限速的目的。 一、简介 GitHub 地址：https://github.com/linfangrong/redismodule-ratelimit 二、架构设计2.1、相关命令 ratelimit.allow : 为指定的 key 设置操作速率约束，后续判断是否能够继续执行需要事先发送该命令进行判断； 2.2、相关代码// 创建一个新的限速器var lm *Limiter = NewLimiter()func NewLimiter() (lm *Limiter) &#123;	lm = &amp;Limiter&#123; dataList: list.New(), dataMap: ...</div></div></div></a><a class="pagination-related" href="/2019/09/01/redis-multithreading/" title="Redis的多线程特性"><img class="cover" src="/assets/images/bg/multithreading.jpeg" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-01</div><div class="info-item-2">Redis的多线程特性</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar-256.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">135</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E8%BF%B0"><span class="toc-text">一、简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B7%E4%BD%93%E7%9A%84%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-text">二、具体的指令解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81MEMORY-DOCKER"><span class="toc-text">2.1、MEMORY DOCKER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81MEMORY-MALLOC-STATS"><span class="toc-text">2.2、MEMORY MALLOC-STATS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81MEMORY-PURGE"><span class="toc-text">2.3、MEMORY PURGE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81MEMORY-STATS"><span class="toc-text">2.4、MEMORY STATS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81MEMORY-USAGE-key-SAMPLES-count"><span class="toc-text">2.5、MEMORY USAGE key [SAMPLES count]</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="CephFS Inode 编号的申请与释放"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放">CephFS Inode 编号的申请与释放</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph Crimson 设计实现深入解析"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/3fs-deploy/" title="3FS 集群部署笔记"><img src="/assets/images/bg/deepseek.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3FS 集群部署笔记"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/05/23/3fs-deploy/" title="3FS 集群部署笔记">3FS 集群部署笔记</a><time datetime="2025-05-22T16:00:00.000Z" title="发表于 2025-05-23 00:00:00">2025-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群部署教程"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph Crimson 集群部署教程"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群部署教程">Ceph Crimson 集群部署教程</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/cephfs-samba/" title="CephFS 对接 Samba 使用教程"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="CephFS 对接 Samba 使用教程"/ loading='lazy'></a><div class="content"><a class="title" href="/2024/12/01/cephfs-samba/" title="CephFS 对接 Samba 使用教程">CephFS 对接 Samba 使用教程</a><time datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/assets/images/bg/redis.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script defer src="/js/utils.js"></script><script defer src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const e=()=>{(()=>{const e=document.querySelectorAll("pre > code.mermaid");0!==e.length&&e.forEach(e=>{const t=document.createElement("pre");t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent;const n=document.createElement("div");n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)})})();const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>(e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,n)=>{const d=e.firstElementChild,a=`mermaid-${n}`,r=`%%{init:{ 'theme':'${t}'}}%%\n`+d.textContent,m=mermaid.render(a,r),o=e=>{d.insertAdjacentHTML("afterend",e)};"string"==typeof m?o(m):m.then(({svg:e})=>o(e))})})(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const t="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=null,n=t=>{const e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.textContent=t)},i=(i,o)=>{t&&(window.shuoshuoComment.destroyGitalk=()=>{i.children.length&&(i.innerHTML="",i.classList.add("no-comment"))});new Gitalk({clientID:"6af3be16b94cec39bcf6",clientSecret:"13a5202ff773ffcea6300b6c8ff25f455566737c",repo:"bugwz.github.io",owner:"bugwz",admin:["bugwz"],updateCountCallback:n,...e,id:t?o:"24dbaed63dc8cee17d20d163722cdd71"}).render("gitalk-container")},o=async(t,e)=>{"function"==typeof Gitalk||(await btf.getCSS("/pluginsSrc/gitalk/dist/gitalk.css"),await btf.getScript("/pluginsSrc/gitalk/dist/gitalk.min.js")),i(t,e)};t?window.shuoshuoComment={loadComment:o}:o()})()</script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><script>(()=>{let e=!1;const c=()=>{if(e)return;e=!0;const c=document.createElement("link");c.rel="stylesheet",c.href="/pluginsSrc/@docsearch/css/dist/style.css",c.media="print",c.onload=()=>{c.media="all"},document.head.appendChild(c),btf.getScript("/pluginsSrc/@docsearch/js/dist/umd/index.js").then(()=>{docsearch(Object.assign({appId:"PFB3WGSSCO",apiKey:"3e9cd446e41d93f2f130b91698b699f7",indexName:"bugwz",container:"#docsearch",placeholder:"请输入要搜索的内容"},{maxResultsPerGroup:10}));const e=document.querySelector(".DocSearch-Button");e&&e.click()})},t=()=>{const e=document.querySelector("#search-button > .search");e&&btf.addEventListenerPjax(e,"click",c)};t(),window.addEventListener("pjax:complete",t)})()</script></div></div></body></html>