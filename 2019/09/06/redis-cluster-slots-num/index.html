<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>为什么RedisCluster采用16384个槽位? | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="RedisCluster 目前使用的计算 slot 槽位的算法为 CRC16，该算法本身会产生的 hash 值的大小为 16bit，因此该算法可以产生 65536 个不同的值，取值范围为 0～65535 之间，从下面的代码中我们看到，目前限制的 slot 槽位的个数为 16384。">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么RedisCluster采用16384个槽位?">
<meta property="og:url" content="https://bugwz.com/2019/09/06/redis-cluster-slots-num/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="RedisCluster 目前使用的计算 slot 槽位的算法为 CRC16，该算法本身会产生的 hash 值的大小为 16bit，因此该算法可以产生 65536 个不同的值，取值范围为 0～65535 之间，从下面的代码中我们看到，目前限制的 slot 槽位的个数为 16384。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/redis.jpg">
<meta property="article:published_time" content="2019-09-05T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-23T13:45:23.117Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="RedisCluster">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/redis.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "为什么RedisCluster采用16384个槽位?",
  "url": "https://bugwz.com/2019/09/06/redis-cluster-slots-num/",
  "image": "https://bugwz.com/assets/images/bg/redis.jpg",
  "datePublished": "2019-09-05T16:00:00.000Z",
  "dateModified": "2025-05-23T13:45:23.117Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2019/09/06/redis-cluster-slots-num/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '为什么RedisCluster采用16384个槽位?',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/self/github-dark.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">135</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/redis.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">为什么RedisCluster采用16384个槽位?</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">为什么RedisCluster采用16384个槽位?</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-05T16:00:00.000Z" title="发表于 2019-09-06 00:00:00">2019-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-23T13:45:23.117Z" title="更新于 2025-05-23 21:45:23">2025-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/RedisCluster/">RedisCluster</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.2k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p><code>RedisCluster</code>目前使用的计算<code>slot</code>槽位的算法为<code>CRC16</code>，该算法本身会产生的<code>hash</code>值的大小为<code>16bit</code>，因此该算法可以产生<code>2^16=65536</code>个不同的值，取值范围为<code>0～65535</code>之间，从下面的代码中我们看到，目前限制的<code>slot</code>槽位的个数为<code>16384</code>（相关的代码为<code>crc16(key+s+1,e-s-1) &amp; 0x3FFF</code>）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We have 16384 hash slots. The hash slot of a given key is obtained</span><br><span class="hljs-comment"> * as the least significant 14 bits of the crc16 of the key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * However if the key contains the &#123;...&#125; pattern, only the part between</span><br><span class="hljs-comment"> * &#123; and &#125; is hashed. This may be useful in the future to force certain</span><br><span class="hljs-comment"> * keys to be in the same node (assuming no resharding is in progress). */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyHashSlot</span><span class="hljs-params">(<span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> keylen)</span> &#123;<br>    <span class="hljs-type">int</span> s, e; <span class="hljs-comment">/* start-end indexes of &#123; and &#125; */</span><br><br>    <span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt; keylen; s++)<br>        <span class="hljs-keyword">if</span> (key[s] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">/* No &#x27;&#123;&#x27; ? Hash the whole key. This is the base case. */</span><br>    <span class="hljs-keyword">if</span> (s == keylen) <span class="hljs-keyword">return</span> crc16(key,keylen) &amp; <span class="hljs-number">0x3FFF</span>;<br><br>    <span class="hljs-comment">/* &#x27;&#123;&#x27; found? Check if we have the corresponding &#x27;&#125;&#x27;. */</span><br>    <span class="hljs-keyword">for</span> (e = s+<span class="hljs-number">1</span>; e &lt; keylen; e++)<br>        <span class="hljs-keyword">if</span> (key[e] == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">/* No &#x27;&#125;&#x27; or nothing between &#123;&#125; ? Hash the whole key. */</span><br>    <span class="hljs-keyword">if</span> (e == keylen || e == s+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> crc16(key,keylen) &amp; <span class="hljs-number">0x3FFF</span>;<br><br>    <span class="hljs-comment">/* If we are here there is both a &#123; and a &#125; on its right. Hash</span><br><span class="hljs-comment">     * what is in the middle between &#123; and &#125;. */</span><br>    <span class="hljs-keyword">return</span> crc16(key+s+<span class="hljs-number">1</span>,e-s<span class="hljs-number">-1</span>) &amp; <span class="hljs-number">0x3FFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么槽位个数的时候为什么不直接采用65536呢？作者在2015年5月在相关的<a target="_blank" rel="noopener" href="https://github.com/antirez/redis/issues/2576">issue#2576</a>上就给出了答案，作者的回复如下：</p>
<p><img src="/assets/images/slotsNum.png" alt="antirze的回复" loading="lazy"></p>
<p>作者这句话的翻译如下所示：</p>
<blockquote>
<p>原因是：</p>
<ol>
<li>正常的心跳包会携带着节点的完整配置，通过使用与旧的配置信息幂等的配置来更新旧配置。 这意味着它们需要包含原始形式的节点的插槽配置信息，使用16384个slots的话将会占用2k的空间，但是如果使用65536个slots的话将会占用8k空间。 </li>
<li>同时，由于其他设计权衡，RedisCluster不太可能扩展到超过1000个Master节点。</li>
</ol>
<p>所以16384在正确的范围内可以确保每个Master有足够的插槽，最多1000个Master，但是足够小的slots数字可以很容易地将slots的配置作为原始位图数据进行传播。 请注意，在小型集群中，位图难以压缩，因为当N很小时，位图将设置slots&#x2F;N位，这个是一个很大的比特集。</p>
</blockquote>
<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>依据作者给出的答案，作者吧原因定位于<strong>带宽消耗</strong>以及<strong>使用现状</strong>方面，接下来详细说明一下这样设置的原因，RedisCluster使用<code>cluster meet &lt;ip&gt; &lt;port&gt; [bus-port]</code>指令将节点连接到工作集群中，例如将两个redis实例<code>10.0.0.1:6379</code>和<code> 10.0.0.2:6379</code>加入到集群中，我们可以使用<code>redis-cli</code>连接上<code>10.0.0.1:6379</code>，执行<code>cluster meet 10.0.0.2:6379</code>使两个节点建立连接，后续这两个节点就会定期发送<code>ping/pong</code>来交换数据信息。</p>
<p>这里分析一下在节点数据交换的过程中的几个重点：</p>
<ul>
<li>节点交换的数据类型与大小；</li>
<li>节点数据交换的频率；</li>
</ul>
<h3 id="2-1、节点交换的数据类型与大小"><a href="#2-1、节点交换的数据类型与大小" class="headerlink" title="2.1、节点交换的数据类型与大小"></a>2.1、节点交换的数据类型与大小</h3><p>在RedisCluster的不同节点通信过程中，会调用<code>clusterSendPing(clusterLink *link, int type)</code>，依据<code>type</code>区分类型，然后调用<code>clusterBuildMessageHdr()；</code>和<code>clusterSendMessage()；</code>函数构建并发送消息，下面是节点的消息类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Message types.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that the PING, PONG and MEET messages are actually the same exact</span><br><span class="hljs-comment"> * kind of packet. PONG is the reply to ping, in the exact format as a PING,</span><br><span class="hljs-comment"> * while MEET is a special PING that forces the receiver to add the sender</span><br><span class="hljs-comment"> * as a node (if it is not already in the list). */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PING 0          <span class="hljs-comment">/* Ping */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PONG 1          <span class="hljs-comment">/* Pong (reply to Ping) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MEET 2          <span class="hljs-comment">/* Meet &quot;let&#x27;s join&quot; message */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAIL 3          <span class="hljs-comment">/* Mark node xxx as failing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PUBLISH 4       <span class="hljs-comment">/* Pub/Sub Publish propagation */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 <span class="hljs-comment">/* May I failover? */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     <span class="hljs-comment">/* Yes, you have my vote */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_UPDATE 7        <span class="hljs-comment">/* Another node slots configuration */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MFSTART 8       <span class="hljs-comment">/* Pause clients for manual failover */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MODULE 9        <span class="hljs-comment">/* Module cluster API message. */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_COUNT 10        <span class="hljs-comment">/* Total number of message types. */</span></span><br></code></pre></td></tr></table></figure>

<h4 id="2-1-1、消息头信息"><a href="#2-1-1、消息头信息" class="headerlink" title="2.1.1、消息头信息"></a>2.1.1、消息头信息</h4><p>在节点通信过程中，节点之间需要进行数据交换，以下结构体是节点之间进行数据交换的基础信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTER_SLOTS 16384</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> sig[<span class="hljs-number">4</span>];        <span class="hljs-comment">/* 签名“RCmb”（Redis群集消息总线） */</span><br>    <span class="hljs-type">uint32_t</span> totlen;    <span class="hljs-comment">/* 消息的总长度 */</span><br>    <span class="hljs-type">uint16_t</span> ver;       <span class="hljs-comment">/* 协议版本，目前设置为1 */</span><br>    <span class="hljs-type">uint16_t</span> port;      <span class="hljs-comment">/* TCP基本端口号r. */</span><br>    <span class="hljs-type">uint16_t</span> type;      <span class="hljs-comment">/* 消息类型 */</span><br>    <span class="hljs-type">uint16_t</span> count;     <span class="hljs-comment">/* 仅用于某种消息 */</span><br>    <span class="hljs-type">uint64_t</span> currentEpoch;  <span class="hljs-comment">/* 相应于发送节点的纪元 */</span><br>    <span class="hljs-type">uint64_t</span> configEpoch;   <span class="hljs-comment">/* 如果是主服务器的配置纪元，或者如果它是从</span><br><span class="hljs-comment">    													 服务器则由其主服务器通告的最后一个纪元 */</span><br>    <span class="hljs-type">uint64_t</span> offset;    <span class="hljs-comment">/* 如果节点是从属节点，则节点是主节点或已处理的</span><br><span class="hljs-comment">    											 复制偏移量时，主复制偏移量 */</span><br>    <span class="hljs-type">char</span> sender[CLUSTER_NAMELEN]; <span class="hljs-comment">/* 发件人节点的名称 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> myslots[CLUSTER_SLOTS/<span class="hljs-number">8</span>]; <span class="hljs-comment">/* 发送节点负责的槽信息 */</span><br>    <span class="hljs-type">char</span> slaveof[CLUSTER_NAMELEN]; <span class="hljs-comment">/* 如果发送节点是从节点，记录对应主节点的nodeId */</span><br>    <span class="hljs-type">char</span> myip[NET_IP_STR_LEN];    <span class="hljs-comment">/* 发件人IP，如果不存在则为零 */</span><br>    <span class="hljs-type">char</span> notused1[<span class="hljs-number">34</span>];  <span class="hljs-comment">/* 34个保留字节供将来使用 */</span><br>    <span class="hljs-type">uint16_t</span> cport;      <span class="hljs-comment">/* Sender TCP集群总线端口 */</span><br>    <span class="hljs-type">uint16_t</span> flags;      <span class="hljs-comment">/* 发件人节点标志 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> state; <span class="hljs-comment">/* 来自发件人POV的集群状态 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mflags[<span class="hljs-number">3</span>]; <span class="hljs-comment">/* 消息标志：CLUSTERMSG_FLAG [012] _... */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">clusterMsgData</span> <span class="hljs-title">data</span>;</span> <span class="hljs-comment">/* 群集消息数据 */</span><br>&#125; clusterMsg;<br></code></pre></td></tr></table></figure>

<p>这里只讨论与slots相关的<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项信息，该项为一个<code>char</code>数组，这个数组实际上是一个<code>bitmap</code>，这个<code>bitmap</code>的每一位表示一个槽，如果对应的槽位为<code>1</code>，代表对应的槽位是属于该节点的。</p>
<p>分析整个结构体可以看出其中空间占用最大的就是<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项，占用空间<code>16384/8/1024=2kb</code>，因此，如果槽位为<code>65536</code>，发送心跳信息的消息头达<code>8k</code>，发送的心跳包过于庞大；</p>
<h3 id="2-1-2、消息体信息"><a href="#2-1-2、消息体信息" class="headerlink" title="2.1.2、消息体信息"></a>2.1.2、消息体信息</h3><p>在消息体中，会携带一定数量的其他节点信息用于交换。其他节点的信息的数量约为集群总节点数量的1&#x2F;10，至少携带3个节点的信息，<strong>节点数量越多，消息体内容越大</strong>，10个节点状态下的消息体的大小大概约为1Kb左右；</p>
<p>具体消息体的信息是？？？待分析</p>
<h2 id="2-2、节点数据交换的频率"><a href="#2-2、节点数据交换的频率" class="headerlink" title="2.2、节点数据交换的频率"></a>2.2、节点数据交换的频率</h2><p><code>Cluster</code>节点之间的<code>ping/pong</code>操作由<code>clusterCron()</code>函数不断触发，该函数每秒执行<code>10</code>次，在<code>clusterCron()</code>函数中，每调用<code>10</code>次，执行一次<code>Cluster</code>节点的<code>ping</code>操作，相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 每秒执行10次 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clusterCron</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  	<span class="hljs-comment">/* 省略部分代码... */</span><br>  	<span class="hljs-comment">/* 每10次迭代对一些随机节点进行1次ping操作，这样我们通常每秒ping一个随机节点 */</span><br>    <span class="hljs-keyword">if</span> (!(iteration % <span class="hljs-number">10</span>)) &#123;<br>        <span class="hljs-type">int</span> j;<br><br>      	<span class="hljs-comment">/* 检查几个随机节点并使用最早的pong_received时间ping一个节点. */</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>            de = dictGetRandomKey(server.cluster-&gt;nodes);<br>            clusterNode *this = dictGetVal(de);<br><br>            <span class="hljs-comment">/* Don&#x27;t ping nodes disconnected or with a ping currently active.</span><br><span class="hljs-comment">            /* 不要ping断开连接的节点或当前活跃的节点. */</span><br>            <span class="hljs-keyword">if</span> (this-&gt;link == <span class="hljs-literal">NULL</span> || this-&gt;ping_sent != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (this-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (min_pong_node == <span class="hljs-literal">NULL</span> || min_pong &gt; this-&gt;pong_received) &#123;<br>                min_pong_node = this;<br>                min_pong = this-&gt;pong_received;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min_pong_node) &#123;<br>            serverLog(LL_DEBUG,<span class="hljs-string">&quot;Pinging node %.40s&quot;</span>, min_pong_node-&gt;name);<br>            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 省略部分代码... */</span><br>  	di = dictGetSafeIterator(server.cluster-&gt;nodes);<br>    <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;<br>      	<span class="hljs-comment">/* 省略部分代码... */</span><br>      	<span class="hljs-comment">/* 如果我们当前在此实例中没有活动的ping，并且收到的PONG早于</span><br><span class="hljs-comment">      	 * 群集超时的一半，则立即发送新的ping，以确保所有节点都被ping，</span><br><span class="hljs-comment">      	 * 而没有太大的延迟 */</span><br>        <span class="hljs-keyword">if</span> (node-&gt;link &amp;&amp;<br>            node-&gt;ping_sent == <span class="hljs-number">0</span> &amp;&amp;<br>            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/<span class="hljs-number">2</span>)<br>        &#123;<br>            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      	<span class="hljs-comment">/* 省略部分代码... */</span><br>		&#125;<br>   	dictReleaseIterator(di);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的大致逻辑是：</p>
<ul>
<li>每次（秒）会随机选取<code>5个</code>节点，找出最久没有通信的节点发送<code>ping</code>消息；</li>
<li>每<code>100毫秒</code>(<code>1秒10次</code>)都会扫描本地节点列表，如果发现节点最近一次接受<code>pong</code>消息的时间大于<code>cluster-node-timeout/2</code>则立刻发送<code>ping</code>消息；</li>
</ul>
<p><strong>因此我们可以计算出每秒单节点发出的ping消息的数量为：</strong></p>
<p><code>1+10*numOf(node.pong_received&gt;cluster_node_timeout/2)</code></p>
<p>针对于大致的带宽消耗，《Redis的开发与运维》中在第10章 集群的集群运维 - 带宽消耗小节中，有这么一句话：</p>
<blockquote>
<p>例如，一个总节点数为200的Redis集群，部署在20台物理机上每台划分10个节点，cluster-node-timeout采用默认15秒，这时ping&#x2F;pong消息占用带宽达到25Mb。如果把cluster-node-timeout设为20，对带宽的消耗降低到15Mb以下。</p>
</blockquote>
<ul>
<li>相关链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=247484663&idx=1&sn=bffafa6cbaa2a0bdf8ab487901867932&utm_source=tuicool&utm_medium=referral">面试官:知道为什么RedisCluster有16384个槽么?</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2019/09/06/redis-cluster-slots-num/">https://bugwz.com/2019/09/06/redis-cluster-slots-num/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/RedisCluster/">RedisCluster</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/redis.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/09/01/redis-multithreading/" title="Redis的多线程特性"><img class="cover" src="/assets/images/bg/multithreading.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis的多线程特性</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2019/09/13/charles/" title="Charles工具的介绍与使用"><img class="cover" src="/assets/images/bg/network.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Charles工具的介绍与使用</div></div><div class="info-2"><div class="info-item-1">Charles 是 MacOS 上十分好用的一款抓包工具，它不仅可以抓取明文数据包，也可以在手机端安装相关 SSL 证书后抓取加密的数据包，对于分析手机端应用的交互行为十分有帮助，本文中使用的版本为 4.2.8，这里记录一下如何使用 Charles 在 MacOS 下对于安卓手机进行抓包。 一、环境配置与要求 环境与软件：自行安装，不做介绍 环境： Charles 本身依赖于 Java 环境，因此需要确保 MacOS 本身已经安装配置完成 Java 的环境； 软件： MacOS 端安装成功 Charles ，并且配置完成所需要抓取的网址信息；   设备关联：手机和 Mac 处于同一个局域网中，并且将指定的代理服务器配置为 Charles 实际所监听的 IP 和端口； 证书安装：手机安装完成 Charles SSL CA 证书，证书的获取方式下文会详细介绍（仅用于抓取 HTTPs 的数据包）； 抓包分析：开始抓包分析即可；  二、MacOS 端软件配置 安装 Charles HTTPS 证书 ：依次点击 Help ，SSL Proxying ，Install Charles...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/05/21/codis-slots-rebalance/" title="Codis的Slots-Rebalance算法"><img class="cover" src="/assets/images/bg/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-21</div><div class="info-item-2">Codis的Slots-Rebalance算法</div></div><div class="info-2"><div class="info-item-1">Codis 实现了另一种的 Redis 集群方案。在该方案中为了能够实现类似于 RedisCluster 的横向扩缩容的能力，Codis 内部实现了一种 Slot-Rebalance 的算法，该算法中所有的 key 都被哈希到 1024 个 slots 上，在每个 slots 分配均匀的前提下，如果一个分片中的 slots 过多，该分片中存储的 key 的数量也就越多，该分片对应的负载也就越大，在扩缩容之后为了保证集群中各分片的负载均衡，需要调整分片的 slots...</div></div></div></a><a class="pagination-related" href="/2019/01/12/localtime/" title="localtime函数死锁分析"><img class="cover" src="/assets/images/bg/deadlock.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-12</div><div class="info-item-2">localtime函数死锁分析</div></div><div class="info-2"><div class="info-item-1">一、简介前段时间，线上的redis实例出现了一些异常的情况，具体变现就是bgsave子进程hang住了，从而引发了后续的很多问题，通过排查最终发现是localtime相关函数引起的，这里做一下总结记录。 C 库函数 *struct tm *localtime(const time_t timer) 作用是根据本地时区信息将 time 函数获取的 UTC 时间调整为为本地时间，并将具体的时间信息填充到tm结构体之中； 二、详细介绍由于localtime函数的具体底层实现的缘由，在某些场景下会触发localtime函数导致的死锁问题，这里详细的分析原因以及后续的处理方案； 2.1 底层实现分析localtime函数底层的调用栈信息为： localtime()   =&gt;   __tz_convert()   localtime 函数的底层代码实现（代码位于./time/localtime.c）：  /* Return the `struct tm&#x27; representation of *T in local time.  */struct tm *localtime...</div></div></div></a><a class="pagination-related" href="/2019/01/24/memory-redis/" title="Redis的Memory命令讲解"><img class="cover" src="/assets/images/bg/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-24</div><div class="info-item-2">Redis的Memory命令讲解</div></div><div class="info-2"><div class="info-item-1">一、简述Memory指令是Redis4.0版本更新的特性，可用于详细的分析内存的使用情况，内存使用诊断，内存碎片回收等工作； 可以通过memory help指令打印出memory指令的信息，详细信息如下所示： 1) MEMORY &lt;subcommand&gt; arg arg ... arg. Subcommands are:2) DOCTOR - Return memory problems reports.3) MALLOC-STATS -- Return internal statistics report from the memory allocator.4) PURGE -- Attempt to purge dirty pages for reclamation by the allocator.5) STATS -- Return information about the memory usage of the server.6) USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] -- Return memory in...</div></div></div></a><a class="pagination-related" href="/2022/12/31/redis-az-sync/" title="Redis异地多活方案杂谈"><img class="cover" src="/assets/images/bg/redis.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-31</div><div class="info-item-2">Redis异地多活方案杂谈</div></div><div class="info-2"><div class="info-item-1">Redis 的异地多活是一种跨地域容灾、并提供低延迟访问的部署方案。业界提供了很多的构建思路，这里将对比一下这里方案，并详细介绍一下业界的设计与实现。 一、简介二、思考2.1、Redis异地多活的定位在使用 Redis 的异地多活部署方案之前，为了提供 Redis 集群的高可用，我们也会提供跨地域主从的部署方式，通过这种方式我们也能实现地域级别的容灾能力。考虑到业务在使用 Redis 前的关注点一般是：性能、延迟、可用性以及数据一致性，我们将通过这四个关键点来对比一下这两种方案的不同：  性能（高性能， QPS ）： 跨地域主从：跨地域写性能较差，本地域读性能较好； 异地多活：本地域读写性能较好；   延迟（低延迟， Avg ， P99 等）： 跨地域主从：跨地域写延迟交高，本地域读延迟较低； 异地多活：本地域读写延迟较低；   可用性（高可用）： 跨地域主从：集群间的容灾切换，存在主从切换的瞬时访问问题，满足高可用需求； 异地多活：集群内的主从故障切换，满足高可用需求；   数据一致性： 跨地域主从：提供 Redis...</div></div></div></a><a class="pagination-related" href="/2022/12/04/redis-persistence/" title="Redis持久化演进史与奇思妙想"><img class="cover" src="/assets/images/bg/redis.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-04</div><div class="info-item-2">Redis持久化演进史与奇思妙想</div></div><div class="info-2"><div class="info-item-1">目前 Redis 主要支持两种持久化的方式：RDB 和 AOF 。这两者在 Redis 的演进过程中也发生了很多有意思的变化。RDB 的数据格式也已经进行了十次版本迭代，AOF 从最初的 Rewrite 到 Redis 7.0.0 的 Multi-Part-AOF 也发生了很多的变化，这里将对每个版本进行详细的剖析，学习 Redis 的持久化演进历史。这篇文章主要借鉴于 Redis 持久化机制演进与百度智能云的实践 ，同时按照自己的理解绘制了一些示意图。 一、简介Redis 支持两种持久化的方式：RDB 和 AOF 。 二、Redis RDB 持久化演进史2.1、持久化的数据版本演进2.1.1、版本一 版本范围：2.0.0 ～ 2.2.15 （以下分析基于 2.2.15 版本）  RDB版本号：0001  版本特点：  首次支持对五种数据类型数据的持久化；   持久化数据内容：  标记头尾信息；  多 DB 信息（ REDIS_SELECTDB ）；  过期时间属性（单位秒， REDIS_EXPIRETIME...</div></div></div></a><a class="pagination-related" href="/2019/09/01/redis-multithreading/" title="Redis的多线程特性"><img class="cover" src="/assets/images/bg/multithreading.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-01</div><div class="info-item-2">Redis的多线程特性</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">135</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-text">一、引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E6%9E%90"><span class="toc-text">二、分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A4%A7%E5%B0%8F"><span class="toc-text">2.1、节点交换的数据类型与大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1%E3%80%81%E6%B6%88%E6%81%AF%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.1、消息头信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E3%80%81%E6%B6%88%E6%81%AF%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.2、消息体信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-text">2.2、节点数据交换的频率</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CephFS Inode 编号的申请与释放"/></a><div class="content"><a class="title" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放">CephFS Inode 编号的申请与释放</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 设计实现深入解析"/></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/3fs-deploy/" title="3FS 集群部署笔记"><img src="/assets/images/bg/deepseek.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3FS 集群部署笔记"/></a><div class="content"><a class="title" href="/2025/05/23/3fs-deploy/" title="3FS 集群部署笔记">3FS 集群部署笔记</a><time datetime="2025-05-22T16:00:00.000Z" title="发表于 2025-05-23 00:00:00">2025-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群部署教程"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群部署教程"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群部署教程">Ceph Crimson 集群部署教程</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/cephfs-samba/" title="CephFS 对接 Samba 使用教程"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CephFS 对接 Samba 使用教程"/></a><div class="content"><a class="title" href="/2024/12/01/cephfs-samba/" title="CephFS 对接 Samba 使用教程">CephFS 对接 Samba 使用教程</a><time datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/assets/images/bg/redis.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'f357b73d0b92cdde7445c2a3515bed8d'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: '请输入要搜索的内容',
  }, {"maxResultsPerGroup":10}))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>