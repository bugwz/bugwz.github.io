<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>为什么RedisCluster采用16384个槽位? | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="RedisCluster 目前使用的计算 slot 槽位的算法为 CRC16，该算法本身会产生的 hash 值的大小为 16bit，因此该算法可以产生 65536 个不同的值，取值范围为 0～65535 之间，从下面的代码中我们看到，目前限制的 slot 槽位的个数为 16384。"><meta property="og:type" content="article"><meta property="og:title" content="为什么RedisCluster采用16384个槽位?"><meta property="og:url" content="https://bugwz.com/2019/09/06/redis-cluster-slots-num/index.html"><meta property="og:site_name" content="咕咕"><meta property="og:description" content="RedisCluster 目前使用的计算 slot 槽位的算法为 CRC16，该算法本身会产生的 hash 值的大小为 16bit，因此该算法可以产生 65536 个不同的值，取值范围为 0～65535 之间，从下面的代码中我们看到，目前限制的 slot 槽位的个数为 16384。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bugwz.com/assets/images/bg/redis.jpg"><meta property="article:published_time" content="2019-09-05T16:00:00.000Z"><meta property="article:modified_time" content="2025-12-16T13:38:47.398Z"><meta property="article:author" content="bugwz"><meta property="article:tag" content="Redis"><meta property="article:tag" content="RedisCluster"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bugwz.com/assets/images/bg/redis.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "为什么RedisCluster采用16384个槽位?",
  "url": "https://bugwz.com/2019/09/06/redis-cluster-slots-num/",
  "image": "https://bugwz.com/assets/images/bg/redis.jpg",
  "datePublished": "2019-09-05T16:00:00.000Z",
  "dateModified": "2025-12-16T13:38:47.398Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2019/09/06/redis-cluster-slots-num/index.html"><link rel="preconnect"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><noscript><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"></noscript><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:500,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"为什么RedisCluster采用16384个槽位?",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/self/github-dark.css" media="print" onload='this.media="all"'><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/assets/images/bg/redis.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">为什么RedisCluster采用16384个槽位?</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span>友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">为什么RedisCluster采用16384个槽位?</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-05T16:00:00.000Z" title="发表于 2019-09-06 00:00:00">2019-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-16T13:38:47.398Z" title="更新于 2025-12-16 21:38:47">2025-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/RedisCluster/">RedisCluster</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.2k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p><code>RedisCluster</code>目前使用的计算<code>slot</code>槽位的算法为<code>CRC16</code>，该算法本身会产生的<code>hash</code>值的大小为<code>16bit</code>，因此该算法可以产生<code>2^16=65536</code>个不同的值，取值范围为<code>0～65535</code>之间，从下面的代码中我们看到，目前限制的<code>slot</code>槽位的个数为<code>16384</code>（相关的代码为<code>crc16(key+s+1,e-s-1) &amp; 0x3FFF</code>）；</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We have 16384 hash slots. The hash slot of a given key is obtained</span><br><span class="hljs-comment"> * as the least significant 14 bits of the crc16 of the key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * However if the key contains the &#123;...&#125; pattern, only the part between</span><br><span class="hljs-comment"> * &#123; and &#125; is hashed. This may be useful in the future to force certain</span><br><span class="hljs-comment"> * keys to be in the same node (assuming no resharding is in progress). */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">keyHashSlot</span><span class="hljs-params">(<span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> keylen)</span> &#123;<br>    <span class="hljs-type">int</span> s, e; <span class="hljs-comment">/* start-end indexes of &#123; and &#125; */</span><br><br>    <span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt; keylen; s++)<br>        <span class="hljs-keyword">if</span> (key[s] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">/* No &#x27;&#123;&#x27; ? Hash the whole key. This is the base case. */</span><br>    <span class="hljs-keyword">if</span> (s == keylen) <span class="hljs-keyword">return</span> crc16(key,keylen) &amp; <span class="hljs-number">0x3FFF</span>;<br><br>    <span class="hljs-comment">/* &#x27;&#123;&#x27; found? Check if we have the corresponding &#x27;&#125;&#x27;. */</span><br>    <span class="hljs-keyword">for</span> (e = s+<span class="hljs-number">1</span>; e &lt; keylen; e++)<br>        <span class="hljs-keyword">if</span> (key[e] == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">/* No &#x27;&#125;&#x27; or nothing between &#123;&#125; ? Hash the whole key. */</span><br>    <span class="hljs-keyword">if</span> (e == keylen || e == s+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> crc16(key,keylen) &amp; <span class="hljs-number">0x3FFF</span>;<br><br>    <span class="hljs-comment">/* If we are here there is both a &#123; and a &#125; on its right. Hash</span><br><span class="hljs-comment">     * what is in the middle between &#123; and &#125;. */</span><br>    <span class="hljs-keyword">return</span> crc16(key+s+<span class="hljs-number">1</span>,e-s<span class="hljs-number">-1</span>) &amp; <span class="hljs-number">0x3FFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么槽位个数的时候为什么不直接采用65536呢？作者在2015年5月在相关的<a target="_blank" rel="noopener" href="https://github.com/antirez/redis/issues/2576">issue#2576</a>上就给出了答案，作者的回复如下：</p><p><img src="/assets/images/slotsNum.png" alt="antirze的回复" loading="lazy"></p><p>作者这句话的翻译如下所示：</p><blockquote><p>原因是：</p><ol><li>正常的心跳包会携带着节点的完整配置，通过使用与旧的配置信息幂等的配置来更新旧配置。 这意味着它们需要包含原始形式的节点的插槽配置信息，使用16384个slots的话将会占用2k的空间，但是如果使用65536个slots的话将会占用8k空间。</li><li>同时，由于其他设计权衡，RedisCluster不太可能扩展到超过1000个Master节点。</li></ol><p>所以16384在正确的范围内可以确保每个Master有足够的插槽，最多1000个Master，但是足够小的slots数字可以很容易地将slots的配置作为原始位图数据进行传播。 请注意，在小型集群中，位图难以压缩，因为当N很小时，位图将设置slots&#x2F;N位，这个是一个很大的比特集。</p></blockquote><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>依据作者给出的答案，作者吧原因定位于<strong>带宽消耗</strong>以及<strong>使用现状</strong>方面，接下来详细说明一下这样设置的原因，RedisCluster使用<code>cluster meet &lt;ip&gt; &lt;port&gt; [bus-port]</code>指令将节点连接到工作集群中，例如将两个redis实例<code>10.0.0.1:6379</code>和<code>10.0.0.2:6379</code>加入到集群中，我们可以使用<code>redis-cli</code>连接上<code>10.0.0.1:6379</code>，执行<code>cluster meet 10.0.0.2:6379</code>使两个节点建立连接，后续这两个节点就会定期发送<code>ping/pong</code>来交换数据信息。</p><p>这里分析一下在节点数据交换的过程中的几个重点：</p><ul><li>节点交换的数据类型与大小；</li><li>节点数据交换的频率；</li></ul><h3 id="2-1、节点交换的数据类型与大小"><a href="#2-1、节点交换的数据类型与大小" class="headerlink" title="2.1、节点交换的数据类型与大小"></a>2.1、节点交换的数据类型与大小</h3><p>在RedisCluster的不同节点通信过程中，会调用<code>clusterSendPing(clusterLink *link, int type)</code>，依据<code>type</code>区分类型，然后调用<code>clusterBuildMessageHdr()；</code>和<code>clusterSendMessage()；</code>函数构建并发送消息，下面是节点的消息类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Message types.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that the PING, PONG and MEET messages are actually the same exact</span><br><span class="hljs-comment"> * kind of packet. PONG is the reply to ping, in the exact format as a PING,</span><br><span class="hljs-comment"> * while MEET is a special PING that forces the receiver to add the sender</span><br><span class="hljs-comment"> * as a node (if it is not already in the list). */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PING 0          <span class="hljs-comment">/* Ping */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PONG 1          <span class="hljs-comment">/* Pong (reply to Ping) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MEET 2          <span class="hljs-comment">/* Meet &quot;let&#x27;s join&quot; message */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAIL 3          <span class="hljs-comment">/* Mark node xxx as failing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_PUBLISH 4       <span class="hljs-comment">/* Pub/Sub Publish propagation */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 <span class="hljs-comment">/* May I failover? */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     <span class="hljs-comment">/* Yes, you have my vote */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_UPDATE 7        <span class="hljs-comment">/* Another node slots configuration */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MFSTART 8       <span class="hljs-comment">/* Pause clients for manual failover */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_MODULE 9        <span class="hljs-comment">/* Module cluster API message. */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTERMSG_TYPE_COUNT 10        <span class="hljs-comment">/* Total number of message types. */</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-1、消息头信息"><a href="#2-1-1、消息头信息" class="headerlink" title="2.1.1、消息头信息"></a>2.1.1、消息头信息</h4><p>在节点通信过程中，节点之间需要进行数据交换，以下结构体是节点之间进行数据交换的基础信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLUSTER_SLOTS 16384</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> sig[<span class="hljs-number">4</span>];        <span class="hljs-comment">/* 签名“RCmb”（Redis群集消息总线） */</span><br>    <span class="hljs-type">uint32_t</span> totlen;    <span class="hljs-comment">/* 消息的总长度 */</span><br>    <span class="hljs-type">uint16_t</span> ver;       <span class="hljs-comment">/* 协议版本，目前设置为1 */</span><br>    <span class="hljs-type">uint16_t</span> port;      <span class="hljs-comment">/* TCP基本端口号r. */</span><br>    <span class="hljs-type">uint16_t</span> type;      <span class="hljs-comment">/* 消息类型 */</span><br>    <span class="hljs-type">uint16_t</span> count;     <span class="hljs-comment">/* 仅用于某种消息 */</span><br>    <span class="hljs-type">uint64_t</span> currentEpoch;  <span class="hljs-comment">/* 相应于发送节点的纪元 */</span><br>    <span class="hljs-type">uint64_t</span> configEpoch;   <span class="hljs-comment">/* 如果是主服务器的配置纪元，或者如果它是从</span><br><span class="hljs-comment">    													 服务器则由其主服务器通告的最后一个纪元 */</span><br>    <span class="hljs-type">uint64_t</span> offset;    <span class="hljs-comment">/* 如果节点是从属节点，则节点是主节点或已处理的</span><br><span class="hljs-comment">    											 复制偏移量时，主复制偏移量 */</span><br>    <span class="hljs-type">char</span> sender[CLUSTER_NAMELEN]; <span class="hljs-comment">/* 发件人节点的名称 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> myslots[CLUSTER_SLOTS/<span class="hljs-number">8</span>]; <span class="hljs-comment">/* 发送节点负责的槽信息 */</span><br>    <span class="hljs-type">char</span> slaveof[CLUSTER_NAMELEN]; <span class="hljs-comment">/* 如果发送节点是从节点，记录对应主节点的nodeId */</span><br>    <span class="hljs-type">char</span> myip[NET_IP_STR_LEN];    <span class="hljs-comment">/* 发件人IP，如果不存在则为零 */</span><br>    <span class="hljs-type">char</span> notused1[<span class="hljs-number">34</span>];  <span class="hljs-comment">/* 34个保留字节供将来使用 */</span><br>    <span class="hljs-type">uint16_t</span> cport;      <span class="hljs-comment">/* Sender TCP集群总线端口 */</span><br>    <span class="hljs-type">uint16_t</span> flags;      <span class="hljs-comment">/* 发件人节点标志 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> state; <span class="hljs-comment">/* 来自发件人POV的集群状态 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mflags[<span class="hljs-number">3</span>]; <span class="hljs-comment">/* 消息标志：CLUSTERMSG_FLAG [012] _... */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">clusterMsgData</span> <span class="hljs-title">data</span>;</span> <span class="hljs-comment">/* 群集消息数据 */</span><br>&#125; clusterMsg;<br></code></pre></td></tr></table></figure><p>这里只讨论与slots相关的<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项信息，该项为一个<code>char</code>数组，这个数组实际上是一个<code>bitmap</code>，这个<code>bitmap</code>的每一位表示一个槽，如果对应的槽位为<code>1</code>，代表对应的槽位是属于该节点的。</p><p>分析整个结构体可以看出其中空间占用最大的就是<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项，占用空间<code>16384/8/1024=2kb</code>，因此，如果槽位为<code>65536</code>，发送心跳信息的消息头达<code>8k</code>，发送的心跳包过于庞大；</p><h3 id="2-1-2、消息体信息"><a href="#2-1-2、消息体信息" class="headerlink" title="2.1.2、消息体信息"></a>2.1.2、消息体信息</h3><p>在消息体中，会携带一定数量的其他节点信息用于交换。其他节点的信息的数量约为集群总节点数量的1&#x2F;10，至少携带3个节点的信息，<strong>节点数量越多，消息体内容越大</strong>，10个节点状态下的消息体的大小大概约为1Kb左右；</p><p>具体消息体的信息是？？？待分析</p><h2 id="2-2、节点数据交换的频率"><a href="#2-2、节点数据交换的频率" class="headerlink" title="2.2、节点数据交换的频率"></a>2.2、节点数据交换的频率</h2><p><code>Cluster</code>节点之间的<code>ping/pong</code>操作由<code>clusterCron()</code>函数不断触发，该函数每秒执行<code>10</code>次，在<code>clusterCron()</code>函数中，每调用<code>10</code>次，执行一次<code>Cluster</code>节点的<code>ping</code>操作，相关代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 每秒执行10次 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clusterCron</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  	<span class="hljs-comment">/* 省略部分代码... */</span><br>  	<span class="hljs-comment">/* 每10次迭代对一些随机节点进行1次ping操作，这样我们通常每秒ping一个随机节点 */</span><br>    <span class="hljs-keyword">if</span> (!(iteration % <span class="hljs-number">10</span>)) &#123;<br>        <span class="hljs-type">int</span> j;<br><br>      	<span class="hljs-comment">/* 检查几个随机节点并使用最早的pong_received时间ping一个节点. */</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>            de = dictGetRandomKey(server.cluster-&gt;nodes);<br>            clusterNode *this = dictGetVal(de);<br><br>            <span class="hljs-comment">/* Don&#x27;t ping nodes disconnected or with a ping currently active.</span><br><span class="hljs-comment">            /* 不要ping断开连接的节点或当前活跃的节点. */</span><br>            <span class="hljs-keyword">if</span> (this-&gt;link == <span class="hljs-literal">NULL</span> || this-&gt;ping_sent != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (this-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (min_pong_node == <span class="hljs-literal">NULL</span> || min_pong &gt; this-&gt;pong_received) &#123;<br>                min_pong_node = this;<br>                min_pong = this-&gt;pong_received;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min_pong_node) &#123;<br>            serverLog(LL_DEBUG,<span class="hljs-string">&quot;Pinging node %.40s&quot;</span>, min_pong_node-&gt;name);<br>            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 省略部分代码... */</span><br>  	di = dictGetSafeIterator(server.cluster-&gt;nodes);<br>    <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;<br>      	<span class="hljs-comment">/* 省略部分代码... */</span><br>      	<span class="hljs-comment">/* 如果我们当前在此实例中没有活动的ping，并且收到的PONG早于</span><br><span class="hljs-comment">      	 * 群集超时的一半，则立即发送新的ping，以确保所有节点都被ping，</span><br><span class="hljs-comment">      	 * 而没有太大的延迟 */</span><br>        <span class="hljs-keyword">if</span> (node-&gt;link &amp;&amp;<br>            node-&gt;ping_sent == <span class="hljs-number">0</span> &amp;&amp;<br>            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/<span class="hljs-number">2</span>)<br>        &#123;<br>            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      	<span class="hljs-comment">/* 省略部分代码... */</span><br>		&#125;<br>   	dictReleaseIterator(di);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的大致逻辑是：</p><ul><li>每次（秒）会随机选取<code>5个</code>节点，找出最久没有通信的节点发送<code>ping</code>消息；</li><li>每<code>100毫秒</code>(<code>1秒10次</code>)都会扫描本地节点列表，如果发现节点最近一次接受<code>pong</code>消息的时间大于<code>cluster-node-timeout/2</code>则立刻发送<code>ping</code>消息；</li></ul><p><strong>因此我们可以计算出每秒单节点发出的ping消息的数量为：</strong></p><p><code>1+10*numOf(node.pong_received&gt;cluster_node_timeout/2)</code></p><p>针对于大致的带宽消耗，《Redis的开发与运维》中在第10章 集群的集群运维 - 带宽消耗小节中，有这么一句话：</p><blockquote><p>例如，一个总节点数为200的Redis集群，部署在20台物理机上每台划分10个节点，cluster-node-timeout采用默认15秒，这时ping&#x2F;pong消息占用带宽达到25Mb。如果把cluster-node-timeout设为20，对带宽的消耗降低到15Mb以下。</p></blockquote><ul><li>相关链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=247484663&idx=1&sn=bffafa6cbaa2a0bdf8ab487901867932&utm_source=tuicool&utm_medium=referral">面试官:知道为什么RedisCluster有16384个槽么?</a></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2019/09/06/redis-cluster-slots-num/">https://bugwz.com/2019/09/06/redis-cluster-slots-num/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/RedisCluster/">RedisCluster</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/redis.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2019/09/13/charles/" title="Charles工具的介绍与使用"><img class="cover" src="/assets/images/bg/network.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Charles工具的介绍与使用</div></div><div class="info-2"><div class="info-item-1">Charles 是 MacOS 上十分好用的一款抓包工具，它不仅可以抓取明文数据包，也可以在手机端安装相关 SSL 证书后抓取加密的数据包，对于分析手机端应用的交互行为十分有帮助，本文中使用的版本为 4.2.8，这里记录一下如何使用 Charles 在 MacOS 下对于安卓手机进行抓包。 一、环境配置与要求 环境与软件：自行安装，不做介绍 环境： Charles 本身依赖于 Java 环境，因此需要确保 MacOS 本身已经安装配置完成 Java 的环境； 软件： MacOS 端安装成功 Charles ，并且配置完成所需要抓取的网址信息； 设备关联：手机和 Mac 处于同一个局域网中，并且将指定的代理服务器配置为 Charles 实际所监听的 IP 和端口； 证书安装：手机安装完成 Charles SSL CA 证书，证书的获取方式下文会详细介绍（仅用于抓取 HTTPs 的数据包）； 抓包分析：开始抓包分析即可； 二、MacOS 端软件配置 安装 Charles HTTPS 证书 ：依次点击 Help ，SSL Proxying ，Install Charles Roo...</div></div></div></a><a class="pagination-related" href="/2019/09/01/redis-multithreading/" title="Redis的多线程特性"><img class="cover" src="/assets/images/bg/multithreading.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis的多线程特性</div></div><div class="info-2"><div class="info-item-1">Redis6.0即将发布，比较吸引我的便是Redis6.0支持的多线程技术，Redis本身也并不是简单的单进程&#x2F;线程模型，包括bgsave的进程以及对于一些慢请求的io线程（惰性删除，日志刷盘等），这次多线程的优化主要解决了Redis单进程&#x2F;线程处理模型在协议解析以及网络IO上的消耗问题，在命令的处理上仍旧是单线程。 一、逻辑分析2.1、两个配置 io-threads：启用的IO的线程数，最大为128（老版本中配置判断为512，新版本已经修复统一为128）； io-threads-do-reads：是否启用IO多线程； 2.2、两个队列 clients_pending_read：待处理的客户端的请求数据队列（需要进行协议解析等操作）； clients_pending_write：待处理的客户端的回复数据队列（需要进行回复客户端等操作）； 2.3、两类线程注意：启用的所有的多线程在同一时刻执行的任务类型是一样的 IO_THREADS_OP_WRITE：执行clients_pending_read任务的线程； IO_THREADS_OP_READ：执行cli...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/10/07/redismodule-redis-protobuf/" title="RedisModule剖析 - RedisProtobuf"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-07</div><div class="info-item-2">RedisModule剖析 - RedisProtobuf</div></div><div class="info-2"><div class="info-item-1">RedisProtobuf 是一款支持 Protobuf （目前仅支持Version 3） 的 Redis 模块，从而支持了较高级的嵌套数据结构，其设计灵感来自于 RedisJSON。 一、简介 GitHub 地址：https://github.com/sewenew/redis-protobuf 二、架构设计2.1、依赖库 Protobuf : 仅支持 version 3 ； 2.2、相关命令 pb.type : 获取指定 key 的消息类型； pb.set : 设置指定 key 的消息类型的内容信息，支持新增与变更； pb.get : 获取指定 key 的消息内容，支持 binary 和 json 的返回格式； pb.clear : 清除指定 key 的消息内容，支持指定路径； pb.len : 获取指定 key 的消息长度，支持指定路径； pb.append : 给指定 key 的特定路径中追加数据，目标路径的类型可以为 string&#x2F;array ; pb.del : 删除指定 key ，或者删除指定 key 中 array&#x2F;map 中的 value...</div></div></div></a><a class="pagination-related" href="/2022/07/01/redismodule-redistimeseries/" title="RedisModule剖析 - RedisTimeSeries"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="info-item-2">RedisModule剖析 - RedisTimeSeries</div></div><div class="info-2"><div class="info-item-1">RedisTimeSeries 是一款基于 RedisModule 实现的时序数据库模块，提供了基础的时序操作功能，包括不限于聚合查询，范围查询，保留周期，降采样（数据压缩），插值变更，二级索引等。由于数据存储于内存中，因此提供了高性能读写访问能力，但同时也受限于内存存储，可能并不适合用在极大数据量的时序场景中。考虑到身靠着Redis生态这棵大树，也许能够和Redis生态的众多组件碰撞出有趣的火花。 一、简介 官网：https://redis.io/docs/stack/timeseries/ GitHub 地址：https://github.com/RedisTimeSeries/RedisTimeSeries 命令文档地址：https://redis.io/commands/ts.add/ 支持功能： 大容量插入，低延迟读取； 按开始时间和结束时间查询； 任何时间桶的聚合查询（ Min 、 Max 、 Avg 、 Sum 、 Range 、 Count 、 First 、 Last 、 STD.P 、 STD.S 、 Var.P 、 Var.S 、 twa ）； 可配置的最长...</div></div></div></a><a class="pagination-related" href="/2021/04/15/redismodule-smartcache/" title="RedisModule剖析 - SmartCache"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-15</div><div class="info-item-2">RedisModule剖析 - SmartCache</div></div><div class="info-2"><div class="info-item-1">SmartCache 是一款基于 RedisModule 实现的数据缓存模块，目前仅支持与 MySQL 进行数据缓存交互。在客户端访问数据的时候，如果该数据不存在于 Redis 中，则 Redis 会向配置的 MySQL 发起数据请求，将数据缓存到本地，并设置一定的过期时间，之后将缓存的数据发送给客户端，从而实现了 Read-Through Cache 这种缓存模式。缓存的数据经过格式化处理（格式化方式比较简单，参考下文），因此客户端读取到访问数据后还需要进行额外的转换解析。 一、简介 GitHub 地址：https://github.com/fcerbell/redismodule-smartcache/ 二、架构设计2.1、相关命令 scache.create : 创建一个新的缓存信息，通过指定的 mysql 地址信息，该缓存维护一个与mysql的连接信息； scache.list : 遍历出所有创建的缓存信息（返回缓存信息标示）； scache.info : 获取指定的缓存信息（缓存信息使用链表存储，数据量较多时访问可能有性能瓶颈）； scache.test : 验证特定...</div></div></div></a><a class="pagination-related" href="/2022/09/29/redismodule-redistimer/" title="RedisModule剖析 - RedisTimer"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-29</div><div class="info-item-2">RedisModule剖析 - RedisTimer</div></div><div class="info-2"><div class="info-item-1">RedisTimer 是一款基于 Redis 的时间事件来实现的计时器的模块，通过时间事件机制来实现延迟&#x2F;循环执行对应的脚本（函数），由于该模块执行脚本（函数）的命令为 FCALL，因此要求Redis版本最低为7.0.0，该模块也支持数据的持久化，用于保证计时器的信息不丢失。 一、简介 GitHub 地址：https://github.com/tzongw/redis-timer 二、架构设计2.1、相关命令 timer.new : 创建一个新的计时器，会在指定的时间之后执行对应的脚本（函数），会直接覆盖同名的已经存在的计时器； timer.kill : 删除之前创建的计时器，并且删除对应的计时器key； timer.info : 查看特定的计时器的信息； 2.2、数据结构// 计时器的数据结构typedef struct TimerData &#123; RedisModuleString *key; // 对应计时器key对象 RedisModuleString *function; // 需要执行的脚本 mstime_t i...</div></div></div></a><a class="pagination-related" href="/2021/09/01/redismodule-redlock/" title="RedisModule剖析 - RedLock"><img class="cover" src="/assets/images/bg/redis.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-01</div><div class="info-item-2">RedisModule剖析 - RedLock</div></div><div class="info-2"><div class="info-item-1">RedLock 是一款基于 RedisModule 实现的分布式锁模块，该模块提供了写&#x2F;读锁的操作接口，相比于使用 Redis 的现有命令进行支持，这个模块的命令语义更明确，且有利于进行流量区分与筛选，在使用中能够很好的区分开其他流量与锁操作相关的流量。整体的模块实现比较简单，阅读相对比较容易。 一、简介 GitHub 地址：https://github.com/wujunwei/redlock/ 二、架构设计2.1、相关命令 slock.lock : 新增加一个写锁，可以指定该锁的过期时间； slock.unlock : 解锁之前的一个写锁，只有具有相同的客户端id的链接才可以解锁； slock.rlock : 新增加一个读锁，可以指定该锁的过期时间，多个客户端同时获取写锁时会影响该锁的读的引用计数； slock.runlock : 解锁之前的一个读锁，实际是减少对应锁的引用计数，当引用计数减少为0时，删除该key； slock.info : 获取锁的信息； 2.2、数据结构// RedLock结构体typedef struct slock &#123; m...</div></div></div></a><a class="pagination-related" href="/2019/01/13/tcl-first/" title="TCL语言入门"><img class="cover" src="/assets/images/bg/tcl.jpg" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-13</div><div class="info-item-2">TCL语言入门</div></div><div class="info-2"><div class="info-item-1">一、简述Tcl是一种很通用的脚本语言，它几乎在所有的平台上都可以释运行，一条TCL的命令串包含若干条命令，命令使用换行符或分号来隔开；而每一条命令包含若干个域(field)，域使用空白（空格或TAB）来隔开——第一个域是命令的名字，其它的域是该命令的参数。 二、基本语法2.1、注释注释在调试的过程中轻常碰到。TCL语言的注释符号是 # ，加在每一行的最前面。 2.2、脚本、命令、单词一个TCL 脚本 可以包含一个或多个 命令 。 命令 之间必须用换行符或分号隔开，推荐使用换行符分开。下面就是一个合法的TCL 脚本 ，它由两个赋值 命令 组成； set a 1set b 2 TCL的每一个 命令 包含一个或几个 单词，第一个单词代表命令名，另外的单词则是这个命令的参数，单词之间必须用 空格 或 TAB键 隔开。上面代码中的 set ， a ， 1 分别是三个单词。 TCL解释器对一个 命令 的求值过程分为两部分：分析和执行； 在分析阶段，TCL 解释器运用规则把 命令 分成一个个独立的单词，同时进行必要的 置换(substitution) ； 在执行阶段，TCL 解释器会把第...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"/ loading='lazy'></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="toc-text">一、引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E6%9E%90"><span class="toc-text">二、分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A4%A7%E5%B0%8F"><span class="toc-text">2.1、节点交换的数据类型与大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1%E3%80%81%E6%B6%88%E6%81%AF%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.1、消息头信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E3%80%81%E6%B6%88%E6%81%AF%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.2、消息体信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-text">2.2、节点数据交换的频率</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/25/proxyassistant/" title="ProxyAssistant - 强大的浏览器代理管理扩展"><img src="/assets/images/bg/proxyassistant.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="ProxyAssistant - 强大的浏览器代理管理扩展"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/25/proxyassistant/" title="ProxyAssistant - 强大的浏览器代理管理扩展">ProxyAssistant - 强大的浏览器代理管理扩展</a><time datetime="2026-01-24T16:00:00.000Z" title="发表于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/06/ceph-cmd-register-exec/" title="Ceph 命令注册及执行流程"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph 命令注册及执行流程"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/12/06/ceph-cmd-register-exec/" title="Ceph 命令注册及执行流程">Ceph 命令注册及执行流程</a><time datetime="2025-12-05T16:00:00.000Z" title="发表于 2025-12-06 00:00:00">2025-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph 和 LinuxKernel 版本时间对照表"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/11/08/ceph_linux_versions/" title="Ceph 和 LinuxKernel 版本时间对照表">Ceph 和 LinuxKernel 版本时间对照表</a><time datetime="2025-11-07T16:00:00.000Z" title="发表于 2025-11-08 00:00:00">2025-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/02/ceph-port/" title="Ceph 各组件端口使用分析"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ceph 各组件端口使用分析"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/10/02/ceph-port/" title="Ceph 各组件端口使用分析">Ceph 各组件端口使用分析</a><time datetime="2025-10-01T16:00:00.000Z" title="发表于 2025-10-02 00:00:00">2025-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放"><img src="/assets/images/bg/ceph.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="CephFS Inode 编号的申请与释放"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/08/09/cephfs-inode-num/" title="CephFS Inode 编号的申请与释放">CephFS Inode 编号的申请与释放</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/assets/images/bg/redis.jpg)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2026 By bugwz</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const e=e=>{const t=(e=>{if(!e)return null;const t=e.trim().split(/[\s,]+/).map(e=>Number(e));return 4!==t.length||t.some(e=>Number.isNaN(e))?null:t})(e.getAttribute("viewBox"));if(t)return t;try{const t=e.getBBox();if(t&&t.width&&t.height)return[t.x,t.y,t.width,t.height]}catch(e){}const n=Number(e.getAttribute("width"))||0,i=Number(e.getAttribute("height"))||0;return n>0&&i>0?[0,0,n,i]:[0,0,100,100]},t=(e,t)=>{e.setAttribute("viewBox",`${t[0]} ${t[1]} ${t[2]} ${t[3]}`)},n=(e,t,n)=>Math.max(t,Math.min(n,e)),i=({source:e,initViewBox:t})=>{const n=(()=>{if("string"==typeof e){const t=document.createElement("template");t.innerHTML=e.trim();const n=t.content.querySelector("svg");return n?n.cloneNode(!0):null}return e&&"function"==typeof e.cloneNode?e.cloneNode(!0):null})();if(!n)return;t&&4===t.length&&n.setAttribute("viewBox",t.join(" ")),n.getAttribute("xmlns")||n.setAttribute("xmlns","http://www.w3.org/2000/svg"),!n.getAttribute("xmlns:xlink")&&n.outerHTML.includes("xlink:")&&n.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");const i="dark"===document.documentElement.getAttribute("data-theme"),r=getComputedStyle(document.body).backgroundColor||(i?"#1e1e1e":"#ffffff");n.style.background||(n.style.background=r);const o=(new XMLSerializer).serializeToString(n),a=new Blob([o],{type:"image/svg+xml;charset=utf-8"}),s=URL.createObjectURL(a);window.open(s,"_blank","noopener"),setTimeout(()=>URL.revokeObjectURL(s),3e4)},r=(e,t,n,i)=>{const r=e[2]*t,o=e[3]*t;return[n-(n-e[0])*t,i-(i-e[1])*t,r,o]},o=i=>{const o=i.querySelector("svg");if(!o)return;const a=e(o);if(i.__mermaidInitViewBox=a,i.__mermaidCurViewBox=a.slice(),t(o,a),i.__mermaidGestureBound)return;i.__mermaidGestureBound=!0;const s=(t,n)=>{const r=o.getBoundingClientRect(),a=i.__mermaidCurViewBox||e(o);return{x:a[0]+(t-r.left)*(a[2]/r.width),y:a[1]+(n-r.top)*(a[3]/r.height),rect:r,vb:a}},d={pointers:new Map,startVb:null,startDist:0,startCenter:null},m=e=>{e=(e=>{const t=i.__mermaidInitViewBox||e,r=.1*t[2],o=10*t[2],a=.1*t[3],s=10*t[3];return e[2]=n(e[2],r,o),e[3]=n(e[3],a,s),e})(e),i.__mermaidCurViewBox=e,t(o,e)},c=e=>{d.pointers.delete(e.pointerId),0===d.pointers.size?(d.startVb=null,d.startDist=0,d.startCenter=null,i.__mermaidLastSinglePointer=null):1===d.pointers.size&&(i.__mermaidLastSinglePointer=[...d.pointers.values()][0])};o.addEventListener("pointerdown",t=>{if(!i.__mermaidLocked&&("mouse"!==t.pointerType||0===t.button))if(o.setPointerCapture(t.pointerId),d.pointers.set(t.pointerId,{x:t.clientX,y:t.clientY}),1===d.pointers.size)d.startVb=(i.__mermaidCurViewBox||e(o)).slice();else if(2===d.pointers.size){const t=[...d.pointers.values()],n=t[0].x-t[1].x,r=t[0].y-t[1].y;d.startDist=Math.hypot(n,r),d.startVb=(i.__mermaidCurViewBox||e(o)).slice(),d.startCenter={x:(t[0].x+t[1].x)/2,y:(t[0].y+t[1].y)/2}}}),o.addEventListener("pointermove",t=>{if(!i.__mermaidLocked&&d.pointers.has(t.pointerId)){if(d.pointers.set(t.pointerId,{x:t.clientX,y:t.clientY}),1===d.pointers.size&&d.startVb){const n=[...d.pointers.values()][0],r=(t.clientX,t.movementX,t.clientY,t.movementY,i.__mermaidLastSinglePointer||n),a=n.x-r.x,c=n.y-r.y;i.__mermaidLastSinglePointer=n;const{rect:l}=s(n.x,n.y),u=(i.__mermaidCurViewBox||e(o)).slice(),p=a*(u[2]/l.width),_=c*(u[3]/l.height);return void m([u[0]-p,u[1]-_,u[2],u[3]])}if(2===d.pointers.size&&d.startVb&&d.startDist>0){const e=[...d.pointers.values()],t=e[0].x-e[1].x,n=e[0].y-e[1].y,i=Math.hypot(t,n);if(!i)return;const o=d.startDist/i,a={x:(e[0].x+e[1].x)/2,y:(e[0].y+e[1].y)/2},c=s(a.x,a.y),l=c.x,u=c.y,p=r(d.startVb,o,l,u);m(p)}}}),o.addEventListener("pointerup",c),o.addEventListener("pointercancel",c),o.addEventListener("wheel",t=>{if(i.__mermaidLocked)return;t.preventDefault();const n=t.deltaY>0?1.1:.9,{x:a,y:d}=s(t.clientX,t.clientY),c=(i.__mermaidCurViewBox||e(o)).slice();m(r(c,n,a,d))},{passive:!1}),o.addEventListener("dblclick",()=>{if(i.__mermaidLocked)return;const e=i.__mermaidInitViewBox;e&&(i.__mermaidCurViewBox=e.slice(),t(o,e))})},a=e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,n)=>{const r=e.firstElementChild,a=e.querySelector("svg");a&&a.remove(),e.__mermaidGestureBound=!1;const s=r.dataset.config?JSON.parse(r.dataset.config):{};s.theme||(s.theme=t);const d=`mermaid-${n}`,m=`%%{init: ${JSON.stringify(s)}}%%\n`+r.textContent,c=mermaid.render(d,m),l=t=>{r.insertAdjacentHTML("afterend",t),o(e),e.__mermaidOriginalSvg=t,(e=>{const t=e.__mermaidOriginalSvg;let n=e.querySelector(".mermaid-open-btn");n||(n=document.createElement("button"),n.type="button",n.className="mermaid-open-btn",e.appendChild(n)),n.innerHTML='<i class="fa fa-search fa-fw" aria-hidden="true"></i>',n.__mermaidViewerBound||(n.addEventListener("click",n=>{n.preventDefault(),n.stopPropagation();const r=t||e.querySelector("svg");if(!r)return;const o=e.__mermaidInitViewBox;i({source:r,initViewBox:o})}),n.__mermaidViewerBound=!0);let r=e.querySelector(".mermaid-lock-btn");if(!r){r=document.createElement("button"),r.type="button",r.className="mermaid-lock-btn",r.title="Click to unlock interaction",e.appendChild(r);const t=t=>{r.innerHTML=t?'<i class="fa fa-lock fa-fw" aria-hidden="true"></i>':'<i class="fa fa-unlock fa-fw" aria-hidden="true"></i>',r.classList.toggle("locked",t),r.classList.toggle("unlocked",!t),e.__mermaidLocked=t,e.style.setProperty("--mermaid-interaction",t?"none":"auto")};t(!0),r.__mermaidLockBound||(r.addEventListener("click",n=>{n.preventDefault(),n.stopPropagation(),t(!e.__mermaidLocked)}),r.__mermaidLockBound=!0)}})(e)};"string"==typeof c?l(c):c.then(({svg:e})=>l(e))})},s=()=>{(()=>{const e=document.querySelectorAll("pre > code.mermaid");0!==e.length&&e.forEach(e=>{const t=document.createElement("pre");t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent;const n=document.createElement("div");n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)})})();const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>a(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",s,"mermaid"),window.pjax?s():document.addEventListener("DOMContentLoaded",s)})()</script><script>(()=>{const t="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=null,n=t=>{const e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.textContent=t)},i=(i,o)=>{t&&(window.shuoshuoComment.destroyGitalk=()=>{i.children.length&&(i.innerHTML="",i.classList.add("no-comment"))});new Gitalk({clientID:"6af3be16b94cec39bcf6",clientSecret:"ff79d2c5b817fe837ad43a1d9f8e0dd68190ceb5",repo:"bugwz.github.io",owner:"bugwz",admin:["bugwz"],updateCountCallback:n,...e,id:t?o:"f357b73d0b92cdde7445c2a3515bed8d"}).render("gitalk-container")},o=async(t,e)=>{"function"==typeof Gitalk||(await btf.getCSS("/pluginsSrc/gitalk/dist/gitalk.css"),await btf.getScript("/pluginsSrc/gitalk/dist/gitalk.min.js")),i(t,e)};t?window.shuoshuoComment={loadComment:o}:o()})()</script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="/pluginsSrc/@docsearch/css/dist/style.css"/><script src="/pluginsSrc/@docsearch/js/dist/umd/index.js"></script><script>(()=>{docsearch(Object.assign({appId:"PFB3WGSSCO",apiKey:"3e9cd446e41d93f2f130b91698b699f7",indexName:"bugwz",container:"#docsearch",placeholder:"请输入要搜索的内容"},{maxResultsPerGroup:10}));const e=()=>{document.querySelector(".DocSearch-Button").click()},c=()=>{btf.addEventListenerPjax(document.querySelector("#search-button > .search"),"click",e)};c(),window.addEventListener("pjax:complete",c)})()</script></div></div></body></html>