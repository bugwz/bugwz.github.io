<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>译 - Scalable Bloom Filters | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="《Scalable Bloom Filters》直译过来是《可扩展的布隆过滤器》。这篇论文讲述了一种布隆过滤器的变体实现方式，通过将预设的误判率分配给多个子布隆过滤器来约束整体的一个误判率情况，并且可以通过新增子布隆过滤器来实现对存储元素数量的调节，以满足初始容量无法准确估计的情况，论文中详细介绍了在不同的误判率变化率以及布隆过滤器容量变化率的情况下，存储空间等的使用情况。目前了解到的，Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="译 - Scalable Bloom Filters">
<meta property="og:url" content="https://bugwz.com/2022/03/01/scalable-bloom-filters/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="《Scalable Bloom Filters》直译过来是《可扩展的布隆过滤器》。这篇论文讲述了一种布隆过滤器的变体实现方式，通过将预设的误判率分配给多个子布隆过滤器来约束整体的一个误判率情况，并且可以通过新增子布隆过滤器来实现对存储元素数量的调节，以满足初始容量无法准确估计的情况，论文中详细介绍了在不同的误判率变化率以及布隆过滤器容量变化率的情况下，存储空间等的使用情况。目前了解到的，Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/paper.jpg">
<meta property="article:published_time" content="2022-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-08T05:48:45.854Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="论文">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="BloomFilter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/paper.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "译 - Scalable Bloom Filters",
  "url": "https://bugwz.com/2022/03/01/scalable-bloom-filters/",
  "image": "https://bugwz.com/assets/images/bg/paper.jpg",
  "datePublished": "2022-02-28T16:00:00.000Z",
  "dateModified": "2025-06-08T05:48:45.854Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2022/03/01/scalable-bloom-filters/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '译 - Scalable Bloom Filters',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">126</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/paper.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">译 - Scalable Bloom Filters</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">译 - Scalable Bloom Filters</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-28T16:00:00.000Z" title="发表于 2022-03-01 00:00:00">2022-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T05:48:45.854Z" title="更新于 2025-06-08 13:48:45">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/%E6%9D%82%E9%A1%B9/">杂项</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.3k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div>

<p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/abs/pii/S0020019006003127">《Scalable Bloom Filters》</a> 这篇论文讲述了一种布隆过滤器的变体实现方式，通过将预设的误判率分配给多个子布隆过滤器来约束整体的一个误判率情况，并且可以通过新增子布隆过滤器来实现对存储元素数量的调节，以满足初始容量无法准确估计的情况，论文中详细介绍了在不同的误判率变化率以及布隆过滤器容量变化率的情况下，存储空间等的使用情况。目前了解到的，<a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a> 和 <a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/145972.html">TairBloom</a> 都参考了这篇论文实现了各自的布隆过滤器。</p>
</div>



<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Bloom Filters provide space-efficient storage of sets at the cost of a probability of false positives on membership queries. The size of the filter must be defined a priori based on the number of elements to store and the desired false positive probability, being impossible to store extra elements without increasing the false positive probability. This leads typically to a conservative assumption regarding maximum set size, possibly by orders of magnitude, and a consequent space waste. This paper proposes Scalable Bloom Filters, a variant of Bloom Filters that can adapt dynamically to the number of elements stored, while assuring a maximum false positive probability.</p>
<p>布隆过滤器已查询成员资格时的误判概率为代价，提供了对数据集的高效空间存储能力。过滤器的大小需要依据要存储的元素数量和所需的误报概率来提前确定，如果不允许增加误报率，就不能存储额外的元素。这通常会导致我们对数据集合的大小做一个保守的估计（可能是数数量级的差异），这就会导致空间的浪费。本文提出了可扩展的布隆过滤器，它是布隆过滤器的一个变体，在保证最大误判率的情况下能够动态适应可存储元素的数量。</p>
<p>Keywords: Data Structures, Bloom Filters, Distributed Systems, Randomized Algorithms</p>
<p>关键词：数据结构、布隆过滤器、分布式系统、随机算法</p>
<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Bloom filters <code>[1]</code> provide space-efficient storage of sets at the cost of a probability of false positive on membership queries. Insertion and membership testing in Bloom filters implies an amount of randomization, since elements are transformed using one-way hash functions. Testing for the presence of elements that have actually been inserted in the filter will always give a positive result; there are no false negatives. On the contrary, there is always some probability of false positives: elements that have not been inserted into the filter can erroneously pass the membership test.</p>
<p>布隆过滤器<code>[1]</code>通过以成员查询的误判率为代价，提供了高效的空间来存储数据集。由于元素是使用单向哈希函数转换，因此布隆过滤器中的插入和成员测试（查询）意味着一定程度的随机化。查询一个元素是否已经插入总是能得到明确的答案，不会存在假阴性（误判）。对应的，总是有一些误判的情况：没有被插入过滤器的元素被错误地通过成员资格测试（被误判已经插入）。</p>
<p>An important property of Bloom filters is the linear relation between the filter size and the number of elements that can be stored. For any given maximum false positive probability, it is possible to determine how much filter state is needed per element <code>[2]</code>. As expected, lower false positive rates require more state per element.</p>
<p>布隆过滤器的一个重要特性是过滤器大小和可以存储的元素数量之间的线性关系。 对于任何给定的最大误报概率，可以确定每个元素[2] 需要多少个状态（每个元素对应多少的比特位，即布隆过滤器中的哈希函数个数）。 正如预期的那样，较低的误报率对于每个元素来说就需要更多的状态（误判率较低的情况下，所需要的哈希函数的个数会较多）。</p>
<p>If the maximum allowable error probability and the number of elements to store are both known, it is straightforward to dimension an appropriate filter. However, it is not always possible to know in advance how many elements will need to be stored; this leads to over-dimensioning the filters or relinquishing the maximum error probability.</p>
<p>如果已知允许误判的最大概率和需要存储的元素数量，则可以直接确定合适的过滤器大小。 但是，（业务方）并不总是可以提前知道（或者准确预测）需要存储多少元素。 这就会导致过滤器大小过大（预估的存储元素过多导致）或超过最大的误判率（预估的存储元素较少导致）。</p>
<p>In this paper we provide a solution for the case in which not only is the number of elements not known in advance but also we need to strictly enforce some maximum error probability. We prove that this is possible, by means of a novel construction: <code>Scalable Bloom Filters (SBF)</code>.</p>
<p>在本文中，我们提供了一种解决方案来处理不仅事先不知道元素数量而且还需要严格限制最大误判率的场景。我们通过一种新颖的结构证明这是可能的：<code>可扩展的布隆过滤器（SBF）</code>。</p>
<p>After a brief review of related work, this paper is organised as follows. <code>Section 3</code> reviews the basic mathematical properties of Bloom filters. <code>Section 4</code> introduces <code>Scalable Bloom Filters</code> and gives an evaluation of their properties. <code>Section 5</code> ends the paper with our conclusions.</p>
<p>在对相关工作进行简要回顾后，本文组织如下。 <code>第 3 节</code> 回顾了布隆过滤器的基本数学属性。 <code>第 4 节</code>介绍了可扩展的布隆过滤器并评估了它们的属性。 <code>第 5 节</code> 以我们的结论结束本文。</p>
<h2 id="2、相关工作"><a href="#2、相关工作" class="headerlink" title="2、相关工作"></a>2、相关工作</h2><p>In recent years, Bloom filters have received increased attention, and they are now being used in a large number of systems, including peer-to-peer systems <code>[3, 4]</code>, web caches <code>[5]</code>, database systems <code>[6]</code> and others <code>[7, 2]</code>. Several variants of the basic Bloom filter technique have been proposed in the literature.</p>
<p>近年来，布隆过滤器受到越来越多的关注，现在它正在大量系统中被使用，包括点对点系统<code>[3, 4]</code>、Web缓存<code>[5]</code>、数据库系统<code> [6]</code>和其他<code>[7, 2]</code>。 文献中已经提出了基本布隆过滤器技术的几种变体。</p>
<p>In <code>[5]</code> the authors introduce the idea of a counting Bloom filter, allowing elements to be removed from the set represented by the Bloom filter; <code>Spectral Bloom Filters</code> <code>[8]</code> use a similar approach to store multi-sets; <code>[9]</code> proposes a multi-segment Bloom Filter that allows efficient access when this data structure is stored on disk; a similar approach <code>[10]</code> is used in a network routing algorithm; Compressed Bloom Filters <code>[11]</code> improve performance when the Bloom Filter is passed as a message, by using larger but sparser filters that lead to smaller compressed sizes.</p>
<p>在<code>[5]</code>中，作者介绍了计数布隆过滤器的概念，它允许从布隆过滤器的集合中删除元素； 频谱布隆过滤器（Spectral Bloom Filters） <code>[8]</code> 使用类似的方法来存储多集； <code>[9]</code> 提出了一种多段布隆过滤器，当这种数据结构存储在磁盘上时能提供高效的访问； 在网络路由算法中使用了类似的方法<code>[10]</code>； 当布隆过滤器作为消息传递时，压缩的布隆过滤器 <code>[11]</code> 通过使用更大但更稀疏的过滤器来提高性能，从而导致更小的压缩大小。</p>
<p>All these variants suffer from the same limitation of the original Bloom filters: it is necessary to dimension, a priori, the size of the filters. We believe that it would be possible to drop this limitation for most (or even all) of these proposals by creating scalable variants along the lines of <code>SBF</code>.</p>
<p>所有这些变体都受到原始布隆过滤器的相同约束：必须提前确定过滤器的大小。 我们相信，通过按照<code>SBF</code>的思路可以创建可扩展的变体，可以为这些提案中的大多数（甚至所有）方案解除这一限制。</p>
<h2 id="3、布隆过滤器"><a href="#3、布隆过滤器" class="headerlink" title="3、布隆过滤器"></a>3、布隆过滤器</h2><p>A Bloom filter is traditionally implemented by a single array of <code>M</code> bits, where <code>M</code> is the filter size. On filter creation all bits are reset to zeroes. A filter is also parameterized by a constant <code>k</code> that defines the number of hash functions used to activate and test bits on the filter. Each hash function should output one index in <code>M</code>. When inserting an element <code>e</code> on the filter, the bits in the <code>k</code> indexes <code>h1(e)</code>, <code>h2(e)</code>, . . . , <code>hk(e)</code> are set.</p>
<p>布隆过滤器传统上由 <code>M</code> 位的单个数组实现，其中 <code>M</code> 是过滤器大小。 在创建过滤器时，所有位都重置为零。 过滤器也由常量 <code>k</code> 参数化，该常量定义了用于激活和测试（添加和查询）过滤器位的哈希函数的数量。 每个哈希函数应该在 <code>M</code> 中输出一个索引（对应数据集合中的某一个比特位）。 当在过滤器上插入元素 <code>e</code> 时，<code>k</code> 中的位索引 <code>h1(e)</code>、<code>h2(e)</code>、. . . , <code>hk(e)</code> 被设置（为 <code>1</code>）。</p>
<p>In particular, a filter with <code>M = 15</code> bits and <code>k = 3</code> hash functions could become as follows, after the insertion of one element:</p>
<p>特别的是（举例说明），在插入一个元素后，一个大小为 <code>M = 15</code> 位和哈希函数 <code>k = 3</code> 的布隆过滤器的情况可能如下：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-1.png" loading="lazy"></p>
</div>


<p>The same procedure is used to insert other elements, each time setting the bits given by the corresponding <code>k</code> indexes.</p>
<p>相同的过程也用于插入其他元素，每次都需要设置对应的 <code>k</code> 个索引的比特位。</p>
<p>In order to query a Bloom filter, say for element <code>x</code>, it suffices to verify if all bits in indexes <code>h1(x)</code>, <code>h2(x)</code>, . . . , <code>hk(x)</code> are set. If one or more of these bits is not set, then the queried element is definitely not present on the filter. Otherwise, if all these bits are set, then the element is considered to be on the filter. Given this procedure, an error probability exists for positive matches, since the tested indexes might have been set by the insertion of other elements.</p>
<p>为了查询布隆过滤器，比如元素 <code>x</code>，需要验证索引 <code>h1(x)</code>、<code>h2(x)</code>、…, <code>hk(x)</code> 中的所有位是否都被设置（都等于 <code>1</code> ）。如果这些位中有一个或多个没有被设置，则查询的元素肯定不存在于过滤器中。 否则，如果所有的这些比特位都被设置了，则认为该元素在过滤器中。 基于此过程，匹配命中存在误判率，因为测试（查询）的索引比特位可能会被已插入的其他元素来设置。</p>
<p>With the above setup, all hash functions are used to generate indexes over <code>M</code>. Since these hash functions are independent, nothing prevents collisions in the outputs. In the most extreme case we could have <code>h1(x) = h2(x) = . . . = hk(x)</code>. This means that in the general case each element will be described by <code>1</code> to <code>k</code> distinct indexes. Although for large values of <code>M</code> a collision seldom occurs, this aspect makes some elements more prone to false positives (and also complicates the analytical derivation of probabilities) <code>[12]</code>.</p>
<p>通过上述设置，所有哈希函数都用于在 <code>M</code> 上生成索引。 由于这些哈希函数是相互独立的，因此输出特征值的冲突不可避免。 在最极端的情况下，可能会出现 <code>h1(x) = h2(x) = . . . = hk(x)</code>的情况。 在一般的情况下，每个元素将由 <code>1</code> 到 <code>k</code> 个不同的索引来表示。 尽管当 <code>M</code> 值较大的时候很少会发生碰撞，但这一方面使某些元素更容易出现误报（并且也使概率的分析推导变得更加复杂）<code>[12]</code>。</p>
<p>A variant of Bloom filters <code>[2]</code>, which we adopt in this paper, consists of partitioning the <code>M</code> bits among the <code>k</code> hash functions, thus creating k slices of <code>m = M/k</code> bits. In this variant, each hash function <code>hi()</code>, with <code>1 ≤ i ≤ k</code>, produces an index over <code>m</code> for its respective slice. Therefore, each element is always described by exactly <code>k</code> bits, which results in a more robust filter, with no element specially sensitive to false positives.</p>
<p>我们在本文中采用的布隆过滤器 <code>[2]</code> 是一种变体，包括在 k 个哈希函数中划分 <code>M</code> 位，从而创建 <code>m = M/k</code> 位的 <code>k</code> 个切片。 在这个变体中，每个散列函数 <code>hi()</code> ，<code>1 ≤ i ≤ k</code>，为其各自的切片在 <code>m</code> 上生成一个索引。因此，每个元素总是用精确的 <code>k</code> 位来标示，这将导致过滤器更加健壮，没有对误报特别敏感的元素。</p>
<p>For <code>M = 15</code> and <code>k = 3</code> a filter would have <code>3</code> slices with <code>5</code> bits in each. After insertion of one element, the resulting configuration would have exactly one bit set in each slice. Each slice is depicted here in a column.</p>
<p>对于 <code>M = 15</code> 和 <code>k = 3</code>，过滤器将有 <code>3</code> 个切片，每个切片有 <code>5</code> 位。 插入一个元素后，生成的配置将在每个切片中设置一个位。 每个切片在此处以列的形式描述。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-2.png" loading="lazy"></p>
</div>


<div>

<p><strong>基础变量信息汇总：</strong></p>
<ul>
<li><code>M</code> : 布隆过滤器的大小，单位比特；</li>
<li><code>n</code> : 期望写入的元素的数量；</li>
<li><code>k</code> : 哈希函数的个数，对应单个元素的索引数量；</li>
<li><code>P</code> : 误判率；</li>
<li><code>s</code> : 下一个子布隆过滤器容量的增长倍数；</li>
<li><code>r</code> : 下一个子布隆过滤器的误判率的变化倍数；</li>
</ul>
</div>


<h3 id="3-1、假阳性"><a href="#3-1、假阳性" class="headerlink" title="3.1、假阳性"></a>3.1、假阳性</h3><p>False positives can occur when testing for the presence of a given element <code>x</code>, not present in the filter, and all <code>k</code> bits given by <code>hi(x)</code>, <code>1 ≤ i ≤ k</code>, happen to be set due to the insertion of other elements. Intuitively, if the number of slices <code>k</code> or the slice size <code>m</code> are increased the error probability will decrease.</p>
<p>当测试（查询）给定元素 <code>x</code> 的是否存在时，如果该元素不存在于过滤器中，但是由于 <code>hi(x)</code> 给出的所有 <code>k</code> 个位置（<code>1 ≤ i ≤ k</code>） 恰好被已经插入的其他元素设置了，则可能发生误报。直观地说，如果切片数量 <code>k</code> 或切片大小 <code>m</code> 增加，将会降低误判的概率。</p>
<p>The probability of a given bit being set in a slice is the fill ratio <code>p</code> between the number of set bits in the slice and the slice size <code>m</code>. For a large value <code>m</code>, this ratio will be approximately the same across all slices, and the false positive probability <code>P</code> for the filter will be :</p>
<p>（假设）在切片中设置给定（比特）位的概率是切片中设置位的数量与切片大小 <code>m</code> 之间的填充率 <code>p</code>。 对于较大的值 <code>m</code>，该比率在所有切片中将大致相同，过滤器的误报概率 <code>P</code> 将为：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-3.png" loading="lazy"></p>
</div>

<p>In the example above, with one element inserted, <code>p</code> is <code>1/5</code> and the overall error probability <code>P</code> is <code>(1/5)^3</code> , thus <code>0.8%</code>.</p>
<p>在上例中，插入一个元素后，<code>p</code>为<code>1/5</code>，总误判率<code>p</code>为<code>（1/5）^3</code>，因此为<code>0.8%</code>。</p>
<p>In each slice, the probability that a given <code>0</code> bit becomes set after introducing one element is <code>1/m</code>; it will remain unset with probability <code>1 − 1/m</code>. If <code>n</code> elements have been inserted, the probability that the given bit is still <code>0</code> is <code>(1 − 1/m)^n</code>. Therefore, the probability that a specific bit in a slice is set after <code>n</code> insertions, which is also the expected fill ratio <code>p</code>, is:</p>
<p>在每个切片中，在插入一个元素后给定（比特）位 <code>0</code> 被置的概率是 <code>1/m</code>，未被设置的概率为 <code>1 - 1/m</code> 。 如果已插入 <code>n</code> 个元素，则给定（比特）位仍为 <code>0</code> 的概率为 <code>(1 − 1/m)^n</code>。 因此，在 <code>n</code> 次插入之后，切片中的特定（比特）位被设置的概率，也是预期的填充率 <code>p</code>，为：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-4.png" loading="lazy"></p>
</div>

<h3 id="3-2、限定错误"><a href="#3-2、限定错误" class="headerlink" title="3.2、限定错误"></a>3.2、限定错误</h3><p>From the analysis in the previous section, it is evident that the error probability <code>P</code> increases with <code>n</code> and decreases with <code>m</code> and <code>k</code>. We now determine how to choose <code>k</code> (and thus <code>m</code>) such that, for a given filter size <code>M</code>, we can maximize the number of stored elements <code>n</code>, while keeping the error probability below a certain value <code>P</code>.</p>
<p>从上一节的分析可以看出，错误概率（误判率） <code>P</code> 随着 <code>n</code> 的增加而增加，随着 <code>m</code> 和 <code>k</code> 的增加而减少。 我们现在确定如何选择 <code>k</code>（因此选择 <code>m</code>），使得对于给定的过滤器大小 <code>M</code>，我们可以最大化存储元素的数量 <code>n</code>，同时将错误概率保持在某个 <code>P</code> 值以下。</p>
<p>For usable values of <code>m</code>, <code>1−1/m</code> is almost the same as <code>e^(−1/m)</code> (from the Taylor series expansion); we can use this approximation to obtain:</p>
<p>对于 <code>m</code> 的可用值，<code>1−1/m</code> 与<code>e^(−1/m)</code> 几乎相同（来自泰勒级数展开式）； 我们可以使用这个近似来获得：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-5.png" loading="lazy"></p>
</div>


<p>from which we obtain:</p>
<p>我们从中获得：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-6.png" loading="lazy"></p>
</div>

<p>From <code>M = km</code> and <code>P = p^k</code> we obtain <code>m = M * ln(p) / ln(P)</code>; therefore:</p>
<p>从 <code>M = km</code> 和 <code>P = p^k</code> 我们得到 <code>m = M * ln(p) / ln(P)</code>； 所以：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-7.png" loading="lazy"></p>
</div>

<p>For any given error probability <code>P</code> and filter size <code>M</code>, <code>n</code> is maximized by making <code>p = 1/2</code>, regardless of <code>P</code> or <code>M</code>. As <code>p</code> corresponds to the fill ratio of a slice, a filter depicts an optimal use when slices are half full. With <code>p = 1/2</code> we obtain:</p>
<p>对于任何给定的错误概率（误判率）<code>P</code> 和过滤器大小 <code>M</code>，通过使 <code>p = 1/2</code> 最大化 <code>n</code>，而不管 <code>P</code> 或 <code>M</code>。 由于 <code>p</code> 对应于切片的填充率，因此过滤器描述了切片半满时的最佳使用。 使用<code>p = 1/2</code>，我们得到：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-8.png" loading="lazy"></p>
</div>

<p>In this expression it is clear that the number of elements <code>n</code> that can be stored, for a given error <code>P</code>, is linear on the filter size <code>M</code>. Finally, from <code>P = p^k</code> and with <code>p = 1/2</code> we obtain:</p>
<p>在这个表达式中，很明显，对于给定的误差 <code>P</code>，可以存储的元素数量 <code>n</code> 与过滤器大小 <code>M</code> 成线性关系。 最后，从 <code>P = p^k</code> 和 <code>p = 1/2</code> 我们得到：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-10.png" loading="lazy"></p>
</div>

<div>

<p><img src="/assets/images/scalable-bloom-filter-9.png" alt="表1" loading="lazy"></p>
</div>

<p>Table 1. Several capacities for a bloom filter with 32 Kilobytes.</p>
<p>表1. 32KB 的布隆过滤器的几种容量</p>
<p>With these formulae it is now possible to determine the optimal filter parameters in order to respect a maximum error probability. For example, to have a maximum error of <code>0.1%</code> we should have at least <code>10</code> slices, since <code>log2 * (1 / 0.001) ≈ 9.96 (2^10 = 1024)</code>. If this filter is allocated <code>32</code> kilobytes, each slice will have <code>26214</code> bits and the filter is predicted to hold up to <code>18232</code> elements. See <code>Table 1</code>.</p>
<p>使用这些公式，为了考虑最大错误概率，可以确定最佳过滤器的参数。 例如，要获得 <code>0.1%</code> 的最大误差，我们应该至少有 <code>10</code> 个切片，因为<code>log2 * (1 / 0.001) ≈ 9.96 (2^10 = 1024)</code>。 如果此过滤器分配了 <code>32</code> 千字节，则每个切片将具有 <code>26214</code> 位，并且预计该过滤器最多可容纳 <code>18232</code> 个元素。 参见 <code>表 1</code>。</p>
<h2 id="4、可扩展的布隆过滤器"><a href="#4、可扩展的布隆过滤器" class="headerlink" title="4、可扩展的布隆过滤器"></a>4、可扩展的布隆过滤器</h2><p>A Scalable Bloom Filter addresses the problem of having to choose an a priori maximum size for the set, and allows an arbitrary growth of the set being represented. The two key ideas are:</p>
<p>可扩展的布隆过滤器解决了必须事先为集合确定最大容量大小的问题，并允许对应的集合的大小任意增长。 两个关键思想是：</p>
<ul>
<li>A SBF is made up of a series of one or more (plain) Bloom Filters; when filters get full due to the limit on the fill ratio, a new one is added; querying is made by testing for the presence in each filter.</li>
<li>Each successive bloom filter is created with a tighter maximum error probability on a geometric progression, so that the compounded probability over the whole series converges to some wanted value, even accounting for an infinite series.</li>
</ul>
<br />

<ul>
<li>SBF 由一系列一个或多个（普通）布隆过滤器组成； 当过滤器由于填充率的限制而被填满时，会添加一个新的； 查询时会验证元素在每个过滤器的存在。</li>
<li>每个连续的布隆过滤器都是在几何级数上以更严格的最大错误概率（误判率）创建的，因此整个系列的复合概率收敛到某个想要的值，甚至可以考虑无限系列。</li>
</ul>
<p>The SBF starts with one filter with <code>k0</code> slices and error probability <code>P0</code>. When this filter gets full, a new one is added with <code>k1</code> slices and <code>P1 = P0 * r</code> error probability, where <code>r</code> is the tightening ratio with <code>0 &lt; r &lt; 1</code>. At a given moment we will have <code>l</code> filters with error probabilities <code>P0</code>, <code>P0 * r</code>, <code>P0 * r^2</code> , . . . <code>P0 * r^(l−1)</code>. The compounded error probability for the <code>SBF</code> will be:</p>
<p>SBF 从一个具有 <code>k0</code> 切片和错误概率（误判率） <code>P0</code> 的过滤器开始。当此过滤器已满时，会添加一个带有 <code>k1</code> 切片和 <code>P1 = P0 * r</code> 错误概率（误判率）的新的过滤器，其中 <code>r</code> 是 <code>0 &lt; r &lt; 1</code> 的紧缩比率（缩小比率）。 在给定时刻，我们将有 <code>l</code> 个错误概率（误判率）为 <code>P0</code>，<code>P0 * r</code>，<code>P0 * r^2</code> ， . . .  <code>P0 * r^(l−1)</code>。 <code>SBF</code> 的复合错误概率为：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-11.png" loading="lazy"></p>
</div>


<p>We can use the known approximation:</p>
<p>我们可以使用已知的近似值：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-12.png" loading="lazy"></p>
</div>

<p>to obtain an upper bound (which will be tight for small <code>Pi</code>):</p>
<p>获得一个上限（对于小的 <code>Pi</code> 来说会很紧）：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-13.png" loading="lazy"></p>
</div>

<p>and therefore:</p>
<p>因此：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-14.png" loading="lazy"></p>
</div>

<p>The number of slices for each filter will be:</p>
<p>每个过滤器的切片数将为：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-15.png" loading="lazy"></p>
</div>


<p>and</p>
<p>并且</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-16.png" loading="lazy"></p>
</div>

<p>To have each <code>ki</code> as an integer, a natural choice will be <code>r = 1/2</code>, resulting in:</p>
<p>要将每个 <code>ki</code> 作为整数，自然选择将是 <code>r = 1/2</code>，结果是：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-17.png" loading="lazy"></p>
</div>

<p>which means an extra slice per new filter. The compounded error probability for the <code>SBF</code> will be bounded by:</p>
<p>这意味着每个新过滤器都有一个额外的切片。 <code>SBF</code> 的复合错误概率将受以下限制：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-18.png" loading="lazy"></p>
</div>

<div>

<p><img src="/assets/images/scalable-bloom-filter-19.png" loading="lazy"></p>
</div>

<p>Figure 1. Space usage as a function of set size. Two SBFs, with slice growth factors <code>s = 1</code> and <code>s = 2</code>, are compared with a static bloom. Both with <code>r = 0.5</code>,<code> m0 = 128</code> and <code>P = 10^−6</code> .</p>
<p>图1.  空间使用量与集合大小的函数关系。 将切片生长因子（布隆过滤器的容量增长倍数） <code>s = 1</code>  和 <code>s = 2</code> 的两个 SBF 与静态布隆过滤器进行比较。 都具有 <code>r = 0.5</code> 、 <code>m0 = 128</code> 和 <code>P = 10^−6</code> 。</p>
<div>

<p><strong>图1 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （set size） ：数据集大小（数量）；</li>
<li>纵坐标（ABF size in bits）：布隆过滤器的大小，单位比特；</li>
</ul>
</li>
<li>含义解释：<ul>
<li>静态（普通）布隆过滤器的大小是固定的（根据特定的误判率以及容量确定的），随着数据集的增长，布隆过滤器的大小是没有变化的；</li>
<li>当可扩展布隆过滤器的增长因子为 <code>1</code> 时，下一个创建的布隆过滤器的容量是前一个的 <code>1倍</code>，随着数据集的增长，布隆过滤器的大小呈现 <code>指数增长</code> 的现象；</li>
<li>当可扩展布隆过滤器的增长因子为 <code>2</code> 时，下一个创建的布隆过滤器的容量是前一个的 <code>2倍</code>，随着数据集的增长，布隆过滤器的大小呈现 <code>阶梯状增长</code> 的现象；</li>
</ul>
</li>
</ul>
</div>

<p>Another possibility is to use an <code>r</code> other than <code>1/2</code> and round up the resulting <code>ki’s</code> to obtain the number of slices. We will see below that choosing <code>r</code> around <code>0.8 – 0.9</code> will result in better average space usage for wide ranges of growth.</p>
<p>另一种可能性是使用 <code>1/2</code> 以外的 <code>r</code> 并四舍五入得到的 <code>ki&#39;s</code> 以获得切片数。 我们将在下面看到，在 <code>0.8 - 0.9</code> 之间选择 <code>r</code> 将导致更大范围的增长更好的平均空间使用率。</p>
<h3 id="4-1、可扩展的增长"><a href="#4-1、可扩展的增长" class="headerlink" title="4.1、可扩展的增长"></a>4.1、可扩展的增长</h3><p>The estimation of the set size that is to be stored in a filter may be wrong, possibly by several orders of magnitude. We may also want to use not much more memory than needed at a given time, and start a filter with a small size. Therefore, a <code>SBF</code> should be able to adapt to variations in size of several orders of magnitude in an efficient way.</p>
<p>预估的存储在过滤器中的集合大小可能是错误的，有可能相差几个数量级。 可能我们还希望在给定时间内使用不超过所需的内存，并启动一个小尺寸的过滤器。 因此，<code>SBF</code> 应该能够以有效的方式适应几个数量级的大小变化。</p>
<p>When a new filter is added to a <code>SBF</code>, its size can be chosen orthogonally to the required false positive probability. A flexible growth can be obtained by making the filter sizes grow exponentially. We can have a <code>SBF</code> made up of a series of filters with slices having sizes <code>m0</code>, <code>m0 * s</code>, <code>m0 * s^2</code> , . . . , <code>m0 * s^(l−1)</code> .</p>
<p>当一个新的过滤器被添加到一个 <code>SBF</code> 时，它的大小可以与所需的误报概率正交地选择（正相交？）。 通过使过滤器的大小呈指数增长，可以获得灵活的增长。 我们可以有一个由一系列过滤器组成的 <code>SBF</code>，这些过滤器的切片大小为 <code>m0</code>、<code>m0 * s</code>、<code>m0 * s^2</code>、.. . . , <code>m0 * s^(l−1)</code> 。</p>
<p>Given that filters stop being used when the fill ratio reaches <code>1/2</code>, filter <code>i</code> will hold approximately:</p>
<p>鉴于过滤器在填充率达到 <code>1/2</code> 时停止使用，过滤器 <code>i</code> 将保持大约：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-20.png" loading="lazy"></p>
</div>


<p>elements. The <code>SBF</code> with <code>l</code> stages will hold about:</p>
<p>元素。 具有 <code>l</code> 个阶段的 <code>SBF</code> 将保持大约：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-21.png" loading="lazy"></p>
</div>


<p>elements. This geometric progression allows a fast adaptation to set sizes of different orders of magnitude. A practical choice will be <code>s = 2</code>, which preserves <code>mi</code> as a power of <code>2</code>, if <code>m0</code> already starts as such; this is useful, as the range of a hash function is typically a power of <code>2</code>.</p>
<p>元素。 这种几何级数允许快速适应不同数量级的设置大小。 一个实际的选择是 <code>s = 2</code>，如果 <code>m0</code> 已经开始这样，它会将 <code>mi</code> 保留为 <code>2</code> 的幂； 这很有用，因为散列函数的范围通常是 <code>2</code> 的幂。</p>
<p>In general, other values of <code>s</code> may be used. <code>Figure 1</code> shows the required size for the <code>SBF</code> as a function of set size, <code>n</code>, for <code>s = 1</code> and <code>s = 2</code>. The case <code>s = 1</code> gives a constant <code>m</code> in all stages; this case is not feasible as it would lead to much inefficiency, as the number of stages required grows linearly with set size, and in each stage an extra slice would be required (for <code>r = 1/2</code>); this would result in rapidly increasing space per element and computational cost for the hash functions. For <code>s = 2</code> we can see that not only the number of stages remains low, as it increases logarithmically with the set size, but also the space required for the <code>22624</code> element set is only slightly more than for a static filter dimensioned for that size.</p>
<p>通常，可以使用其他值的<code>s</code>。 <code>图 1</code> 显示了 <code>SBF</code> 所需的大小作为集合大小 <code>n</code> 的函数，对于 <code>s = 1</code> 和 <code>s = 2</code>。 当 <code>s = 1</code> 在所有阶段给出一个常数 <code>m</code>； 这种情况是不可行的，因为它会导致效率低下，因为所需的阶段数会随着集合大小线性增长，并且在每个阶段都需要一个额外的切片（对于 <code>r = 1/2</code>）； 这将导致每个元素的空间和散列函数的计算成本迅速增加。 对于<code>s = 2</code>，我们可以看到不仅阶段数仍然很低，因为它随着集合大小呈对数增加，而且<code>22624</code>元素集所需的空间仅比静态过滤器尺寸略多 对于那个尺寸。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-22.png" alt="图2" loading="lazy"></p>
</div>

<p>Figure 2. Relative space usage with respect to a static filter as a function of set growth. With <code>r = 0.5</code> and <code>P = 10^−6</code> .</p>
<p>图 2. 相对于静态布隆过滤器的相对空间使用率作为集合增长的函数。 使用 <code>r = 0.5</code> 和 <code>P = 10^−6</code> 。</p>
<div>

<p><strong>图2 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （growth magnitude） ：增长幅度；</li>
<li>纵坐标（relative space usage）：相对空间使用量，相比静态（普通）布隆过滤器；</li>
</ul>
</li>
<li>含义解释：<ul>
<li>观察可扩展的布隆过滤器的下一个子布隆过滤器的误判率是上一个的 <code>0.5</code> 倍，并且误判率为 <code>10^-6 = 0.000001</code> 的情况下；</li>
</ul>
</li>
</ul>
</div>


<p>To better understand adaptation to growth, we should not plot space usage against an absolute set size, but against the relative growth over the initial size. We should have a scale-free graph telling us how much space will be used according to the orders of magnitude in size the filter has to adapt to. <code>Figure 2</code> plots the space usage relative to a static filter dimensioned for the required size. Here we can see that if the set had to grow by <code>6</code> orders of magnitude, for <code>s = 2</code> the <code>SBF</code> would use about twice the space of a static filter exactly dimensioned for the final size, and for<code>s = 4</code> about <code>50%</code> more space. In terms of space usage we can see that practical values of <code>s</code> like <code>2</code>, <code>4</code> or above can be chosen, and values below <code>2</code> and approaching <code>1</code> will give progressively worse results.</p>
<p>为了更好地理解对增长的适应，我们不应该根据绝对集合大小绘制空间使用情况，而是针对初始大小的相对增长。 我们应该有一个无标度图，告诉我们根据过滤器必须适应的大小数量级将使用多少空间。 <code>图 2</code> 绘制了相对于所需尺寸的静态过滤器的空间使用情况。 在这里我们可以看到，如果集合必须增长 <code>6</code> 数量级，对于 <code>s = 2</code>，<code>SBF</code> 将使用大约两倍的静态过滤器空间，该静态过滤器的尺寸恰好适合最终尺寸，而对于<code>s = 4</code> 约 <code>50%</code> 更多空间。 在空间使用方面，我们可以看到 <code>s</code> 的实际值可以选择，例如 <code>2</code>、<code>4</code> 或更高，低于 <code>2</code> 和接近 <code>1</code> 的值会产生越来越差的结果。</p>
<p>Another aspect to consider in the choice of <code>s</code> is the number of stages required for the <code>SBF</code>. <code>Figure 3</code> plots the number of stages as a function of <code>s</code>, for two cases of set growth: <code>10^2</code> and <code>10^6</code>. This figure confirms that <code>s</code> should not be chosen near <code>1</code> and that the practical choice of <code>s</code> as a power of <code>two</code> is a sensible one with this respect.</p>
<p>在选择 <code>s</code> 时要考虑的另一个方面是 <code>SBF</code> 所需的级数。 <code>图 3</code> 将阶段数绘制为 <code>s</code> 的函数，对于两种集合增长情况：<code>10^2</code> 和 <code>10^6</code>。 这个数字证实了 <code>s</code> 不应该选择在 <code>1</code> 附近，并且在这方面实际选择 <code>s</code> 作为 <code>2</code> 的幂是一个明智的选择。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-23.png" alt="图 3" loading="lazy"></p>
</div>

<p>Figure 3. Number of stages as a function of <code>s</code>.</p>
<p>图 3. 阶段数作为 <code>s</code> 的函数。</p>
<div>

<p><strong>图3 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （s） ：下一个子布隆过滤器容量的增长倍数；</li>
<li>纵坐标（l）：子布隆过滤器的数量；</li>
</ul>
</li>
</ul>
</div>

<p>From these figures one could be led to think that the larger the <code>s</code> the better. However, as <code>s</code> tends to infinity, each successive stage of the <code>SBF</code> will take considerably more space which will remain poorly used for considerably more time until it gets full. A better criterion is to consider the average space usage over the lifetime of the <code>SBF</code> from an empty set until the final set size. <code>Figure 4</code> plots this average space usage relative to a static filter (dimensioned for the final set size), as a function of <code>s</code>, for several combinations of error probability (<code>10^−3</code> and <code>10^−6</code>) and set growth (<code>10^2</code> and <code>10^6</code> ). These curves cover a wide range of scenarios; they show that, as long as <code>s</code> is not very close to <code>1</code>, increasing <code>s</code> is not profitable.</p>
<p>从这些数字可以导致人们认为 <code>s</code> 越大越好。 然而，由于 <code>s</code> 趋于无穷大，<code>SBF</code> 的每个连续阶段将占用相当多的空间，这些空间将在相当长的时间内保持不良使用状态，直到它被填满。 更好的标准是考虑 <code>SBF</code> 生命周期内从空集到最终集大小的平均空间使用情况。 <code>图 4</code> 绘制了相对于静态过滤器的平均空间使用情况（根据最终集大小确定），作为 <code>s</code> 的函数，对于错误概率的几种组合（<code>10^−3</code> 和 <code>10^−6 </code>) 并设置增长（<code>10^2</code> 和 <code>10^6</code>）。 这些曲线涵盖了广泛的场景； 他们表明，只要 <code>s</code> 不是很接近 <code>1</code>，增加 <code>s</code> 是无利可图的。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-24.png" alt="图 4" loading="lazy"></p>
</div>

<p>Figure 4. Average relative space usage as a function of <code>s</code>, for different combinations of set growth and <code>P</code>, for optimal <code>r</code>.</p>
<p>图 4. 对于集合增长和“P”的不同组合，作为 <code>s</code> 函数的平均相对空间使用率，以获得最佳 <code>r</code>。</p>
<div>

<p><strong>图4 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （s） ：下一个子布隆过滤器容量的增长倍数；</li>
<li>纵坐标（average use ratio）：平均使用率；</li>
</ul>
</li>
</ul>
</div>


<p>Combining these two criteria, i.e. average space and number of stages, with the convenience of having a power of <code>two</code>, we can conclude that <code>2</code> or <code>4</code> will be a sensible choice for <code>s</code>. To keep the number of stages small, we can choose <code>s = 2</code> if we expect a small set growth and <code>s = 4</code> if we expect a larger growth.</p>
<p>结合这两个标准，即平均空间和阶段数，加上 <code>2</code> 的幂的便利性，我们可以得出结论，<code>2</code> 或 <code>4</code> 将是 <code>s</code> 的明智选择。 为了保持阶段的数量较少，如果我们期望小的集合增长，我们可以选择<code>s = 2</code>，如果我们期望更大的增长，我们可以选择<code>s = 4</code>。</p>
<h3 id="4-2、选择错误判断比例"><a href="#4-2、选择错误判断比例" class="headerlink" title="4.2、选择错误判断比例"></a>4.2、选择错误判断比例</h3><p>The other parameter of a <code>SBF</code> that we need to choose is the error probability ratio <code>r</code>. We can choose values other than <code>0.5</code> and round up the resulting number of slices for stage <code>i</code>:</p>
<p>我们需要选择的 <code>SBF</code> 的另一个参数是错误概率比 <code>r</code>。 我们可以选择 <code>0.5</code> 以外的值，并对阶段 <code>i</code> 的切片数进行四舍五入：</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-25.png" loading="lazy"></p>
</div>

<p><code>Figure 5</code> compares the space usage as a function of set growth for different combinations of <code>P</code> and <code>r</code>. It shows that if we use an <code>r</code> larger than <code>0.5</code>, although we start by using more space (we need more initial slices, <code>k0</code>, as <code>P0</code> needs to be smaller for the geometric series to converge to the same <code>P</code>), after some point we end up using less and less space as the set grows, as we add slices less frequently at each new stage. It specially pays to use a large <code>r</code> for a tighter error probability <code>P</code>, as the few extra slices needed initially will be a small overhead over the already large number of slices needed for <code>r = 0.5</code>.</p>
<p><code>图 5</code> 比较了 <code>P</code> 和 <code>r</code> 的不同组合的空间使用作为集合增长的函数。 它表明，如果我们使用大于 <code>0.5</code> 的 <code>r</code> ，尽管我们从使用更多空间开始（我们需要更多初始切片， <code>k0</code>，因为 <code>P0</code> 需要更小才能使几何级数收敛到 相同的<code>P</code>），在某个点之后，随着集合的增长，我们最终使用的空间越来越少，因为我们在每个新阶段添加切片的频率越来越低。 使用较大的 <code>r</code> 来获得更严格的错误概率 <code>P</code> 是特别值得的，因为最初需要的几个额外切片将比<code>r = 0.5</code> 所需的已经大量切片的开销小。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-26.png" alt="图 5" loading="lazy"></p>
</div>

<p>Figure 5. Relative space usage as a function of growth, for different combinations of <code>P</code> and <code>r</code> and <code>s = 2</code>.</p>
<p>图 5. 对于 <code>P</code> 和 <code>r</code> 以及 <code>s = 2</code> 的不同组合，作为增长函数的相对空间使用情况。</p>
<div>

<p><strong>图5 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （growth magnitude） ：增长幅度；</li>
<li>纵坐标（relative space usage）：相对空间使用量，相比静态（普通）布隆过滤器；</li>
</ul>
</li>
</ul>
</div>

<p><code>Figure 4</code> shows average relative space usage, calculated for the optimal <code>r</code> that minimizes average space, for each combination of growth and <code>s</code> values (the optimal <code>r</code> does not depend on <code>P</code>).</p>
<p><code>图 4</code> 显示了平均相对空间使用情况，为最小化平均空间的最佳 <code>r</code> 计算，对于增长和<code>s</code>值的每个组合（最佳<code>r</code>不依赖于<code>P</code>）。</p>
<p>In order to select an appropriate value for <code>r</code> we can observe how the optimal <code>r</code> behaves for different growth and s values. <code>Figure 6</code> shows the optimal <code>r</code> as a function of set growth, for three different values of <code>s (√2, 2, 4)</code>. Considering the choice of <code>s = 2</code> for small expected growth and <code>s = 4</code> for larger growth, one can see that <code>r</code> around <code>0.8 – 0.9</code> is a sensible choice, that gives better space usage than the natural <code>r = 1/2</code>.</p>
<p>为了为 <code>r</code> 选择一个合适的值，我们可以观察最佳 <code>r</code> 对于不同的增长和 s 值的表现。 <code>图 6</code> 显示了最优 <code>r</code> 作为集合增长的函数，对于 <code>s (√2, 2, 4)</code> 的三个不同值。 考虑到较小的预期增长选择 <code>s = 2</code> 和较大增长的 <code>s = 4</code> ，可以看出 <code>r</code> 大约在 <code>0.8 – 0.9</code> 是一个明智的选择，它比自然的 <code> r = 1/2</code>。</p>
<div>

<p><img src="/assets/images/scalable-bloom-filter-27.png" alt="图 6" loading="lazy"></p>
</div>

<p>Figure 6. Optimal <code>r</code> as a function of growth magnitude, for <code>s ∈ &#123;√ 2, 2, 4&#125;</code> and <code>P = 10^−6</code> .</p>
<p>图 6. 对于 <code>s ∈ &#123;√ 2, 2, 4&#125;</code> 和 <code>P = 10^−6</code>，最佳 <code>r</code> 作为增长幅度的函数。</p>
<div>

<p><strong>图6 内容解析：</strong></p>
<ul>
<li>坐标轴信息：<ul>
<li>横坐标 （growth magnitude） ：增长幅度；</li>
<li>纵坐标（optimal r）：最优的 <code>r</code> ；</li>
</ul>
</li>
</ul>
</div>


<h2 id="5、结论"><a href="#5、结论" class="headerlink" title="5、结论"></a>5、结论</h2><p>Bloom Filters and the existing variants require a priori dimensioning of the maximum size of the set to be stored in the filter. Given that it is not always possible to know in advance how many elements will need to be stored, this leads to over-dimensioning the filters, possibly by several orders of magnitude.</p>
<p>布隆过滤器和现有变体需要事先确定要存储在过滤器中的集合的最大大小。 考虑到（用户）并不总能提前知道需要存储多少元素，这就会导致布隆过滤器尺寸过大，可能还会增加几个数量级。</p>
<p>In this paper we have introduced <code>Scalable Bloom Filters (SBF)</code>, a mechanism that allows representing sets without having to know a priori the maximum set size and yet being able to choose from the start the maximum false positive probability. The mechanism adapts to set growth by using a series of classic Bloom Filters of increasing sizes and tighter error probabilities, added as needed.</p>
<p>在本文中，我们介绍了可扩展的布隆过滤器（SBF），一种允许表示集合的机制，而无需事先知道最大集合大小，并且能够从一开始就选择最大误报概率。 该机制通过使用一系列经典的布隆过滤器来适应集合增长，这些布隆过滤器的大小越来越大，错误概率越来越小，根据需要添加。</p>
<p>A <code>SBF</code> is parameterized not only by the initial size and error probability but also by the growth rate of the size and by the error probability tightening rate. In this paper we have studied the impact of these parameters on space usage and shown how they can be chosen for a range of scenarios.</p>
<p><code>SBF</code> 不仅由初始大小和错误概率参数化，而且由大小的增长率和错误概率收紧率参数化。 在本文中，我们研究了这些参数对空间使用的影响，并展示了如何为一系列场景选择它们。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div>

<p>[1]. B. H. Bloom, Space&#x2F;time trade-offs in hash coding with allowable errors, Commun. ACM 13 (7) (1970) 422–426.<br>[2]. F. Chang, W. chang Feng, K. Li, Approximate caches for packet classification, in: Proc. of the 23rd Annual Joint Conference of the IEEE Computer and Communications Societies (INFOCOM 2004), IEEE, 2004.<br>[3]. P. Reynolds, A. Vahdat, Efficient peer-to-peer keyword searching., in: M. Endler, D. C. Schmidt (Eds.), Middleware, Vol. 2672 of Lecture Notes in Computer Science, Springer, 2003, pp. 21–40.<br>[4]. S. C. Rhea, J. Kubiatowicz, Probabilistic location and routing., in: Proc. of the 21st Annual Joint Conference of the IEEE Computer and Communications Societies (INFOCOM 2002), 2002.<br>[5]. L. Fan, P. Cao, J. Almeida, A. Z. Broder, Summary cache: a scalable wide-area web cache sharing protocol, IEEE&#x2F;ACM Trans. Netw. 8 (3) (2000) 281–293.<br>[6]. L. F. Mackert, G. M. Lohman, R* optimizer validation and performance evaluation for distributed queries, in: Proceedings of the Twelfth International Conference on Very Large Data Bases (VLDB ’86), Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1986, pp. 149–159.<br>[7]. A. Broder, M. Mitzenmacher, Network applications of bloom filters: A survey, in: Proc. of Allerton Conference, 2002.<br>[8]. S. Cohen, Y. Matias, Spectral bloom filters, in: Proceedings of the 2003 ACM SIGMOD international conference on Management of data (SIGMOD ’03), ACM Press, New York, NY, USA, 2003, pp. 241–252.<br>[9]. U. Manber, S. Wu, An algorithm for approximate membership checking with application to password security, Inf. Process. Lett. 50 (4) (1994) 191–197.<br>[10]. S. Dharmapurikar, P. Krishnamurthy, D. E. Taylor, Longest prefix matching using bloom filters, in: Proceedings of the 2003 conference on Applications, technologies, architectures, and protocols for computer communications (SIGCOMM ’03), ACM Press, New York, NY, USA, 2003, pp. 201–212.<br>[11]. M. Mitzenmacher, Compressed bloom filters, IEEE&#x2F;ACM Trans. Netw. 10 (5) (2002) 604–612.<br>[12]. P. Bose, H. Guo, E. Kranakis, A. Maheshwari, P. Morin, J. Morrison, M. Smid, Y. Tang, On the false-positive rate of bloom filters, submitted to Information Processing Letters, available at <a target="_blank" rel="noopener" href="http://citeseer.ist.psu.edu/649161.html">http://citeseer.ist.psu.edu/649161.html</a> (2004).</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2022/03/01/scalable-bloom-filters/">https://bugwz.com/2022/03/01/scalable-bloom-filters/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87/">论文</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/BloomFilter/">BloomFilter</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/paper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/01/01/redismodule-redisbloom/" title="RedisModule剖析 - RedisBloom"><img class="cover" src="/assets/images/bg/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RedisModule剖析 - RedisBloom</div></div><div class="info-2"><div class="info-item-1">RedisBloom 这个 Module 内集成了很多的小功能，其中主要包括：可扩展的布隆过滤器（BloomFilter），可扩展的布谷鸟过滤器（CuckooFilter），最小计数草图（Count-Min Sketch），近似百分位（T-Digest），头部K元素（TopK）等。 一、简介RedisBloom 是一款集成了众多功能的 RedisModule 模块，其主要包含了 BloomFilter (布隆过滤器) ，CuckooFilter (布谷鸟过滤器)，Count-Min Sketch (最小计数草图)，T-Digest (近似百分位) 以及 TopK 功能，其中很多功能都是依据 BloomFilter类 的相关功能来进行实现的，这里将会对它们的具体实现做一下深度的剖析。  官网：https://redisbloom.io/ GitHub 地址：https://github.com/RedisBloom/RedisBloom 命令文档地址：https://redis.io/docs/stack/bloom/ 支持功能： 可扩展的 BloomFilter (布隆过滤器)...</div></div></div></a><a class="pagination-related" href="/2022/07/01/redismodule-redistimeseries/" title="RedisModule剖析 - RedisTimeSeries"><img class="cover" src="/assets/images/bg/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RedisModule剖析 - RedisTimeSeries</div></div><div class="info-2"><div class="info-item-1">RedisTimeSeries 是一款基于 RedisModule 实现的时序数据库模块，提供了基础的时序操作功能，包括不限于聚合查询，范围查询，保留周期，降采样（数据压缩），插值变更，二级索引等。由于数据存储于内存中，因此提供了高性能读写访问能力，但同时也受限于内存存储，可能并不适合用在极大数据量的时序场景中。考虑到身靠着Redis生态这棵大树，也许能够和Redis生态的众多组件碰撞出有趣的火花。 一、简介 官网：https://redis.io/docs/stack/timeseries/ GitHub 地址：https://github.com/RedisTimeSeries/RedisTimeSeries 命令文档地址：https://redis.io/commands/ts.add/ 支持功能： 大容量插入，低延迟读取； 按开始时间和结束时间查询； 任何时间桶的聚合查询（ Min 、 Max 、 Avg 、 Sum 、 Range 、 Count 、 First 、 Last 、 STD.P 、 STD.S 、 Var.P 、 Var.S 、 twa...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/05/23/bloom-filter-summary-cache-paper/" title="译 - Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-23</div><div class="info-item-2">译 - Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol</div></div><div class="info-2"><div class="info-item-1">《Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol》翻译过来是 《摘要缓存：可扩展的广域 Web 缓存共享协议》，这篇文章中提出了布隆过滤器的设计背景以及实现原理，详细介绍了在误判率以及存储空间之间的权衡，之后很多系统中实现的布隆过滤器基本都是参考了这篇文论的实现。 摘要Web Proxy之间的共享缓存是减少Web流量并缓解网络瓶颈的一项重要技术。然而，由于现有协议的开销，它并未得到广泛部署。在本文中，我们演示了缓存共享的好处，衡量了现有协议的开销，并提出了一种称为”摘要缓存’’的新协议。在这个新协议中，每个Proxy都保留了一个包含所有Proxy的缓存摘要目录，并在任何查询之前都要检查在这些摘要之中是否存在潜在的匹配项。有两个因素利于我们协议的低开销：摘要的定期更新以及十分简朴的目录信息，每个条目只有8bits。通过使用跟踪驱动的仿真和原型实现，我们证明了与现有的协议（例如 Internet...</div></div></div></a><a class="pagination-related" href="/2019/10/20/the-rsync-algorithm/" title="译 - The rsync algorithm"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-20</div><div class="info-item-2">译 - The rsync algorithm</div></div><div class="info-2"><div class="info-item-1">  《The rsync algorithm》这篇发表于 1996 年的论文中介绍了一种名为 rsync 的增量同步算法，它能够快速地将两个文件夹中的内容同步。该算法利用了文件的局部性和差异性，通过计算文件的弱校验和和块校验和来确定文件的相似性，并进行增量同步。该算法具有高效性、可靠性和安全性等优点，在实际应用中被广泛使用。   0、摘要This report presents an algorithm for updating a file on one machine to be identical to a file on another machine. We assume that the two machines are connected by a low-bandwidth high-latency bi-directional communications link. The algorithm identifies parts of the source file which are identical to some part of the...</div></div></div></a><a class="pagination-related" href="/2022/11/16/bitcoin/" title="译 - Bitcoin: A Peer-to-Peer Electronic Cash System"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-16</div><div class="info-item-2">译 - Bitcoin: A Peer-to-Peer Electronic Cash System</div></div><div class="info-2"><div class="info-item-1">  《Bitcoin: A Peer-to-Peer Electronic Cash System》 翻译过来是《 比特币：一种点对点的电子现金系统》 ，这篇文章是比特币的发明人中本聪于 2008 年发表的比特币白皮书。这篇文章介绍了比特币的设计背景，讲述了比特币的工作原理，是加密货币，区块链领域必读的一篇文章，其中讲述了很多巧妙的构思。作者翻译水平有限，翻译的语句可能会有一些出入，建议有能力的读者还是去阅读一下原文。   0、摘要A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is...</div></div></div></a><a class="pagination-related" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-20</div><div class="info-item-2">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</div></div><div class="info-2"><div class="info-item-1">  译作: 可控的、可扩展的、分布式的副本数据放置算法，论文原文 。 该论文于 2006 年 11 月发布于 SC2006 。 CRUSH 是一种用于大规模分布式存储系统的数据分布算法，它通过伪随机函数将数据对象映射到存储设备上，无需依赖中央目录。CRUSH 算法设计考虑了系统的动态性，支持在添加或移除存储设备时高效地重组数据，并最小化不必要的数据移动。此外，CRUSH 支持多种数据复制和可靠性机制，并允许根据用户定义的策略进行数据分布，这些策略能够在故障域之间有效地分离副本，增强数据安全性。 CRUSH 的核心是其层级集群图，该图描述了存储集群的物理和逻辑结构，并通过一系列规则来确定数据的放置位置。CRUSH 算法通过将数据均匀分布在加权设备上，保持存储和设备带宽资源的平衡利用。算法还考虑了设备的故障和过载情况，能够在设备发生故障或过载时重新分配数据，避免数据丢失并优化系统性能。 CRUSH 的映射性能高效，计算复杂度为 O(logn) ，适用于管理大规模（多 PB...</div></div></div></a><a class="pagination-related" href="/2019/10/14/dynamo/" title="转&#x2F;译-Dynamo:Amazon的高可用键值存储"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-14</div><div class="info-item-2">转&#x2F;译-Dynamo:Amazon的高可用键值存储</div></div><div class="info-2"><div class="info-item-1">本文翻译自 2007 年 Amazon 的分布式存储经典论文：《Dynamo: Amazon’s Highly Available Key-value Store》)，直译为 《Dynamo：Amazon 的高可用键值存储》，这里对排版做了一些调整，以更适合 web 阅读。 Dynamo 是 Amazon 的高可用分布式键值存储（key&#x2F;value storage）系统。这篇论文发表 的时候（2007）它还只是一个内部服务，现在（改名为 DynamoDB）已经发展成 AWS 最核心 的存储产品（服务）之一，与 S3 等并列。据了解，国内某一线大厂的公有云键值 存储服务，也是参考这篇文章设计和实现的。 现在提到键值存储，大家首先想到的可能是 Redis，那么 Dynamo 和 Redis 是不是竞品， 只是一个开源一个是商业的？不是的，二者针对的场景不同，这里非常粗地列举几方面：  使用场景：Dynamo 定位是永远可写（always writable）的持久文件系统，Redis 主要用作（易失）缓存或内存数据库 存储方式：Dynamo 是磁盘，Redis...</div></div></div></a><a class="pagination-related" href="/2022/09/24/gorilla-cn/" title="译 - Gorilla: A Fast, Scalable, In-Memory Time Series Database"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="info-item-2">译 - Gorilla: A Fast, Scalable, In-Memory Time Series Database</div></div><div class="info-2"><div class="info-item-1">  《Gorilla: A Fast, Scalable, In-Memory Time Series Database》 这篇论文讲述了 Facebook 在存储时序数据模型时的一些实践，重点讲述了他们内部的一款内存型的时序数据库 Gorilla。论文中通过使用 Delta-Of-Delta 和 XOR 方式分别对时序数据的时间戳以及浮点数据进行压缩编码，极大的节省了时序数据的存储开销，这也成为了业界时序数据库主流的数据编码压缩方式。这篇论文是时序数据库领域必读的一篇文章。        摘要Large-scale internet services aim to remain highly available and responsive in the presence of unexpected failures. Providing this service often requires monitoring and analyzing tens of millions of measurements per second across a large number...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">126</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-text">2、相关工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">3、布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E5%81%87%E9%98%B3%E6%80%A7"><span class="toc-text">3.1、假阳性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E9%99%90%E5%AE%9A%E9%94%99%E8%AF%AF"><span class="toc-text">3.2、限定错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">4、可扩展的布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%A2%9E%E9%95%BF"><span class="toc-text">4.1、可扩展的增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E9%80%89%E6%8B%A9%E9%94%99%E8%AF%AF%E5%88%A4%E6%96%AD%E6%AF%94%E4%BE%8B"><span class="toc-text">4.2、选择错误判断比例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-text">5、结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 设计实现深入解析"/></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群搭建指南"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南">Ceph Crimson 集群搭建指南</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph QoS 机制深入分析"/></a><div class="content"><a class="title" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析">Ceph QoS 机制深入分析</a><time datetime="2024-10-24T16:00:00.000Z" title="发表于 2024-10-25 00:00:00">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录"><img src="/assets/images/bg/gpfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPFS 集群部署与运维记录"/></a><div class="content"><a class="title" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录">GPFS 集群部署与运维记录</a><time datetime="2024-07-31T16:00:00.000Z" title="发表于 2024-08-01 00:00:00">2024-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/30/ceph-crush/" title="Ceph CRUSH 设计实现剖析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph CRUSH 设计实现剖析"/></a><div class="content"><a class="title" href="/2023/06/30/ceph-crush/" title="Ceph CRUSH 设计实现剖析">Ceph CRUSH 设计实现剖析</a><time datetime="2023-06-29T16:00:00.000Z" title="发表于 2023-06-30 00:00:00">2023-06-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="paperlayout-btn" type="button" title="论文布局"><i class="fas fa-language"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '30d5ab40be6a230411209fe93d1e6245'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: '请输入要搜索的内容',
  }, {"maxResultsPerGroup":10}))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>