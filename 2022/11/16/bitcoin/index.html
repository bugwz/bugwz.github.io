<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>译 - Bitcoin: A Peer-to-Peer Electronic Cash System | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="《Bitcoin: A Peer-to-Peer Electronic Cash System》翻译过来是《 比特币：一种点对点的电子现金系统》 ，这篇文章是比特币的发明人中本聪于 2008 年发表的比特币白皮书。这篇文章介绍了比特币的设计背景，讲述了比特币的工作原理，是加密货币，区块链领域必读的一篇文章，其中讲述了很多巧妙的构思。作者翻译水平有限，翻译的语句可能会有一些出入，建议有能力的读者还是">
<meta property="og:type" content="article">
<meta property="og:title" content="译 - Bitcoin: A Peer-to-Peer Electronic Cash System">
<meta property="og:url" content="https://bugwz.com/2022/11/16/bitcoin/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="《Bitcoin: A Peer-to-Peer Electronic Cash System》翻译过来是《 比特币：一种点对点的电子现金系统》 ，这篇文章是比特币的发明人中本聪于 2008 年发表的比特币白皮书。这篇文章介绍了比特币的设计背景，讲述了比特币的工作原理，是加密货币，区块链领域必读的一篇文章，其中讲述了很多巧妙的构思。作者翻译水平有限，翻译的语句可能会有一些出入，建议有能力的读者还是">
<meta property="og:locale">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/paper.jpg">
<meta property="article:published_time" content="2022-11-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-23T13:45:23.117Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="比特币">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/paper.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "译 - Bitcoin: A Peer-to-Peer Electronic Cash System",
  "url": "https://bugwz.com/2022/11/16/bitcoin/",
  "image": "https://bugwz.com/assets/images/bg/paper.jpg",
  "datePublished": "2022-11-15T16:00:00.000Z",
  "dateModified": "2025-05-23T13:45:23.117Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2022/11/16/bitcoin/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '译 - Bitcoin: A Peer-to-Peer Electronic Cash System',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">131</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/paper.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">译 - Bitcoin: A Peer-to-Peer Electronic Cash System</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">译 - Bitcoin: A Peer-to-Peer Electronic Cash System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-15T16:00:00.000Z" title="Created 2022-11-16 00:00:00">2022-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-23T13:45:23.117Z" title="Updated 2025-05-23 21:45:23">2025-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/">比特币</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div>

<p><a target="_blank" rel="noopener" href="https://bitcoin.org/bitcoin.pdf">《Bitcoin: A Peer-to-Peer Electronic Cash System》</a> 翻译过来是《 比特币：一种点对点的电子现金系统》 ，这篇文章是比特币的发明人中本聪于 2008 年发表的比特币白皮书。这篇文章介绍了比特币的设计背景，讲述了比特币的工作原理，是加密货币，区块链领域必读的一篇文章，其中讲述了很多巧妙的构思。作者翻译水平有限，翻译的语句可能会有一些出入，建议有能力的读者还是去阅读一下原文。</p>
</div>

<h2 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h2><p>A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they’ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.</p>
<p>本文提出了一种完全通过点对点（对等）技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。数字签名提供了部分解决方案，但是如果仍然需要第三方的支持才能防止双重支付的话，那么这种系统也就失去了存在的价值。 我们提出了一种使用对等网络来解决双重支付问题的方法。该网络通过随机散列对全部交易加上时间戳， 将它们合并入一个不断延伸的基于随机散列的工作量证明的链条上作为交易记录，除非重新完成全部的工作量证明，否则已经形成的交易记录将不可更改。最长的链不仅可以证明所见证的事件顺序，还可以证明它来自最大的 CPU 算力池。只要大部分的 CPU 计算能力没有打算合作起来对全网进行攻击，那么它们就会生成最长的链并超过攻击者。这个网络本身需要的结构非常少。信息尽最大努力在全网广播，节点可以随意离开和重新加入网络，并接受最长的工作量证明链作为他们离开时发生的事情的证明。</p>
<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for nonreversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.</p>
<p>互联网上的贸易几乎完全依赖于可信赖的第三方金融机构来处理电子支付信息。尽管该系统在大多数交易情况下都运行良好，但它仍然受限于基于信任的模型的固有弱点的约束。我们无法实现完全不可逆的交易，因为金融机构总是不可避免地会出面协调争端。调解开销增加了交易的成本，并限制了最小实际交易规模，也限制了小额临时交易的可能性，更大的问题在于失去了为不可逆服务进行不可逆支付的能力。因为有潜在的退款的可能性，因此需要提高交易双方的信任度。而商家就必须时刻提防着自己的客户，因此就会向客户索取他们本来不需要的个人信息。商业行为中一定比例的欺诈通常是不可避免的。这些成本和支付的不确定性可以通过使用实物货币来避免，但是不存在在没有可信方的情况下使用通信渠道进行支付的机制。</p>
<p>What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes.</p>
<p>所以我们需要的是一种基于密码证明而非信任的电子支付系统，它允许任何的双方自愿与对方进行交易，而无需受信任的第三方。在计算上无法逆转（无法回退）的交易将保护卖家免受欺诈，并且使用常规的合约机制也可以来保护买家。在本文中，我们提出了一种通过使用点对点分布式时间戳服务器生成有序时间的电子交易证明来解决双重支出问题的方法。只要诚实的节点所控制的计算能力的总和，大于任何合作的攻击者计算能力的总和，该系统就是安全的。</p>
<h2 id="2、交易"><a href="#2、交易" class="headerlink" title="2、交易"></a>2、交易</h2><p>We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.</p>
<p>我们定义一枚电子硬币就是一个数字签名链。每个所有者通过对先前交易的哈希值和下一个所有者的公钥进行数字签名并将它们添加到硬币的末尾来将硬币转移到下一位所有者。收款者可以校验签名从而验证链的所有权。</p>
<div>

<p><img src="/assets/images/bitcoin-1.png" loading="lazy"></p>
</div>


<p>The problem of course is the payee can’t verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.</p>
<p>该问题的关键在于，收款人很难校验之前的某位所有者是否对这枚电子货币进行了双重支付。通常的解决方案是引入信得过的类似于造币厂的第三方权威机构，它会检查每笔交易是否存在双重支付。每次交易后，必须将币返还给造币厂并发行新币，只有造币厂直接发行的币才可信，这样能够防止双重支付。这个解决方案的问题在于，整个货币系统的命运依赖于运作造币厂的公司，因为每一笔交易都要经过它们，（造币厂）就像银行一样。</p>
<p>We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don’t care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.</p>
<p>我们需要一种方法让收款人知道以前的所有者没有签署任何早期的交易。就我们的目的而言，最早的交易才是最重要的，因此我们不关心之后的操作是否存在双重支付。确认一个不存在的交易的唯一方法是了解所有的交易。在造币厂模型中，造币厂知道所有的交易，并且决定交易的先后顺序。为了在没有受信任的第三方的情况下实现这一点，交易必须公开宣布 [1] ，我们需要一个系统让参与者就收到交易的顺序的单一历史达成一致。收款人需要证明在每次交易时，大多数的节点都同意它是第一个收到的。</p>
<h2 id="3、时间戳服务器"><a href="#3、时间戳服务器" class="headerlink" title="3、时间戳服务器"></a>3、时间戳服务器</h2><p>The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.</p>
<p>我们提出的解决方案开始于时间戳服务器。时间戳的工作原理是获取要加盖时间戳的项目块的散列值，并广泛发布该散列值，例如在报纸或者 Usenet 中发帖 [2-5]。时间戳证明了数据在对应时刻是一定存在的，因此才能获取到对应的随机散列值。每个时间戳都在其哈希值中包含前一个时间戳，之后每一个时间戳都会加强它之前的时间戳，这就形成了一个链条。</p>
<div>

<p><img src="/assets/images/bitcoin-2.png" loading="lazy"></p>
</div>



<h2 id="4、工作证明"><a href="#4、工作证明" class="headerlink" title="4、工作证明"></a>4、工作证明</h2><p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back’s Hashcash [6], rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.</p>
<p>为了在点对点（对等）的基础上构建分布式的时间戳服务器，我们需要使用类似于 Adam Back 的 哈希现金（Hashcash） [6] 的工作证明系统，而不是像报纸或 Usenet 的帖子。工作量证明涉及到扫描一个散列后的值，该值在散列时（例如使用 SHA-256 ）以多个零位开始。所需的平均工作量与所需的零位数量成指数关系，并且可以通过执行单个散列来进行验证。</p>
<p>For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block’s hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.</p>
<p>对于我们的时间戳网络，我们能通过在块中随机增加一个随机数并且直到找到对应块散列所需要的零位的方式来实现了工作证明。只要该 CPU 耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的块是被链接在该区块之后的，因此想要更改该区块中的信息就还需要重做之后所有区块的全部工作量。</p>
<div>

<p><img src="/assets/images/bitcoin-3.png" loading="lazy"></p>
</div>


<p>The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.</p>
<p>工作量证明还解决了在决策中确定大多数的问题。如果决定大多数的方式是基于 IP 地址的，一个 IP 地址一票，那么如果有人拥有分配大量 IP地址的权利，则该机制就会被破坏了。工作量证明本质上是一个 CPU 一票。多数决定由最长的链来确定，因为最长的链中包含了最大的工作量。如果大多数 CPU 能力由诚实的节点控制，那么诚实链将增长的最快并超过任何的竞争链。要修改过去的区块，攻击者必须重做该区块及后所有区块的工作量证明，然后赶上并超越诚实节点的工作量。稍后我们将展示，随着后续块的添加，较慢的攻击者能够赶上的概率将呈指数下降。</p>
<p>To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they’re generated too fast, the difficulty increases.</p>
<p>为了补偿不断增加的硬件速度和参与网络计算节点的数量波动，工作量证明的难度将由移动的平均线决定，其目标是每小时的平均块数。如果区块生成的速度过快，那么难度就会提高。</p>
<h2 id="5、网络"><a href="#5、网络" class="headerlink" title="5、网络"></a>5、网络</h2><p>The steps to run the network are as follows:</p>
<p>运行该网络的步骤如下：</p>
<ol>
<li>New transactions are broadcast to all nodes.</li>
<li>Each node collects new transactions into a block.</li>
<li>Each node works on finding a difficult proof-of-work for its block.</li>
<li>When a node finds a proof-of-work, it broadcasts the block to all nodes.</li>
<li>Nodes accept the block only if all transactions in it are valid and not already spent.</li>
<li>Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.</li>
</ol>
<br />

<ol>
<li>新的交易向全部节点进行广播；</li>
<li>每一个节点都将收到的交易信息纳入一个区块中；</li>
<li>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</li>
<li>当一个节点找到了一个工作量证明，它就会广播给全部节点；</li>
<li>当且仅当包含在该区块中的所有交易都是有效的并且之前没有存在过，其他节点才会认同该区块的有效性；</li>
<li>其他节点表示它们接受该区块，并在跟随该区块的末尾制造出新的区块来延长该链条，使用已经接收到的散列值作为新区块的上一个散列值。</li>
</ol>
<p>Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.</p>
<p>节点始终认为最长的链是正确的链，并将继续努力扩展它。 如果两个节点同时广播不同版本的新区块，其他节点在接收到该区块的时间上可能有先后的区别。 在这种情况下，它们将会处理收到的第一个区块，但也会保存另一个区块以防止它后续成为最长的链。该僵局的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。</p>
<p>New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.</p>
<p>新的交易广播不一定需要到达所有节点。 只要它们到达很多节点，它们很快就会进入一个区块。 块广播也可以容忍丢失消息。 如果一个节点没有收到一个块，它会在收到下一个块时意识到它错过了一个块并请求获取它。</p>
<h2 id="6、激励"><a href="#6、激励" class="headerlink" title="6、激励"></a>6、激励</h2><p>By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.</p>
<p>按照惯例，区块中的第一笔交易是一项特殊交易，它产生了一枚由该区块创建者拥有的新的电子货币。这样就增加了节点支持该网络的激励，并在没有中央机构来发行他们的情况下，提供了一种将电子货币分配到流通领域的一种方法。这种将一定数量的新货币持续增添到货币系统中的方法，类似于黄金矿工消耗资源挖掘金矿来增加黄金的流通量。在这歌场景中，我们消耗的是 CPU 时间和电力。</p>
<p>The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.</p>
<p>另一个激励的来源则是交易费用。 如果某笔交易的输出值小于其输入值，则差额就是交易费用，该费用会添加到包含该交易的区块的激励值中。 一旦预定数量的代币开始流通，那么激励机制就可以逐渐转换为完全依靠交易费，以至于能够避免出现通货膨胀。</p>
<p>The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.</p>
<p>激励系统也有助于鼓励节点保持诚实。 如果一个贪婪的攻击者能够聚集比所有诚实节点更多的 CPU 能力，那么他就面临一个选择：要么将其用于诚实工作产生新的电子货币，或者将其用于进行二次支付攻击。那么他就会发现，遵守规则更有利可图，这些规则有利于他获得比其他人加起来更多的新硬币，而不是破坏系统使其自身财富的有效性受损。</p>
<h2 id="7、回收硬盘空间"><a href="#7、回收硬盘空间" class="headerlink" title="7、回收硬盘空间"></a>7、回收硬盘空间</h2><p>Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block’s hash, transactions are hashed in a Merkle Tree [7] [2] [5], with only the root included in the block’s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored.</p>
<p>如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被随机散列后构建成一 种 Merkle 树 [7]  [2] [5] 的形态，只有根包含在区块的哈希中。 然后可以通过砍掉树的分支来压缩旧块。 不需要存储内部散列。</p>
<div>

<p><img src="/assets/images/bitcoin-4.png" loading="lazy"></p>
</div>


<p>A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 &#x3D; 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore’s Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.</p>
<p>一个没有交易的区块头大约有 80 个字节。 如果我们假设每 10 分钟生成一次块，则每年 80 字节 * 6 * 24 * 365 &#x3D; 4.2MB。 截至 2008 年，计算机系统通常配备 2GB RAM，并且摩尔定律预测当前每年增长 1.2GB，因此即使块头必须保存在内存中，存储也应该不是问题。</p>
<h2 id="8、简化付款验证"><a href="#8、简化付款验证" class="headerlink" title="8、简化付款验证"></a>8、简化付款验证</h2><p>It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he’s convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it’s timestamped in. He can’t check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.</p>
<p>可以在不运行完整网络节点的情况下验证支付。 用户只需要保留一份最长工作量证明链的区块头副本，它就可以不断通过查询网络节点，直到它确信它拥有最长的链，并能够通过 Merkle 的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性是不可能的，但是通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并在进一步确认网络已接受后续添加的区块。</p>
<div>

<p><img src="/assets/images/bitcoin-5.png" loading="lazy"></p>
</div>

<p>As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker’s fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user’s software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.</p>
<p>因此，只要诚实节点控制网络，校验机制就是可靠的，如果网络被攻击者制伏则更容易受到攻击。 虽然网络节点可以自己验证交易，但只要攻击者可以继续压倒网络，简化的方法就可以被攻击者伪造的交易所愚弄。 防止这种情况的一种策略是在网络节点检测到无效块时接受来自网络节点的警报，提示用户的软件下载完整块和警报交易以确认不一致。 经常收到付款的企业可能仍希望运行自己的节点以获得更独立的安全性和更快的验证。</p>
<h2 id="9、合并和拆分值"><a href="#9、合并和拆分值" class="headerlink" title="9、合并和拆分值"></a>9、合并和拆分值</h2><p>Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender.</p>
<p>尽管可以单独处理硬币，但为转账中的每一分钱都进行单独交易会很笨拙。 为了允许拆分和组合价值，交易包含多个输入和输出。 通常会有来自先前较大交易的单个输入或组合较小金额的多个输入，并且最多有两个输出：一个用于支付，另一个将找零（如果有）返回给发送者。</p>
<div>

<p><img src="/assets/images/bitcoin-6.png" loading="lazy"></p>
</div>

<p>It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction’s history.</p>
<p>应该注意的是，扇出（一个事务依赖于多个事务，而这些事务又依赖于更多事务）在这里不是问题。 永远不需要获取交易历史的完整独立副本。</p>
<h2 id="10、隐私"><a href="#10、隐私" class="headerlink" title="10、隐私"></a>10、隐私</h2><p>The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the “tape”, is made public, but without telling who the parties were.</p>
<p>传统的银行业务模型通过限制相关方和受信任的第三方对信息的访问来实现一定程度的隐私。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了，但是隐私依然可以得到保护：将公钥保持为匿名。公众可以看到有人正在向其他人汇款，但是很难将交易同特定的人联系在一起。这类似于证券交易所发布的信息级别，其中公开了个人交易的时间和大小，即 “录音带” ，但没有说明当事人是谁。</p>
<div>

<p><img src="/assets/images/bitcoin-7.png" loading="lazy"></p>
</div>



<p>As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.</p>
<p>作为额外的防火墙，每个交易都应该使用一个新的密钥对，以防止它们被链接到一个共同的所有者。 对于多输入交易，一定程度的追溯仍然是不可避免的，这必然表明它们的输入属于同一所有者。 风险在于，如果所有者的密钥被泄露，那么就可以追溯出此人的其它很多交易。</p>
<h2 id="11、计算"><a href="#11、计算" class="headerlink" title="11、计算"></a>11、计算</h2><p>We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.</p>
<p>我们考虑攻击者试图生成比诚实链更快的替代链的场景。 即使做到了这一点，这也不会使系统能够接受任意的更改，例如凭空创造价值或拿走不属于攻击者的钱。 这是因为节点不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。</p>
<p>The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker’s chain being extended by one block, reducing the gap by -1.</p>
<p>诚实链和攻击者链之间的竞争可以被描述为二叉树随机漫步（Binomial Random Walk）。 成功事件是诚实链被延长一个区块，领先优势增加一，失败事件是攻击者的链被延长一个区块，差距减少一。</p>
<p>The probability of an attacker catching up from a given deficit is analogous to a Gambler’s Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:</p>
<p>攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题（Gambler’s Ruin problem）。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数为无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填补上亏空的概率，也就是该攻击者赶上诚实链条， 如下所示 [8] ：</p>
<ul>
<li>p &#x3D; probability an honest node finds the next block</li>
<li>q &#x3D; probability the attacker finds the next block</li>
<li>qz &#x3D; probability the attacker will ever catch up from z blocks behind</li>
</ul>
<br />

<ul>
<li>p &#x3D; 诚实节点制造出下一个节点的概率</li>
<li>q &#x3D; 攻击者制造出下一个节点的概率</li>
<li>qz &#x3D; 攻击者最终消弭了z个区块的落后差距</li>
</ul>
<div>

<p><img src="/assets/images/bitcoin-8.png" loading="lazy"></p>
</div>



<p>Given our assumption that p &gt; q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn’t make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.</p>
<p>假定 p &gt; q，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝就变得愈发渺茫。</p>
<p>We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can’t change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.</p>
<p>那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了， 然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。</p>
<p>The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.</p>
<p>收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。</p>
<p>The recipient waits until the transaction has been added to a block and z blocks have been linked after it. He doesn’t know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker’s potential progress will be a Poisson distribution with expected value:</p>
<p>然后收款人将等待交易出现在首个区块中，然后在等到z个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将耗费平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为：</p>
<div>

<p><img src="/assets/images/bitcoin-9.png" loading="lazy"></p>
</div>

<p>To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:</p>
<p>当此情形，为了计算攻击者追赶上的概率，我们将攻击者取得进展区块数量的泊松分布的概率密度，乘以在该数量下攻击者依然能够追赶上的概率。</p>
<div>

<p><img src="/assets/images/bitcoin-10.png" loading="lazy"></p>
</div>

<p>Rearranging to avoid summing the infinite tail of the distribution…</p>
<p>化为如下形式，避免对无限数列求和：</p>
<div>

<p><img src="/assets/images/bitcoin-11.png" loading="lazy"></p>
</div>

<p>Converting to C code…</p>
<p>写为如下C语言代码：</p>
<div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">AttackerSuccessProbability</span><span class="params">(<span class="type">double</span> q, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span> - q;</span><br><span class="line">    <span class="type">double</span> lambda = z * (q / p);</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">int</span> i, k;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= z; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> poisson = <span class="built_in">exp</span>(-lambda);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            poisson *= lambda / i;</span><br><span class="line">        sum -= poisson * (<span class="number">1</span> - <span class="built_in">pow</span>(q / p, z - k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>


<p>Running some results, we can see the probability drop off exponentially with z.</p>
<p>对其进行运算，我们可以得到如下的概率结果，发现概率对 z 值呈指数下降。</p>
<div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">q=0.1</span><br><span class="line">z=0 P=1.0000000</span><br><span class="line">z=1 P=0.2045873</span><br><span class="line">z=2 P=0.0509779</span><br><span class="line">z=3 P=0.0131722</span><br><span class="line">z=4 P=0.0034552</span><br><span class="line">z=5 P=0.0009137</span><br><span class="line">z=6 P=0.0002428</span><br><span class="line">z=7 P=0.0000647</span><br><span class="line">z=8 P=0.0000173</span><br><span class="line">z=9 P=0.0000046</span><br><span class="line">z=10 P=0.0000012</span><br><span class="line">q=0.3</span><br><span class="line">z=0 P=1.0000000</span><br><span class="line">z=5 P=0.1773523</span><br><span class="line">z=10 P=0.0416605</span><br><span class="line">z=15 P=0.0101008</span><br><span class="line">z=20 P=0.0024804</span><br><span class="line">z=25 P=0.0006132</span><br><span class="line">z=30 P=0.0001522</span><br><span class="line">z=35 P=0.0000379</span><br><span class="line">z=40 P=0.0000095</span><br><span class="line">z=45 P=0.0000024</span><br><span class="line">z=50 P=0.0000006</span><br></pre></td></tr></table></figure>

</div>


<p>Solving for P less than 0.1%…</p>
<p>求解令 P 小于 0.1% 的 z 值：</p>
<div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">P &lt; 0.001</span><br><span class="line">q=0.10 z=5</span><br><span class="line">q=0.15 z=8</span><br><span class="line">q=0.20 z=11</span><br><span class="line">q=0.25 z=15</span><br><span class="line">q=0.30 z=24</span><br><span class="line">q=0.35 z=41</span><br><span class="line">q=0.40 z=89</span><br><span class="line">q=0.45 z=340</span><br></pre></td></tr></table></figure>

</div>

<h2 id="12、结论"><a href="#12、结论" class="headerlink" title="12、结论"></a>12、结论</h2><p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p>
<p>我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的 CPU 计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的 CPU 计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个 P2P 电子货币系统所需要的全部规则和激励措施。</p>
<h2 id="13、参考"><a href="#13、参考" class="headerlink" title="13、参考"></a>13、参考</h2><div>

<p>[1] W. Dai, “b-money,” <a target="_blank" rel="noopener" href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a>, 1998<br>[2] H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,” In 20th Symposium on Information Theory in the Benelux, May 1999.<br>[3] S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991.<br>[4] D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,” In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.<br>[5] S. Haber, W.S. Stornetta, “Secure names for bit-strings,” In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997.<br>[6] A. Back, “Hashcash - a denial of service counter-measure,” <a target="_blank" rel="noopener" href="http://www.hashcash.org/papers/hashcash.pdf">http://www.hashcash.org/papers/hashcash.pdf</a>, 2002.<br>[7] R.C. Merkle, “Protocols for public key cryptosystems,” In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.<br>[8] W. Feller, “An introduction to probability theory and its applications,” 1957.</p>
<div>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div>

<ul>
<li><a target="_blank" rel="noopener" href="https://nakamotoinstitute.org/static/docs/bitcoin-zh-cn.pdf">https://nakamotoinstitute.org/static/docs/bitcoin-zh-cn.pdf</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://bugwz.com/2022/11/16/bitcoin/">https://bugwz.com/2022/11/16/bitcoin/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/">比特币</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87/">论文</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/paper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/10/22/redislibrary-libmr/" title="Redis相关库学习 - LibMR"><img class="cover" src="/assets/images/bg/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Redis相关库学习 - LibMR</div></div><div class="info-2"><div class="info-item-1">LibMR 是一款适用于 Redis 集群的 Map Reduce （分发Redis命令并获取结果）的依赖库。它基于 libevent 的事件机制，通过使用多个线程池来分发异步任务，目前已经被 RedisTimeSeries 等模块使用。 一、简介 GitHub 地址：https://github.com/RedisGears/LibMR  二、架构设计2.1、相关命令由于该依赖库在编译时可以设置自定义的 modulename ，因此可以避免在不同模块中使用的冲突。  modulename.INNERCOMMUNICATION : 从其他分片中获取消息； modulename.HELLO : 获取当前实例的集群id，仅集群模式下才可以调用； modulename.REFRESHCLUSTER : 更新当前集群的拓扑信息 modulename.CLUSTERSET : 强制设置集群的拓扑信息，该信息只会更改该依赖库中记录的拓扑信息，并不会影响实际的 Redis 集群； modulename.CLUSTERSETFROMSHARD : 与 *.CLUSTERSET...</div></div></div></a><a class="pagination-related" href="/2022/12/04/redis-persistence/" title="Redis持久化演进史与奇思妙想"><img class="cover" src="/assets/images/bg/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Redis持久化演进史与奇思妙想</div></div><div class="info-2"><div class="info-item-1">目前 Redis 主要支持两种持久化的方式：RDB 和 AOF 。这两者在 Redis 的演进过程中也发生了很多有意思的变化。RDB 的数据格式也已经进行了十次版本迭代，AOF 从最初的 Rewrite 到 Redis 7.0.0 的 Multi-Part-AOF 也发生了很多的变化，这里将对每个版本进行详细的剖析，学习 Redis 的持久化演进历史。这篇文章主要借鉴于 Redis 持久化机制演进与百度智能云的实践 ，同时按照自己的理解绘制了一些示意图。 一、简介Redis 支持两种持久化的方式：RDB 和 AOF 。 二、Redis RDB 持久化演进史2.1、持久化的数据版本演进2.1.1、版本一 版本范围：2.0.0 ～ 2.2.15 （以下分析基于 2.2.15 版本）  RDB版本号：0001  版本特点：  首次支持对五种数据类型数据的持久化；   持久化数据内容：  标记头尾信息；  多 DB 信息（ REDIS_SELECTDB ）；  过期时间属性（单位秒， REDIS_EXPIRETIME...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/05/23/bloom-filter-summary-cache-paper/" title="译 - Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-23</div><div class="info-item-2">译 - Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol</div></div><div class="info-2"><div class="info-item-1">《Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol》翻译过来是 《摘要缓存：可扩展的广域 Web 缓存共享协议》，这篇文章中提出了布隆过滤器的设计背景以及实现原理，详细介绍了在误判率以及存储空间之间的权衡，之后很多系统中实现的布隆过滤器基本都是参考了这篇文论的实现。 摘要Web Proxy之间的共享缓存是减少Web流量并缓解网络瓶颈的一项重要技术。然而，由于现有协议的开销，它并未得到广泛部署。在本文中，我们演示了缓存共享的好处，衡量了现有协议的开销，并提出了一种称为”摘要缓存’’的新协议。在这个新协议中，每个Proxy都保留了一个包含所有Proxy的缓存摘要目录，并在任何查询之前都要检查在这些摘要之中是否存在潜在的匹配项。有两个因素利于我们协议的低开销：摘要的定期更新以及十分简朴的目录信息，每个条目只有8bits。通过使用跟踪驱动的仿真和原型实现，我们证明了与现有的协议（例如 Internet...</div></div></div></a><a class="pagination-related" href="/2019/10/14/dynamo/" title="转&#x2F;译-Dynamo:Amazon的高可用键值存储"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-14</div><div class="info-item-2">转&#x2F;译-Dynamo:Amazon的高可用键值存储</div></div><div class="info-2"><div class="info-item-1">本文翻译自 2007 年 Amazon 的分布式存储经典论文：《Dynamo: Amazon’s Highly Available Key-value Store》)，直译为 《Dynamo：Amazon 的高可用键值存储》，这里对排版做了一些调整，以更适合 web 阅读。 Dynamo 是 Amazon 的高可用分布式键值存储（key&#x2F;value storage）系统。这篇论文发表 的时候（2007）它还只是一个内部服务，现在（改名为 DynamoDB）已经发展成 AWS 最核心 的存储产品（服务）之一，与 S3 等并列。据了解，国内某一线大厂的公有云键值 存储服务，也是参考这篇文章设计和实现的。 现在提到键值存储，大家首先想到的可能是 Redis，那么 Dynamo 和 Redis 是不是竞品， 只是一个开源一个是商业的？不是的，二者针对的场景不同，这里非常粗地列举几方面：  使用场景：Dynamo 定位是永远可写（always writable）的持久文件系统，Redis 主要用作（易失）缓存或内存数据库 存储方式：Dynamo 是磁盘，Redis...</div></div></div></a><a class="pagination-related" href="/2022/09/24/gorilla-cn/" title="译 - Gorilla: A Fast, Scalable, In-Memory Time Series Database"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="info-item-2">译 - Gorilla: A Fast, Scalable, In-Memory Time Series Database</div></div><div class="info-2"><div class="info-item-1">  《Gorilla: A Fast, Scalable, In-Memory Time Series Database》 这篇论文讲述了 Facebook 在存储时序数据模型时的一些实践，重点讲述了他们内部的一款内存型的时序数据库 Gorilla。论文中通过使用 Delta-Of-Delta 和 XOR 方式分别对时序数据的时间戳以及浮点数据进行压缩编码，极大的节省了时序数据的存储开销，这也成为了业界时序数据库主流的数据编码压缩方式。这篇论文是时序数据库领域必读的一篇文章。        摘要Large-scale internet services aim to remain highly available and responsive in the presence of unexpected failures. Providing this service often requires monitoring and analyzing tens of millions of measurements per second across a large number...</div></div></div></a><a class="pagination-related" href="/2021/05/01/raft/" title="译 - In Search of an Understandable Consensus Algorithm (Extended Version)"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-01</div><div class="info-item-2">译 - In Search of an Understandable Consensus Algorithm (Extended Version)</div></div><div class="info-2"><div class="info-item-1">  《In Search of an Understandable Consensus Algorithm (Extended Version)》 直译过来就是 《寻找可理解的共识算法（扩展版）》，这篇文章中详细介绍了 Raft 算法的设计初衷以及其主要的设计实现，这是一篇学习共识算法的必读的一片论文。   摘要Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems. In order to enhance...</div></div></div></a><a class="pagination-related" href="/2022/03/01/scalable-bloom-filters/" title="译 - Scalable Bloom Filters"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="info-item-2">译 - Scalable Bloom Filters</div></div><div class="info-2"><div class="info-item-1">  《Scalable Bloom Filters》 这篇论文讲述了一种布隆过滤器的变体实现方式，通过将预设的误判率分配给多个子布隆过滤器来约束整体的一个误判率情况，并且可以通过新增子布隆过滤器来实现对存储元素数量的调节，以满足初始容量无法准确估计的情况，论文中详细介绍了在不同的误判率变化率以及布隆过滤器容量变化率的情况下，存储空间等的使用情况。目前了解到的，RedisBloom 和 TairBloom 都参考了这篇论文实现了各自的布隆过滤器。     摘要Bloom Filters provide space-efficient storage of sets at the cost of a probability of false positives on membership queries. The size of the filter must be defined a priori based on the number of elements to store and the desired false positive probability, being...</div></div></div></a><a class="pagination-related" href="/2019/10/20/the-rsync-algorithm/" title="译 - The rsync algorithm"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-20</div><div class="info-item-2">译 - The rsync algorithm</div></div><div class="info-2"><div class="info-item-1">  《The rsync algorithm》这篇发表于 1996 年的论文中介绍了一种名为 rsync 的增量同步算法，它能够快速地将两个文件夹中的内容同步。该算法利用了文件的局部性和差异性，通过计算文件的弱校验和和块校验和来确定文件的相似性，并进行增量同步。该算法具有高效性、可靠性和安全性等优点，在实际应用中被广泛使用。   0、摘要This report presents an algorithm for updating a file on one machine to be identical to a file on another machine. We assume that the two machines are connected by a low-bandwidth high-latency bi-directional communications link. The algorithm identifies parts of the source file which are identical to some part of the...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">131</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E3%80%81%E6%91%98%E8%A6%81"><span class="toc-text">0、摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BA%A4%E6%98%93"><span class="toc-text">2、交易</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">3、时间戳服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E"><span class="toc-text">4、工作证明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BD%91%E7%BB%9C"><span class="toc-text">5、网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%BF%80%E5%8A%B1"><span class="toc-text">6、激励</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%9B%9E%E6%94%B6%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4"><span class="toc-text">7、回收硬盘空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E7%AE%80%E5%8C%96%E4%BB%98%E6%AC%BE%E9%AA%8C%E8%AF%81"><span class="toc-text">8、简化付款验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%90%88%E5%B9%B6%E5%92%8C%E6%8B%86%E5%88%86%E5%80%BC"><span class="toc-text">9、合并和拆分值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%9A%90%E7%A7%81"><span class="toc-text">10、隐私</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%AE%A1%E7%AE%97"><span class="toc-text">11、计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-text">12、结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-text">13、参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img src="/assets/images/bg/linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群搭建指南"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南">Ceph Crimson 集群搭建指南</a><time datetime="2025-01-11T16:00:00.000Z" title="Created 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img src="/assets/images/bg/linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph QoS 机制深入分析"/></a><div class="content"><a class="title" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析">Ceph QoS 机制深入分析</a><time datetime="2024-10-24T16:00:00.000Z" title="Created 2024-10-25 00:00:00">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南"><img src="/assets/images/bg/linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ceph-ansible 集群部署运维指南"/></a><div class="content"><a class="title" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南">ceph-ansible 集群部署运维指南</a><time datetime="2023-04-11T16:00:00.000Z" title="Created 2023-04-12 00:00:00">2023-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/10/gfs/" title="译 - The Google File System"><img src="/assets/images/bg/paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="译 - The Google File System"/></a><div class="content"><a class="title" href="/2023/01/10/gfs/" title="译 - The Google File System">译 - The Google File System</a><time datetime="2023-01-09T16:00:00.000Z" title="Created 2023-01-10 00:00:00">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/redis-az-sync/" title="Redis异地多活方案杂谈"><img src="/assets/images/bg/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis异地多活方案杂谈"/></a><div class="content"><a class="title" href="/2022/12/31/redis-az-sync/" title="Redis异地多活方案杂谈">Redis异地多活方案杂谈</a><time datetime="2022-12-30T16:00:00.000Z" title="Created 2022-12-31 00:00:00">2022-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '28ba206f45f05276aef75a2ca860fa4b'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: 'Search for Posts',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>