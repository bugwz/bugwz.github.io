<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ceph CRUSH 设计实现剖析 | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: [译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data](https:&#x2F;&#x2F;bugwz.com&#x2F;2023&#x2F;06&#x2F;2">
<meta property="og:type" content="article">
<meta property="og:title" content="Ceph CRUSH 设计实现剖析">
<meta property="og:url" content="https://bugwz.com/2023/06/30/ceph-crush/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: [译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data](https:&#x2F;&#x2F;bugwz.com&#x2F;2023&#x2F;06&#x2F;2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/ceph.png">
<meta property="article:published_time" content="2023-06-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-19T15:39:50.861Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="Ceph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/ceph.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ceph CRUSH 设计实现剖析",
  "url": "https://bugwz.com/2023/06/30/ceph-crush/",
  "image": "https://bugwz.com/assets/images/bg/ceph.png",
  "datePublished": "2023-06-29T16:00:00.000Z",
  "dateModified": "2025-06-19T15:39:50.861Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2023/06/30/ceph-crush/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ceph CRUSH 设计实现剖析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/ceph.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">Ceph CRUSH 设计实现剖析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Ceph CRUSH 设计实现剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T16:00:00.000Z" title="发表于 2023-06-30 00:00:00">2023-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-19T15:39:50.861Z" title="更新于 2025-06-19 23:39:50">2025-06-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.1k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: <a href="https://bugwz.com/2023/06/20/crush">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</a> 。CRUSH map 是 Ceph 集群中一个关键的配置组件，它定义了数据如何在集群的物理硬件上分布。 CRUSH 算法使得 Ceph 能够在无需中心化或者分布式元数据管理器的情况下，高效、可靠地进行数据复制和恢复。</p>
<h1 id="一、CRUSH-map-解析"><a href="#一、CRUSH-map-解析" class="headerlink" title="一、CRUSH map 解析"></a>一、CRUSH map 解析</h1><p>CRUSH map 包含了集群的层次结构和各种规则，这些规则定义了数据应该如何在集群中分布。 CRUSH map 主要包含以下几个部分：</p>
<ul>
<li><code>Tunables</code> : 一组可用于调整 CRUSH 算法行为的参数。</li>
<li><code>Devices</code> : 定义集群中所有可用的存储设备的列表。</li>
<li><code>Types</code> : 定义存储层次结构中的不同层级类型。</li>
<li><code>Buckets</code> : 组织和管理存储设备（如 OSDs ）的逻辑容器。</li>
<li><code>Rules</code> : 定义了数据的复制方式。</li>
</ul>
<p><strong>新建 crush map 相关代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_map* <span class="title function_">crush_create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">crush_map</span>* <span class="title">m</span>;</span></span><br><span class="line">    m = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*m));</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化配置</span></span><br><span class="line">    set_optimal_crush_map(m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_optimal_crush_map</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_local_tries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_local_fallback_tries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_total_tries = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_descend_once = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_vary_r = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_stable = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;allowed_bucket_algs = ((<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_UNIFORM) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_LIST) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_STRAW) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_STRAW2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 crush map</span></span><br><span class="line"><span class="built_in">rm</span> -rf crushmap.file crushmap-human.file</span><br><span class="line">ceph osd getcrushmap -o crushmap.file</span><br><span class="line">crushtool -d crushmap.file -o crushmap-human.file</span><br><span class="line"><span class="built_in">cat</span> crushmap-human.file</span><br></pre></td></tr></table></figure>

<p><strong>CRUSH map 示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># begin crush map</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_fallback_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_total_tries</span> <span class="number">50</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_descend_once</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_vary_r</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_stable</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">straw_calc_version</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">allowed_bucket_algs</span> <span class="number">54</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># devices</span></span><br><span class="line"><span class="string">device</span> <span class="number">0</span> <span class="string">osd.0</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">1</span> <span class="string">osd.1</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">2</span> <span class="string">osd.2</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">3</span> <span class="string">osd.3</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">4</span> <span class="string">osd.4</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">5</span> <span class="string">osd.5</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># types</span></span><br><span class="line"><span class="string">type</span> <span class="number">0</span> <span class="string">osd</span></span><br><span class="line"><span class="string">type</span> <span class="number">1</span> <span class="string">host</span></span><br><span class="line"><span class="string">type</span> <span class="number">2</span> <span class="string">chassis</span></span><br><span class="line"><span class="string">type</span> <span class="number">3</span> <span class="string">rack</span></span><br><span class="line"><span class="string">type</span> <span class="number">4</span> <span class="string">row</span></span><br><span class="line"><span class="string">type</span> <span class="number">5</span> <span class="string">pdu</span></span><br><span class="line"><span class="string">type</span> <span class="number">6</span> <span class="string">pod</span></span><br><span class="line"><span class="string">type</span> <span class="number">7</span> <span class="string">room</span></span><br><span class="line"><span class="string">type</span> <span class="number">8</span> <span class="string">datacenter</span></span><br><span class="line"><span class="string">type</span> <span class="number">9</span> <span class="string">zone</span></span><br><span class="line"><span class="string">type</span> <span class="number">10</span> <span class="string">region</span></span><br><span class="line"><span class="string">type</span> <span class="number">11</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buckets</span></span><br><span class="line"><span class="string">host</span> <span class="string">node01</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-3</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-4</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.0</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.1</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">host</span> <span class="string">node02</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-5</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-6</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.2</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.3</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">host</span> <span class="string">node03</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-7</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-8</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.4</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.5</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">root</span> <span class="string">default</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-1</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-2</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.58612</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node01</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node02</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node03</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">firstn</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># end crush map</span></span><br></pre></td></tr></table></figure>



<p><img src="/assets/images/ceph-crush-topo.png" alt="Ceph CRUSH Topo" loading="lazy"></p>
<h2 id="1-1、Tunables"><a href="#1-1、Tunables" class="headerlink" title="1.1、Tunables"></a>1.1、Tunables</h2><p>一组可用于调整 CRUSH 算法行为的参数。通过调整这些参数，管理员可以优化数据的分布和复制策略，以适应特定的性能需求或硬件配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># begin crush map</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_fallback_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_total_tries</span> <span class="number">50</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_descend_once</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_vary_r</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_stable</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">straw_calc_version</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">allowed_bucket_algs</span> <span class="number">54</span></span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>choose_local_tries</code>: 控制 CRUSH 算法在尝试找到一个本地副本（即在同一物理位置，如同一机架或同一数据中心）时的尝试次数。如果设置为 0 ，表示 CRUSH 算法不会尝试在本地找到副本。增加这个值会使算法更倾向于在本地找到副本，可能提高访问速度但减少数据分散度。</li>
<li><code>choose_local_fallback_tries</code>: 定义了在 choose_local_tries 未能找到本地副本后， CRUSH 算法尝试找到非本地副本之前的额外本地尝试次数。如果设置为 0 ，表示没有额外的本地回退尝试。增加这个值可以增加在本地找到副本的机会，同样可能影响数据的分散度和容错性。</li>
<li><code>choose_total_tries</code>: 定义了 CRUSH 算法在放弃之前尝试选择不同项的总次数。较低的值可能导致数据分布不均，而较高的值增加了计算复杂性，但可以改善数据的均匀分布。</li>
<li><code>chooseleaf_descend_once</code>: 控制 CRUSH 算法在选择叶节点（通常是存储设备）时是否只遍历树结构一次。设置为 1 时，算法只遍历一次，减少了计算量并提高了效率，但可能影响在复杂拓扑中的数据分布精度。</li>
<li><code>chooseleaf_vary_r</code>: 控制每次选择叶节点时种子是否有所变化，以增加随机性。设置为 1 时，每次选择过程的随机性增加，有助于数据的均匀分布。</li>
<li><code>chooseleaf_stable</code>: 确保相同的输入在 CRUSH 算法的不同版本中给出相同的输出。设置为 1 时，可以保持数据分布的一致性，特别是在升级或修改集群配置时。</li>
<li><code>straw_calc_version</code>: 指定使用 Straw 算法的版本， Straw 算法用于决定数据在不同存储桶之间的分配。版本 1 是较旧的版本，可能不如版本 2 在数据分布上有效和均匀。</li>
<li><code>allowed_bucket_algs</code>: 指定允许使用的 bucket 算法的位掩码。通过限制或启用特定的 bucket 算法，管理员可以根据具体的数据分布需求调整算法的使用，影响数据的分布和性能。</li>
</ul>
<h2 id="1-2、Devices"><a href="#1-2、Devices" class="headerlink" title="1.2、Devices"></a>1.2、Devices</h2><p>定义集群中所有可用的存储设备的列表。每个设备通常对应一个 OSD（Object Storage Daemon）。每个条目通常包含: 设备ID，OSD编号，类别。<strong>device 的 id 都是大于等于零的非负数。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devices</span></span><br><span class="line"><span class="string">device</span> <span class="number">0</span> <span class="string">osd.0</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">1</span> <span class="string">osd.1</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">2</span> <span class="string">osd.2</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">3</span> <span class="string">osd.3</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">4</span> <span class="string">osd.4</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">5</span> <span class="string">osd.5</span> <span class="string">class</span> <span class="string">hdd</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3、Types"><a href="#1-3、Types" class="headerlink" title="1.3、Types"></a>1.3、Types</h2><p>定义存储层次结构中的不同层级类型。</p>
<p><strong>字段解析:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># types</span></span><br><span class="line"><span class="string">type</span> <span class="number">0</span> <span class="string">osd</span>         <span class="comment"># 基本存储单元，通常对应一个物理存储设备</span></span><br><span class="line"><span class="string">type</span> <span class="number">1</span> <span class="string">host</span>        <span class="comment"># 一台物理服务器或虚拟机，它可以包含一个或多个 osd</span></span><br><span class="line"><span class="string">type</span> <span class="number">2</span> <span class="string">chassis</span>     <span class="comment"># 机箱或机柜，可以包含一组服务器或多个设备</span></span><br><span class="line"><span class="string">type</span> <span class="number">3</span> <span class="string">rack</span>        <span class="comment"># 数据中心中的一个机架，通常包含多个服务器或机柜</span></span><br><span class="line"><span class="string">type</span> <span class="number">4</span> <span class="string">row</span>         <span class="comment"># 数据中心中的一行机架</span></span><br><span class="line"><span class="string">type</span> <span class="number">5</span> <span class="string">pdu</span>         <span class="comment"># 电源分配单元。不常见，可以用来表示依赖于同一电源单元的设备组</span></span><br><span class="line"><span class="string">type</span> <span class="number">6</span> <span class="string">pod</span>         <span class="comment"># 表示包含多个机架或行的更大物理单元</span></span><br><span class="line"><span class="string">type</span> <span class="number">7</span> <span class="string">room</span>        <span class="comment"># 数据中心中的一个房间，可能包含多个 pod 或行</span></span><br><span class="line"><span class="string">type</span> <span class="number">8</span> <span class="string">datacenter</span>  <span class="comment"># 整个数据中心，是物理存储资源的大集合</span></span><br><span class="line"><span class="string">type</span> <span class="number">9</span> <span class="string">zone</span>        <span class="comment"># 一个区域或集群的一部分</span></span><br><span class="line"><span class="string">type</span> <span class="number">10</span> <span class="string">region</span>     <span class="comment"># 一个更大的地理区域，可能包含多个数据中心或区域</span></span><br><span class="line"><span class="string">type</span> <span class="number">11</span> <span class="string">root</span>       <span class="comment"># CRUSH 层次结构中的最顶层，代表整个存储集群</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4、Buckets"><a href="#1-4、Buckets" class="headerlink" title="1.4、Buckets"></a>1.4、Buckets</h2><p>用来组织和管理存储设备（如 OSDs ）的逻辑容器。每个 bucket 可以包含 OSDs 或其他 buckets ，形成一个层次化的结构，这有助于定义数据在集群中的分布方式。 bucket 的设计允许 CRUSH 算法模拟物理存储的层次结构，如机架、行、数据中心等，以及在这些层次上实施数据复制和负载均衡策略。<strong>bucket 的 id 都是小于零的负数。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># buckets</span></span><br><span class="line"><span class="string">host</span> <span class="string">node01</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-3</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-4</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.0</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.1</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">default</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-1</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-2</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.58612</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node01</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node02</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node03</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>host/root</code>: bucket 类型。对应于 CRUSH 层次结构中的一个层级，如 host、rack、datacenter 等。</li>
<li><code>node01/default</code>: bucket 名称。通常反映其在物理或逻辑结构中的角色，如 node01、default 等。</li>
<li><code>id</code>: bucket id。这个 id 在 CRUSH map 中是唯一的，用于区分不同的 buckets。</li>
<li><code>alg</code>: bucket 算法。bucket 使用特定的算法来决定如何在其包含的项（ OSDs 或其他 buckets ）之间分配数据。常见的算法包括 uniform&#x2F;list&#x2F;tree&#x2F;straw&#x2F;straw2 。<ul>
<li><code>uniform</code>: 对应 CRUSH_BUCKET_UNIFORM 。一种简单的分配策略，其中所有子项都具有相同的权重，适用于所有子项具有均等的存储容量和性能的情况。</li>
<li><code>list</code>: 对应 CRUSH_BUCKET_LIST 。按照列表中的顺序和指定的权重来分配数据，允许管理员精确控制数据分配的顺序，适用于需要按特定顺序优先分配数据的场景。</li>
<li><code>tree</code>: 对应 CRUSH_BUCKET_TREE 。基于树形结构的数据分配方法，其中数据是按层次结构递归分配的。适用于复杂的层次结构，如多层数据中心的环境，它可以有效地在多个层级上平衡数据分布。</li>
<li><code>straw</code>: 对应 CRUSH_BUCKET_STRAW 。使用一种称为 straw 算法的方法来分配数据。每个子项被赋予一个 straw ，其长度与子项的权重成比例。选择子项的概率与其 straw 的长度成正比。适用于子项之间权重差异较大的情况。</li>
<li><code>straw2</code>: 对应 CRUSH_BUCKET_STRAW2 。straw 算法的改进版本，它修正了原始 straw 算法中的一些不平衡问题，提供了更加均匀和公平的数据分配。在各种场景下都能提供更好的负载均衡和数据分散性。</li>
</ul>
</li>
<li><code>hash</code>: hash 函数。用于决定如何在 bucket 的子项之间选择。常见的哈希函数包括 rjenkins1（对应配置参数为 0 ） 。</li>
<li><code>item</code>: bucket 子项。这些子项可以是 OSDs（Object Storage Daemons）或者是其他的 buckets 。每个条目定义了子项的 ID 、权重以及其他可能的属性。</li>
</ul>
<p><strong>部分桶算法的比较:</strong></p>
<table>
<thead>
<tr>
<th align="center">桶算法</th>
<th align="center">时间复杂度</th>
<th align="center">添加</th>
<th align="center">移除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uniform</td>
<td align="center">O(1)</td>
<td align="center">差</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">O(n)</td>
<td align="center">优</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">straw2</td>
<td align="center">O(n)</td>
<td align="center">优</td>
<td align="center">优</td>
</tr>
</tbody></table>
<h2 id="1-5、Rules"><a href="#1-5、Rules" class="headerlink" title="1.5、Rules"></a>1.5、Rules</h2><p>定义了数据的复制方式。例如，一个规则可能指定一个数据块应该被复制三次，并存储在不同的机架上以确保容错。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">firstn</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># end crush map</span></span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>rule</code>: rule 标记。</li>
<li><code>replicated_rule</code>: rule name。自定义的 rule 。</li>
<li><code>id</code>: rule id。规则的唯一标识符。</li>
<li><code>type</code>: rule type。可选值为 replicated&#x2F;erasure&#x2F;msr_firstn&#x2F;msr_indep 。<ul>
<li><code>replicated</code>: 最常用的规则类型，用于创建数据的多个副本。每个数据对象会在多个物理位置存储相同的副本，以提高数据的可用性和耐久性。适用于需要高数据可靠性和快速恢复能力的场景。如果一个存储节点失败，其他节点上的副本可以立即提供数据，无需复杂的恢复过程。</li>
<li><code>erasure</code>: 使用纠删码技术，将数据分割成多个数据块和校验块。这种方法可以在保持相似的容错能力的同时，比简单复制更有效地使用存储空间。适用于大规模数据存储，特别是当存储成本是一个重要考虑因素时。虽然纠删码提供了高存储效率，但其恢复过程可能比复制更复杂，对性能的影响也较大。</li>
<li><code>msr_firstn</code>: MSR (Multi-Site Replication) 是一种多站点复制策略，其中 FirstN 指的是在多个站点中选择前 N 个站点进行数据复制。适用于需要跨地理位置进行数据复制的场景，以实现灾难恢复和数据本地化。FirstN策略确保数据被复制到指定数量的最优站点，通常基于位置或其他标准选择。</li>
<li><code>msr_indep</code>: MSR (Multi-Site Replication) 是一种多站点复制策略，其中 IndeP 指数据在每个站点独立地被复制和管理，而不是选择固定数量的站点。这种模式适用于那些需要在每个站点独立管理数据的场景，允许每个站点根据本地需求和策略来优化数据存储和访问。这种类型的复制可以提高灵活性和数据自治。</li>
</ul>
</li>
<li><code>step</code>: <ul>
<li><code>take</code>: 指定了 CRUSH 算法开始选择的起点。通常，这个起点是一个 bucket ，例如一个数据中心、机架或服务器组。</li>
<li><code>chooseleaf</code>: 选择方式。选择存储数据的叶子节点。叶子节点通常是指实际存储数据的设备，如硬盘或SSD。</li>
<li><code>choose</code>: 选择方式。类似于 chooseleaf ，但不限于选择叶子节点。 choose 可以用于在任何级别的 bucket 中进行选择。该操作允许在非叶子级别进行更复杂的数据分布决策，例如在不同的数据中心或机架之间进行选择。</li>
<li><code>firstn</code>: 选择模式。指定选择的叶子节点的数量。这个数字可以是具体的数量，也可以是 0 （表示根据复制因子自动确定数量）。常用于需要固定数量副本的场景，如在多个数据中心或机架中复制数据，确保数据的高可用性和冗余。</li>
<li><code>indep</code>: 选择模式。表示每次选择都是独立的，不受之前选择的影响。这意味着即使多次执行相同的选择操作，也可能得到不同的结果。适用于需要增强随机性和分布均匀性的场景。它有助于避免因选择过程中的依赖关系而导致的数据局部化和热点问题。</li>
<li><code>type</code>: 指定叶子节点的类型，如 host、rack 等，这决定了数据复制的物理分隔程度。</li>
<li><code>emit</code>: 标志着选择过程的结束，输出最终确定的存储目标。</li>
</ul>
</li>
</ul>
<h1 id="二、对象映射规则"><a href="#二、对象映射规则" class="headerlink" title="二、对象映射规则"></a>二、对象映射规则</h1><p><strong>数据对象到 OSD 的映射主要包含两个阶段:</strong></p>
<ul>
<li>对象映射到 PG：简单的哈希。</li>
<li>PG 映射到 OSD 列表：CRUSH 伪随机算法。</li>
</ul>
<h2 id="2-1、对象映射到-PG"><a href="#2-1、对象映射到-PG" class="headerlink" title="2.1、对象映射到 PG"></a>2.1、对象映射到 PG</h2><p><strong>概要代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象的定位信息</span></span><br><span class="line"><span class="type">object_locator_t</span> <span class="title function_">oloc</span><span class="params">(pool, namespacestr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象信息</span></span><br><span class="line"><span class="type">object_t</span> <span class="title function_">oid</span><span class="params">(objstr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算对象的原始 pg id 信息</span></span><br><span class="line"><span class="type">pg_t</span> pgid = osdmap.object_locator_to_pg(oid, oloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象的原始 pg id 信息转换为实际可存储的 pg 信息</span></span><br><span class="line"><span class="comment">// 其实是将原始 pg id 映射到 pg_num 的有效范围内</span></span><br><span class="line"><span class="type">pg_t</span> mpgid = osdmap.raw_pg_to_pg(pgid);</span><br></pre></td></tr></table></figure>

<p><strong>计算 pgid 的规则如下:</strong> （注意这里的 hashfunc 为特定 pool 的 hash 类型，目前支持 <code>linux</code> 和 <code>rjenkins</code> 这两种类型，默认为 <code>rjenkins</code>）</p>
<ul>
<li>如果 <code>oloc.hash &gt;= 0</code> : 则 <code>pgid = pg_t(oloc.hash, oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 非空 &amp;&amp; oloc.nspace 非空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.nspace + &#39;\037&#39; + oloc.key), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 非空 &amp;&amp; oloc.nspace 为空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.key), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 为空 &amp;&amp; oloc.nspace 非空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.nspace + &#39;\037&#39; + oid.name), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 为空 &amp;&amp; oloc.nspace 为空</code> : 则 <code>pgid = pg_t(hashfunc(oid.name), oloc.pool)</code></li>
</ul>
<p><img src="/assets/images/ceph-crush-pgid.png" alt="PGID" loading="lazy"></p>
<p><strong>计算 mpgid 的规则如下:</strong></p>
<ul>
<li>规则前提: pg_num_mask 是将 pg_num 向上取到最近的二次幂数值，然后减一得到的（pgp_num 和 pgp_num_mask 关系亦如此）。比如 pg_num&#x3D;16，则 pg_num_mask&#x3D;15； pg_num&#x3D;10，则 pg_num_mask&#x3D;15； </li>
<li>计算规则:<ul>
<li>如果 <code>(pgid.m_seed &amp; pg_num_mask) &lt; pg_num</code> ， 则 <code>mpgid.m_seed = pgid.m_seed &amp; pg_num_mask</code></li>
<li>如果 <code>(pgid.m_seed &amp; pg_num_mask) &gt;= pg_num</code> ， 则 <code>mpgid.m_seed = pgid.m_seed &amp; (pg_num_mask &gt;&gt; 1)</code></li>
</ul>
</li>
<li>参考数值计算示例:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">pgid.m_seed</th>
<th align="center">pg_num</th>
<th align="center">pg_num_mask</th>
<th align="center">(pgid.m_seed &amp; pg_num_mask) &lt; pg_num</th>
<th align="center">mpgid.m_seed</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">10</td>
<td align="center">15</td>
<td align="center">Yes</td>
<td align="center">7 &amp; 15 &#x3D; 7</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">10</td>
<td align="center">15</td>
<td align="center">No</td>
<td align="center">12 &amp; (15 &gt;&gt; 1) &#x3D; 4</td>
</tr>
<tr>
<td align="center">133</td>
<td align="center">16</td>
<td align="center">15</td>
<td align="center">Yes</td>
<td align="center">133 &amp; 15 &#x3D; 5</td>
</tr>
</tbody></table>
<p><strong>对象映射到 PG 的相关代码实现:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_locator_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// You specify either the hash or the key -- not both</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">int64_t</span> pool;    <span class="comment">// pool id</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key;      <span class="comment">// key string (if non-empty)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> nspace;   <span class="comment">// namespace</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">int64_t</span> hash;    <span class="comment">// hash position (if &gt;= 0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pg_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> m_pool;</span><br><span class="line">    <span class="type">uint32_t</span> m_seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pg_t</span> <span class="title function_">OSDMap::object_locator_to_pg</span><span class="params">(<span class="type">const</span> <span class="type">object_t</span>&amp; oid, <span class="type">const</span> <span class="type">object_locator_t</span>&amp; loc)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pg_t</span> pg;</span><br><span class="line">    <span class="type">int</span> ret = object_locator_to_pg(oid, loc, pg);</span><br><span class="line">    ceph_assert(ret == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> pg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">OSDMap::object_locator_to_pg</span><span class="params">(<span class="type">const</span> <span class="type">object_t</span>&amp; oid, <span class="type">const</span> <span class="type">object_locator_t</span>&amp; loc, <span class="type">pg_t</span>&amp; pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (loc.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!get_pg_pool(loc.get_pool())) &#123;</span><br><span class="line">            <span class="keyword">return</span> -ENOENT;</span><br><span class="line">        &#125;</span><br><span class="line">        pg = <span class="type">pg_t</span>(loc.hash, loc.get_pool());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map_to_pg(loc.get_pool(), oid.name, loc.key, loc.nspace, &amp;pg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapping</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">OSDMap::map_to_pg</span><span class="params">(<span class="type">int64_t</span> poolid, <span class="type">const</span> <span class="built_in">string</span>&amp; name, <span class="type">const</span> <span class="built_in">string</span>&amp; key, <span class="type">const</span> <span class="built_in">string</span>&amp; nspace, <span class="type">pg_t</span>* pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// calculate ps (placement seed)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">pg_pool_t</span>* pool = get_pg_pool(poolid);</span><br><span class="line">    <span class="keyword">if</span> (!pool) <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="type">ps_t</span> ps;</span><br><span class="line">    <span class="keyword">if</span> (!key.empty())</span><br><span class="line">        ps = pool-&gt;hash_key(key, nspace);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ps = pool-&gt;hash_key(name, nspace);</span><br><span class="line">    *pg = <span class="type">pg_t</span>(ps, poolid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pg_t</span> <span class="title function_">pg_pool_t::raw_pg_to_pg</span><span class="params">(<span class="type">pg_t</span> pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    pg.set_ps(ceph_stable_mod(pg.ps(), pg_num, pg_num_mask));</span><br><span class="line">    <span class="keyword">return</span> pg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ceph_stable_mod</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> b, <span class="type">int</span> bmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &amp; bmask) &lt; b)</span><br><span class="line">        <span class="keyword">return</span> x &amp; bmask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (bmask &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pg_pool_t::calc_pg_masks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pg_num_mask = (<span class="number">1</span> &lt;&lt; cbits(pg_num - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    pgp_num_mask = (<span class="number">1</span> &lt;&lt; cbits(pgp_num - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、PG-映射到-OSD-列表"><a href="#2-2、PG-映射到-OSD-列表" class="headerlink" title="2.2、PG 映射到 OSD 列表"></a>2.2、PG 映射到 OSD 列表</h2><p>根据上一步生成的 pgid 信息，之后利用 CRUSH 伪随机算法，便可以计算出最终映射的 osd 列表。 注意：虽然 rule 存在 replicated 和 erasure 等不同的类型，但是关键的计算 osd 列表的逻辑都是相同的，只是在处理可用 osd 列表的顺序时，逻辑有些不同，具体实现可以参考 <code>OSDMap::_raw_to_up_osds</code> 函数。</p>
<p><strong>部分关键函数:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">crush_finalize</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>)</span></span><br><span class="line"><span class="type">void</span> OSDMap::_<span class="title function_">pg_to_up_acting_osds</span><span class="params">(...)</span></span><br><span class="line"><span class="type">void</span> OSDMap::_<span class="title function_">pg_to_raw_osds</span><span class="params">(...)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CrushWrapper::do_rule</span><span class="params">(...)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_do_rule</span><span class="params">(...)</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">crush_work_size</span><span class="params">(...)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crush_init_workspace</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_msr_do_rule</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_do_rule_no_retry</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_choose_firstn</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">crush_choose_indep</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_bucket_choose</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_uniform_choose</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_list_choose</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_tree_choose</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_straw_choose</span><span class="params">(...)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_straw2_choose</span><span class="params">(...)</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-1、数组空间初始化"><a href="#2-2-1、数组空间初始化" class="headerlink" title="2.2.1、数组空间初始化"></a>2.2.1、数组空间初始化</h3><p>当通过 CRUSH 计算出最终的 osd 列表前，我们需要现在准备存储 osd 的空间，该空间对应的是一个 char 数组，对应代码为 <code>char work[crush_work_size(crush, maxout)]</code> 。在计算 osd 列表的时候会传入两个数组变量，一个是 out ，另一个是 out2 ，其中 out 用于存储非叶子节点的 item ，out2 用于存储叶子节点的 item 。</p>
<p><strong>相关函数如下:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当所有的 bucket 被添加到 crush map 之后，会调用该函数设置 map-&gt;working_size 的大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crush_finalize</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">crush_work_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> result_max)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组中 crush_work_bucket 结构体成员变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crush_init_workspace</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* m, <span class="type">void</span>* v)</span></span><br></pre></td></tr></table></figure>

<p><strong>假设 crush map 的构成信息图如上最开始所示，则其对应的 work 数组空间如下所示:</strong></p>
<p><img src="/assets/images/ceph-crush-work-format.png" alt="Ceph CRUSH Work Array" loading="lazy"></p>
<h3 id="2-2-2、获取OSD主流程"><a href="#2-2-2、获取OSD主流程" class="headerlink" title="2.2.2、获取OSD主流程"></a>2.2.2、获取OSD主流程</h3><p><strong>关键函数如下:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> OSDMap::_pg_to_raw_osds(<span class="type">const</span> <span class="type">pg_pool_t</span>&amp; pool, <span class="type">pg_t</span> pg, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;* osds, <span class="type">ps_t</span>* ppps) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// placement ps</span></span><br><span class="line">    <span class="type">ps_t</span> pps = pool.raw_pg_to_pps(pg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: pool 副本数量</span></span><br><span class="line">    <span class="type">unsigned</span> size = pool.get_size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应 crush role id</span></span><br><span class="line">    <span class="type">int</span> ruleno = pool.get_crush_rule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pps 是后面使用的 x 参数</span></span><br><span class="line">    <span class="keyword">if</span> (ruleno &gt;= <span class="number">0</span>) crush-&gt;do_rule(ruleno, pps, *osds, size, osd_weight, pg.pool());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除不存在的 OSDs</span></span><br><span class="line">    _remove_nonexistent_osds(pool, *osds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppps) *ppps = pps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxout 对应 pool 设置的副本数量</span></span><br><span class="line">template&lt;typename WeightVector&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_rule</span><span class="params">(<span class="type">int</span> rule, <span class="type">int</span> x, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; out, <span class="type">int</span> maxout, <span class="type">const</span> WeightVector&amp; weight, <span class="type">uint64_t</span> choose_args_index)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rawout[maxout];</span><br><span class="line">    <span class="type">char</span> work[crush_work_size(crush, maxout)];</span><br><span class="line">    crush_init_workspace(crush, work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arg_map 用于 straw2 算法</span></span><br><span class="line">    crush_choose_arg_map arg_map = choose_args_get_with_fallback(choose_args_index);</span><br><span class="line">    <span class="type">int</span> numrep = crush_do_rule(crush, rule, x, rawout, maxout, <span class="built_in">std</span>::data(weight), <span class="built_in">std</span>::size(weight), work, arg_map.args);</span><br><span class="line">    <span class="keyword">if</span> (numrep &lt; <span class="number">0</span>) numrep = <span class="number">0</span>;</span><br><span class="line">    out.resize(numrep);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numrep; i++) out[i] = rawout[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_do_rule</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> ruleno, <span class="type">int</span> x, <span class="type">int</span>* result, <span class="type">int</span> result_max, <span class="type">const</span> __u32* weight,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> weight_max, <span class="type">void</span>* cwin, <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* choose_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">crush_rule</span>* <span class="title">rule</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((__u32)ruleno &gt;= <span class="built_in">map</span>-&gt;max_rules) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot; bad ruleno %d\n&quot;</span>, ruleno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rule = <span class="built_in">map</span>-&gt;rules[ruleno];</span><br><span class="line">    <span class="keyword">if</span> (rule_type_is_msr(rule-&gt;type)) &#123;</span><br><span class="line">        <span class="comment">// 处理 CRUSH_RULE_TYPE_MSR_FIRSTN 和 CRUSH_RULE_TYPE_MSR_INDEP 类型的 rule</span></span><br><span class="line">        <span class="keyword">return</span> crush_msr_do_rule(<span class="built_in">map</span>, ruleno, x, result, result_max, weight, weight_max, cwin, choose_args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 CRUSH_RULE_TYPE_REPLICATED 和 CRUSH_RULE_TYPE_ERASURE 类型的 rule</span></span><br><span class="line">        <span class="keyword">return</span> crush_do_rule_no_retry(<span class="built_in">map</span>, ruleno, x, result, result_max, weight, weight_max, cwin, choose_args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>crush_do_rule_no_retry 函数内部会针对不同的 step 执行不同的操作，详细如下:</strong></p>
<ul>
<li><code>CRUSH_RULE_SET_CHOOSE_TRIES</code>: 对应操作为 <code>step set_choose_tries</code> ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_TRIES</code>: 对应操作为 <code>step set_choose_local_tries</code> ， 会覆盖 chooseleaf_descend_once 参数， 相关的参数还有 choose_total_tries ；</li>
<li><code>CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES</code>: 对应操作为 <code>step set_choose_local_tries</code> ，对应配置为 choose_local_tries ；</li>
<li><code>CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES</code>: 对应操作为 <code>step set_choose_local_fallback_tries</code> ，对应配置为 choose_local_fallback_tries ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_VARY_R</code>: 对应操作为 <code>step set_chooseleaf_vary_r</code>，对应配置为 chooseleaf_vary_r ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_STABLE</code>: 对应操作为 <code>step set_chooseleaf_stable</code>， 对应配置为 chooseleaf_stable ；</li>
<li><code>CRUSH_RULE_TAKE</code>: 对应操作为 <code>step take</code> ；</li>
<li><code>CRUSH_RULE_CHOOSELEAF_FIRSTN</code>: 对应操作为 <code>step chooseleaf firstn</code> ；</li>
<li><code>CRUSH_RULE_CHOOSE_FIRSTN</code>: 对应操作为 <code>step choose firstn</code> ；</li>
<li><code>CRUSH_RULE_CHOOSELEAF_INDEP</code>: 对应操作为 <code>step chooseleaf indep</code> ；</li>
<li><code>CRUSH_RULE_CHOOSE_INDEP</code>: 对应操作为 <code>step choose indep</code> ；</li>
<li><code>CRUSH_RULE_EMIT</code>: 对应操作为 <code>step emit</code> ；</li>
</ul>
<h3 id="2-2-3、Choose-Firstn-逻辑"><a href="#2-2-3、Choose-Firstn-逻辑" class="headerlink" title="2.2.3、Choose Firstn 逻辑"></a>2.2.3、Choose Firstn 逻辑</h3><p>当 step 操作方式为 <code>chooseleaf firstn</code> 或者 <code>choose firstn</code> 时，会执行到 <code>crush_choose_firstn</code> 函数的处理逻辑中，这种方式意味着会选择前 N 个符合条件的元素。</p>
<p><strong>示例 rule:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">firstn</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择 item 的伪代码总结:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>选择 item 的详细代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * crush_choose_firstn - 选择给定类型的 numrep 个不同项目</span></span><br><span class="line"><span class="comment"> * @map: 对应 crush map</span></span><br><span class="line"><span class="comment"> * @work:</span></span><br><span class="line"><span class="comment"> * @bucket: item 所归属的 bucket</span></span><br><span class="line"><span class="comment"> * @weight:</span></span><br><span class="line"><span class="comment"> * @weight_max:</span></span><br><span class="line"><span class="comment"> * @x: 输入哈希值，对应为 pgp seed</span></span><br><span class="line"><span class="comment"> * @numrep: crush rule 中单个 step 定义的要选择的 item 数量</span></span><br><span class="line"><span class="comment"> * @type: crush rule 中单个 step 定义的要选择的 item 类型</span></span><br><span class="line"><span class="comment"> * @out: 选中的 item 的数组</span></span><br><span class="line"><span class="comment"> * @outpos: 选中的 item 要存储在 out 数组中的索引</span></span><br><span class="line"><span class="comment"> * @out_size: 待选择的 item 的数量，计算规则为 pool 的副本数量减去已选择的 item 的数量</span></span><br><span class="line"><span class="comment"> * @tries: 默认为 choose_total_tries + 1 ， 默认为 51</span></span><br><span class="line"><span class="comment"> * @recurse_tries: 递归 chooseleaf 尝试的次数</span></span><br><span class="line"><span class="comment"> * @local_retries: 对应 choose_local_tries 配置，默认为 50</span></span><br><span class="line"><span class="comment"> * @local_fallback_retries: 对应 choose_local_fallback_tries 配置，默认为 0</span></span><br><span class="line"><span class="comment"> * @recurse_to_leaf: 是否递归到叶子节点</span></span><br><span class="line"><span class="comment"> * @vary_r: 对应 chooseleaf_vary_r 配置，默认为 1</span></span><br><span class="line"><span class="comment"> * @stable: 对应 chooseleaf_stable 配置，默认为 1</span></span><br><span class="line"><span class="comment"> * @out2: 第二个输出向量用于叶 item （如果 @recurse_to_leaf）</span></span><br><span class="line"><span class="comment"> * @parent_r: 从父级传递的 r 值</span></span><br><span class="line"><span class="comment"> * @choose_args:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_choose_firstn</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_work* work, <span class="type">const</span> <span class="keyword">struct</span> crush_bucket* bucket,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> __u32* weight, <span class="type">int</span> weight_max, <span class="type">int</span> x, <span class="type">int</span> numrep, <span class="type">int</span> type, <span class="type">int</span>* out, <span class="type">int</span> outpos,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> out_size, <span class="type">unsigned</span> <span class="type">int</span> tries, <span class="type">unsigned</span> <span class="type">int</span> recurse_tries, <span class="type">unsigned</span> <span class="type">int</span> local_retries,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> local_fallback_retries, <span class="type">int</span> recurse_to_leaf, <span class="type">unsigned</span> <span class="type">int</span> vary_r,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> stable, <span class="type">int</span>* out2, <span class="type">int</span> parent_r, <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* choose_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// rep 代表 replication ，对应副本 id</span></span><br><span class="line">    <span class="type">int</span> rep;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ftotal, flocal;</span><br><span class="line">    <span class="type">int</span> retry_descent, retry_bucket, skip_rep;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">crush_bucket</span>* <span class="title">in</span> =</span> bucket;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> item = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> itemtype;</span><br><span class="line">    <span class="type">int</span> collide, reject;</span><br><span class="line">    <span class="type">int</span> count = out_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历选择 item</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// stable 默认为 1 , 因此 rep 范围为 [0, numrep) , 含义为逐步获取 numrep 个副本 item</span></span><br><span class="line">    <span class="comment">// count 为待选择的 item 数量，范围为 pool 的副本数量减去已选择的 item 的数量</span></span><br><span class="line">    <span class="keyword">for</span> (rep = stable ? <span class="number">0</span> : outpos; rep &lt; numrep &amp;&amp; count &gt; <span class="number">0</span>; rep++) &#123;</span><br><span class="line">        <span class="comment">// 总失败次数</span></span><br><span class="line">        ftotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否跳过当前副本</span></span><br><span class="line">        skip_rep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// retry_descent 是一个标志变量，用于控制是否需要重新尝试选择过程，但这次是在更深层次的桶结构中。</span></span><br><span class="line">            <span class="comment">// &quot;descent&quot; 在这里指的是在 CRUSH 桶的层次结构中向下进行，即从当前桶向下到其子桶中进行选择。</span></span><br><span class="line">            retry_descent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录当前 bucket</span></span><br><span class="line">            in = bucket;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置当前 bucket 中的失败次数</span></span><br><span class="line">            flocal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 是否发生了碰撞，即选择了重复的 item</span></span><br><span class="line">                collide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是否在当前 bucket 中重试</span></span><br><span class="line">                retry_bucket = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// rep 是当前的副本编号，表示正在尝试选择第几个副本。在 CRUSH</span></span><br><span class="line">                <span class="comment">// 算法中，每个数据副本都应该尽可能分布在不同的设备上，以提高数据的耐用性和可用性。 parent_r</span></span><br><span class="line">                <span class="comment">// 是从父调用（如果有的话）传递下来的一个值，它可能代表了上一层级选择过程中的某些状态或者迭代次数。</span></span><br><span class="line">                <span class="comment">// 这个值的传递有助于保持选择的连贯性和上下文相关性，特别是在递归调用中。</span></span><br><span class="line">                <span class="comment">// 第一次调用 crush_choose_firstn 的时候，传入的 parent_r 为 0</span></span><br><span class="line">                r = rep + parent_r;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ftotal</span></span><br><span class="line">                <span class="comment">// 是到目前为止总的失败次数，即在当前选择过程中已经尝试并失败的次数。这包括因为冲突、类型不匹配或其他原因导致的选择失败。</span></span><br><span class="line">                <span class="comment">// 通过将 ftotal 加到 r 上，CRUSH</span></span><br><span class="line">                <span class="comment">// 算法在每次失败后修改选择的种子，这有助于在下一次尝试中改变选择的结果，从而尝试避免之前导致失败的情况。</span></span><br><span class="line">                <span class="comment">// 这是一种常见的技术，用于在保持随机性的同时解决潜在的重复冲突或选择死锁。</span></span><br><span class="line">                r += ftotal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前 bucket 中 item 数量为 0 ，则停止在当前 bucket 中寻找 item</span></span><br><span class="line">                <span class="keyword">if</span> (in-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">                    reject = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">goto</span> reject;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// local_fallback_retries 表示本地回退重试的次数，默认为 0 。 </span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// flocal &gt;= (in-&gt;size &gt;&gt; 1): flocal</span></span><br><span class="line">                <span class="comment">// 是本地失败的次数，这个条件检查是否失败次数已经达到或超过了桶大小的一半。 flocal &gt;</span></span><br><span class="line">                <span class="comment">// local_fallback_retries: 检查本地失败次数是否超过了设定的本地回退重试次数。</span></span><br><span class="line">                <span class="keyword">if</span> (local_fallback_retries &gt; <span class="number">0</span> &amp;&amp; flocal &gt;= (in-&gt;size &gt;&gt; <span class="number">1</span>) &amp;&amp; flocal &gt; local_fallback_retries)</span><br><span class="line">                    <span class="comment">// 如果上述条件全部满足，说明常规的选择方法可能不适用，需要使用一种备用的选择方法。</span></span><br><span class="line">                    <span class="comment">// 这是备用的选择方法，用于在常规方法失败后尝试另一种可能的选择方式。这个函数可能是基于某种特定的置换或者排列算法来选择设备。</span></span><br><span class="line">                    item = bucket_perm_choose(in, work-&gt;work[<span class="number">-1</span> - in-&gt;id], x, r);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 从指定 bucket 中选择 item</span></span><br><span class="line">                    <span class="comment">// in 为 bucket</span></span><br><span class="line">                    <span class="comment">// x 为输入哈希值，对应为 pgp seed</span></span><br><span class="line">                    <span class="comment">// choose_args 为 straw2 算法需要使用的参数</span></span><br><span class="line">                    <span class="comment">// outpos 为待选择出的 item 在 out 数组中的索引</span></span><br><span class="line">                    item = crush_bucket_choose(</span><br><span class="line">                        in, work-&gt;work[<span class="number">-1</span> - in-&gt;id], x, r, (choose_args ? &amp;choose_args[<span class="number">-1</span> - in-&gt;id] : <span class="number">0</span>), outpos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 选择的 item 的 id 大小异常，则结束当前 rep 的 for 循环，将 rep++ 之后，进入下一个选择逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (item &gt;= <span class="built_in">map</span>-&gt;max_devices) &#123;</span><br><span class="line">                    dprintk(<span class="string">&quot;   bad item %d\n&quot;</span>, item);</span><br><span class="line">                    skip_rep = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// item 的 id 小于 0 ，代表这是一个 bucket ， 则获取对应 bucket 的类型信息，</span></span><br><span class="line">                <span class="comment">// 否则当前 item 是 osd 类型 ，因此其 type 类型值为 0 。</span></span><br><span class="line">                <span class="keyword">if</span> (item &lt; <span class="number">0</span>)</span><br><span class="line">                    itemtype = <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item]-&gt;type;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    itemtype = <span class="number">0</span>;</span><br><span class="line">                dprintk(<span class="string">&quot;  item %d type %d\n&quot;</span>, item, itemtype);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前 item 的类型与期望的类型不同</span></span><br><span class="line">                <span class="keyword">if</span> (itemtype != type) &#123;</span><br><span class="line">                    <span class="comment">// item &gt;= 0 时，意味着当前 item 是一个叶子节点，此时类型仍然不匹配，基于 rep</span></span><br><span class="line">                    <span class="comment">// 的选择已经没有意义，尝试进入下一个 rep++ 的选择逻辑。</span></span><br><span class="line">                    <span class="comment">// item 为负数时，并且对应 bucket 的类型超限，则非法，结束基于当前 rep 的选择逻辑，尝试进入下一个</span></span><br><span class="line">                    <span class="comment">// rep++ 的选择逻辑。</span></span><br><span class="line">                    <span class="keyword">if</span> (item &gt;= <span class="number">0</span> || (<span class="number">-1</span> - item) &gt;= <span class="built_in">map</span>-&gt;max_buckets) &#123;</span><br><span class="line">                        dprintk(<span class="string">&quot;   bad item type %d\n&quot;</span>, type);</span><br><span class="line">                        skip_rep = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前 item 不是叶子节点，则会从当前 item 对应的 bucket 中继续寻找 item</span></span><br><span class="line">                    <span class="comment">// 有点类似于深度遍历的逻辑。</span></span><br><span class="line">                    in = <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item];</span><br><span class="line">                    retry_bucket = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 走到这里意味着找到了类型匹配的 item ，但是我们需要监测该 item 是否之前已经被选择过。</span></span><br><span class="line">                <span class="comment">// 如果之前被选择过了，意味着发生了冲突。</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outpos; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (out[i] == item) &#123;</span><br><span class="line">                        collide = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有碰撞冲突，且需要递归到叶子节点</span></span><br><span class="line">                <span class="comment">// 如果没有发生冲突，并且需要递归到叶子节点</span></span><br><span class="line">                reject = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!collide &amp;&amp; recurse_to_leaf) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前 item 不是叶子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (item &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> sub_r;</span><br><span class="line">                        <span class="comment">// vary_r 对应 chooseleaf_vary_r 配置，默认为 1</span></span><br><span class="line">                        <span class="keyword">if</span> (vary_r) &#123;</span><br><span class="line">                            <span class="comment">// 当 vary_r 为 1 时， sub_r = r</span></span><br><span class="line">                            sub_r = r &gt;&gt; (vary_r - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            sub_r = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回的值小于等于 outpos ，意味着在内部调用的时候没有找到符合条件的 item</span></span><br><span class="line">                        <span class="keyword">if</span> (crush_choose_firstn(</span><br><span class="line">                                <span class="built_in">map</span>,                       <span class="comment">// 对应 crush map</span></span><br><span class="line">                                work,                      <span class="comment">// </span></span><br><span class="line">                                <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item],   <span class="comment">// 当前 item 的 bucket</span></span><br><span class="line">                                weight,                    <span class="comment">// </span></span><br><span class="line">                                weight_max,                <span class="comment">// </span></span><br><span class="line">                                x,                         <span class="comment">// 输入哈希值，对应为 pgp seed</span></span><br><span class="line">                                stable ? <span class="number">1</span> : outpos + <span class="number">1</span>,   <span class="comment">// stable 对应 chooseleaf_stable 配置，默认为 1</span></span><br><span class="line">                                <span class="number">0</span>,               <span class="comment">// 期望的 item 类型，0 代表着叶子节点 osd 的类型</span></span><br><span class="line">                                out2,            <span class="comment">// 将获取的叶子节点的 item 存入 out2 数组</span></span><br><span class="line">                                outpos,          <span class="comment">// 期望选中的 item 在 out 数组中的索引位置</span></span><br><span class="line">                                count,           <span class="comment">// </span></span><br><span class="line">                                recurse_tries,   <span class="comment">// </span></span><br><span class="line">                                <span class="number">0</span>,               <span class="comment">// </span></span><br><span class="line">                                local_retries,   <span class="comment">// 对应 choose_local_tries 配置，默认为 50</span></span><br><span class="line">                                local_fallback_retries,   <span class="comment">// 对应 choose_local_fallback_tries 配置，默认为 0</span></span><br><span class="line">                                <span class="number">0</span>,                        <span class="comment">// 是否递归到叶子节点</span></span><br><span class="line">                                vary_r,                   <span class="comment">// vary_r 对应 chooseleaf_vary_r 配置，默认为 1</span></span><br><span class="line">                                stable,                   <span class="comment">// stable 对应 chooseleaf_stable 配置，默认为 1</span></span><br><span class="line">                                <span class="literal">NULL</span>,         <span class="comment">// 设置传入的 out2 数组为 NULL ，因为不会使用该变量</span></span><br><span class="line">                                sub_r,        <span class="comment">// 按照默认值的情况， sub_r = r</span></span><br><span class="line">                                choose_args   <span class="comment">// choose_args 为 straw2 算法需要使用的参数</span></span><br><span class="line">                                ) &lt;= outpos) &#123;</span><br><span class="line">                            <span class="comment">// 经过深度遍历的调用后，仍然没有找到新的 item ，则拒绝</span></span><br><span class="line">                            reject = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前 item 已经是一个叶子节点了，则将该 item 记录到 out2 数组中</span></span><br><span class="line">                        out2[outpos] = item;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有被拒绝，并且，也没有发生冲突</span></span><br><span class="line">                <span class="keyword">if</span> (!reject &amp;&amp; !collide) &#123;</span><br><span class="line">                    <span class="comment">// itemtype 为 0 意味着选择的 item 是一个 osd</span></span><br><span class="line">                    <span class="keyword">if</span> (itemtype == <span class="number">0</span>) reject = is_out(<span class="built_in">map</span>, weight, weight_max, item, x);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            reject:</span><br><span class="line">                <span class="comment">// 处理被拒绝或者发生了碰撞冲突的情况</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// reject 对应的场景如下:</span></span><br><span class="line">                <span class="comment">// 1. 当前的 bucket 中 item 数量为 0 ，则拒绝在当前 bucket 中选择；</span></span><br><span class="line">                <span class="comment">// 2. 在选择叶子节点的过程中，如果没有找到符合条件的 item ，则拒绝在当前 bucket 中选择；</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// collide 对应的场景如下:</span></span><br><span class="line">                <span class="comment">// 1. 当前选择的 item 与之前选择过的 item 一致，即发生了碰撞冲突；</span></span><br><span class="line">                <span class="keyword">if</span> (reject || collide) &#123;</span><br><span class="line">                    <span class="comment">// 调整失败数量</span></span><br><span class="line">                    ftotal++;</span><br><span class="line">                    flocal++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 发生了碰撞冲突，但是在当前 bucket 中重试的次数没有超过限制，则可以再次重试。</span></span><br><span class="line">                    <span class="comment">// local_retries 对应 choose_local_tries 配置，默认为 50 。</span></span><br><span class="line">                    <span class="keyword">if</span> (collide &amp;&amp; flocal &lt;= local_retries) retry_bucket = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// local_fallback_retries 对应 choose_local_fallback_tries 配置，默认为 0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (local_fallback_retries &gt; <span class="number">0</span> &amp;&amp; flocal &lt;= in-&gt;size + local_fallback_retries)</span><br><span class="line">                        retry_bucket = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果总失败次数小于 tries ， 则尝试向下寻找</span></span><br><span class="line">                    <span class="comment">// tries 默认为 choose_total_tries + 1 ， 即默认为 51</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ftotal &lt; tries)</span><br><span class="line">                        retry_descent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 放弃当前 rep 的选择</span></span><br><span class="line">                        skip_rep = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    dprintk(<span class="string">&quot;  reject %d  collide %d  ftotal %u  flocal %u\n&quot;</span>, reject, collide, ftotal, flocal);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在当前 bucket 中重新选择。</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 对应的场景如下:</span></span><br><span class="line">                <span class="comment">// 1. 当前选择的 item 的类型不是期望的类型，但其仍是一个 bucket ，可从该 bucket 中继续检索；</span></span><br><span class="line">                <span class="comment">// 2. 如果选择的 item 之前已经选择过，即发生了碰撞冲突，但本地失败的次数仍然在 local_retries</span></span><br><span class="line">                <span class="comment">//    范围内，则可以继续在当前 bucket 中重新选择；</span></span><br><span class="line">                <span class="comment">// 3. 如果启用了本地回退重试，且本地失败的次数满足条件，则可以继续在当前 bucket 中重新选择；</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (retry_bucket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下降重试。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 对应的场景如下:</span></span><br><span class="line">            <span class="comment">// 1. 如果总的失败次数小于 tries ， 则可以继续下降重试</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retry_descent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 经过上述判断，结论是需要跳过当前 rep 的选择。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对应的场景如下:</span></span><br><span class="line">        <span class="comment">// 1. 选择的 item 异常。item 的 id 超过 max_devices 值。</span></span><br><span class="line">        <span class="comment">// 2. 选择的 item 类型不匹配。找到的叶子节点与期望的 item type 不匹配；找到的 item id 超过了 max_buckets值；</span></span><br><span class="line">        <span class="comment">// 3. 异常选择的次数不满足约束。选择过程被拒绝或者发生了碰撞冲突，且失败的次数不满足约束。</span></span><br><span class="line">        <span class="keyword">if</span> (skip_rep) &#123;</span><br><span class="line">            dprintk(<span class="string">&quot;skip rep\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择到符合条件的 item ，将其加入 out 数组</span></span><br><span class="line">        dprintk(<span class="string">&quot;CHOOSE got %d\n&quot;</span>, item);</span><br><span class="line">        out[outpos] = item;</span><br><span class="line">        outpos++;</span><br><span class="line">        count--;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;choose_tries &amp;&amp; ftotal &lt;= <span class="built_in">map</span>-&gt;choose_total_tries) <span class="built_in">map</span>-&gt;choose_tries[ftotal]++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 out 数组中已选中 item 的数量</span></span><br><span class="line">    dprintk(<span class="string">&quot;CHOOSE returns %d\n&quot;</span>, outpos);</span><br><span class="line">    <span class="keyword">return</span> outpos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-4、Choose-Indep-逻辑"><a href="#2-2-4、Choose-Indep-逻辑" class="headerlink" title="2.2.4、Choose Indep 逻辑"></a>2.2.4、Choose Indep 逻辑</h3><p><strong>示例 rule:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">indep</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>选择 item 的伪代码总结:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>选择 item 的详细代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * crush_choose_indep - 选择给定类型的 numrep 个不同项目</span></span><br><span class="line"><span class="comment"> * @map: 对应 crush map</span></span><br><span class="line"><span class="comment"> * @work:</span></span><br><span class="line"><span class="comment"> * @bucket: item 所归属的 bucket</span></span><br><span class="line"><span class="comment"> * @weight:</span></span><br><span class="line"><span class="comment"> * @weight_max:</span></span><br><span class="line"><span class="comment"> * @x: 输入哈希值，对应为 pgp seed</span></span><br><span class="line"><span class="comment"> * @left: 在当前 bucket 中还需要选择的 item 的数量</span></span><br><span class="line"><span class="comment"> * @numrep: crush rule 中单个 step 定义的要选择的 item 数量</span></span><br><span class="line"><span class="comment"> * @type: crush rule 中单个 step 定义的要选择的 item 类型</span></span><br><span class="line"><span class="comment"> * @out: 选中的 item 的数组</span></span><br><span class="line"><span class="comment"> * @outpos: 选中的 item 要存储在 out 数组中的索引</span></span><br><span class="line"><span class="comment"> * @tries: 默认为 choose_total_tries + 1 ， 默认为 51</span></span><br><span class="line"><span class="comment"> * @recurse_tries: 由于 choose_leaf_tries 默认为 0 ，所以该值默认为 1</span></span><br><span class="line"><span class="comment"> * @recurse_to_leaf: 是否递归到叶子节点</span></span><br><span class="line"><span class="comment"> * @out2: 第二个输出向量用于叶 item （如果 @recurse_to_leaf）</span></span><br><span class="line"><span class="comment"> * @parent_r: 从父级传递的 r 值</span></span><br><span class="line"><span class="comment"> * @choose_args: choose_args 为 straw2 算法用到的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">crush_choose_indep</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_work* work,                            <span class="comment">// 2</span></span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> crush_bucket* bucket, <span class="type">const</span> __u32* weight, <span class="type">int</span> weight_max, <span class="type">int</span> x,   <span class="comment">// 6</span></span></span><br><span class="line"><span class="params">                               <span class="type">int</span> left, <span class="type">int</span> numrep, <span class="type">int</span> type, <span class="type">int</span>* out, <span class="type">int</span> outpos, <span class="type">unsigned</span> <span class="type">int</span> tries,        <span class="comment">// 12</span></span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> <span class="type">int</span> recurse_tries, <span class="type">int</span> recurse_to_leaf, <span class="type">int</span>* out2, <span class="type">int</span> parent_r,        <span class="comment">// 16</span></span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* choose_args)</span>                                      <span class="comment">// 17</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">crush_bucket</span>* <span class="title">in</span> =</span> bucket;</span><br><span class="line">    <span class="type">int</span> endpos = outpos + left;</span><br><span class="line">    <span class="type">int</span> rep;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ftotal;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> item = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> itemtype;</span><br><span class="line">    <span class="type">int</span> collide;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化剩余所有要获取的 item 的元素在数组中的索引位置</span></span><br><span class="line">    <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123;</span><br><span class="line">        out[rep] = CRUSH_ITEM_UNDEF;</span><br><span class="line">        <span class="keyword">if</span> (out2) out2[rep] = CRUSH_ITEM_UNDEF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制总的失败次数，并且监测在当前 bucket 中待选择的 item 数量</span></span><br><span class="line">    <span class="keyword">for</span> (ftotal = <span class="number">0</span>; left &gt; <span class="number">0</span> &amp;&amp; ftotal &lt; tries; ftotal++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_INDEP</span></span><br><span class="line">        <span class="keyword">if</span> (out2 &amp;&amp; ftotal) &#123;</span><br><span class="line">            dprintk(<span class="string">&quot;%u %d a: &quot;</span>, ftotal, left);</span><br><span class="line">            <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123; dprintk(<span class="string">&quot; %d&quot;</span>, out[rep]); &#125;</span><br><span class="line">            dprintk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            dprintk(<span class="string">&quot;%u %d b: &quot;</span>, ftotal, left);</span><br><span class="line">            <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123; dprintk(<span class="string">&quot; %d&quot;</span>, out2[rep]); &#125;</span><br><span class="line">            dprintk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 不断循环监测 out 数组中哪个位置上仍没有选取的 item ，则开始执行选取操作</span></span><br><span class="line">        <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (out[rep] != CRUSH_ITEM_UNDEF) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记当前 bucket</span></span><br><span class="line">            in = bucket;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不断循环检索</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 结束循环的条件:</span></span><br><span class="line">            <span class="comment">// 1. bucket 中 item 数量为空</span></span><br><span class="line">            <span class="comment">// 2. 选择的 item 类型为 osd ，但其 id 超过 max_devices ，则异常</span></span><br><span class="line">            <span class="comment">// 3. 选择的 item 为 bucekt ，但是其 id 大于 max_buckets ，则异常</span></span><br><span class="line">            <span class="comment">// 4. 选择 item 发生了冲突，即找到了重复的 item</span></span><br><span class="line">            <span class="comment">// 5. 在需要递归检索叶子节点的时候，找不到对应的叶子节点</span></span><br><span class="line">            <span class="comment">// 6. itemtype == 0 &amp;&amp; is_out(map, weight, weight_max, item, x) 的情况</span></span><br><span class="line">            <span class="comment">// 7. 找到符合条件的 item</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 更新 r 值</span></span><br><span class="line">                r = rep + parent_r;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 bucket 算法为 CRUSH_BUCKET_UNIFORM 则执行特殊处理</span></span><br><span class="line">                <span class="keyword">if</span> (in-&gt;alg == CRUSH_BUCKET_UNIFORM &amp;&amp; in-&gt;size % numrep == <span class="number">0</span>)</span><br><span class="line">                    r += (numrep + <span class="number">1</span>) * ftotal;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 更新 r 值，这是关键点，防止每次 r 值不变，找到的都是相同的 item</span></span><br><span class="line">                    r += numrep * ftotal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// bucket 中元素为空，则跳过当前 bucket</span></span><br><span class="line">                <span class="keyword">if</span> (in-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">                    dprintk(<span class="string">&quot;   empty bucket\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 bucket 内配置的算法不同，执行不同的选取 item 操作</span></span><br><span class="line">                item = crush_bucket_choose(</span><br><span class="line">                    in, work-&gt;work[<span class="number">-1</span> - in-&gt;id], x, r, (choose_args ? &amp;choose_args[<span class="number">-1</span> - in-&gt;id] : <span class="number">0</span>), outpos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// item 的索引大于最大的 device 则为异常，将对应的副本序号的数设置为 CRUSH_ITEM_NONE</span></span><br><span class="line">                <span class="keyword">if</span> (item &gt;= <span class="built_in">map</span>-&gt;max_devices) &#123;</span><br><span class="line">                    dprintk(<span class="string">&quot;   bad item %d\n&quot;</span>, item);</span><br><span class="line">                    out[rep] = CRUSH_ITEM_NONE;</span><br><span class="line">                    <span class="keyword">if</span> (out2) out2[rep] = CRUSH_ITEM_NONE;</span><br><span class="line">                    left--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取当前 item 的类型</span></span><br><span class="line">                <span class="keyword">if</span> (item &lt; <span class="number">0</span>)</span><br><span class="line">                    itemtype = <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item]-&gt;type;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    itemtype = <span class="number">0</span>;</span><br><span class="line">                dprintk(<span class="string">&quot;  item %d type %d\n&quot;</span>, item, itemtype);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 类型不匹配则继续寻找</span></span><br><span class="line">                <span class="keyword">if</span> (itemtype != type) &#123;</span><br><span class="line">                    <span class="comment">// item 已经为叶子节点，此时类型仍然不匹配，则无法继续向下寻找，因此结束当前流程。</span></span><br><span class="line">                    <span class="comment">// item 并不是叶子节点，但是其 bucket id 大于 max_buckets ，意味着这是一个异常的</span></span><br><span class="line">                    <span class="comment">// bucket，也结束当前流程。</span></span><br><span class="line">                    <span class="keyword">if</span> (item &gt;= <span class="number">0</span> || (<span class="number">-1</span> - item) &gt;= <span class="built_in">map</span>-&gt;max_buckets) &#123;</span><br><span class="line">                        dprintk(<span class="string">&quot;   bad item type %d\n&quot;</span>, type);</span><br><span class="line">                        out[rep] = CRUSH_ITEM_NONE;</span><br><span class="line">                        <span class="keyword">if</span> (out2) out2[rep] = CRUSH_ITEM_NONE;</span><br><span class="line">                        left--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从当前 item 的 bucket 中继续往下寻找</span></span><br><span class="line">                    in = <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 监测是否发生冲突，即是否找到相同的 item</span></span><br><span class="line">                collide = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = outpos; i &lt; endpos; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (out[i] == item) &#123;</span><br><span class="line">                        collide = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果存在冲突，则跳出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (collide) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是否需要递归检索到叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> (recurse_to_leaf) &#123;</span><br><span class="line">                    <span class="comment">// 当前 item 非叶子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (item &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 继续往下一层检索</span></span><br><span class="line">                        crush_choose_indep(</span><br><span class="line">                            <span class="built_in">map</span>,</span><br><span class="line">                            work,</span><br><span class="line">                            <span class="built_in">map</span>-&gt;buckets[<span class="number">-1</span> - item],   <span class="comment">// @bucket: 下一次要检索的 bucket</span></span><br><span class="line">                            weight,</span><br><span class="line">                            weight_max,</span><br><span class="line">                            x,   <span class="comment">// @x: 输入哈希值，对应为 pgp seed</span></span><br><span class="line">                            <span class="number">1</span>,   <span class="comment">// @left: 在当前 bucket 中还需要选择的 item 的数量，只需要找到一个叶子节点即可</span></span><br><span class="line">                            numrep,   <span class="comment">// @numrep: crush rule 中单个 step 定义的要选择的 item 数量</span></span><br><span class="line">                            <span class="number">0</span>,   <span class="comment">// @type: crush rule 中单个 step 定义的要选择的 item 类型，这里为 osd 类型</span></span><br><span class="line">                            out2,   <span class="comment">// @out: 选中的 item 的数组，由于这里是叶子节点，所以存入 out2 数组</span></span><br><span class="line">                            rep,             <span class="comment">// @outpos: 选中的 item 要存储在数组中的索引</span></span><br><span class="line">                            recurse_tries,   <span class="comment">// @tries: 这里传入的值为 recurse_tries 的值</span></span><br><span class="line">                            <span class="number">0</span>,               <span class="comment">// @recurse_tries: 这里传入的值为 0</span></span><br><span class="line">                            <span class="number">0</span>,               <span class="comment">// @recurse_to_leaf: 这里传入的值为 0</span></span><br><span class="line">                            <span class="literal">NULL</span>,   <span class="comment">// @out2: 第二个输出向量用于叶 item，由于当前检索的就是叶子节点，所以该值为 0</span></span><br><span class="line">                            r,   <span class="comment">// @parent_r: 从父级传递的 r 值</span></span><br><span class="line">                            choose_args);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (out2 &amp;&amp; out2[rep] == CRUSH_ITEM_NONE) &#123;</span><br><span class="line">                            <span class="comment">// 没有找到对应的叶子节点</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前 item 为叶子节点，直接记录该 item</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (out2) &#123;</span><br><span class="line">                        out2[rep] = item;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> (itemtype == <span class="number">0</span> &amp;&amp; is_out(<span class="built_in">map</span>, weight, weight_max, item, x)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到 item ，跳出当前循环</span></span><br><span class="line">                out[rep] = item;</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次处理结果数组，如果内部还是未定义的 item ，则将其设置为 None</span></span><br><span class="line">    <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (out[rep] == CRUSH_ITEM_UNDEF) &#123; out[rep] = CRUSH_ITEM_NONE; &#125;</span><br><span class="line">        <span class="keyword">if</span> (out2 &amp;&amp; out2[rep] == CRUSH_ITEM_UNDEF) &#123; out2[rep] = CRUSH_ITEM_NONE; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;choose_tries &amp;&amp; ftotal &lt;= <span class="built_in">map</span>-&gt;choose_total_tries) <span class="built_in">map</span>-&gt;choose_tries[ftotal]++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_INDEP</span></span><br><span class="line">    <span class="keyword">if</span> (out2) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot;%u %d a: &quot;</span>, ftotal, left);</span><br><span class="line">        <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123; dprintk(<span class="string">&quot; %d&quot;</span>, out[rep]); &#125;</span><br><span class="line">        dprintk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        dprintk(<span class="string">&quot;%u %d b: &quot;</span>, ftotal, left);</span><br><span class="line">        <span class="keyword">for</span> (rep = outpos; rep &lt; endpos; rep++) &#123; dprintk(<span class="string">&quot; %d&quot;</span>, out2[rep]); &#125;</span><br><span class="line">        dprintk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、Bucket-算法详解"><a href="#三、Bucket-算法详解" class="headerlink" title="三、Bucket 算法详解"></a>三、Bucket 算法详解</h1><p><strong>不同类别的算法实现介绍:</strong></p>
<ul>
<li><code>uniform</code>: 它假定整个集群的设备容量是均匀的，并且设备数量极少变化，他不关心子设备中配置的权重，而是直接通过哈希算法将数据均匀的分布到集群中，时间复杂度 <code>O(1)</code>，优点是计算速度快，缺点是适用范围有限。</li>
<li><code>list</code>&#x2F;<code>tree</code>: 这两种属于分治算法，问题在于各子元素的选择概率是全局相关的，所以子元素的增加、删除和权重的改变都会在一定程度上影响全局的数据分布，由此带来的数据迁移量并不是最优的。<ul>
<li><code>list</code>: 它会逐一检查各个元素，并根据权重确定选中对应子元素的概率，时间复杂度 <code>O(n)</code>，优点是在集群规模不断增加时能最小化数据迁移，缺点是移除旧节点时会导致数据重新分配。</li>
<li><code>tree</code>: 它使用了二叉搜索树，让搜索到各子元素的概率与权重一致，时间复杂度 <code>O(logn)</code>，优点是较好适应集群规模的增减，缺点是 Ceph 实现有缺陷，不推荐使用。</li>
</ul>
</li>
<li><code>straw</code>&#x2F;<code>straw2</code>: <ul>
<li><code>straw</code> 会让所有子元素独立的互相竞争，类似于抽签机制，让子元素的签长基于权重分布，并引入一定的伪随机性，时间服复杂度为 <code>O(n)</code> ，由于子元素签长的计算仍然会依赖于其他子元素的权重，所以并没有能够完全解决最小数据迁移量问题。</li>
<li><code>straw2</code> 的提出解决了 straw 存在的问题，在计算子元素签长时不会依赖于其他子元素的状况，保证数据分布遵循权重分布，并且在集群规模变化时拥有最佳的表现。</li>
</ul>
</li>
</ul>
<p><strong>桶算法的比较:</strong></p>
<table>
<thead>
<tr>
<th align="center">桶算法</th>
<th align="center">选择的时间复杂度</th>
<th align="center">元素添加</th>
<th align="center">元素移除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uniform</td>
<td align="center">O(1)</td>
<td align="center">差</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">O(n)</td>
<td align="center">良</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">tree</td>
<td align="center">O(log(n))</td>
<td align="center">优</td>
<td align="center">优</td>
</tr>
<tr>
<td align="center">straw</td>
<td align="center">O(n)</td>
<td align="center">更优</td>
<td align="center">更优</td>
</tr>
<tr>
<td align="center">straw2</td>
<td align="center">O(n)</td>
<td align="center">良</td>
<td align="center">良</td>
</tr>
</tbody></table>
<h2 id="3-1、Uniform-Buckets"><a href="#3-1、Uniform-Buckets" class="headerlink" title="3.1、Uniform Buckets"></a>3.1、Uniform Buckets</h2><p>在大型存储系统中，通常不会单独添加某个设备（个别故障除外），而是批量添加一组设备，用于扩容或者替换寿命到的设备。因此将它们视为一个单元是很自然的。在这种情况下，<code>uniform buckets</code> 用于表示一组相同的设备。这样做的主要优势在于性能：CRUSH 可以在常数时间内将副本映射到桶中。如果桶的大小发生变化，则设备之间的数据将完全重新排列，就像传统的基于哈希的分发策略一样。</p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_uniform* <span class="title function_">crush_make_uniform_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span> item_weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_uniform_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_uniform_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_uniform_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_uniform_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_uniform* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_uniform_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="keyword">struct</span> crush_work_bucket* work, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bucket_perm_choose(&amp;bucket-&gt;h, work, x, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 为 _pg_to_raw_osds 函数中计算出的 pps</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_perm_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket* bucket, <span class="keyword">struct</span> crush_work_bucket* work, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 r 的值限制在 bucket 的大小范围内</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pr = r % bucket-&gt;size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次需要为 x 从 bucket 中选择多个 item ， 为此我们将 x 记录到 work-&gt;perm_x 字段中，</span></span><br><span class="line">    <span class="comment">// 因此如果 work-&gt;perm_x 发生了变更，则代表需要为新的 x 选择 item ，需要重新计算排列。</span></span><br><span class="line">    <span class="keyword">if</span> (work-&gt;perm_x != (__u32)x || work-&gt;perm_n == <span class="number">0</span>) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot;bucket %d new x=%d\n&quot;</span>, bucket-&gt;id, x);</span><br><span class="line">        work-&gt;perm_x = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 pr 为 0 （即第一个副本），直接使用哈希函数计算一个索引，这是一个优化，因为大多数调用都是请求第一个副本。</span></span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="number">0</span>) &#123;</span><br><span class="line">            s = crush_hash32_3(bucket-&gt;hash, x, bucket-&gt;id, <span class="number">0</span>) % bucket-&gt;size;</span><br><span class="line">            work-&gt;perm[<span class="number">0</span>] = s;</span><br><span class="line">            work-&gt;perm_n = <span class="number">0xffff</span>; <span class="comment">/* magic value, see below */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 pr 不为 0 ，且是新的序列，则初始化排列数组 perm ，使其包含从 0 到 bucket-&gt;size-1 的整数，</span></span><br><span class="line">        <span class="comment">// 并且设置当前 work 中已经选择的 item 数量为 0 。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;size; i++) work-&gt;perm[i] = i;</span><br><span class="line">        work-&gt;perm_n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前处理过 pr 为 0 的情况，则当前为第二次调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (work-&gt;perm_n == <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化排列数组中下标 0 之后的位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; bucket-&gt;size; i++) work-&gt;perm[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于当 pr 为 0 的时候（即第一次计算 x 的排列数组的情况），已经获取了 bucket 中索引 s ，并将</span></span><br><span class="line">        <span class="comment">// 该值记录到 work-&gt;perm[0] （即 work-&gt;perm[0] = s ），为了避免 work-&gt;perm 数组中出现 bucket 中</span></span><br><span class="line">        <span class="comment">// 重复的索引，所以需要将 work-&gt;perm[s] 中记录的值设置为 bucket 的索引 0，即 work-&gt;perm[s] = 0 。</span></span><br><span class="line">        work-&gt;perm[work-&gt;perm[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 work 中已经获取的 item 数量为 1 。</span></span><br><span class="line">        work-&gt;perm_n = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; work-&gt;perm_n; i++) dprintk(<span class="string">&quot; perm_choose have %d: %d\n&quot;</span>, i, work-&gt;perm[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个条件检查当前已生成的排列长度（ work-&gt;perm_n ）是否小于或等于所需的副本位置 pr 。</span></span><br><span class="line">    <span class="comment">// 如果是，需要继续生成排列直到达到这个位置。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 通过不断交换元素位置，生成一个伪随机的排列，直到生成足够长的排列以覆盖所需的副本位置 pr 。</span></span><br><span class="line">    <span class="comment">// 确保了数据的均匀分布和访问的随机性，是 CRUSH 算法处理数据分布的关键机制。</span></span><br><span class="line">    <span class="keyword">while</span> (work-&gt;perm_n &lt;= pr) &#123;</span><br><span class="line">        <span class="comment">// 这里 p 是当前排列的长度，即下一个要处理的排列位置。</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> p = work-&gt;perm_n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 p 已经是最后一个元素的位置，则没有后续元素可以与之交换，因此不执行交换。</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; bucket-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用哈希函数 crush_hash32_3 基于桶的哈希种子、对象标识符 x 、桶的 id 和当前位置 p 计算一个哈希值。</span></span><br><span class="line">            <span class="comment">// 然后取模操作确定在当前位置 p 之后的哪个位置与之交换。这保证了交换的随机性和均匀性。</span></span><br><span class="line">            i = crush_hash32_3(bucket-&gt;hash, x, bucket-&gt;id, p) % (bucket-&gt;size - p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 i 不为 0 （即当前位置 p 不是交换位置），则执行交换操作</span></span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> t = work-&gt;perm[p + i];</span><br><span class="line">                work-&gt;perm[p + i] = work-&gt;perm[p];</span><br><span class="line">                work-&gt;perm[p] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            dprintk(<span class="string">&quot; perm_choose swap %d with %d\n&quot;</span>, p, p + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每完成一次交换，排列长度增加 1 。</span></span><br><span class="line">        work-&gt;perm_n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;size; i++) dprintk(<span class="string">&quot; perm_choose  %d: %d\n&quot;</span>, i, work-&gt;perm[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从排列中获取 pr 位置的索引s，然后返回 bucket-&gt;items[s] ，即为选择的桶中的条目。</span></span><br><span class="line">    s = work-&gt;perm[pr];</span><br><span class="line">out:</span><br><span class="line">    dprintk(<span class="string">&quot; perm_choose %d sz=%d x=%d r=%d (%d) s=%d\n&quot;</span>, bucket-&gt;id, bucket-&gt;size, x, r, pr, s);</span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;items[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="3-2、List-Buckets"><a href="#3-2、List-Buckets" class="headerlink" title="3.2、List Buckets"></a>3.2、List Buckets</h2><p><code>list buckets</code> 将其内容构建为链表，并且可以包含具有任意权重的项目。为了放置副本， <code>CRUSH</code> 从列表头部开始，包含最新添加的项目，并将其权重与所有剩余项目的权重之和进行比较。根据 <code>hash(x, r, item)</code> 的值，要么以适当的概率选择当前项目，要么该过程继续递归地沿着列表向下进行。这种方法源自 <code>RUSHp</code> ，将放置问题重新定义为 “最近添加的” 问题。 “是新项目，还是旧项目？” 对于不断扩展的集群来说，这是一个自然而直观的选择，要么以适当的概率将对象迁移到最新的设备，要么像以前一样保留在旧设备上。当项目添加到存储桶时，其结果是最佳的数据迁移。然而，从列表中间或尾部移除项目可能会导致大量不必要的移动，因此列表存储桶最适合于从不（或很少）收缩的情况。</p>
<p><code>RUSHp</code> 算法大致相当于一个两级 <code>CRUSH</code> 层次结构，由一个包含多个 <code>uniform buckets</code> 的 <code>list buckets</code> 组成。其固定的集群表示形式排除了使用放置规则或 <code>CRUSH</code> 故障域来控制数据放置以增强可靠性的可能性。</p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_list* <span class="title function_">crush_make_list_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_list_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_list_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_list_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_list_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_list* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_list_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = bucket-&gt;h.size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 这个哈希值是随机的，但是对于相同的输入总是产生相同的输出，保证了算法的确定性。</span></span><br><span class="line">        __u64 w = crush_hash32_4(bucket-&gt;h.hash, x, bucket-&gt;h.items[i], r, bucket-&gt;h.id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希值与 0xffff 进行 AND 操作，将哈希值限制在一个较小的范围内（即 0 到 65535 ）。</span></span><br><span class="line">        w &amp;= <span class="number">0xffff</span>;</span><br><span class="line">        dprintk(<span class="string">&quot;list_choose i=%d x=%d r=%d item %d weight %x &quot;</span></span><br><span class="line">                <span class="string">&quot;sw %x rand %llx&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                x,</span><br><span class="line">                r,</span><br><span class="line">                bucket-&gt;h.items[i],</span><br><span class="line">                bucket-&gt;item_weights[i],</span><br><span class="line">                bucket-&gt;sum_weights[i],</span><br><span class="line">                w);</span><br><span class="line">        <span class="comment">// 将结果乘以到目前为止的权重总和（ bucket-&gt;sum_weights[i] ），然后右移 16 位，进行缩小。</span></span><br><span class="line">        <span class="comment">// 将哈希值缩放到一个与权重总和相关的范围内。</span></span><br><span class="line">        w *= bucket-&gt;sum_weights[i];</span><br><span class="line">        w = w &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缩小后的哈希值小于当前条目的权重，这意味着在从 0 到当前权重总和的范围内，只有当值落在当前条目</span></span><br><span class="line">        <span class="comment">// 的权重范围内时，条目才会被选中。因此，条目被选中的概率正比于它的权重相对于权重总和的比例。</span></span><br><span class="line">        <span class="keyword">if</span> (w &lt; bucket-&gt;item_weights[i]) &#123; <span class="keyword">return</span> bucket-&gt;h.items[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有条目都未被选择（理论上不应发生，除非权重配置错误），则打印错误信息，并默认返回列表中的第一个条目。</span></span><br><span class="line">    dprintk(<span class="string">&quot;bad list sums for bucket %d\n&quot;</span>, bucket-&gt;h.id);</span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-3、Tree-Buckets"><a href="#3-3、Tree-Buckets" class="headerlink" title="3.3、Tree Buckets"></a>3.3、Tree Buckets</h2><p>与任何链表数据结构一样，<code>list buckets</code> 对于较小的项目集非常高效，但对于较大的项目集可能不太适用，因为其 <code>O(n)</code> 运行时间可能过长。源自 <code>RUSHt</code> 的树形桶通过将其项目存储在二叉树中解决了这个问题。这将放置时间缩短至 <code>O(log(n))</code>，使其适合管理更大的设备集或嵌套桶。 <code>RUSHt</code> 相当于一个两级 <code>CRUSH</code> 层次结构，由一个包含多个 <code>uniform bucket</code> 的 <code>tree buckets</code> 组成。</p>
<p><code>tree buckets</code> 的结构为带权二叉搜索树，其项目位于叶子节点。每个内部节点都知道其左右子树的总权重，并根据固定策略进行标记（详见下文）。为了在存储桶中选择一个项目，CRUSH 从树的根节点开始，计算输入键 x、副本数量 r、存储桶标识符以及当前树节点（最初为根节点）的标签的哈希值。将结果与左右子树的权重比进行比较，以决定接下来要访问哪个子节点。此过程重复进行，直到到达叶子节点，此时存储桶中的相关项目将被选中。只需进行 <code>log(n)</code> 次哈希运算和节点比较即可定位项目。</p>
<p>存储桶的二叉树节点采用简单的固定策略标记二进制值，以避免在树增长或收缩时标签发生变化。树中最左边的叶子节点始终标记为 “1”。每次树扩展时，旧根节点都会成为新根节点的左子节点，并且树中最左边的叶子节点始终带有标签，新的根节点的标签将旧根节点的标签向左移动一位（例如 1、10、100 等）。树右侧的标签与左侧的标签相同，只是每个值前面都添加了一个 “1” 。一旦对象被放置在特定的子树中，其最终映射将仅取决于该子树中的权重和节点标签，并且只要该子树的项目保持不变，映射就不会改变。尽管分层决策树在嵌套项目之间引入了一些额外的数据迁移，但此策略将移动保持在合理水平，同时即使对于非常大的存储桶也能提供高效的映射。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root default &#123;</span><br><span class="line">        <span class="built_in">id</span> -1             <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="built_in">id</span> -2 class hdd   <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.6</span></span><br><span class="line">        alg tree</span><br><span class="line">        <span class="built_in">hash</span> 0  <span class="comment"># rjenkins1</span></span><br><span class="line">        item host01 weight 0.2</span><br><span class="line">        item host02 weight 0.2</span><br><span class="line">        item host03 weight 0.2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个 <code>bucket</code> 的信息如上，则根据上面的 <code>bucket</code> 生成的 <code>tree</code> 的基础信息为，<code>depth = 3</code> ，<code>num_nodes = 8</code> ，生成的树结构关系如下（相关代码参见 <code>crush_make_tree_bucket</code> 函数）:</p>
<p><img src="/assets/images/ceph-crush-tree-bucket-create.png" alt="Tree Bucket" loading="lazy"></p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_tree* <span class="title function_">crush_make_tree_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_tree_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_tree_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_tree_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_tree_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_tree* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* (binary) tree */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        h++;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定节点 x 的左子节点的位置。这里的 h 是节点 x 的高度。</span></span><br><span class="line"><span class="comment">// 首先调用 height(x) 来获取 x 的高度，然后通过减去 2^(h-1) 来找到左子节点的位置。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = height(x);</span><br><span class="line">    <span class="keyword">return</span> x - (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定节点 x 的右子节点的位置。这里的 h 是节点 x 的高度。</span></span><br><span class="line"><span class="comment">// 首先调用 height(x) 来获取 x 的高度，然后通过加上 2^(h-1) 来找到右子节点的位置。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = height(x);</span><br><span class="line">    <span class="keyword">return</span> x + (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点 x 是否是一个叶子节点（即终端节点）。</span></span><br><span class="line"><span class="comment">// 在二进制表示中，如果最低位是 1 ，则节点是叶子节点。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">terminal</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_tree_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    __u32 w;</span><br><span class="line">    __u64 t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根节点开始</span></span><br><span class="line">    n = bucket-&gt;num_nodes &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是叶子节点</span></span><br><span class="line">    <span class="comment">// 在二进制表示中，如果最低位是1，则节点是叶子节点。</span></span><br><span class="line">    <span class="keyword">while</span> (!terminal(n)) &#123;</span><br><span class="line">        <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前节点的权重</span></span><br><span class="line">        w = bucket-&gt;node_weights[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算哈希值，然后乘以节点的权重。</span></span><br><span class="line">        <span class="comment">// 该哈希函数考虑了桶的哈希类型、对象ID、节点索引、随机种子和桶ID。</span></span><br><span class="line">        t = (__u64)crush_hash32_4(bucket-&gt;h.hash, x, n, r, bucket-&gt;h.id) * (__u64)w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 64 位结果右移 32 位，以缩减范围，使其适应权重的规模。</span></span><br><span class="line">        t = t &gt;&gt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子节点的索引。</span></span><br><span class="line">        l = left(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计算得到的哈希值小于左子节点的权重，则选择左子节点，</span></span><br><span class="line">        <span class="comment">// 否则选择右子节点 (n = right(n);)。</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 假设当前节点权重为 0.6 ， 左子节点权重为 0.4 ， 右子节点权重为 0.2 ,</span></span><br><span class="line">        <span class="comment">// 如果当前计算的 t 为 0.3 ，可以说明要寻找的节点位于左子节点树中；</span></span><br><span class="line">        <span class="comment">// 如果当前计算的 t 为 0.5 ，可以说明要寻找的节点位于右子节点树中；</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; bucket-&gt;node_weights[l])</span><br><span class="line">            n = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n = right(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、Straw-Buckets"><a href="#3-4、Straw-Buckets" class="headerlink" title="3.4、Straw Buckets"></a>3.4、Straw Buckets</h2><p><code>list buckes</code> 和 <code>tree buckets</code> 的结构使得只需计算有限数量的哈希值并将其与权重进行比较，即可选择桶中的项目。在这样做的过程中，它们会采用分治法，要么优先考虑某些项目（例如，位于列表开头的项目），要么完全无需考虑项目的整个子树。这可以提高副本放置过程的性能，但当桶的内容由于项目的添加、移除或重新调整权重而发生变化时，也可能导致重组行为不理想。</p>
<p><code>straw buckets</code> 让所有物品都能公平 “竞争” 。通过类似于抽签的过程，每个桶中的项目都会相互竞争以放置副本。要放置副本，需要为桶中的每个项目抽取一根随机长度的签。获取最长签的项目获胜。每根签的长度最初都是一个固定范围内的值，基于 <code>CRUSH</code> 输入 x、副本数量 r 和桶中项目 i 的哈希值。每根签的长度都会根据项目的权重乘以因子，这样权重较大的项目更有可能获胜。虽然此过程（平均而言）几乎比 <code>list buckets </code>慢两倍，甚至比 <code>tree buckets</code> （以对数方式缩放）更慢，但 <code>straw buckets</code> 在修改嵌套项目时可实现最佳数据移动。</p>
<p><code>straw buckets</code> 的中代码在于签长的计算与选择。相关函数为 <code>int crush_calc_straw(struct crush_map* map, struct crush_bucket_straw* bucket)</code> 。</p>
<p><strong>选择元素的相关伪代码如下:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max_x = <span class="number">-1</span></span><br><span class="line">max_item = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> each item:</span><br><span class="line">　　x = hash(input, r)</span><br><span class="line">　　x = x * item_straw</span><br><span class="line">　　<span class="keyword">if</span> x &gt; max_x</span><br><span class="line">　　　　max_x = x</span><br><span class="line">　　　　max_item = item</span><br><span class="line"><span class="keyword">return</span> max_item</span><br></pre></td></tr></table></figure>


<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_straw* <span class="title function_">crush_make_straw_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_straw_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_straw_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_straw_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_straw_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_straw_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_straw* bucket, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    __u32 i;</span><br><span class="line">    <span class="type">int</span> high = <span class="number">0</span>;</span><br><span class="line">    __u64 high_draw = <span class="number">0</span>;</span><br><span class="line">    __u64 draw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;h.size; i++) &#123;</span><br><span class="line">        draw = crush_hash32_3(bucket-&gt;h.hash, x, bucket-&gt;h.items[i], r);</span><br><span class="line">        draw &amp;= <span class="number">0xffff</span>;</span><br><span class="line">        draw *= bucket-&gt;straws[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || draw &gt; high_draw) &#123;</span><br><span class="line">            high = i;</span><br><span class="line">            high_draw = draw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-5、Straw2-Buckets"><a href="#3-5、Straw2-Buckets" class="headerlink" title="3.5、Straw2 Buckets"></a>3.5、Straw2 Buckets</h2><p>默认的 bucket 算法。</p>
<p><strong>选择元素的相关伪代码如下:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max_x = <span class="number">-1</span></span><br><span class="line">max_item = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> each item:</span><br><span class="line">　　x = hash(input, r)</span><br><span class="line">　　x = ln(x/<span class="number">65536</span>) / weight</span><br><span class="line">　　<span class="keyword">if</span> x &gt; max_x</span><br><span class="line">　　　　max_x = x</span><br><span class="line">　　　　max_item = item</span><br><span class="line"><span class="keyword">return</span> max_item</span><br></pre></td></tr></table></figure>

<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_straw2* <span class="title function_">crush_make_straw2_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_straw2_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw2* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_straw2_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw2* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_straw2_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw2* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_straw2_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_straw2* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_straw2_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_straw2* bucket, <span class="type">int</span> x, <span class="type">int</span> r, <span class="comment">// 3</span></span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* arg, <span class="type">int</span> position)</span> <span class="comment">// 5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, high = <span class="number">0</span>;</span><br><span class="line">    __s64 draw, high_draw = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取 bucket 中元素的权重数组。</span></span><br><span class="line">    <span class="comment">// 就可以通过 ceph osd crush weight-set dump 命令查看预设的 weights 信息，</span></span><br><span class="line">    <span class="comment">// 如果之前没有设置过 weights ，则使用 bucket 中自带的 weights 信息。</span></span><br><span class="line">    __u32* weights = get_choose_arg_weights(bucket, arg, position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bucket 中元素索引数组。</span></span><br><span class="line">    __s32* ids = get_choose_arg_ids(bucket, arg);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;h.size; i++) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot;weight 0x%x item %d\n&quot;</span>, weights[i], ids[i]);</span><br><span class="line">        <span class="comment">// 计算 bucket 中每个元素的签长。</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 计算规则为: (2^44 * log2((hash(x, ids[i], r) &amp; 0xffff) + 1) - 2^48) / weights[i] 。</span></span><br><span class="line">        <span class="comment">// 精简后的规则为: log2(hash(x, ids[i], r) &amp; 0xffff) / weight 。</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 从这里可以看出，从 bucket 中筛选元素的时候，仅使用 bucket 中每个元素的自身的权重，不考虑其他</span></span><br><span class="line">        <span class="comment">// bucket 中的元素的权重。</span></span><br><span class="line">        <span class="keyword">if</span> (weights[i]) &#123; draw = generate_exponential_distribution(bucket-&gt;h.hash, x, ids[i], r, weights[i]); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            draw = S64_MIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到最大的签长</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || draw &gt; high_draw) &#123;</span><br><span class="line">            high = i;</span><br><span class="line">            high_draw = draw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最大签长对应的元素</span></span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="四、数据迁移实践分析"><a href="#四、数据迁移实践分析" class="headerlink" title="四、数据迁移实践分析"></a>四、数据迁移实践分析</h1><h2 id="4-1、调整-bucket-算法"><a href="#4-1、调整-bucket-算法" class="headerlink" title="4.1、调整 bucket 算法"></a>4.1、调整 bucket 算法</h2><p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 crush map</span></span><br><span class="line"><span class="built_in">rm</span> -rf crushmap.file crushmap-human.file</span><br><span class="line">ceph osd getcrushmap -o crushmap.file</span><br><span class="line">crushtool -d crushmap.file -o crushmap-human.file</span><br><span class="line"><span class="built_in">cat</span> crushmap-human.file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 crush map</span></span><br><span class="line"><span class="built_in">rm</span> -rf crushmap-modified.file</span><br><span class="line">vi crushmap-human.file</span><br><span class="line">crushtool -c crushmap-human.file -o crushmap-modified.file</span><br><span class="line">ceph osd setcrushmap -i crushmap-modified.file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整并检查 tunables 配置</span></span><br><span class="line"><span class="comment"># 可以将 tunables 设置为 hammer/jewel/default </span></span><br><span class="line"><span class="comment"># 其中 default 指的是 jewel</span></span><br><span class="line"><span class="comment"># 从 hammer 开始才开始支持 straw2 算法</span></span><br><span class="line">ceph osd crush tunables jewel</span><br><span class="line"><span class="comment"># straw_calc_version 仅支持 0 或者 1</span></span><br><span class="line">ceph osd crush set-tunable straw_calc_version 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 bucket 算法</span></span><br><span class="line">ceph osd crush dump | grep alg</span><br></pre></td></tr></table></figure>


<h2 id="4-2、触发数据迁移"><a href="#4-2、触发数据迁移" class="headerlink" title="4.2、触发数据迁移"></a>4.2、触发数据迁移</h2><p>我们可以通过调整 osd 权重来触发数据迁移。</p>
<p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新平衡数据分布</span></span><br><span class="line">ceph osd crush reweight-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份初始 pg 分布情况</span></span><br><span class="line">ceph pg dump pgs | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;printf &quot;%-10s %-10s\n&quot;, $1, $17&#125;&#x27;</span> &gt; oringin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录原始 osd 的权重</span></span><br><span class="line">ceph osd tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整 osd 的权重</span></span><br><span class="line"><span class="comment"># 下一次测试前需要重置 osd 的权重</span></span><br><span class="line">ceph osd crush reweight osd.0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待一会，再获取新的 pg 分布情况</span></span><br><span class="line">ceph pg dump pgs | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;printf &quot;%-10s %-10s\n&quot;, $1, $17&#125;&#x27;</span> &gt; new</span><br></pre></td></tr></table></figure>

<h2 id="4-3、数据分析"><a href="#4-3、数据分析" class="headerlink" title="4.3、数据分析"></a>4.3、数据分析</h2><p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用下面的脚本详细分析修改前后 pg 分布的差异</span></span><br><span class="line">./check.sh oringin new</span><br></pre></td></tr></table></figure>


<p><strong>pg 变化分析脚本:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> &lt;original_file&gt; &lt;new_file&gt;&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">original_file=<span class="variable">$1</span></span><br><span class="line">new_file=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印表头</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-8s %-12s %-12s %-12s %-12s %-12s\n&quot;</span> <span class="string">&quot;Line&quot;</span> <span class="string">&quot;Origin&quot;</span> <span class="string">&quot;New&quot;</span> <span class="string">&quot;Removed&quot;</span> <span class="string">&quot;Added&quot;</span> <span class="string">&quot;OrderChanged&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接处理diff命令的输出</span></span><br><span class="line">diff <span class="string">&quot;<span class="variable">$original_file</span>&quot;</span> <span class="string">&quot;<span class="variable">$new_file</span>&quot;</span> -y -W 50 --suppress-common-lines | <span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 提取行号</span></span><br><span class="line">    line_number=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取前后的数字列表</span></span><br><span class="line">    front_original=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span> | grep -o <span class="string">&#x27;\[[^]]*\]&#x27;</span> | <span class="built_in">head</span> -n1)</span><br><span class="line">    back_original=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span> | grep -o <span class="string">&#x27;\[[^]]*\]&#x27;</span> | <span class="built_in">tail</span> -n1)</span><br><span class="line"></span><br><span class="line">    front_array=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$front_original</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;[]&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    back_array=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$back_original</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;[]&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化输出变量</span></span><br><span class="line">    removed=<span class="string">&quot;-&quot;</span></span><br><span class="line">    added=<span class="string">&quot;-&quot;</span></span><br><span class="line">    order_changed=<span class="string">&quot;No&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出新增和删除的数字</span></span><br><span class="line">    removed_nums=()</span><br><span class="line">    added_nums=()</span><br><span class="line">    all_numbers=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;front_array[*]&#125;</span> <span class="variable">$&#123;back_array[*]&#125;</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="built_in">sort</span> -n | <span class="built_in">uniq</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="variable">$all_numbers</span>; <span class="keyword">do</span></span><br><span class="line">        count_front=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;front_array[*]&#125;</span>&quot;</span> | grep -o <span class="string">&quot;\b<span class="variable">$num</span>\b&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">        count_back=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;back_array[*]&#125;</span>&quot;</span> | grep -o <span class="string">&quot;\b<span class="variable">$num</span>\b&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (( count_front &gt; count_back )); <span class="keyword">then</span></span><br><span class="line">            removed_nums+=(<span class="string">&quot;<span class="variable">$num</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> (( count_front &lt; count_back )); <span class="keyword">then</span></span><br><span class="line">            added_nums+=(<span class="string">&quot;<span class="variable">$num</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 Removed 和 Added</span></span><br><span class="line">    [[ <span class="variable">$&#123;#removed_nums[@]&#125;</span> -gt 0 ]] &amp;&amp; removed=<span class="string">&quot;<span class="variable">$&#123;removed_nums[*]&#125;</span>&quot;</span></span><br><span class="line">    [[ <span class="variable">$&#123;#added_nums[@]&#125;</span> -gt 0 ]] &amp;&amp; added=<span class="string">&quot;<span class="variable">$&#123;added_nums[*]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出在两个数组中共同存在的元素</span></span><br><span class="line">    common_elements=()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;front_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot; <span class="variable">$&#123;back_array[*]&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$num</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            common_elements+=(<span class="string">&quot;<span class="variable">$num</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查共同元素的索引位置是否一致</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;#common_elements[@]&#125;</span> -gt 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 获取每个共同元素在两个数组中的索引</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;common_elements[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">            <span class="comment"># 在front_array中查找该元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> ((i=0; i&lt;<span class="variable">$&#123;#front_array[@]&#125;</span>; i++)); <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;front_array[$i]&#125;</span>&quot;</span> == <span class="string">&quot;<span class="variable">$num</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                    front_index=<span class="variable">$i</span></span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在back_array中查找该元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> ((i=0; i&lt;<span class="variable">$&#123;#back_array[@]&#125;</span>; i++)); <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;back_array[$i]&#125;</span>&quot;</span> == <span class="string">&quot;<span class="variable">$num</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                    back_index=<span class="variable">$i</span></span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果索引位置不同，则标记为顺序变化</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$front_index</span>&quot;</span> != <span class="string">&quot;<span class="variable">$back_index</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                order_changed=<span class="string">&quot;Yes&quot;</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出格式化结果</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;%-8s %-12s %-12s %-12s %-12s %-12s\n&quot;</span> <span class="string">&quot;<span class="variable">$line_number</span>&quot;</span> <span class="string">&quot;<span class="variable">$front_original</span>&quot;</span> <span class="string">&quot;<span class="variable">$back_original</span>&quot;</span> <span class="string">&quot;<span class="variable">$removed</span>&quot;</span> <span class="string">&quot;<span class="variable">$added</span>&quot;</span> <span class="string">&quot;<span class="variable">$order_changed</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>脚本的示例输出信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bugwz.host crush]<span class="comment"># ./check.sh oringin new</span></span><br><span class="line">Line     Origin       New          Removed      Added        OrderChanged</span><br><span class="line">2.38     [5,0,2]      [5,1,2]      0            1            No</span><br><span class="line">2.37     [0,5,2]      [1,5,2]      0            1            No</span><br><span class="line">2.35     [2,5,0]      [2,5,1]      0            1            No</span><br><span class="line">2.34     [5,3,0]      [5,3,1]      0            1            No</span><br><span class="line">2.30     [2,4,0]      [2,4,1]      0            1            No</span><br><span class="line">2.2f     [1,3,5]      [5,3,1]      -            -            Yes</span><br><span class="line">2.2d     [0,5,2]      [5,1,2]      0            1            Yes</span><br><span class="line">2.2b     [2,0,4]      [2,1,4]      0            1            No</span><br><span class="line">2.29     [1,3,5]      [4,3,1]      5            4            Yes</span><br><span class="line">2.28     [3,0,4]      [3,4,1]      0            1            Yes</span><br><span class="line">2.27     [1,3,5]      [1,3,4]      5            4            No</span><br><span class="line">2.26     [5,1,2]      [5,2,1]      -            -            Yes</span><br><span class="line">2.25     [2,1,5]      [2,5,1]      -            -            Yes</span><br><span class="line">2.24     [1,4,3]      [1,4,2]      3            2            No</span><br><span class="line">2.1f     [4,3,0]      [4,3,1]      0            1            No</span><br><span class="line">3.1e     [3,0,5]      [3,4,1]      0 5          1 4          No</span><br><span class="line">4.19     [0,2,5]      [5,2,1]      0            1            Yes</span><br><span class="line">2.1e     [3,5,0]      [3,5,1]      0            1            No</span><br><span class="line">4.18     [0,4,3]      [2,4,1]      0 3          1 2          No</span><br><span class="line">3.1c     [2,0,4]      [2,1,4]      0            1            No</span><br><span class="line">4.1b     [4,3,0]      [4,3,1]      0            1            No</span><br><span class="line">2.1c     [0,4,2]      [1,5,2]      0 4          1 5          No</span><br><span class="line">3.1d     [1,2,5]      [5,2,1]      -            -            Yes</span><br><span class="line">4.1a     [4,3,0]      [4,3,1]      0            1            No</span><br><span class="line">2.b      [5,0,3]      [5,2,1]      0 3          1 2          No</span><br><span class="line">3.a      [5,1,2]      [5,2,1]      -            -            Yes</span><br><span class="line">2.a      [5,3,0]      [5,3,1]      0            1            No</span><br><span class="line">3.b      [4,0,3]      [4,3,1]      0            1            Yes</span><br><span class="line">2.9      [3,4,0]      [3,4,1]      0            1            No</span><br><span class="line">3.8      [4,3,0]      [4,3,1]      0            1            No</span><br><span class="line">4.f      [2,4,0]      [2,4,1]      0            1            No</span><br><span class="line">2.8      [0,2,5]      [1,2,5]      0            1            No</span><br><span class="line">3.9      [0,2,5]      [3,1,5]      0 2          1 3          No</span><br><span class="line">2.7      [4,0,3]      [4,3,1]      0            1            Yes</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2023/06/30/ceph-crush/">https://bugwz.com/2023/06/30/ceph-crush/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Ceph/">Ceph</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/ceph.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"><img class="cover" src="/assets/images/bg/paper.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</div></div><div class="info-2"><div class="info-item-1">  译作: 可控的、可扩展的、分布式的副本数据放置算法，论文原文 。 该论文于 2006 年 11 月发布于 SC2006 。 CRUSH 是一种用于大规模分布式存储系统的数据分布算法，它通过伪随机函数将数据对象映射到存储设备上，无需依赖中央目录。CRUSH 算法设计考虑了系统的动态性，支持在添加或移除存储设备时高效地重组数据，并最小化不必要的数据移动。此外，CRUSH 支持多种数据复制和可靠性机制，并允许根据用户定义的策略进行数据分布，这些策略能够在故障域之间有效地分离副本，增强数据安全性。 CRUSH 的核心是其层级集群图，该图描述了存储集群的物理和逻辑结构，并通过一系列规则来确定数据的放置位置。CRUSH 算法通过将数据均匀分布在加权设备上，保持存储和设备带宽资源的平衡利用。算法还考虑了设备的故障和过载情况，能够在设备发生故障或过载时重新分配数据，避免数据丢失并优化系统性能。 CRUSH 的映射性能高效，计算复杂度为 O(logn) ，适用于管理大规模（多 PB...</div></div></div></a><a class="pagination-related" href="/2024/03/05/ceph-csi/" title="Ceph CSI 对接 K8S 指南"><img class="cover" src="/assets/images/bg/ceph.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ceph CSI 对接 K8S 指南</div></div><div class="info-2"><div class="info-item-1">一、介绍1.1、Ceph CSI 介绍Ceph CSI 插件实现了支持 CSI 的容器编排器 (CO) 与 Ceph 集群之间的接口。它们支持动态配置 Ceph 卷并将其附加到工作负载。项目地址: https://github.com/ceph/ceph-csi 。该仓库包含用于 RBD、CephFS 和 Kubernetes sidecar 部署 YAML 的 Ceph 容器存储接口 (CSI) 驱动程序，以支持 CSI 功能：provisioner、attacher、resizer、driver-registrar 和 snapper。 本文基于 Ceph CSI v3.14.1 版本进行测试。 Ceph CSI 驱动与测试过的 Kubernetes 版本信息表: (参考 known-to-work-co-platforms)    Ceph CSI 版本 Kubernetes...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="info-item-2">ceph-ansible 集群部署运维指南</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了使用 ceph-ansible 部署和运维 Ceph 集群的过程，包括各版本及其依赖的 Ansible 版本的对应关系、自定义模块与任务的结构、集群部署、运维操作及相关示例。特别强调了环境配置、节点连通性验证、MDS 和 OSD 组件的管理，以及安全和性能优化注意事项。 一、项目介绍以下分析基于 ceph-ansible stable-6.0 分支代码。 1.1、版本与对应关系目前 ceph-ansible 采用不同的代码分支来支持部署不同版本的 ceph 集群，且每个代码分支需要特定的 ansible 版本支持，具体的对应关系如下（以下对应关系更新于 2025&#x2F;05&#x2F;23 ）：    ceph-ansible 分支 支持的 ceph 版本 依赖的 ansible 核心版本 依赖的 ansible 发布版本包    stable-3.0 Jewel(V10), Luminous(V12) 2.4 -   stable-3.1 Luminous(V12), Mimic(V13) 2.4 -   stable-3.2 Luminous(V12),...</div></div></div></a><a class="pagination-related" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Ceph Crimson 集群搭建指南</div></div><div class="info-2"><div class="info-item-1">当前 ceph 集群搭建部署的方式主要有三种: ceph-ansible ，vstart.sh ， cephadm 。 其中 vstart.sh 脚本用于在开发环境中快速搭建测试集群； ceph-ansible 是一种部署 ceph 集群的老方式，支持在宿主机及容器部署的方式，目前社区已不推荐使用；cephadm 是当前最新的支持部署生产集群的方式，仅支持容器部署。接下来主要介绍通过 vstart.sh 和 cephadm 部署 crimson 集群的方式。以下测试基于 v19.2.1 版本进行。 一、vstart.sh 搭建集群vstart.sh 常用于在开发环境环境中快速搭建集群，且在部署集群前我们需要编译出对应的二进制包。由于编译环境可能会有各种依赖缺失，版本异常等问题，这里推荐使用 bugwz&#x2F;ceph-images 中提供的 CentOS Stream 9 的编译打包环境。同时后续的集群的搭建也可以在容器内部进行。 搭建集群操作步骤如下:  软件编译: 使用开发容器镜像，编译对应的 ceph 代码，产出对应的二进制运行文件； 集群部署: 在开发容器内部使用...</div></div></div></a><a class="pagination-related" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">Ceph Crimson 设计实现深入解析</div></div><div class="info-2"><div class="info-item-1">Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。 以下分析基于 v19.2.1 进行分析。 一、架构对比Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD...</div></div></div></a><a class="pagination-related" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Ceph QoS 机制深入分析</div></div><div class="info-2"><div class="info-item-1">一、CephFS QoS社区的相关实现：  基于 tokenbucket 算法的目录 QoS : https://github.com/ceph/ceph/pull/29266 基于 dmclock 算法的 subvolume QoS : 来自日本的 line 公司提出的想法，https://github.com/ceph/ceph/pull/38506 ， https://github.com/ceph/ceph/pull/52147  1.1、基于 TokenBucket 算法的目录 QoS该实现并未合并到主分支。  相关材料：  社区的原始PR: https://github.com/ceph/ceph/pull/29266  实现特点：  基于 TokenBucketThrottle 类在客户端侧实现的 TokenBucket 类型的 QoS，用于约束每个独立的客户端的访问请求； QoS 的限制粒度为每个独立的客户端，没有全局的QoS限制； 用于限制目录级别的操作 QoS； 支持 IOPS 和 BPS 的 QoS 限制，且支持突发流量； 仅支持 FUSE...</div></div></div></a><a class="pagination-related" href="/2023/06/01/ceph-test/" title="Ceph 集群性能测试工具详解"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">Ceph 集群性能测试工具详解</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了包括 rados bench、rbd bench、dd 、fio 、vdbench 、mdtest 、iozone、cosbench、cbt 等测试工具对于 Ceph 集群的性能压测的使用。对于每个工具都提供了压测命令参数、示例命令等使用说明，实现了对 Ceph 块存储、文件存储、对象存储、rados 对象存储等存储类别的性能压测。文中重点阐述了各命令的使用格式、基本功能和参数选择，为用户在 Ceph 环境中进行性能评估提供了实用指南。 一、rados bench以下基于 v19.2.1 版本进行测试。 用途:  测试 ceph rados 对象存储性能；  1.1、测试配置参数命令格式: rados bench $seconds $type [args...]  $seconds : 压测运行时间； $type : 压测类型，可选值为 write&#x2F;seq&#x2F;rand （分别代表写&#x2F;连续读&#x2F;随机读）； -p : 指定压测的目标 pool ； -b : 只有当压测类型为 write 时可用，用于设置写入 block...</div></div></div></a><a class="pagination-related" href="/2024/03/05/ceph-csi/" title="Ceph CSI 对接 K8S 指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="info-item-2">Ceph CSI 对接 K8S 指南</div></div><div class="info-2"><div class="info-item-1">一、介绍1.1、Ceph CSI 介绍Ceph CSI 插件实现了支持 CSI 的容器编排器 (CO) 与 Ceph 集群之间的接口。它们支持动态配置 Ceph 卷并将其附加到工作负载。项目地址: https://github.com/ceph/ceph-csi 。该仓库包含用于 RBD、CephFS 和 Kubernetes sidecar 部署 YAML 的 Ceph 容器存储接口 (CSI) 驱动程序，以支持 CSI 功能：provisioner、attacher、resizer、driver-registrar 和 snapper。 本文基于 Ceph CSI v3.14.1 版本进行测试。 Ceph CSI 驱动与测试过的 Kubernetes 版本信息表: (参考 known-to-work-co-platforms)    Ceph CSI 版本 Kubernetes...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81CRUSH-map-%E8%A7%A3%E6%9E%90"><span class="toc-text">一、CRUSH map 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81Tunables"><span class="toc-text">1.1、Tunables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81Devices"><span class="toc-text">1.2、Devices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81Types"><span class="toc-text">1.3、Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81Buckets"><span class="toc-text">1.4、Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E3%80%81Rules"><span class="toc-text">1.5、Rules</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99"><span class="toc-text">二、对象映射规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%88%B0-PG"><span class="toc-text">2.1、对象映射到 PG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81PG-%E6%98%A0%E5%B0%84%E5%88%B0-OSD-%E5%88%97%E8%A1%A8"><span class="toc-text">2.2、PG 映射到 OSD 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E3%80%81%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.2.1、数组空间初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E3%80%81%E8%8E%B7%E5%8F%96OSD%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2.2、获取OSD主流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E3%80%81Choose-Firstn-%E9%80%BB%E8%BE%91"><span class="toc-text">2.2.3、Choose Firstn 逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4%E3%80%81Choose-Indep-%E9%80%BB%E8%BE%91"><span class="toc-text">2.2.4、Choose Indep 逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Bucket-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、Bucket 算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81Uniform-Buckets"><span class="toc-text">3.1、Uniform Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81List-Buckets"><span class="toc-text">3.2、List Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81Tree-Buckets"><span class="toc-text">3.3、Tree Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81Straw-Buckets"><span class="toc-text">3.4、Straw Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81Straw2-Buckets"><span class="toc-text">3.5、Straw2 Buckets</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%AE%9E%E8%B7%B5%E5%88%86%E6%9E%90"><span class="toc-text">四、数据迁移实践分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E8%B0%83%E6%95%B4-bucket-%E7%AE%97%E6%B3%95"><span class="toc-text">4.1、调整 bucket 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E8%A7%A6%E5%8F%91%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-text">4.2、触发数据迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-text">4.3、数据分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 设计实现深入解析"/></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群搭建指南"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南">Ceph Crimson 集群搭建指南</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph QoS 机制深入分析"/></a><div class="content"><a class="title" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析">Ceph QoS 机制深入分析</a><time datetime="2024-10-24T16:00:00.000Z" title="发表于 2024-10-25 00:00:00">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/gpfs-csi/" title="GPFS CSI 对接 K8S 指南"><img src="/assets/images/bg/gpfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPFS CSI 对接 K8S 指南"/></a><div class="content"><a class="title" href="/2024/09/01/gpfs-csi/" title="GPFS CSI 对接 K8S 指南">GPFS CSI 对接 K8S 指南</a><time datetime="2024-08-31T16:00:00.000Z" title="发表于 2024-09-01 00:00:00">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录"><img src="/assets/images/bg/gpfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPFS 集群部署与运维记录"/></a><div class="content"><a class="title" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录">GPFS 集群部署与运维记录</a><time datetime="2024-07-31T16:00:00.000Z" title="发表于 2024-08-01 00:00:00">2024-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e0e317ec34af90884cc4dd6bb091ac0b'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: '请输入要搜索的内容',
  }, {"maxResultsPerGroup":10}))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>