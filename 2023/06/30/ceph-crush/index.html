<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ceph CRUSH 实现细节分析 | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: [译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data](https:&#x2F;&#x2F;bugwz.com&#x2F;2023&#x2F;06&#x2F;2">
<meta property="og:type" content="article">
<meta property="og:title" content="Ceph CRUSH 实现细节分析">
<meta property="og:url" content="https://bugwz.com/2023/06/30/ceph-crush/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: [译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data](https:&#x2F;&#x2F;bugwz.com&#x2F;2023&#x2F;06&#x2F;2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/ceph.png">
<meta property="article:published_time" content="2023-06-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-11T15:19:29.344Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="Ceph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/ceph.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ceph CRUSH 实现细节分析",
  "url": "https://bugwz.com/2023/06/30/ceph-crush/",
  "image": "https://bugwz.com/assets/images/bg/ceph.png",
  "datePublished": "2023-06-29T16:00:00.000Z",
  "dateModified": "2025-06-11T15:19:29.344Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2023/06/30/ceph-crush/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ceph CRUSH 实现细节分析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">132</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/ceph.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">Ceph CRUSH 实现细节分析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Ceph CRUSH 实现细节分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T16:00:00.000Z" title="发表于 2023-06-30 00:00:00">2023-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-11T15:19:29.344Z" title="更新于 2025-06-11 23:19:29">2025-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.3k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: <a href="https://bugwz.com/2023/06/20/crush">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</a> 。CRUSH map 是 Ceph 集群中一个关键的配置组件，它定义了数据如何在集群的物理硬件上分布。 CRUSH 算法使得 Ceph 能够在无需中心化或者分布式元数据管理器的情况下，高效、可靠地进行数据复制和恢复。</p>
<h1 id="一、CRUSH-map-解析"><a href="#一、CRUSH-map-解析" class="headerlink" title="一、CRUSH map 解析"></a>一、CRUSH map 解析</h1><p>CRUSH map 包含了集群的层次结构和各种规则，这些规则定义了数据应该如何在集群中分布。 CRUSH map 主要包含以下几个部分：</p>
<ul>
<li><code>Tunables</code> : 一组可用于调整 CRUSH 算法行为的参数。</li>
<li><code>Devices</code> : 定义集群中所有可用的存储设备的列表。</li>
<li><code>Types</code> : 定义存储层次结构中的不同层级类型。</li>
<li><code>Buckets</code> : 组织和管理存储设备（如 OSDs ）的逻辑容器。</li>
<li><code>Rules</code> : 定义了数据的复制方式。</li>
</ul>
<p><strong>新建 crush map 相关代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_map* <span class="title function_">crush_create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">crush_map</span>* <span class="title">m</span>;</span></span><br><span class="line">    m = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*m));</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化配置</span></span><br><span class="line">    set_optimal_crush_map(m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_optimal_crush_map</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_local_tries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_local_fallback_tries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;choose_total_tries = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_descend_once = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_vary_r = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;chooseleaf_stable = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>-&gt;allowed_bucket_algs = ((<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_UNIFORM) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_LIST) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_STRAW) | </span><br><span class="line">                                (<span class="number">1</span> &lt;&lt; CRUSH_BUCKET_STRAW2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 crush map</span></span><br><span class="line"><span class="built_in">rm</span> -rf crushmap.file crushmap-human.file</span><br><span class="line">ceph osd getcrushmap -o crushmap.file</span><br><span class="line">crushtool -d crushmap.file -o crushmap-human.file</span><br><span class="line"><span class="built_in">cat</span> crushmap-human.file</span><br></pre></td></tr></table></figure>

<p><strong>CRUSH map 示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># begin crush map</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_fallback_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_total_tries</span> <span class="number">50</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_descend_once</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_vary_r</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_stable</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">straw_calc_version</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">allowed_bucket_algs</span> <span class="number">54</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># devices</span></span><br><span class="line"><span class="string">device</span> <span class="number">0</span> <span class="string">osd.0</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">1</span> <span class="string">osd.1</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">2</span> <span class="string">osd.2</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">3</span> <span class="string">osd.3</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">4</span> <span class="string">osd.4</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">5</span> <span class="string">osd.5</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># types</span></span><br><span class="line"><span class="string">type</span> <span class="number">0</span> <span class="string">osd</span></span><br><span class="line"><span class="string">type</span> <span class="number">1</span> <span class="string">host</span></span><br><span class="line"><span class="string">type</span> <span class="number">2</span> <span class="string">chassis</span></span><br><span class="line"><span class="string">type</span> <span class="number">3</span> <span class="string">rack</span></span><br><span class="line"><span class="string">type</span> <span class="number">4</span> <span class="string">row</span></span><br><span class="line"><span class="string">type</span> <span class="number">5</span> <span class="string">pdu</span></span><br><span class="line"><span class="string">type</span> <span class="number">6</span> <span class="string">pod</span></span><br><span class="line"><span class="string">type</span> <span class="number">7</span> <span class="string">room</span></span><br><span class="line"><span class="string">type</span> <span class="number">8</span> <span class="string">datacenter</span></span><br><span class="line"><span class="string">type</span> <span class="number">9</span> <span class="string">zone</span></span><br><span class="line"><span class="string">type</span> <span class="number">10</span> <span class="string">region</span></span><br><span class="line"><span class="string">type</span> <span class="number">11</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buckets</span></span><br><span class="line"><span class="string">host</span> <span class="string">node01</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-3</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-4</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.0</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.1</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">host</span> <span class="string">node02</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-5</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-6</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.2</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.3</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">host</span> <span class="string">node03</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-7</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-8</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.4</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.5</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">root</span> <span class="string">default</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-1</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-2</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.58612</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node01</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node02</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node03</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">firstn</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># end crush map</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1、Tunables"><a href="#1-1、Tunables" class="headerlink" title="1.1、Tunables"></a>1.1、Tunables</h2><p>一组可用于调整 CRUSH 算法行为的参数。通过调整这些参数，管理员可以优化数据的分布和复制策略，以适应特定的性能需求或硬件配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># begin crush map</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_local_fallback_tries</span> <span class="number">0</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">choose_total_tries</span> <span class="number">50</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_descend_once</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_vary_r</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">chooseleaf_stable</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">straw_calc_version</span> <span class="number">1</span></span><br><span class="line"><span class="string">tunable</span> <span class="string">allowed_bucket_algs</span> <span class="number">54</span></span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>choose_local_tries</code>: 控制 CRUSH 算法在尝试找到一个本地副本（即在同一物理位置，如同一机架或同一数据中心）时的尝试次数。如果设置为 0 ，表示 CRUSH 算法不会尝试在本地找到副本。增加这个值会使算法更倾向于在本地找到副本，可能提高访问速度但减少数据分散度。</li>
<li><code>choose_local_fallback_tries</code>: 定义了在 choose_local_tries 未能找到本地副本后， CRUSH 算法尝试找到非本地副本之前的额外本地尝试次数。如果设置为 0 ，表示没有额外的本地回退尝试。增加这个值可以增加在本地找到副本的机会，同样可能影响数据的分散度和容错性。</li>
<li><code>choose_total_tries</code>: 定义了 CRUSH 算法在放弃之前尝试选择不同项的总次数。较低的值可能导致数据分布不均，而较高的值增加了计算复杂性，但可以改善数据的均匀分布。</li>
<li><code>chooseleaf_descend_once</code>: 控制 CRUSH 算法在选择叶节点（通常是存储设备）时是否只遍历树结构一次。设置为 1 时，算法只遍历一次，减少了计算量并提高了效率，但可能影响在复杂拓扑中的数据分布精度。</li>
<li><code>chooseleaf_vary_r</code>: 控制每次选择叶节点时种子是否有所变化，以增加随机性。设置为 1 时，每次选择过程的随机性增加，有助于数据的均匀分布。</li>
<li><code>chooseleaf_stable</code>: 确保相同的输入在 CRUSH 算法的不同版本中给出相同的输出。设置为 1 时，可以保持数据分布的一致性，特别是在升级或修改集群配置时。</li>
<li><code>straw_calc_version</code>: 指定使用 Straw 算法的版本， Straw 算法用于决定数据在不同存储桶之间的分配。版本 1 是较旧的版本，可能不如版本 2 在数据分布上有效和均匀。</li>
<li><code>allowed_bucket_algs</code>: 指定允许使用的 bucket 算法的位掩码。通过限制或启用特定的 bucket 算法，管理员可以根据具体的数据分布需求调整算法的使用，影响数据的分布和性能。</li>
</ul>
<h2 id="1-2、Devices"><a href="#1-2、Devices" class="headerlink" title="1.2、Devices"></a>1.2、Devices</h2><p>定义集群中所有可用的存储设备的列表。每个设备通常对应一个 OSD（Object Storage Daemon）。每个条目通常包含: 设备ID，OSD编号，类别。<strong>device 的 id 都是大于等于零的非负数。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devices</span></span><br><span class="line"><span class="string">device</span> <span class="number">0</span> <span class="string">osd.0</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">1</span> <span class="string">osd.1</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">2</span> <span class="string">osd.2</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">3</span> <span class="string">osd.3</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">4</span> <span class="string">osd.4</span> <span class="string">class</span> <span class="string">hdd</span></span><br><span class="line"><span class="string">device</span> <span class="number">5</span> <span class="string">osd.5</span> <span class="string">class</span> <span class="string">hdd</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3、Types"><a href="#1-3、Types" class="headerlink" title="1.3、Types"></a>1.3、Types</h2><p>定义存储层次结构中的不同层级类型。</p>
<p><strong>字段解析:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># types</span></span><br><span class="line"><span class="string">type</span> <span class="number">0</span> <span class="string">osd</span>         <span class="comment"># 基本存储单元，通常对应一个物理存储设备</span></span><br><span class="line"><span class="string">type</span> <span class="number">1</span> <span class="string">host</span>        <span class="comment"># 一台物理服务器或虚拟机，它可以包含一个或多个 osd</span></span><br><span class="line"><span class="string">type</span> <span class="number">2</span> <span class="string">chassis</span>     <span class="comment"># 机箱或机柜，可以包含一组服务器或多个设备</span></span><br><span class="line"><span class="string">type</span> <span class="number">3</span> <span class="string">rack</span>        <span class="comment"># 数据中心中的一个机架，通常包含多个服务器或机柜</span></span><br><span class="line"><span class="string">type</span> <span class="number">4</span> <span class="string">row</span>         <span class="comment"># 数据中心中的一行机架</span></span><br><span class="line"><span class="string">type</span> <span class="number">5</span> <span class="string">pdu</span>         <span class="comment"># 电源分配单元。不常见，可以用来表示依赖于同一电源单元的设备组</span></span><br><span class="line"><span class="string">type</span> <span class="number">6</span> <span class="string">pod</span>         <span class="comment"># 表示包含多个机架或行的更大物理单元</span></span><br><span class="line"><span class="string">type</span> <span class="number">7</span> <span class="string">room</span>        <span class="comment"># 数据中心中的一个房间，可能包含多个 pod 或行</span></span><br><span class="line"><span class="string">type</span> <span class="number">8</span> <span class="string">datacenter</span>  <span class="comment"># 整个数据中心，是物理存储资源的大集合</span></span><br><span class="line"><span class="string">type</span> <span class="number">9</span> <span class="string">zone</span>        <span class="comment"># 一个区域或集群的一部分</span></span><br><span class="line"><span class="string">type</span> <span class="number">10</span> <span class="string">region</span>     <span class="comment"># 一个更大的地理区域，可能包含多个数据中心或区域</span></span><br><span class="line"><span class="string">type</span> <span class="number">11</span> <span class="string">root</span>       <span class="comment"># CRUSH 层次结构中的最顶层，代表整个存储集群</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4、Buckets"><a href="#1-4、Buckets" class="headerlink" title="1.4、Buckets"></a>1.4、Buckets</h2><p>用来组织和管理存储设备（如 OSDs ）的逻辑容器。每个 bucket 可以包含 OSDs 或其他 buckets ，形成一个层次化的结构，这有助于定义数据在集群中的分布方式。 bucket 的设计允许 CRUSH 算法模拟物理存储的层次结构，如机架、行、数据中心等，以及在这些层次上实施数据复制和负载均衡策略。<strong>bucket 的 id 都是小于零的负数。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># buckets</span></span><br><span class="line"><span class="string">host</span> <span class="string">node01</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-3</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-4</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.19537</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.0</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">        <span class="string">item</span> <span class="string">osd.1</span> <span class="string">weight</span> <span class="number">0.09769</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">default</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">-1</span>            <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="string">id</span> <span class="number">-2</span> <span class="string">class</span> <span class="string">hdd</span>  <span class="comment"># do not change unnecessarily</span></span><br><span class="line">        <span class="comment"># weight 0.58612</span></span><br><span class="line">        <span class="string">alg</span> <span class="string">straw2</span></span><br><span class="line">        <span class="string">hash</span> <span class="number">0</span>  <span class="comment"># rjenkins1</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node01</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node02</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">        <span class="string">item</span> <span class="string">node03</span> <span class="string">weight</span> <span class="number">0.19537</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>host/root</code>: bucket 类型。对应于 CRUSH 层次结构中的一个层级，如 host、rack、datacenter 等。</li>
<li><code>node01/default</code>: bucket 名称。通常反映其在物理或逻辑结构中的角色，如 node01、default 等。</li>
<li><code>id</code>: bucket id。这个 id 在 CRUSH map 中是唯一的，用于区分不同的 buckets。</li>
<li><code>alg</code>: bucket 算法。bucket 使用特定的算法来决定如何在其包含的项（ OSDs 或其他 buckets ）之间分配数据。常见的算法包括 uniform&#x2F;list&#x2F;tree&#x2F;straw&#x2F;straw2 。<ul>
<li><code>uniform</code>: 对应 CRUSH_BUCKET_UNIFORM 。一种简单的分配策略，其中所有子项都具有相同的权重，适用于所有子项具有均等的存储容量和性能的情况。</li>
<li><code>list</code>: 对应 CRUSH_BUCKET_LIST 。按照列表中的顺序和指定的权重来分配数据，允许管理员精确控制数据分配的顺序，适用于需要按特定顺序优先分配数据的场景。</li>
<li><code>tree</code>: 对应 CRUSH_BUCKET_TREE 。基于树形结构的数据分配方法，其中数据是按层次结构递归分配的。适用于复杂的层次结构，如多层数据中心的环境，它可以有效地在多个层级上平衡数据分布。</li>
<li><code>straw</code>: 对应 CRUSH_BUCKET_STRAW 。使用一种称为 straw 算法的方法来分配数据。每个子项被赋予一个 straw ，其长度与子项的权重成比例。选择子项的概率与其 straw 的长度成正比。适用于子项之间权重差异较大的情况。</li>
<li><code>straw2</code>: 对应 CRUSH_BUCKET_STRAW2 。straw 算法的改进版本，它修正了原始 straw 算法中的一些不平衡问题，提供了更加均匀和公平的数据分配。在各种场景下都能提供更好的负载均衡和数据分散性。</li>
</ul>
</li>
<li><code>hash</code>: hash 函数。用于决定如何在 bucket 的子项之间选择。常见的哈希函数包括 rjenkins1（对应配置参数为 0 ） 。</li>
<li><code>item</code>: bucket 子项。这些子项可以是 OSDs（Object Storage Daemons）或者是其他的 buckets 。每个条目定义了子项的 ID 、权重以及其他可能的属性。</li>
</ul>
<p><strong>部分桶算法的比较:</strong></p>
<table>
<thead>
<tr>
<th align="center">桶算法</th>
<th align="center">时间复杂度</th>
<th align="center">添加</th>
<th align="center">移除</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uniform</td>
<td align="center">O(1)</td>
<td align="center">差</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">O(n)</td>
<td align="center">优</td>
<td align="center">差</td>
</tr>
<tr>
<td align="center">straw2</td>
<td align="center">O(n)</td>
<td align="center">优</td>
<td align="center">优</td>
</tr>
</tbody></table>
<h2 id="1-5、Rules"><a href="#1-5、Rules" class="headerlink" title="1.5、Rules"></a>1.5、Rules</h2><p>定义了数据的复制方式。例如，一个规则可能指定一个数据块应该被复制三次，并存储在不同的机架上以确保容错。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rules</span></span><br><span class="line"><span class="string">rule</span> <span class="string">replicated_rule</span> &#123;</span><br><span class="line">        <span class="string">id</span> <span class="number">0</span></span><br><span class="line">        <span class="string">type</span> <span class="string">replicated</span></span><br><span class="line">        <span class="string">step</span> <span class="string">take</span> <span class="string">default</span></span><br><span class="line">        <span class="string">step</span> <span class="string">chooseleaf</span> <span class="string">firstn</span> <span class="number">0</span> <span class="string">type</span> <span class="string">host</span></span><br><span class="line">        <span class="string">step</span> <span class="string">emit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># end crush map</span></span><br></pre></td></tr></table></figure>

<p><strong>字段解析:</strong></p>
<ul>
<li><code>rule</code>: rule 标记。</li>
<li><code>replicated_rule</code>: rule name。自定义的 rule 。</li>
<li><code>id</code>: rule id。规则的唯一标识符。</li>
<li><code>type</code>: rule type。可选值为 replicated&#x2F;erasure&#x2F;msr_firstn&#x2F;msr_indep 。<ul>
<li><code>replicated</code>: 最常用的规则类型，用于创建数据的多个副本。每个数据对象会在多个物理位置存储相同的副本，以提高数据的可用性和耐久性。适用于需要高数据可靠性和快速恢复能力的场景。如果一个存储节点失败，其他节点上的副本可以立即提供数据，无需复杂的恢复过程。</li>
<li><code>erasure</code>: 使用纠删码技术，将数据分割成多个数据块和校验块。这种方法可以在保持相似的容错能力的同时，比简单复制更有效地使用存储空间。适用于大规模数据存储，特别是当存储成本是一个重要考虑因素时。虽然纠删码提供了高存储效率，但其恢复过程可能比复制更复杂，对性能的影响也较大。</li>
<li><code>msr_firstn</code>: MSR (Multi-Site Replication) 是一种多站点复制策略，其中 FirstN 指的是在多个站点中选择前 N 个站点进行数据复制。适用于需要跨地理位置进行数据复制的场景，以实现灾难恢复和数据本地化。FirstN策略确保数据被复制到指定数量的最优站点，通常基于位置或其他标准选择。</li>
<li><code>msr_indep</code>: MSR (Multi-Site Replication) 是一种多站点复制策略，其中 IndeP 指数据在每个站点独立地被复制和管理，而不是选择固定数量的站点。这种模式适用于那些需要在每个站点独立管理数据的场景，允许每个站点根据本地需求和策略来优化数据存储和访问。这种类型的复制可以提高灵活性和数据自治。</li>
</ul>
</li>
<li><code>step</code>: <ul>
<li><code>take</code>: 指定了 CRUSH 算法开始选择的起点。通常，这个起点是一个 bucket ，例如一个数据中心、机架或服务器组。</li>
<li><code>chooseleaf</code>: 选择方式。选择存储数据的叶子节点。叶子节点通常是指实际存储数据的设备，如硬盘或SSD。</li>
<li><code>choose</code>: 选择方式。类似于 chooseleaf ，但不限于选择叶子节点。 choose 可以用于在任何级别的 bucket 中进行选择。该操作允许在非叶子级别进行更复杂的数据分布决策，例如在不同的数据中心或机架之间进行选择。</li>
<li><code>firstn</code>: 选择模式。指定选择的叶子节点的数量。这个数字可以是具体的数量，也可以是 0 （表示根据复制因子自动确定数量）。常用于需要固定数量副本的场景，如在多个数据中心或机架中复制数据，确保数据的高可用性和冗余。</li>
<li><code>indep</code>: 选择模式。表示每次选择都是独立的，不受之前选择的影响。这意味着即使多次执行相同的选择操作，也可能得到不同的结果。适用于需要增强随机性和分布均匀性的场景。它有助于避免因选择过程中的依赖关系而导致的数据局部化和热点问题。</li>
<li><code>type</code>: 指定叶子节点的类型，如 host、rack 等，这决定了数据复制的物理分隔程度。</li>
<li><code>emit</code>: 标志着选择过程的结束，输出最终确定的存储目标。</li>
</ul>
</li>
</ul>
<h1 id="二、对象映射规则"><a href="#二、对象映射规则" class="headerlink" title="二、对象映射规则"></a>二、对象映射规则</h1><p><strong>数据对象到 OSD 的映射主要包含两个阶段:</strong></p>
<ul>
<li>对象映射到 PG：简单的哈希。</li>
<li>PG 映射到 OSD 列表：CRUSH 伪随机算法。</li>
</ul>
<h2 id="2-1、对象映射到-PG"><a href="#2-1、对象映射到-PG" class="headerlink" title="2.1、对象映射到 PG"></a>2.1、对象映射到 PG</h2><p><strong>概要代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象的定位信息</span></span><br><span class="line"><span class="type">object_locator_t</span> <span class="title function_">oloc</span><span class="params">(pool, namespacestr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象信息</span></span><br><span class="line"><span class="type">object_t</span> <span class="title function_">oid</span><span class="params">(objstr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算对象的原始 pg id 信息</span></span><br><span class="line"><span class="type">pg_t</span> pgid = osdmap.object_locator_to_pg(oid, oloc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象的原始 pg id 信息转换为实际可存储的 pg 信息</span></span><br><span class="line"><span class="comment">// 其实是将原始 pg id 映射到 pg_num 的有效范围内</span></span><br><span class="line"><span class="type">pg_t</span> mpgid = osdmap.raw_pg_to_pg(pgid);</span><br></pre></td></tr></table></figure>

<p><strong>计算 pgid 的规则如下:</strong> （注意这里的 hashfunc 为特定 pool 的 hash 类型，目前支持 <code>linux</code> 和 <code>rjenkins</code> 这两种类型，默认为 <code>rjenkins</code>）</p>
<ul>
<li>如果 <code>oloc.hash &gt;= 0</code> : 则 <code>pgid = pg_t(oloc.hash, oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 非空 &amp;&amp; oloc.nspace 非空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.nspace + &#39;\037&#39; + oloc.key), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 非空 &amp;&amp; oloc.nspace 为空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.key), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 为空 &amp;&amp; oloc.nspace 非空</code> : 则 <code>pgid = pg_t(hashfunc(oloc.nspace + &#39;\037&#39; + oid.name), oloc.pool)</code></li>
<li>如果 <code>oloc.hash &lt; 0 &amp;&amp; oloc.key 为空 &amp;&amp; oloc.nspace 为空</code> : 则 <code>pgid = pg_t(hashfunc(oid.name), oloc.pool)</code></li>
</ul>
<p><img src="/assets/images/ceph-crush-pgid.png" alt="PGID" loading="lazy"></p>
<p><strong>计算 mpgid 的规则如下:</strong></p>
<ul>
<li>规则前提: pg_num_mask 是将 pg_num 向上取到最近的二次幂数值，然后减一得到的（pgp_num 和 pgp_num_mask 关系亦如此）。比如 pg_num&#x3D;16，则 pg_num_mask&#x3D;15； pg_num&#x3D;10，则 pg_num_mask&#x3D;15； </li>
<li>计算规则:<ul>
<li>如果 <code>(pgid.m_seed &amp; pg_num_mask) &lt; pg_num</code> ， 则 <code>mpgid.m_seed = pgid.m_seed &amp; pg_num_mask</code></li>
<li>如果 <code>(pgid.m_seed &amp; pg_num_mask) &gt;= pg_num</code> ， 则 <code>mpgid.m_seed = pgid.m_seed &amp; (pg_num_mask &gt;&gt; 1)</code></li>
</ul>
</li>
<li>参考数值计算示例:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">pgid.m_seed</th>
<th align="center">pg_num</th>
<th align="center">pg_num_mask</th>
<th align="center">(pgid.m_seed &amp; pg_num_mask) &lt; pg_num</th>
<th align="center">mpgid.m_seed</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">10</td>
<td align="center">15</td>
<td align="center">Yes</td>
<td align="center">7 &amp; 15 &#x3D; 7</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">10</td>
<td align="center">15</td>
<td align="center">No</td>
<td align="center">12 &amp; (15 &gt;&gt; 1) &#x3D; 4</td>
</tr>
<tr>
<td align="center">133</td>
<td align="center">16</td>
<td align="center">15</td>
<td align="center">Yes</td>
<td align="center">133 &amp; 15 &#x3D; 5</td>
</tr>
</tbody></table>
<p><strong>对象映射到 PG 的相关代码实现:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_locator_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// You specify either the hash or the key -- not both</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">int64_t</span> pool;    <span class="comment">// pool id</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key;      <span class="comment">// key string (if non-empty)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> nspace;   <span class="comment">// namespace</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="type">int64_t</span> hash;    <span class="comment">// hash position (if &gt;= 0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pg_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> m_pool;</span><br><span class="line">    <span class="type">uint32_t</span> m_seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pg_t</span> <span class="title function_">OSDMap::object_locator_to_pg</span><span class="params">(<span class="type">const</span> <span class="type">object_t</span>&amp; oid, <span class="type">const</span> <span class="type">object_locator_t</span>&amp; loc)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pg_t</span> pg;</span><br><span class="line">    <span class="type">int</span> ret = object_locator_to_pg(oid, loc, pg);</span><br><span class="line">    ceph_assert(ret == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> pg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">OSDMap::object_locator_to_pg</span><span class="params">(<span class="type">const</span> <span class="type">object_t</span>&amp; oid, <span class="type">const</span> <span class="type">object_locator_t</span>&amp; loc, <span class="type">pg_t</span>&amp; pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (loc.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!get_pg_pool(loc.get_pool())) &#123;</span><br><span class="line">            <span class="keyword">return</span> -ENOENT;</span><br><span class="line">        &#125;</span><br><span class="line">        pg = <span class="type">pg_t</span>(loc.hash, loc.get_pool());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map_to_pg(loc.get_pool(), oid.name, loc.key, loc.nspace, &amp;pg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapping</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">OSDMap::map_to_pg</span><span class="params">(<span class="type">int64_t</span> poolid, <span class="type">const</span> <span class="built_in">string</span>&amp; name, <span class="type">const</span> <span class="built_in">string</span>&amp; key, <span class="type">const</span> <span class="built_in">string</span>&amp; nspace, <span class="type">pg_t</span>* pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// calculate ps (placement seed)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">pg_pool_t</span>* pool = get_pg_pool(poolid);</span><br><span class="line">    <span class="keyword">if</span> (!pool) <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="type">ps_t</span> ps;</span><br><span class="line">    <span class="keyword">if</span> (!key.empty())</span><br><span class="line">        ps = pool-&gt;hash_key(key, nspace);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ps = pool-&gt;hash_key(name, nspace);</span><br><span class="line">    *pg = <span class="type">pg_t</span>(ps, poolid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pg_t</span> <span class="title function_">pg_pool_t::raw_pg_to_pg</span><span class="params">(<span class="type">pg_t</span> pg)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    pg.set_ps(ceph_stable_mod(pg.ps(), pg_num, pg_num_mask));</span><br><span class="line">    <span class="keyword">return</span> pg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ceph_stable_mod</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> b, <span class="type">int</span> bmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &amp; bmask) &lt; b)</span><br><span class="line">        <span class="keyword">return</span> x &amp; bmask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (bmask &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pg_pool_t::calc_pg_masks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pg_num_mask = (<span class="number">1</span> &lt;&lt; cbits(pg_num - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    pgp_num_mask = (<span class="number">1</span> &lt;&lt; cbits(pgp_num - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、PG-映射到-OSD-列表"><a href="#2-2、PG-映射到-OSD-列表" class="headerlink" title="2.2、PG 映射到 OSD 列表"></a>2.2、PG 映射到 OSD 列表</h2><p><strong>概要代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; up, acting;</span><br><span class="line"><span class="type">int</span> up_p, acting_p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 PG 映射的 OSD 列表</span></span><br><span class="line">osdmap.pg_to_up_acting_osds(mpgid, &amp;up, &amp;up_p, &amp;acting, &amp;acting_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_do_rule_no_retry</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> ruleno, <span class="type">int</span> x, <span class="type">int</span>* result, <span class="type">int</span> result_max, <span class="type">const</span> __u32* weight, <span class="type">int</span> weight_max, <span class="type">void</span>* cwin, <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* choose_args)</span></span><br></pre></td></tr></table></figure>


<p><strong>在处理 crush rule 的时候，内部会针对不同的操作类型执行不同的操作，相关的操作类型如下:</strong></p>
<ul>
<li><code>CRUSH_RULE_SET_CHOOSE_TRIES</code>: 对应操作为 <code>step set_choose_tries</code> ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_TRIES</code>: 对应操作为 <code>step set_choose_local_tries</code> ， 会覆盖 chooseleaf_descend_once 参数， 相关的参数还有 choose_total_tries ；</li>
<li><code>CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES</code>: 对应操作为 <code>step set_choose_local_tries</code> ；</li>
<li><code>CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES</code>: 对应操作为 <code>step set_choose_local_fallback_tries</code> ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_VARY_R</code>: 对应操作为 <code>step set_chooseleaf_vary_r</code>，对应配置为 chooseleaf_vary_r ；</li>
<li><code>CRUSH_RULE_SET_CHOOSELEAF_STABLE</code>: 对应操作为 <code>step set_chooseleaf_stable</code>， 对应配置为 chooseleaf_stable ；</li>
<li><code>CRUSH_RULE_TAKE</code>: 对应操作为 <code>step take</code> ；</li>
<li><code>CRUSH_RULE_CHOOSELEAF_FIRSTN</code>: 对应操作为 <code>step chooseleaf firstn</code> ；</li>
<li><code>CRUSH_RULE_CHOOSE_FIRSTN</code>: 对应操作为 <code>step choose firstn</code> ；</li>
<li><code>CRUSH_RULE_CHOOSELEAF_INDEP</code>: 对应操作为 <code>step chooseleaf indep</code> ；</li>
<li><code>CRUSH_RULE_CHOOSE_INDEP</code>: 对应操作为 <code>step choose indep</code> ；</li>
<li><code>CRUSH_RULE_EMIT</code>: 对应操作为 <code>step emit</code> ；</li>
</ul>
<p><strong>PG 映射到 OSD 列表的相关代码实现:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> OSDMap::_pg_to_raw_osds(<span class="type">const</span> <span class="type">pg_pool_t</span>&amp; pool, <span class="type">pg_t</span> pg, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;* osds, <span class="type">ps_t</span>* ppps) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// placement ps</span></span><br><span class="line">    <span class="type">ps_t</span> pps = pool.raw_pg_to_pps(pg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: pool 副本数量</span></span><br><span class="line">    <span class="type">unsigned</span> size = pool.get_size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应 crush role id</span></span><br><span class="line">    <span class="type">int</span> ruleno = pool.get_crush_rule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (ruleno &gt;= <span class="number">0</span>) crush-&gt;do_rule(ruleno, pps, *osds, size, osd_weight, pg.pool());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除不存在的 OSDs</span></span><br><span class="line">    _remove_nonexistent_osds(pool, *osds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppps) *ppps = pps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename WeightVector&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_rule</span><span class="params">(<span class="type">int</span> rule, <span class="type">int</span> x, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; out, <span class="type">int</span> maxout, <span class="type">const</span> WeightVector&amp; weight, <span class="type">uint64_t</span> choose_args_index)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rawout[maxout];</span><br><span class="line">    <span class="type">char</span> work[crush_work_size(crush, maxout)];</span><br><span class="line">    crush_init_workspace(crush, work);</span><br><span class="line">    crush_choose_arg_map arg_map = choose_args_get_with_fallback(choose_args_index);</span><br><span class="line">    <span class="type">int</span> numrep = crush_do_rule(crush, rule, x, rawout, maxout, <span class="built_in">std</span>::data(weight), <span class="built_in">std</span>::size(weight), work, arg_map.args);</span><br><span class="line">    <span class="keyword">if</span> (numrep &lt; <span class="number">0</span>) numrep = <span class="number">0</span>;</span><br><span class="line">    out.resize(numrep);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numrep; i++) out[i] = rawout[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_do_rule</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="type">int</span> ruleno, <span class="type">int</span> x, <span class="type">int</span>* result, <span class="type">int</span> result_max, <span class="type">const</span> __u32* weight, <span class="type">int</span> weight_max, <span class="type">void</span>* cwin, <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* choose_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">crush_rule</span>* <span class="title">rule</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((__u32)ruleno &gt;= <span class="built_in">map</span>-&gt;max_rules) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot; bad ruleno %d\n&quot;</span>, ruleno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rule = <span class="built_in">map</span>-&gt;rules[ruleno];</span><br><span class="line">    <span class="keyword">if</span> (rule_type_is_msr(rule-&gt;type)) &#123;</span><br><span class="line">        <span class="comment">// 处理 CRUSH_RULE_TYPE_MSR_FIRSTN 和 CRUSH_RULE_TYPE_MSR_INDEP 类型的 rule</span></span><br><span class="line">        <span class="keyword">return</span> crush_msr_do_rule(<span class="built_in">map</span>, ruleno, x, result, result_max, weight, weight_max, cwin, choose_args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 CRUSH_RULE_TYPE_REPLICATED 和 CRUSH_RULE_TYPE_ERASURE 类型的 rule</span></span><br><span class="line">        <span class="keyword">return</span> crush_do_rule_no_retry(<span class="built_in">map</span>, ruleno, x, result, result_max, weight, weight_max, cwin, choose_args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_bucket_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket* in, <span class="keyword">struct</span> crush_work_bucket* work, <span class="type">int</span> x, <span class="type">int</span> r, <span class="type">const</span> <span class="keyword">struct</span> crush_choose_arg* arg, <span class="type">int</span> position)</span></span><br><span class="line">&#123;</span><br><span class="line">    dprintk(<span class="string">&quot; crush_bucket_choose %d x=%d r=%d\n&quot;</span>, in-&gt;id, x, r);</span><br><span class="line">    BUG_ON(in-&gt;size == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">switch</span> (in-&gt;alg) &#123;</span><br><span class="line">    <span class="keyword">case</span> CRUSH_BUCKET_UNIFORM: <span class="keyword">return</span> bucket_uniform_choose((<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_uniform*)in, work, x, r);</span><br><span class="line">    <span class="keyword">case</span> CRUSH_BUCKET_LIST: <span class="keyword">return</span> bucket_list_choose((<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_list*)in, x, r);</span><br><span class="line">    <span class="keyword">case</span> CRUSH_BUCKET_TREE: <span class="keyword">return</span> bucket_tree_choose((<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_tree*)in, x, r);</span><br><span class="line">    <span class="keyword">case</span> CRUSH_BUCKET_STRAW: <span class="keyword">return</span> bucket_straw_choose((<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_straw*)in, x, r);</span><br><span class="line">    <span class="keyword">case</span> CRUSH_BUCKET_STRAW2: <span class="keyword">return</span> bucket_straw2_choose((<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_straw2*)in, x, r, arg, position);</span><br><span class="line">    <span class="keyword">default</span>: dprintk(<span class="string">&quot;unknown bucket %d alg %d\n&quot;</span>, in-&gt;id, in-&gt;alg); <span class="keyword">return</span> in-&gt;items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h1 id="三、Bucket-算法分析"><a href="#三、Bucket-算法分析" class="headerlink" title="三、Bucket 算法分析"></a>三、Bucket 算法分析</h1><h2 id="3-1、Uniform-Buckets"><a href="#3-1、Uniform-Buckets" class="headerlink" title="3.1、Uniform Buckets"></a>3.1、Uniform Buckets</h2><p>在大型系统中，很少单独添加设备。相反，新的存储通常以相同设备块的形式部署，通常是服务器机架中的附加机架，或者整个机柜。达到使用寿命的设备通常会以类似的方式作为一组设备退役（个别故障除外），因此将它们视为一个单元是很自然的。在这种情况下，CRUSH 统一桶用于表示一组相同的设备。这样做的主要优势在于性能：CRUSH 可以在常数时间内将副本映射到统一桶中。如果一致性限制不适用，可以使用其他类型的桶。</p>
<p>给定 CRUSH 输入值 x 和副本数量 r，我们使用函数 c(r, x) &#x3D; (hash(x) + rp) mod m，从大小为 m 的均匀存储桶中选择一个项目，其中 p 是随机（但确定性地）选择的大于 m 的素数。对于任何 r ≤ m，我们可以通过一些简单的数论引理证明，我们总是会选择一个不同的项目。当 r &gt; m 时，此保证不再成立，这意味着具有相同输入 x 的两个不同副本 r 可能解析为同一个项目。实际上，这只不过意味着碰撞概率不为零，以及随后的放置算法会进行回溯（参见第 3.2.1 节）。</p>
<p>如果统一存储桶的大小发生变化，则设备之间的数据将完全重新排列，就像传统的基于哈希的分发策略一样。</p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_uniform* <span class="title function_">crush_make_uniform_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span> item_weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_uniform_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_uniform_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_uniform_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_uniform_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_uniform* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_uniform_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_uniform* bucket, <span class="keyword">struct</span> crush_work_bucket* work, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bucket_perm_choose(&amp;bucket-&gt;h, work, x, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 为 _pg_to_raw_osds 函数中计算出的 pps</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_perm_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket* bucket, <span class="keyword">struct</span> crush_work_bucket* work, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 r 的值限制在 bucket 的大小范围内</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pr = r % bucket-&gt;size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次需要为 x 从 bucket 中选择多个 item ， 为此我们将 x 记录到 work-&gt;perm_x 字段中，</span></span><br><span class="line">    <span class="comment">// 因此如果 work-&gt;perm_x 发生了变更，则代表需要为新的 x 选择 item ，需要重新计算排列。</span></span><br><span class="line">    <span class="keyword">if</span> (work-&gt;perm_x != (__u32)x || work-&gt;perm_n == <span class="number">0</span>) &#123;</span><br><span class="line">        dprintk(<span class="string">&quot;bucket %d new x=%d\n&quot;</span>, bucket-&gt;id, x);</span><br><span class="line">        work-&gt;perm_x = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 pr 为 0 （即第一个副本），直接使用哈希函数计算一个索引，这是一个优化，因为大多数调用都是请求第一个副本。</span></span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="number">0</span>) &#123;</span><br><span class="line">            s = crush_hash32_3(bucket-&gt;hash, x, bucket-&gt;id, <span class="number">0</span>) % bucket-&gt;size;</span><br><span class="line">            work-&gt;perm[<span class="number">0</span>] = s;</span><br><span class="line">            work-&gt;perm_n = <span class="number">0xffff</span>; <span class="comment">/* magic value, see below */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 pr 不为 0 ，且是新的序列，则初始化排列数组 perm ，使其包含从 0 到 bucket-&gt;size-1 的整数，</span></span><br><span class="line">        <span class="comment">// 并且设置当前 work 中已经选择的 item 数量为 0 。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;size; i++) work-&gt;perm[i] = i;</span><br><span class="line">        work-&gt;perm_n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前处理过 pr 为 0 的情况，则当前为第二次调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (work-&gt;perm_n == <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化排列数组中下标 0 之后的位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; bucket-&gt;size; i++) work-&gt;perm[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于当 pr 为 0 的时候（即第一次计算 x 的排列数组的情况），已经获取了 bucket 中索引 s ，并将</span></span><br><span class="line">        <span class="comment">// 该值记录到 work-&gt;perm[0] （即 work-&gt;perm[0] = s ），为了避免 work-&gt;perm 数组中出现 bucket 中</span></span><br><span class="line">        <span class="comment">// 重复的索引，所以需要将 work-&gt;perm[s] 中记录的值设置为 bucket 的索引 0，即 work-&gt;perm[s] = 0 。</span></span><br><span class="line">        work-&gt;perm[work-&gt;perm[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 work 中已经获取的 item 数量为 1 。</span></span><br><span class="line">        work-&gt;perm_n = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; work-&gt;perm_n; i++) dprintk(<span class="string">&quot; perm_choose have %d: %d\n&quot;</span>, i, work-&gt;perm[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个条件检查当前已生成的排列长度（ work-&gt;perm_n ）是否小于或等于所需的副本位置 pr 。</span></span><br><span class="line">    <span class="comment">// 如果是，需要继续生成排列直到达到这个位置。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 通过不断交换元素位置，生成一个伪随机的排列，直到生成足够长的排列以覆盖所需的副本位置 pr 。</span></span><br><span class="line">    <span class="comment">// 确保了数据的均匀分布和访问的随机性，是 CRUSH 算法处理数据分布的关键机制。</span></span><br><span class="line">    <span class="keyword">while</span> (work-&gt;perm_n &lt;= pr) &#123;</span><br><span class="line">        <span class="comment">// 这里 p 是当前排列的长度，即下一个要处理的排列位置。</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> p = work-&gt;perm_n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 p 已经是最后一个元素的位置，则没有后续元素可以与之交换，因此不执行交换。</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; bucket-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用哈希函数 crush_hash32_3 基于桶的哈希种子、对象标识符 x 、桶的 id 和当前位置 p 计算一个哈希值。</span></span><br><span class="line">            <span class="comment">// 然后取模操作确定在当前位置 p 之后的哪个位置与之交换。这保证了交换的随机性和均匀性。</span></span><br><span class="line">            i = crush_hash32_3(bucket-&gt;hash, x, bucket-&gt;id, p) % (bucket-&gt;size - p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 i 不为 0 （即当前位置 p 不是交换位置），则执行交换操作</span></span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> t = work-&gt;perm[p + i];</span><br><span class="line">                work-&gt;perm[p + i] = work-&gt;perm[p];</span><br><span class="line">                work-&gt;perm[p] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            dprintk(<span class="string">&quot; perm_choose swap %d with %d\n&quot;</span>, p, p + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每完成一次交换，排列长度增加 1 。</span></span><br><span class="line">        work-&gt;perm_n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucket-&gt;size; i++) dprintk(<span class="string">&quot; perm_choose  %d: %d\n&quot;</span>, i, work-&gt;perm[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从排列中获取 pr 位置的索引s，然后返回 bucket-&gt;items[s] ，即为选择的桶中的条目。</span></span><br><span class="line">    s = work-&gt;perm[pr];</span><br><span class="line">out:</span><br><span class="line">    dprintk(<span class="string">&quot; perm_choose %d sz=%d x=%d r=%d (%d) s=%d\n&quot;</span>, bucket-&gt;id, bucket-&gt;size, x, r, pr, s);</span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;items[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="3-1、List-Buckets"><a href="#3-1、List-Buckets" class="headerlink" title="3.1、List Buckets"></a>3.1、List Buckets</h2><p>列表桶将其内容构建为链表，并且可以包含具有任意权重的项目。为了放置副本，CRUSH 从列表头部开始，包含最新添加的项目，并将其权重与所有剩余项目的权重之和进行比较。根据 hash(x, r, item) 的值，要么以适当的概率选择当前项目，要么该过程继续递归地沿着列表向下进行。这种方法源自 RUSHp，将放置问题重新定义为“最近添加的”问题。“是新项目，还是旧项目？”对于不断扩展的集群来说，这是一个自然而直观的选择：要么以适当的概率将对象迁移到最新的设备，要么像以前一样保留在旧设备上。当项目添加到存储桶时，其结果是最佳的数据迁移。然而，从列表中间或尾部移除项目可能会导致大量不必要的移动，因此列表存储桶最适合于从不（或很少）收缩的情况。</p>
<p>RUSHp 算法大致相当于一个两级 CRUSH 层次结构，由一个包含多个 uniform bucket 的列表存储桶组成。其固定的集群表示形式排除了使用放置规则或 CRUSH 故障域来控制数据放置以增强可靠性的可能性。</p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_list* <span class="title function_">crush_make_list_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_list_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_list_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_list_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_list_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_list* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_list_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_list* bucket, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = bucket-&gt;h.size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 这个哈希值是随机的，但是对于相同的输入总是产生相同的输出，保证了算法的确定性。</span></span><br><span class="line">        __u64 w = crush_hash32_4(bucket-&gt;h.hash, x, bucket-&gt;h.items[i], r, bucket-&gt;h.id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希值与 0xffff 进行 AND 操作，将哈希值限制在一个较小的范围内（即 0 到 65535 ）。</span></span><br><span class="line">        w &amp;= <span class="number">0xffff</span>;</span><br><span class="line">        dprintk(<span class="string">&quot;list_choose i=%d x=%d r=%d item %d weight %x &quot;</span></span><br><span class="line">                <span class="string">&quot;sw %x rand %llx&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                x,</span><br><span class="line">                r,</span><br><span class="line">                bucket-&gt;h.items[i],</span><br><span class="line">                bucket-&gt;item_weights[i],</span><br><span class="line">                bucket-&gt;sum_weights[i],</span><br><span class="line">                w);</span><br><span class="line">        <span class="comment">// 将结果乘以到目前为止的权重总和（ bucket-&gt;sum_weights[i] ），然后右移 16 位，进行缩小。</span></span><br><span class="line">        <span class="comment">// 将哈希值缩放到一个与权重总和相关的范围内。</span></span><br><span class="line">        w *= bucket-&gt;sum_weights[i];</span><br><span class="line">        w = w &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缩小后的哈希值小于当前条目的权重，这意味着在从 0 到当前权重总和的范围内，只有当值落在当前条目</span></span><br><span class="line">        <span class="comment">// 的权重范围内时，条目才会被选中。因此，条目被选中的概率正比于它的权重相对于权重总和的比例。</span></span><br><span class="line">        <span class="keyword">if</span> (w &lt; bucket-&gt;item_weights[i]) &#123; <span class="keyword">return</span> bucket-&gt;h.items[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有条目都未被选择（理论上不应发生，除非权重配置错误），则打印错误信息，并默认返回列表中的第一个条目。</span></span><br><span class="line">    dprintk(<span class="string">&quot;bad list sums for bucket %d\n&quot;</span>, bucket-&gt;h.id);</span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-2、Tree-Buckets"><a href="#3-2、Tree-Buckets" class="headerlink" title="3.2、Tree Buckets"></a>3.2、Tree Buckets</h2><p>与任何链表数据结构一样，列表桶对于较小的项目集非常高效，但对于较大的项目集可能不太适用，因为其 O(n) 运行时间可能过长。源自 RUSHt 的树形桶通过将其项目存储在二叉树中解决了这个问题。这将放置时间缩短至 O(log n)，使其适合管理更大的设备集或嵌套桶。RUSHt 相当于一个两级 CRUSH 层次结构，由一个包含多个均匀分布桶的树形桶组成。</p>
<p>树形存储桶的结构为带权二叉搜索树，其项目位于叶子节点。每个内部节点都知道其左右子树的总权重，并根据固定策略进行标记（详见下文）。为了在存储桶中选择一个项目，CRUSH 从树的根节点开始，计算输入键 x、副本数量 r、存储桶标识符以及当前树节点（最初为根节点）的标签的哈希值。将结果与左右子树的权重比进行比较，以决定接下来要访问哪个子节点。此过程重复进行，直到到达叶子节点，此时存储桶中的相关项目将被选中。只需进行 log n 次哈希运算和节点比较即可定位项目。</p>
<p>存储桶的二叉树节点采用简单的固定策略标记二进制值，以避免在树增长或收缩时标签发生变化。树中最左边的叶子节点始终标记为“1”。每次树扩展时，旧根节点都会成为新根节点的左子节点，并且树中最左边的叶子节点始终带有标签，新的根节点的标签将旧根节点的标签向左移动一位（例如 1、10、100 等）。树右侧的标签与左侧的标签相同，只是每个值前面都添加了一个“1”。图 4 显示了一棵有六片叶子的带标签二叉树。此策略确保，当新项目添加到（或从）存储桶中，并且树增长（或收缩）时，任何现有叶子项目在二叉树中的路径只会通过在放置决策树的起始位置的根节点处添加（或删除）其他节点而改变。一旦对象被放置在特定的子树中，其最终映射将仅取决于该子树中的权重和节点标签，并且只要该子树的项目保持不变，映射就不会改变。尽管分层决策树在嵌套项目之间引入了一些额外的数据迁移，但此策略将移动保持在合理水平，同时即使对于非常大的存储桶也能提供高效的映射。</p>
<p><img src="/assets/images/ceph-crush-tree-bucket-create.png" alt="Tree Bucket" loading="lazy"></p>
<p><strong>代码解析:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> crush_bucket_tree* <span class="title function_">crush_make_tree_bucket</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> type, <span class="type">int</span> size, <span class="type">int</span>* items, <span class="type">int</span>* weights)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_add_tree_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_remove_tree_bucket_item</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">crush_adjust_tree_bucket_item_weight</span><span class="params">(<span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> item, <span class="type">int</span> weight)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">crush_reweight_tree_bucket</span><span class="params">(<span class="keyword">struct</span> crush_map* <span class="built_in">map</span>, <span class="keyword">struct</span> crush_bucket_tree* bucket)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* (binary) tree */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        h++;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定节点 x 的左子节点的位置。这里的 h 是节点 x 的高度。</span></span><br><span class="line"><span class="comment">// 首先调用 height(x) 来获取 x 的高度，然后通过减去 2^(h-1) 来找到左子节点的位置。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = height(x);</span><br><span class="line">    <span class="keyword">return</span> x - (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定节点 x 的右子节点的位置。这里的 h 是节点 x 的高度。</span></span><br><span class="line"><span class="comment">// 首先调用 height(x) 来获取 x 的高度，然后通过加上 2^(h-1) 来找到右子节点的位置。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = height(x);</span><br><span class="line">    <span class="keyword">return</span> x + (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点 x 是否是一个叶子节点（即终端节点）。</span></span><br><span class="line"><span class="comment">// 在二进制表示中，如果最低位是 1 ，则节点是叶子节点。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">terminal</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bucket_tree_choose</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> crush_bucket_tree* bucket, <span class="type">int</span> x, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    __u32 w;</span><br><span class="line">    __u64 t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根节点开始</span></span><br><span class="line">    n = bucket-&gt;num_nodes &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是叶子节点</span></span><br><span class="line">    <span class="comment">// 在二进制表示中，如果最低位是1，则节点是叶子节点。</span></span><br><span class="line">    <span class="keyword">while</span> (!terminal(n)) &#123;</span><br><span class="line">        <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前节点的权重</span></span><br><span class="line">        w = bucket-&gt;node_weights[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算哈希值，然后乘以节点的权重。</span></span><br><span class="line">        <span class="comment">// 该哈希函数考虑了桶的哈希类型、对象ID、节点索引、随机种子和桶ID。</span></span><br><span class="line">        t = (__u64)crush_hash32_4(bucket-&gt;h.hash, x, n, r, bucket-&gt;h.id) * (__u64)w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 64 位结果右移 32 位，以缩减范围，使其适应权重的规模。</span></span><br><span class="line">        t = t &gt;&gt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子节点的索引。</span></span><br><span class="line">        l = left(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计算得到的哈希值小于左子节点的权重，则选择左子节点，</span></span><br><span class="line">        <span class="comment">// 否则选择右子节点 (n = right(n);)。</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 假设当前节点权重为 0.6 ， 左子节点权重为 0.4 ， 右子节点权重为 0.2 ,</span></span><br><span class="line">        <span class="comment">// 如果当前计算的 t 为 0.3 ，可以说明要寻找的节点位于左子节点树中；</span></span><br><span class="line">        <span class="comment">// 如果当前计算的 t 为 0.5 ，可以说明要寻找的节点位于右子节点树中；</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; bucket-&gt;node_weights[l])</span><br><span class="line">            n = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n = right(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bucket-&gt;h.items[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2023/06/30/ceph-crush/">https://bugwz.com/2023/06/30/ceph-crush/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Ceph/">Ceph</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/ceph.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"><img class="cover" src="/assets/images/bg/paper.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</div></div><div class="info-2"><div class="info-item-1">  译作: 可控的、可扩展的、分布式的副本数据放置算法，论文原文 。 该论文于 2006 年 11 月发布于 SC2006 。 CRUSH 是一种用于大规模分布式存储系统的数据分布算法，它通过伪随机函数将数据对象映射到存储设备上，无需依赖中央目录。CRUSH 算法设计考虑了系统的动态性，支持在添加或移除存储设备时高效地重组数据，并最小化不必要的数据移动。此外，CRUSH 支持多种数据复制和可靠性机制，并允许根据用户定义的策略进行数据分布，这些策略能够在故障域之间有效地分离副本，增强数据安全性。 CRUSH 的核心是其层级集群图，该图描述了存储集群的物理和逻辑结构，并通过一系列规则来确定数据的放置位置。CRUSH 算法通过将数据均匀分布在加权设备上，保持存储和设备带宽资源的平衡利用。算法还考虑了设备的故障和过载情况，能够在设备发生故障或过载时重新分配数据，避免数据丢失并优化系统性能。 CRUSH 的映射性能高效，计算复杂度为 O(logn) ，适用于管理大规模（多 PB...</div></div></div></a><a class="pagination-related" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img class="cover" src="/assets/images/bg/ceph.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ceph QoS 机制深入分析</div></div><div class="info-2"><div class="info-item-1">一、CephFS QoS社区的相关实现：  基于 tokenbucket 算法的目录 QoS : https://github.com/ceph/ceph/pull/29266 基于 dmclock 算法的 subvolume QoS : 来自日本的 line 公司提出的想法，https://github.com/ceph/ceph/pull/38506 ， https://github.com/ceph/ceph/pull/52147  1.1、基于 TokenBucket 算法的目录 QoS该实现并未合并到主分支。  相关材料：  社区的原始PR: https://github.com/ceph/ceph/pull/29266  实现特点：  基于 TokenBucketThrottle 类在客户端侧实现的 TokenBucket 类型的 QoS，用于约束每个独立的客户端的访问请求； QoS 的限制粒度为每个独立的客户端，没有全局的QoS限制； 用于限制目录级别的操作 QoS； 支持 IOPS 和 BPS 的 QoS 限制，且支持突发流量； 仅支持 FUSE...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="info-item-2">ceph-ansible 集群部署运维指南</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了使用 ceph-ansible 部署和运维 Ceph 集群的过程，包括各版本及其依赖的 Ansible 版本的对应关系、自定义模块与任务的结构、集群部署、运维操作及相关示例。特别强调了环境配置、节点连通性验证、MDS 和 OSD 组件的管理，以及安全和性能优化注意事项。 一、项目介绍以下分析基于 ceph-ansible stable-6.0 分支代码。 1.1、版本与对应关系目前 ceph-ansible 采用不同的代码分支来支持部署不同版本的 ceph 集群，且每个代码分支需要特定的 ansible 版本支持，具体的对应关系如下（以下对应关系更新于 2025&#x2F;05&#x2F;23 ）：    ceph-ansible 分支 支持的 ceph 版本 依赖的 ansible 核心版本 依赖的 ansible 发布版本包    stable-3.0 Jewel(V10), Luminous(V12) 2.4 -   stable-3.1 Luminous(V12), Mimic(V13) 2.4 -   stable-3.2 Luminous(V12),...</div></div></div></a><a class="pagination-related" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">Ceph Crimson 设计实现深入解析</div></div><div class="info-2"><div class="info-item-1">Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。 以下分析基于 v19.2.1 进行分析。 一、架构对比Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD...</div></div></div></a><a class="pagination-related" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Ceph Crimson 集群搭建指南</div></div><div class="info-2"><div class="info-item-1">当前 ceph 集群搭建部署的方式主要有三种: ceph-ansible ，vstart.sh ， cephadm 。 其中 vstart.sh 脚本用于在开发环境中快速搭建测试集群； ceph-ansible 是一种部署 ceph 集群的老方式，支持在宿主机及容器部署的方式，目前社区已不推荐使用；cephadm 是当前最新的支持部署生产集群的方式，仅支持容器部署。接下来主要介绍通过 vstart.sh 和 cephadm 部署 crimson 集群的方式。以下测试基于 v19.2.1 版本进行。 一、vstart.sh 搭建集群vstart.sh 常用于在开发环境环境中快速搭建集群，且在部署集群前我们需要编译出对应的二进制包。由于编译环境可能会有各种依赖缺失，版本异常等问题，这里推荐使用 bugwz&#x2F;ceph-images 中提供的 CentOS Stream 9 的编译打包环境。同时后续的集群的搭建也可以在容器内部进行。 搭建集群操作步骤如下:  软件编译: 使用开发容器镜像，编译对应的 ceph 代码，产出对应的二进制运行文件； 集群部署: 在开发容器内部使用...</div></div></div></a><a class="pagination-related" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Ceph QoS 机制深入分析</div></div><div class="info-2"><div class="info-item-1">一、CephFS QoS社区的相关实现：  基于 tokenbucket 算法的目录 QoS : https://github.com/ceph/ceph/pull/29266 基于 dmclock 算法的 subvolume QoS : 来自日本的 line 公司提出的想法，https://github.com/ceph/ceph/pull/38506 ， https://github.com/ceph/ceph/pull/52147  1.1、基于 TokenBucket 算法的目录 QoS该实现并未合并到主分支。  相关材料：  社区的原始PR: https://github.com/ceph/ceph/pull/29266  实现特点：  基于 TokenBucketThrottle 类在客户端侧实现的 TokenBucket 类型的 QoS，用于约束每个独立的客户端的访问请求； QoS 的限制粒度为每个独立的客户端，没有全局的QoS限制； 用于限制目录级别的操作 QoS； 支持 IOPS 和 BPS 的 QoS 限制，且支持突发流量； 仅支持 FUSE...</div></div></div></a><a class="pagination-related" href="/2023/06/01/ceph-test/" title="Ceph 集群性能测试工具详解"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">Ceph 集群性能测试工具详解</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了包括 rados bench、rbd bench、dd 、fio 、vdbench 、mdtest 、iozone、cosbench、cbt 等测试工具对于 Ceph 集群的性能压测的使用。对于每个工具都提供了压测命令参数、示例命令等使用说明，实现了对 Ceph 块存储、文件存储、对象存储、rados 对象存储等存储类别的性能压测。文中重点阐述了各命令的使用格式、基本功能和参数选择，为用户在 Ceph 环境中进行性能评估提供了实用指南。 一、rados bench以下基于 v19.2.1 版本进行测试。 用途:  测试 ceph rados 对象存储性能；  1.1、测试配置参数命令格式: rados bench $seconds $type [args...]  $seconds : 压测运行时间； $type : 压测类型，可选值为 write&#x2F;seq&#x2F;rand （分别代表写&#x2F;连续读&#x2F;随机读）； -p : 指定压测的目标 pool ； -b : 只有当压测类型为 write 时可用，用于设置写入 block...</div></div></div></a><a class="pagination-related" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"><img class="cover" src="/assets/images/bg/paper.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-20</div><div class="info-item-2">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</div></div><div class="info-2"><div class="info-item-1">  译作: 可控的、可扩展的、分布式的副本数据放置算法，论文原文 。 该论文于 2006 年 11 月发布于 SC2006 。 CRUSH 是一种用于大规模分布式存储系统的数据分布算法，它通过伪随机函数将数据对象映射到存储设备上，无需依赖中央目录。CRUSH 算法设计考虑了系统的动态性，支持在添加或移除存储设备时高效地重组数据，并最小化不必要的数据移动。此外，CRUSH 支持多种数据复制和可靠性机制，并允许根据用户定义的策略进行数据分布，这些策略能够在故障域之间有效地分离副本，增强数据安全性。 CRUSH 的核心是其层级集群图，该图描述了存储集群的物理和逻辑结构，并通过一系列规则来确定数据的放置位置。CRUSH 算法通过将数据均匀分布在加权设备上，保持存储和设备带宽资源的平衡利用。算法还考虑了设备的故障和过载情况，能够在设备发生故障或过载时重新分配数据，避免数据丢失并优化系统性能。 CRUSH 的映射性能高效，计算复杂度为 O(logn) ，适用于管理大规模（多 PB...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">132</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81CRUSH-map-%E8%A7%A3%E6%9E%90"><span class="toc-text">一、CRUSH map 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81Tunables"><span class="toc-text">1.1、Tunables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81Devices"><span class="toc-text">1.2、Devices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81Types"><span class="toc-text">1.3、Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81Buckets"><span class="toc-text">1.4、Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E3%80%81Rules"><span class="toc-text">1.5、Rules</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99"><span class="toc-text">二、对象映射规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%88%B0-PG"><span class="toc-text">2.1、对象映射到 PG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81PG-%E6%98%A0%E5%B0%84%E5%88%B0-OSD-%E5%88%97%E8%A1%A8"><span class="toc-text">2.2、PG 映射到 OSD 列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Bucket-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">三、Bucket 算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81Uniform-Buckets"><span class="toc-text">3.1、Uniform Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81List-Buckets"><span class="toc-text">3.1、List Buckets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81Tree-Buckets"><span class="toc-text">3.2、Tree Buckets</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 设计实现深入解析"/></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群搭建指南"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南">Ceph Crimson 集群搭建指南</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph QoS 机制深入分析"/></a><div class="content"><a class="title" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析">Ceph QoS 机制深入分析</a><time datetime="2024-10-24T16:00:00.000Z" title="发表于 2024-10-25 00:00:00">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/30/ceph-crush/" title="Ceph CRUSH 实现细节分析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph CRUSH 实现细节分析"/></a><div class="content"><a class="title" href="/2023/06/30/ceph-crush/" title="Ceph CRUSH 实现细节分析">Ceph CRUSH 实现细节分析</a><time datetime="2023-06-29T16:00:00.000Z" title="发表于 2023-06-30 00:00:00">2023-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"><img src="/assets/images/bg/paper.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data"/></a><div class="content"><a class="title" href="/2023/06/20/crush/" title="译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data">译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</a><time datetime="2023-06-19T16:00:00.000Z" title="发表于 2023-06-20 00:00:00">2023-06-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e0e317ec34af90884cc4dd6bb091ac0b'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: '请输入要搜索的内容',
  }, {"maxResultsPerGroup":10}))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>