<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ceph 集群性能测试工具详解 | 咕咕</title><meta name="author" content="bugwz"><meta name="copyright" content="bugwz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文详细介绍了包括 rados bench、rbd bench、dd 、fio 、vdbench 、mdtest 、iozone、cosbench、cbt等测试工具对于 Ceph 集群的性能压测的使用。对于每个工具都提供了压测命令参数、示例命令等使用说明，实现了对 Ceph 块存储、文件存储、对象存储、rados 对象存储等存储类别的性能压测。文中重点阐述了各命令的使用格式、基本功能和参数选择，为">
<meta property="og:type" content="article">
<meta property="og:title" content="Ceph 集群性能测试工具详解">
<meta property="og:url" content="https://bugwz.com/2023/06/01/ceph-test/index.html">
<meta property="og:site_name" content="咕咕">
<meta property="og:description" content="本文详细介绍了包括 rados bench、rbd bench、dd 、fio 、vdbench 、mdtest 、iozone、cosbench、cbt等测试工具对于 Ceph 集群的性能压测的使用。对于每个工具都提供了压测命令参数、示例命令等使用说明，实现了对 Ceph 块存储、文件存储、对象存储、rados 对象存储等存储类别的性能压测。文中重点阐述了各命令的使用格式、基本功能和参数选择，为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/bg/ceph.png">
<meta property="article:published_time" content="2023-05-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-29T13:09:10.571Z">
<meta property="article:author" content="bugwz">
<meta property="article:tag" content="Ceph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/bg/ceph.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ceph 集群性能测试工具详解",
  "url": "https://bugwz.com/2023/06/01/ceph-test/",
  "image": "https://bugwz.com/assets/images/bg/ceph.png",
  "datePublished": "2023-05-31T16:00:00.000Z",
  "dateModified": "2025-05-29T13:09:10.571Z",
  "author": [
    {
      "@type": "Person",
      "name": "bugwz",
      "url": "https://bugwz.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/images/bg/favicon.png"><link rel="canonical" href="https://bugwz.com/2023/06/01/ceph-test/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ceph 集群性能测试工具详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/bg/ceph.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">咕咕</span></a><a class="nav-page-title" href="/"><span class="site-name">Ceph 集群性能测试工具详解</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Ceph 集群性能测试工具详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-31T16:00:00.000Z" title="发表于 2023-06-01 00:00:00">2023-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-29T13:09:10.571Z" title="更新于 2025-05-29 21:09:10">2025-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">17.3k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文详细介绍了包括 rados bench、rbd bench、dd 、fio 、vdbench 、mdtest 、iozone、cosbench、cbt 等测试工具对于 Ceph 集群的性能压测的使用。对于每个工具都提供了压测命令参数、示例命令等使用说明，实现了对 Ceph 块存储、文件存储、对象存储、rados 对象存储等存储类别的性能压测。文中重点阐述了各命令的使用格式、基本功能和参数选择，为用户在 Ceph 环境中进行性能评估提供了实用指南。</p>
<h1 id="一、rados-bench"><a href="#一、rados-bench" class="headerlink" title="一、rados bench"></a>一、rados bench</h1><p>以下基于 v19.2.1 版本进行测试。</p>
<p><strong>用途:</strong></p>
<ul>
<li>测试 ceph rados 对象存储性能；</li>
</ul>
<h2 id="1-1、测试配置参数"><a href="#1-1、测试配置参数" class="headerlink" title="1.1、测试配置参数"></a>1.1、测试配置参数</h2><p><strong>命令格式:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rados bench <span class="variable">$seconds</span> <span class="variable">$type</span> [args...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$seconds</code> : 压测运行时间；</li>
<li><code>$type</code> : 压测类型，可选值为 write&#x2F;seq&#x2F;rand （分别代表写&#x2F;连续读&#x2F;随机读）；</li>
<li><code>-p</code> : 指定压测的目标 pool ；</li>
<li><code>-b</code> : 只有当压测类型为 write 时可用，用于设置写入 block 的大小，默认为 4M；</li>
<li><code>-O</code> : 设置写入 object 的大小，默认为 4M（与 -b 参数值相同）；</li>
<li><code>-t</code> : 并发数量，默认为 16 ；</li>
<li><code>--no-cleanup</code> : 压测数据后不清理，可用于后续测试读性能；</li>
<li><code>--run-name</code> : 压测任务名（压测任务元信息对象名）。当压测类型为 write 的时，在压测结果后会将压测的配置信息写入该名称的对象中；当压测类型为 seq&#x2F;rand 时或者启用了 –reuse-bench 参数，则会在压测开始前尝试读取该名称的对象中存储的压测元信息。当执行压测数据清理的时候也会尝试读取其中的压测元信息。其中压测元信息中包括 object_size&#x2F;finished&#x2F;prev_pid&#x2F;op_size。当对一个 pool 执行多个客户端并发压测的时候一定要指定不同的任务名，否则可能无法同时启动多个压测任务，或者会导致压测元信息持久化信息的异常；</li>
<li><code>--no-hints</code> : 默认不指定该参数；</li>
<li><code>--reuse-bench</code> : 默认不指定该参数；</li>
<li><code>--show-time</code> : 默认不指定该参数；</li>
<li><code>--write-object</code> : 只有当压测类型为 write 时可用，用于设置压测写入目标为 object ，默认写入目标为 object；</li>
<li><code>--write-omap</code> : 只有当压测类型为 write 时可用，用于设置压测写入目标为 omap；</li>
<li><code>--write-xattr</code> : 只有当压测类型为 write 时可用，用于设置压测写入目标为 xattr；</li>
</ul>
<h2 id="1-2、测试命令示例"><a href="#1-2、测试命令示例" class="headerlink" title="1.2、测试命令示例"></a>1.2、测试命令示例</h2><p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看命令详情</span></span><br><span class="line">rados bench --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 tp01 的测试 pool</span></span><br><span class="line">ceph osd pool create tp01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看池信息</span></span><br><span class="line">ceph osd pool get tp01 all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该池占用的资源</span></span><br><span class="line">rados -p tp01 <span class="built_in">df</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理测试文件</span></span><br><span class="line">rados -p tp01 cleanup</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压测写</span></span><br><span class="line">rados bench 120 write -p tp01 -b 4194304 -O 4194304 -t 16 --show-time --no-cleanup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压测顺序读</span></span><br><span class="line">rados bench 120 <span class="built_in">seq</span> -p tp01 -t 16 --show-time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压测随机读</span></span><br><span class="line">rados bench 120 rand -p tp01 -t 16 --show-time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理压测数据</span></span><br><span class="line">rados cleanup -p tp01</span><br></pre></td></tr></table></figure>

<h1 id="二、rbd-bench"><a href="#二、rbd-bench" class="headerlink" title="二、rbd bench"></a>二、rbd bench</h1><p>以下基于 v19.2.1 版本进行测试。</p>
<p><strong>用途:</strong></p>
<ul>
<li>测试块存储性能；</li>
</ul>
<h2 id="2-1、测试配置参数"><a href="#2-1、测试配置参数" class="headerlink" title="2.1、测试配置参数"></a>2.1、测试配置参数</h2><p><strong>命令格式:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd bench [-p/--pool &lt;pool&gt;] [--namespace &lt;namespace&gt;] [--image &lt;image&gt;]</span><br><span class="line">          [--io-size &lt;io-size&gt;] [--io-threads &lt;io-threads&gt;]</span><br><span class="line">          [--io-total &lt;io-total&gt;] [--io-pattern &lt;io-pattern&gt;]</span><br><span class="line">          [--rw-mix-read &lt;rw-mix-read&gt;] --io-type &lt;io-type&gt;</span><br><span class="line">          &lt;image-spec&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-p/--pool</code> : 指定压测的 pool ；</li>
<li><code>--namespace</code> : 指定压测的 namespace ；</li>
<li><code>--image</code> : 指定压测的 image ；</li>
<li><code>--io-size</code> : 每次操作 IO 的大小，可选值 &lt; 4G ， 默认为 4K ；</li>
<li><code>--io-threads</code> : 默认为 16 ；</li>
<li><code>--io-total</code> : 默认为 1G ；</li>
<li><code>--io-pattern</code> : 执行 IO 的模式，用于设置多线程情况下每个线程操作数据的起始点，可选值为 rand&#x2F;seq&#x2F;full-seq （随机的&#x2F;连续的&#x2F;完全连续的） ，默认为 seq 。rand 模式下随机设定每个线程的数据起始点。seq 模式下按照线程数量分配 image 总大小，分配给每个线程相互独立的数据范围，设置每个线程的数据起始点，实现每个线程操作自己范围内的数据。full-seq 模式下，每个线程分配的起始点为分别是 0<em>io-size , 1</em>io-size, 2*io-size 等；</li>
<li><code>--rw-mix-read</code> : 设置读写操作的比例，这里的值为读操作的比例，可选值 &lt;&#x3D; 100 ， 默认为 50 。 这里采用的概率范围计算方法，计算规则为每次执行压测的时候获取 0 到 100 以内的数字，如果获取的数字小于该值则执行读操作，如果获取的数字大于等于该值则执行写操作，通常由于 100 以内的每个数字出现的概率相同，所以可以按照数字的多少来划分概率；</li>
<li><code>--io-type</code> : 压测类型，可选值为 read&#x2F;write&#x2F;readwrite(rw) （读&#x2F;写&#x2F;读写混合）；</li>
<li><code>image-spec</code> :</li>
</ul>
<p><img src="/assets/images/ceph-test-rbd-bench-rand.png" alt="rand" loading="lazy"></p>
<p><img src="/assets/images/ceph-test-rbd-bench-seq.png" alt="seq" loading="lazy"></p>
<p><img src="/assets/images/ceph-test-rbd-bench-fullseq.png" alt="full-seq" loading="lazy"></p>
<h2 id="2-2、测试命令示例"><a href="#2-2、测试命令示例" class="headerlink" title="2.2、测试命令示例"></a>2.2、测试命令示例</h2><p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看命令详情</span></span><br><span class="line">rbd <span class="built_in">help</span> bench</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 tp02 的 pool</span></span><br><span class="line">ceph osd pool create tp02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化名为 tp02 的 pool</span></span><br><span class="line">rbd pool init tp02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 tp02 的 pool 中创建一个名为 img01 的 image， 并限制其大小为 50G</span></span><br><span class="line">rbd create tp02/img01 --size 50G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射 image 到本机</span></span><br><span class="line">rbd map tp02/img01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的 pool</span></span><br><span class="line">ceph osd lspools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 tp02 中的所有 image</span></span><br><span class="line">rbd <span class="built_in">ls</span> -p tp02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像的映射信息</span></span><br><span class="line">rbd showmapped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像信息</span></span><br><span class="line">rbd info tp02/img01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像容量</span></span><br><span class="line">rbd --pool tp02 --image img01 <span class="built_in">du</span></span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机读</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern rand --io-type <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern rand --io-type write</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序读</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern <span class="built_in">seq</span> --io-type <span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序写</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern <span class="built_in">seq</span> --io-type write</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机比例读写: 读:80%，写:20%</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern rand --io-type readwrite --rw-mix-read 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机比例读写: 读:20%，写:80%</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern rand --io-type readwrite --rw-mix-read 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序比例读写: 读:80%，写:20%</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern <span class="built_in">seq</span> --io-type readwrite --rw-mix-read 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序比例读写: 读:20%，写:80%</span></span><br><span class="line">rbd bench --pool tp02 --image img01 --io-size 4K --io-threads 16 --io-total 16G --io-pattern <span class="built_in">seq</span> --io-type readwrite --rw-mix-read 20</span><br></pre></td></tr></table></figure>


<h1 id="三、dd"><a href="#三、dd" class="headerlink" title="三、dd"></a>三、dd</h1><p><strong>用途:</strong></p>
<ul>
<li>测试裸设备存储性能；</li>
<li>测试块存储性能；</li>
<li>测试文件存储性能；</li>
</ul>
<h2 id="3-1、测试配置参数"><a href="#3-1、测试配置参数" class="headerlink" title="3.1、测试配置参数"></a>3.1、测试配置参数</h2><p><strong>命令格式:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> [OPERAND]...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bs</code> : 每次操作的字节数，该值会覆盖 ibs 和 obs ， 默认为 512 ；</li>
<li><code>cbs</code> : 每次转换的字节数；</li>
<li><code>conv</code> : 根据逗号分隔的符号列表转换文件；</li>
<li><code>count</code> : 操作的块总数量；</li>
<li><code>ibs</code> : 每次读取最多的字节数，默认为 512 ；</li>
<li><code>if</code> : 从文件中读取，而不是从标准输入中读取；</li>
<li><code>iflag</code> : 读操作的 flag 列表，以逗号分隔；</li>
<li><code>obs</code> : 每次写入字节数，默认为 512 ；</li>
<li><code>of</code> : 写入到文件，而不是写入到标准输出；</li>
<li><code>oflag</code> : 写操作的 flag 列表，以逗号分隔 ；</li>
<li><code>seek</code> : 在输出开始时跳过 N 个 obs 大小的块；</li>
<li><code>skip</code> : 在输入开始时跳过 N 个 ibs 大小的块；</li>
<li><code>status</code> : 打印到标准错误的级别信息，none 仅展示错误消息， noxfer 阻止最终传输统计信息， progress 显示周期性传输统计信息；</li>
</ul>
<p><strong>命令相关的 flag 参数如下:</strong></p>
<ul>
<li><code>append</code> : 追加模式，仅对输出有意义，建议使用 conv&#x3D;notrunc ；</li>
<li><code>direct</code> : 使用直接 I&#x2F;O 操作数据；</li>
<li><code>directory</code> : 仅支持操作目录；</li>
<li><code>dsync</code> : 使用同步 I&#x2F;O 操作数据；</li>
<li><code>sync</code> : 使用同步 I&#x2F;O 操作数据，也适用于元数据；</li>
<li><code>fullblock</code> : 累积完整的输入块，仅限 iflag ；</li>
<li><code>nonblock</code> : 使用非阻塞 I&#x2F;O ；</li>
<li><code>noatime</code> : 不更新访问时间 ；</li>
<li><code>nocache</code> : 请求丢弃缓存。另见 oflag&#x3D;sync ；</li>
<li><code>noctty</code> : 不从文件分配控制终端 ；</li>
<li><code>nofollow</code> : 不跟随符号链接；</li>
<li><code>count_bytes</code> : 将 ‘count&#x3D;N’ 视为字节计数，仅限 iflag ；</li>
<li><code>skip_bytes</code> : 将 ‘skip&#x3D;N’ 视为字节计数，仅限 iflag ；</li>
<li><code>seek_bytes</code> : 将 ‘seek&#x3D;N’ 视为字节计数，仅限 oflag ；</li>
</ul>
<p><strong>命令相关的 conv 参数如下:</strong></p>
<ul>
<li><code>ascii</code> : 从 EBCDIC 到 ASCII ；</li>
<li><code>ebcdic</code> : 从 ASCII 到 EBCDIC ；</li>
<li><code>ibm</code> : 从 ASCII 到替代 EBCDIC ；</li>
<li><code>block</code> : 用空格填充以换行符结尾的记录到 cbs 大小；</li>
<li><code>unblock</code> : 用换行符替换 cbs 大小记录中的尾随空格；</li>
<li><code>lcase</code> : 将大写字母转换为小写字母；</li>
<li><code>ucase</code> : 将小写字母转换为大写字母；</li>
<li><code>sparse</code> : 尝试在输出中为 NUL 输入块进行跳过而不是写入；</li>
<li><code>swab</code> : 交换每对输入字节；</li>
<li><code>sync</code> : 用 NUL 填充每个输入块到 ibs 大小；与 block 或 unblock 一起使用时，用空格而不是 NUL 填充；</li>
<li><code>excl</code> : 如果输出文件已存在则失败；</li>
<li><code>nocreat</code> : 不创建输出文件；</li>
<li><code>notrunc</code> : 不截断输出文件；</li>
<li><code>noerror</code> : 读取错误后继续；</li>
<li><code>fdatasync</code> : 在完成前物理写入输出文件数据；</li>
<li><code>fsync</code> : 在完成前物理写入输出文件数据，也写入元数据；</li>
</ul>
<h2 id="3-2、测试命令示例"><a href="#3-2、测试命令示例" class="headerlink" title="3.2、测试命令示例"></a>3.2、测试命令示例</h2><p>通常 dd 命令可以与 time 命令结合使用，以便于获取 dd 执行的耗时信息。</p>
<p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 sdc 盘支持的最大 I/O 块大小</span></span><br><span class="line"><span class="built_in">cat</span> /sys/block/sdc/queue/max_sectors_kb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line"><span class="built_in">sync</span>; <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1、裸设备性能测试"><a href="#3-2-1、裸设备性能测试" class="headerlink" title="3.2.1、裸设备性能测试"></a>3.2.1、裸设备性能测试</h3><p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对 /dev/sdc 裸设备进行写性能测试</span></span><br><span class="line">time <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sdc bs=1M count=50000 oflag=direct status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 /dev/sdc 裸设备进行读性能测试</span></span><br><span class="line">time <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdc of=/dev/null bs=1M count=50000 iflag=direct status=progress</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2、块存储性能测试"><a href="#3-2-2、块存储性能测试" class="headerlink" title="3.2.2、块存储性能测试"></a>3.2.2、块存储性能测试</h3><p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看硬盘信息</span></span><br><span class="line">lsblk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬盘分区</span></span><br><span class="line">sudo fdisk /dev/sdc</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对 /dev/sdc1 块设备进行写性能测试</span></span><br><span class="line">time <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sdc1 bs=1M count=50000 oflag=direct status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 /dev/sdc 块设备进行读性能测试</span></span><br><span class="line">time <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdc1 of=/dev/null bs=1M count=50000 iflag=direct status=progress</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3、文件存储性能测试"><a href="#3-2-3、文件存储性能测试" class="headerlink" title="3.2.3、文件存储性能测试"></a>3.2.3、文件存储性能测试</h3><p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看硬盘信息</span></span><br><span class="line">lsblk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬盘分区</span></span><br><span class="line">sudo fdisk /dev/sdc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区</span></span><br><span class="line">mkfs.ext4 /dev/sdc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载分区</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/data</span><br><span class="line">mount /dev/sdc1 /mnt/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动挂载，可以编辑/etc/fstab 文件，添加一条挂载分区的记录</span></span><br><span class="line">/dev/sdc1 /mnt/data ext4 defaults 0 0</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写性能测试</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/mnt/data/testfile bs=1M count=50000 oflag=direct status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读性能测试</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/mnt/data/testfile of=/dev/null bs=1M count=50000 iflag=direct status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写性能测试</span></span><br><span class="line"><span class="comment"># fdatasync 表示每次写入数据后，将数据同步到磁盘中</span></span><br><span class="line"><span class="comment"># notrunc 表示不截断输出文件</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/mnt/data/testfile bs=1M count=50000 oflag=direct conv=fdatasync,notrunc status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写限速</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1M count=100000 | pv -L 2M | <span class="built_in">dd</span> of=/mnt/data/testfile oflag=direct status=progress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读限速</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/mnt/data/testfile bs=1M count=500000 iflag=direct | pv -L 8M | <span class="built_in">dd</span> of=/dev/null status=progress</span><br></pre></td></tr></table></figure>


<h1 id="四、fio"><a href="#四、fio" class="headerlink" title="四、fio"></a>四、fio</h1><p><strong>用途:</strong></p>
<ul>
<li>测试裸设备存储性能；</li>
<li>测试块存储性能；</li>
<li>测试文件存储性能；</li>
<li>测试对象存储性能；</li>
<li>测试 ceph rados 对象存储性能；</li>
</ul>
<p><strong>以下介绍基于 fio <a target="_blank" rel="noopener" href="https://github.com/axboe/fio/tree/fio-3.40">3.40</a> 版本。</strong></p>
<p><strong>软件环境及安装:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装环境依赖</span></span><br><span class="line">dnf install -y ceph-common librbd1 librbd-devel curl openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">wget https://github.com/axboe/fio/archive/refs/tags/fio-3.40.tar.gz</span><br><span class="line">tar -zxvf fio-3.40.tar.gz</span><br><span class="line"><span class="built_in">cd</span> fio-fio-3.40</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="4-1、测试配置参数"><a href="#4-1、测试配置参数" class="headerlink" title="4.1、测试配置参数"></a>4.1、测试配置参数</h2><p><strong>命令格式:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fio [options] [job options] &lt;job file(s)&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--debug</code> : 启用调试日志。可选参数为一个或多个。process,file,io,mem,blktrace,verify,random,parse,diskutil,job,mutex,profile,time,net,rate,compress,steadystate,helperthread,zbd ；</li>
<li><code>--parse-only</code> : 仅解析选项，不启动任何 IO ；</li>
<li><code>--merge-blktrace-only</code> : 仅合并 blktrace，不启动任何 IO ；</li>
<li><code>--output</code> : 将输出写入文件；</li>
<li><code>--bandwidth-log</code> : 生成聚合带宽日志；</li>
<li><code>--minimal</code> : 最小化（简洁）输出；</li>
<li><code>--output-format=type</code> : 输出格式，可选值为 terse&#x2F;json&#x2F;json+&#x2F;normal ；</li>
<li><code>--terse-version=type</code> : 设置简洁版本输出格式，可选值为 2&#x2F;3&#x2F;4 ，默认为 3 ；</li>
<li><code>--cpuclock-test</code> : 执行 CPU 时钟的测试&#x2F;验证；</li>
<li><code>--crctest=[type]</code> : 测试校验和函数的速度；</li>
<li><code>--cmdhelp=cmd</code> : 打印命令帮助，all 表示所有命令；</li>
<li><code>--enghelp=engine</code> : 打印 ioengine 帮助，或列出可用的 ioengine ；</li>
<li><code>--enghelp=engine,cmd</code> : 打印 ioengine 命令的帮助；</li>
<li><code>--showcmd</code> : 将作业文件转换为命令行选项；</li>
<li><code>--eta=when</code> : 何时打印 ETA 估计，可选值为 always&#x2F;never&#x2F;auto ；</li>
<li><code>--eta-newline=t</code> : 每经过 t 时间强制换行；</li>
<li><code>--status-interval=t</code> : 每经过 t 时间强制完整状态转储；</li>
<li><code>--readonly</code> : 开启安全只读检查，防止写入；</li>
<li><code>--section=name</code> : 仅运行作业文件中指定的部分，可以指定多个部分；</li>
<li><code>--alloc-size=kb</code> : 将 smalloc 池设置为此大小，单位为 kb ， 默认为 16384 ；</li>
<li><code>--warnings-fatal</code> : fio 解析器警告为致命错误；</li>
<li><code>--max-jobs=nr</code> : 支持的最大线程&#x2F;进程数；</li>
<li><code>--server=args</code> : 启动后端 fio 服务器；</li>
<li><code>--daemonize=pidfile</code> : 后台运行 fio 服务器，将 pid 写入文件；</li>
<li><code>--client=hostname</code> : 与远程后端 fio 服务器在主机名通信；</li>
<li><code>--remote-config=file</code> : 告诉 fio 服务器加载此本地作业文件；</li>
<li><code>--idle-prof=option</code> : 报告系统或每个 CPU 的空闲情况（option&#x3D;system,percpu），或仅运行单位工作校准（option&#x3D;calibrate）；</li>
<li><code>--inflate-log=log</code> : 解压并输出压缩日志；</li>
<li><code>--trigger-file=file</code> : 当文件存在时执行触发命令；</li>
<li><code>--trigger-timeout=t</code> : 在此时间执行触发；</li>
<li><code>--trigger=cmd</code> : 将此命令设置为本地触发器；</li>
<li><code>--trigger-remote=cmd</code> : 将此命令设置为远程触发器；</li>
<li><code>--aux-path=path</code> : 使用此路径存储 fio 状态生成的文件；</li>
</ul>
<p><strong>支持的 io engines 列表:</strong> (使用 <code>fio --enghelp</code> 命令列出， 可使用 <code>fio --enghelp=$name</code> 命令列出对应 io engine 的参数，部分参数解释通过 AI 分析，请谨慎参考)</p>
<ul>
<li><code>cpuio</code> : 专门用于测试 CPU 性能的 I&#x2F;O 引擎。它不涉及任何实际的磁盘或网络 I&#x2F;O 操作，而是通过执行计算密集型任务来模拟 I&#x2F;O 负载。这种引擎通常用于评估 CPU 的处理能力和多线程性能；</li>
<li><code>mmap</code> : 通过内存映射文件进行 I&#x2F;O 操作。这种方法可以直接通过内存访问文件数据，适用于需要高速缓存和内存操作的测试；</li>
<li><code>sync</code> : 使用标准的同步 I&#x2F;O 系统调用（如 read() 和 write()）。这是最基本的 I&#x2F;O 引擎，适用于普通的磁盘 I&#x2F;O 性能测试；</li>
<li><code>psync</code> : 使用 POSIX 同步 I&#x2F;O 系统调用。这种引擎使用 pread() 和 pwrite()，允许进行位置指定的同步 I&#x2F;O 操作；</li>
<li><code>vsync</code> : 类似于 psync，但使用 vmsplice() 来进行数据传输，适用于需要高效数据移动的场景；</li>
<li><code>pvsync</code> : 类似于 psync，但使用 preadv() 和 pwritev() 系统调用，这些调用允许进行向量化的读写操作，即一次操作可以处理多个非连续的内存块；</li>
<li><code>pvsync2</code> : 这是 pvsync 的改进版本，使用更现代的 preadv2() 和 pwritev2() 系统调用，支持额外的标志和功能，如 RWF_NOWAIT，可以提高异步处理能力；</li>
<li><code>null</code> : 一个特殊的 I&#x2F;O 引擎，它实际上不执行任何 I&#x2F;O 操作。这可以用来测试 fio 本身的开销或用作控制组；</li>
<li><code>net</code> : 用于网络 I&#x2F;O 性能测试。这种引擎可以模拟网络数据发送和接收，用于评估网络设备和协议的性能；</li>
<li><code>netsplice</code> : 使用 splice() 和网络套接字结合的方式进行数据传输。这种方法可以直接在内核中转移数据到网络套接字，减少用户空间和内核空间之间的数据复制；</li>
<li><code>ftruncate</code> : 使用 ftruncate() 系统调用来改变文件的大小。这种引擎主要用于测试文件系统如何处理文件大小的变化，特别是在文件系统扩展和收缩时的性能；</li>
<li><code>filecreate</code> : 专注于文件创建操作。使用这个引擎可以测试文件系统创建新文件的性能，这对于评估文件系统的元数据操作性能非常重要；</li>
<li><code>filestat</code> : 用于测试文件状态操作，如使用 stat() 系统调用。这可以帮助评估文件系统在处理文件元数据查询时的效率；</li>
<li><code>filedelete</code> : 用于测试文件删除操作的性能。它可以帮助用户了解在特定存储系统上删除文件所需的时间和资源消耗；</li>
<li><code>dircreate</code> : 用于测试目录创建操作的性能。使用这个引擎可以测量创建新目录所需的时间；</li>
<li><code>dirstat</code> : 用于测试获取目录状态的操作性能，比如读取目录中的文件列表；</li>
<li><code>dirdelete</code> : 用于测试删除目录的性能；</li>
<li><code>exec</code> : 允许fio执行外部命令或脚本，这可以用来测试系统在执行特定命令或脚本时的I&#x2F;O性能；</li>
<li><code>posixaio</code> : 使用 POSIX 异步 I&#x2F;O 接口。这种引擎在多平台上提供异步 I&#x2F;O 功能，但在 Linux 上通常不如 libaio 高效；</li>
<li><code>falloc</code> : 使用 fallocate() 系统调用来预分配文件空间。这种方法可以在文件实际写入之前确保空间被分配，用于测试文件系统如何处理空间分配请求；</li>
<li><code>e4defrag</code> : 专门用于测试 ext4 文件系统的碎片整理操作。这可以帮助评估 ext4 文件系统在长时间运行后，文件碎片整理对性能的影响；</li>
<li><code>splice</code> : 使用 Linux 的 splice() 系统调用来移动数据。这种方法可以在两个文件描述符之间直接传输数据，减少数据复制操作的开销；</li>
<li><code>mtd</code> : 针对内存技术设备（Memory Technology Device）的 I&#x2F;O 引擎。MTD 设备通常是嵌入式存储设备，如闪存，不具备常见的块设备接口。这个引擎允许 fio 直接与这类设备进行交互，测试其性能，特别是在嵌入式系统或 IoT 设备中非常有用；</li>
<li><code>sg</code> : 使用 SCSI generic (sg) 接口进行 I&#x2F;O 操作的引擎。这个引擎允许 fio 直接与 SCSI 设备进行交互，绕过传统的块设备层。这对于需要直接评估 SCSI 命令性能或进行低级别 SCSI 测试的场景非常有用；</li>
<li><code>io_uring</code> : 利用 Linux 的 io_uring 接口进行 I&#x2F;O 操作。这是一种现代的异步 I&#x2F;O 接口，提供了比传统 AIO 更高的性能和更低的 CPU 使用率；</li>
<li><code>io_uring_cmd</code> : 擎利用了Linux的io_uring接口，这是一种高效的异步I&#x2F;O执行方式。io_uring_cmd引擎可以帮助开发者测试和优化使用io_uring接口的应用程序的性能；</li>
<li><code>libaio</code> : 利用 Linux 的异步 I&#x2F;O 子系统（AIO）。这种引擎可以在不阻塞应用程序的情况下提交和完成 I&#x2F;O，适用于高性能和高并发的 I&#x2F;O 测试；</li>
<li><code>rdma</code> : 使用远程直接内存访问（RDMA）技术进行数据传输。这种引擎适用于需要高性能网络通信的场景，如数据中心内部或高性能计算环境；</li>
<li><code>rados</code> : 专为测试 Ceph RADOS 存储集群设计的引擎。它直接与 Ceph 的 RADOS 层交互，用于评估 Ceph 集群的性能；</li>
<li><code>rbd</code> : 针对 Ceph 块设备（RBD）的 I&#x2F;O 引擎。它允许直接对 Ceph 块存储进行性能测试，适用于评估虚拟化环境中的存储性能；</li>
<li><code>http</code> : 使fio能够执行HTTP请求，从而测试HTTP服务器的性能。这包括了解服务器处理请求的能力，以及在高负载下的稳定性和响应时间；</li>
</ul>
<p><strong>相关参数:</strong> (使用 <code>fio --cmdhelp=all</code> 命令列出)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">description             : 文本工作描述</span><br><span class="line">name                    : 此工作的名称</span><br><span class="line">wait_for                : 此工作在开始前需要等待的工作名称</span><br><span class="line">filename                : 用于工作负载的文件</span><br><span class="line">  lockfile              : 执行 IO 时的锁文件</span><br><span class="line">directory               : 存储文件的目录</span><br><span class="line">filename_format         : 覆盖默认的 <span class="variable">$jobname</span>.<span class="variable">$jobnum</span>.<span class="variable">$filenum</span> 命名</span><br><span class="line">unique_filename         : 对于网络客户端，文件名前缀为源 IP</span><br><span class="line">opendir                 : 递归添加此目录及其下的文件</span><br><span class="line">rw                      : IO 方向，可选值为 <span class="built_in">read</span>/write/trim/randread/randwrite/randtrim/rw/readwrite/randrw/trimwrite ，默认值为 <span class="built_in">read</span> ；</span><br><span class="line">  bs                    : 块大小单位</span><br><span class="line">  ba                    : IO 块偏移对齐</span><br><span class="line">  bsrange               : 设置块大小范围（比 bs 更详细）</span><br><span class="line">  bssplit               : 设置特定的块大小混合</span><br><span class="line">  bs_unaligned          : 不对 IO 缓冲区大小进行扇区对齐</span><br><span class="line">  randrepeat            : 使用可重复的随机 IO 模式</span><br><span class="line">  randseed              : 设置随机生成器的种子值</span><br><span class="line">  norandommap           : 接受可能的重复随机块</span><br><span class="line">  ignore_error          : 设置要忽略的特定错误列表</span><br><span class="line">rw_sequencer            : IO 偏移生成器修饰符</span><br><span class="line">ioengine                : 使用的 IO 引擎</span><br><span class="line">iodepth                 : 保持在运行中的 IO 缓冲区数量</span><br><span class="line">  iodepth_batch         : 一次提交的 IO 缓冲区数量</span><br><span class="line">  iodepth_batch_complete_min: 一次检索的最小 IO 缓冲区数量</span><br><span class="line">  iodepth_batch_complete_max: 一次检索的最大 IO 缓冲区数量</span><br><span class="line">  iodepth_low           : 排队深度的低水位线</span><br><span class="line">  serialize_overlap     : 等待重叠的在运行 IO 完成</span><br><span class="line">io_submit_mode          : IO 提交和完成的方式</span><br><span class="line">size                    : 设备或文件的总大小</span><br><span class="line">io_size                 : 要执行的 I/O 总大小</span><br><span class="line">fill_device             : 写入直到发生 ENOSPC 错误</span><br><span class="line">filesize                : 单个文件的大小</span><br><span class="line">file_append             : IO 将从文件末尾开始</span><br><span class="line">offset                  : 从此偏移开始 IO</span><br><span class="line">  offset_increment      : 从一个偏移到下一个偏移的增量</span><br><span class="line">offset_align            : 从此偏移对齐开始 IO</span><br><span class="line">number_ios              : 在此 IO 数量后强制完成工作</span><br><span class="line">random_generator        : 使用的随机数生成器类型</span><br><span class="line">random_distribution     : 随机偏移分布生成器</span><br><span class="line">percentage_random       : 顺序/随机混合中应为随机的百分比</span><br><span class="line">allrandrepeat           : 对所有内容使用可重复的随机数</span><br><span class="line">nrfiles                 : 在此文件数量之间分配工作负载</span><br><span class="line">  file_service_type     : 如何选择下一个要服务的文件</span><br><span class="line">openfiles               : 同时保持打开的文件数量</span><br><span class="line">fallocate               : 布局文件时是否进行预分配</span><br><span class="line">fadvise_hint            : 使用 fadvise() 向内核建议 IO 模式</span><br><span class="line">fsync                   : 每给定块数为写入发出 fsync</span><br><span class="line">fdatasync               : 每给定块数为写入发出 fdatasync</span><br><span class="line">write_barrier           : 每第 N 次写入作为屏障写入</span><br><span class="line">sync_file_range         : 使用 sync_file_range()</span><br><span class="line">direct                  : 使用 O_DIRECT IO（否定缓冲）</span><br><span class="line">atomic                  : 使用带 O_DIRECT 的原子 IO（意味着 O_DIRECT）</span><br><span class="line">buffered                : 使用缓冲 IO（否定直接）</span><br><span class="line">  <span class="built_in">sync</span>                  : 对缓冲写入使用 O_SYNC</span><br><span class="line">overwrite               : 写入时，设置是否覆盖当前数据</span><br><span class="line">loops                   : 运行工作的次数</span><br><span class="line">numjobs                 : 复制此工作的次数</span><br><span class="line">startdelay              : 仅在此时间段过去后开始工作</span><br><span class="line">runtime                 : 在经过此时间后停止工作负载</span><br><span class="line">time_based              : 继续运行直到达到运行时间/超时</span><br><span class="line">verify_only             : 验证先前写入的数据仍然有效</span><br><span class="line">ramp_time               : 在测量性能前的加速时间</span><br><span class="line">clocksource             : 使用的时间源类型</span><br><span class="line">mem                     : IO 缓冲区的支持类型</span><br><span class="line">verify                  : 验证写入的数据</span><br><span class="line">  do_verify             : 写入后运行验证阶段</span><br><span class="line">  verify_interval       : 每 N 字节存储验证缓冲区头</span><br><span class="line">  verify_offset         : 将验证头位置偏移 N 字节</span><br><span class="line">  verify_pattern        : IO 缓冲区的填充模式</span><br><span class="line">  verify_fatal          : 在单个验证失败时退出，不继续</span><br><span class="line">  verify_dump           : 在失败时转储良好和坏块的内容</span><br><span class="line">  verify_async          : 使用的异步验证器线程数量</span><br><span class="line">  verify_backlog        : 写入此数量的块后进行验证</span><br><span class="line">  verify_backlog_batch  : 验证此数量的 IO 块</span><br><span class="line">  experimental_verify   : 启用实验性验证</span><br><span class="line">  verify_state_load     : 加载验证终止状态</span><br><span class="line">  verify_state_save     : 在终止时保存验证状态</span><br><span class="line">  trim_percentage       : 要修剪（即丢弃）的验证块数量</span><br><span class="line">    trim_verify_zero    : 验证修剪（即丢弃）的块是否返回为零</span><br><span class="line">    trim_backlog        : 写入此数量的块后进行修剪</span><br><span class="line">    trim_backlog_batch  : 修剪此数量的 IO 块</span><br><span class="line">write_iolog             : 将 IO 模式存储到文件</span><br><span class="line">read_iolog              : 从文件回放 IO 模式</span><br><span class="line">  read_iolog_chunked    : 分块解析 IO 模式</span><br><span class="line">  replay_no_stall       : 尽可能快地回放 IO 模式文件而不暂停</span><br><span class="line">  replay_redirect       : 将所有 I/O 重放到此设备，无论跟踪设备如何</span><br><span class="line">  replay_scale          : 将偏移对齐到此块大小</span><br><span class="line">  replay_align          : 按此因子缩小偏移</span><br><span class="line">  replay_time_scale     : 缩放重放事件的时间</span><br><span class="line">  replay_skip           : 跳过某些 IO 类型（读、写、修剪、刷新）</span><br><span class="line">merge_blktrace_file     : 合并的 blktrace 输出文件名</span><br><span class="line">merge_blktrace_scalars  : 缩放每个跟踪的百分比</span><br><span class="line">merge_blktrace_iters    : 每个跟踪运行的迭代次数</span><br><span class="line">exec_prerun             : 在运行工作之前执行此文件</span><br><span class="line">exec_postrun            : 在运行工作之后执行此文件</span><br><span class="line">ioscheduler             : 在支持设备上使用此 IO 调度程序</span><br><span class="line">zonemode                : zonesize、zonerange 和 zoneskip 参数的模式</span><br><span class="line">zonesize                : 每个区域读取的数据量</span><br><span class="line">zonerange               : 给出 IO 区域的大小</span><br><span class="line">zoneskip                : IO 区域之间的空间</span><br><span class="line">read_beyond_wp          : 允许读取超出区域写入指针</span><br><span class="line">max_open_zones          : 将随机写入限制为 SMR 驱动器的指定顺序区域数量</span><br><span class="line">zone_reset_threshold    : 分区块设备重置阈值</span><br><span class="line">zone_reset_frequency    : 分区块设备区域重置频率（以 HZ 为单位）</span><br><span class="line">lockmem                 : 锁定此内存量（每个工作者）</span><br><span class="line">rwmixread               : 混合工作负载中读取的百分比</span><br><span class="line">rwmixwrite              : 混合工作负载中写入的百分比</span><br><span class="line"><span class="built_in">nice</span>                    : 设置工作 CPU <span class="built_in">nice</span> 值</span><br><span class="line">prio                    : 设置工作 IO 优先级值</span><br><span class="line">prioclass               : 设置工作 IO 优先级类</span><br><span class="line">thinktime               : IO 缓冲区之间的空闲时间（微秒）</span><br><span class="line">  thinktime_spin        : 通过旋转此时间量（微秒）开始思考时间</span><br><span class="line">  thinktime_blocks      : <span class="string">&#x27;thinktime&#x27;</span> 之间的 IO 缓冲区周期</span><br><span class="line">rate                    : 设置带宽速率</span><br><span class="line">  rate_min              : 工作必须达到此速率，否则将关闭</span><br><span class="line">  rate_process          : 控制如何管理速率 IO 的进程</span><br><span class="line">  rate_cycle            : 速率限制的窗口平均值（毫秒）</span><br><span class="line">  rate_ignore_thinktime : 速率 IO 忽略思考时间设置</span><br><span class="line">rate_iops               : 将 IO 使用限制为此数量的 IO 操作/秒</span><br><span class="line">  rate_iops_min         : 工作必须达到此速率，否则将关闭</span><br><span class="line">max_latency             : 最大容忍的 IO 延迟（微秒）</span><br><span class="line">latency_target          : 支持此延迟的最大队列深度</span><br><span class="line">latency_window          : 维持 latency_target 的时间</span><br><span class="line">latency_percentile      : IO 的百分比必须低于 latency_target</span><br><span class="line">latency_run             : 不断调整队列深度以匹配 latency_target</span><br><span class="line">invalidate              : 在运行工作之前使缓冲区/页面缓存失效</span><br><span class="line">write_hint              : 设置预期的写入寿命</span><br><span class="line">create_serialize        : 序列化创建工作文件</span><br><span class="line">create_fsync            : 创建后 fsync 文件</span><br><span class="line">create_on_open          : 在打开进行 IO 时创建文件</span><br><span class="line">create_only             : 仅执行文件创建阶段</span><br><span class="line">allow_file_create       : 允许 fio 创建文件，如果它们不存在</span><br><span class="line">allow_mounted_write     : 允许写入已挂载的分区</span><br><span class="line">pre_read                : 在开始正式测试之前预读文件</span><br><span class="line">cpumask                 : CPU 亲和性掩码</span><br><span class="line">cpus_allowed            : 设置允许的 CPU</span><br><span class="line">  cpus_allowed_policy   : cpus_allowed 的分配策略</span><br><span class="line">numa_cpu_nodes          : NUMA CPU 节点绑定</span><br><span class="line">numa_mem_policy         : NUMA 内存策略设置</span><br><span class="line">end_fsync               : 在工作结束时包含 fsync</span><br><span class="line">fsync_on_close          : 关闭时 fsync 文件</span><br><span class="line"><span class="built_in">unlink</span>                  : 工作完成后取消链接创建的文件</span><br><span class="line">unlink_each_loop        : 在工作中的每个循环完成后取消链接创建的文件</span><br><span class="line">exitall                 : 当一个工作退出时终止所有工作</span><br><span class="line">exit_what               : 对 exitall 的细粒度控制</span><br><span class="line">exitall_on_error        : 当一个工作出错退出时终止所有工作</span><br><span class="line">stonewall               : 在此工作和之前的工作之间插入硬屏障</span><br><span class="line">new_group               : 标记新组的开始（用于报告）</span><br><span class="line">thread                  : 使用线程而不是进程</span><br><span class="line">per_job_logs            : 在生成的日志文件中包含工作编号与否</span><br><span class="line">write_bw_log            : 在运行期间写入带宽日志</span><br><span class="line">  bwavgtime             : 计算带宽的时间窗口（毫秒）</span><br><span class="line">write_lat_log           : 在运行期间写入延迟日志</span><br><span class="line">write_iops_log          : 在运行期间写入 IOPS 日志</span><br><span class="line">  iopsavgtime           : 计算 IOPS 的时间窗口（毫秒）</span><br><span class="line">log_avg_msec            : 在此时间段内平均 bw/iops/lat 日志</span><br><span class="line">log_hist_msec           : 以此时间值的频率转储完成延迟直方图</span><br><span class="line">log_hist_coarseness     : 范围 [0,6] 的整数。较高的粗糙度输出每个样本的直方图箱数较少。这些的箱数分别为 [1216, 608, 304, 152, 76, 38, 19]。</span><br><span class="line">write_hist_log          : 在运行期间写入延迟直方图日志</span><br><span class="line">log_max_value           : 在窗口中记录最大样本而不是平均值</span><br><span class="line">log_offset              : 为每个日志条目包含 IO 的偏移</span><br><span class="line">log_compression         : 以此大小的压缩块记录</span><br><span class="line">  log_compression_cpus  : 将日志压缩限制在这些 CPU 上</span><br><span class="line">log_store_compressed    : 以压缩格式存储日志</span><br><span class="line">log_unix_epoch          : 在日志文件中使用 Unix 时间</span><br><span class="line">block_error_percentiles : 记录修剪块错误并制作直方图</span><br><span class="line">group_reporting         : 按组进行报告</span><br><span class="line">stats                   : 启用统计数据收集</span><br><span class="line">zero_buffers            : 将 IO 缓冲区初始化为全零</span><br><span class="line">refill_buffers          : 在每次 IO 提交时重新填充 IO 缓冲区</span><br><span class="line">scramble_buffers        : 在每次 IO 提交时稍微扰乱缓冲区</span><br><span class="line">buffer_pattern          : IO 缓冲区的填充模式</span><br><span class="line">buffer_compress_percentage: 缓冲区的可压缩性（大约）</span><br><span class="line">  buffer_compress_chunk : 缓冲区中可压缩区域的大小</span><br><span class="line">dedupe_percentage       : 可去重的缓冲区百分比</span><br><span class="line">clat_percentiles        : 启用完成延迟百分位数的报告</span><br><span class="line">lat_percentiles         : 启用 IO 延迟百分位数的报告</span><br><span class="line">slat_percentiles        : 启用提交延迟百分位数的报告</span><br><span class="line">percentile_list         : 指定要报告的完成延迟和块错误的自定义百分位数列表</span><br><span class="line">significant_figures     : 输出格式设置为正常的有效数字</span><br><span class="line">disk_util               : 记录磁盘利用率统计</span><br><span class="line">gtod_reduce             : 大大减少 gettimeofday() 调用的数量</span><br><span class="line">  disable_lat           : 禁用延迟数字</span><br><span class="line">  disable_clat          : 禁用完成延迟数字</span><br><span class="line">  disable_slat          : 禁用提交延迟数字</span><br><span class="line">  disable_bw_measurement: 禁用带宽记录</span><br><span class="line">gtod_cpu                : 在此 CPU 上设置专用的 gettimeofday() 线程</span><br><span class="line">unified_rw_reporting    : 统一跨数据方向的报告</span><br><span class="line">continue_on_error       : 在 IO 期间的非致命错误上继续</span><br><span class="line">error_dump              : 转储每个错误的信息</span><br><span class="line">profile                 : 选择特定的内置性能测试</span><br><span class="line">cgroup                  : 将工作添加到此名称的 cgroup</span><br><span class="line">  cgroup_nodelete       : 工作完成后不删除 cgroup</span><br><span class="line">  cgroup_weight         : 使用给定的 cgroup 权重</span><br><span class="line">uid                     : 使用此用户 ID 运行工作</span><br><span class="line">gid                     : 使用此组 ID 运行工作</span><br><span class="line">kb_base                 : 数据量的单位前缀解释（IEC 和 SI）</span><br><span class="line">unit_base               : 结果摘要数据的位倍数（字节为 8，位为 1）</span><br><span class="line">hugepage-size           : 使用大页时，指定每页的大小</span><br><span class="line">flow_id                 : 使用的流索引 ID</span><br><span class="line">  flow                  : 此工作的流控制权重</span><br><span class="line">  flow_watermark        : 流控制的高水位线。此选项应为所有具有非零流的线程设置为相同值。</span><br><span class="line">  flow_sleep            : 在被流控制机制阻止后休眠的微秒数</span><br><span class="line">steadystate             : 定义判断工作何时达到稳态的标准和限制</span><br><span class="line">  steadystate_duration  : 在达到稳态指定持续时间后停止工作负载</span><br><span class="line">  steadystate_ramp_time : 数据收集的延迟时间，用于稳态工作终止测试</span><br></pre></td></tr></table></figure>


<h2 id="4-2、测试命令示例"><a href="#4-2、测试命令示例" class="headerlink" title="4.2、测试命令示例"></a>4.2、测试命令示例</h2><h3 id="4-2-1、裸设备-x2F-块存储性能测试"><a href="#4-2-1、裸设备-x2F-块存储性能测试" class="headerlink" title="4.2.1、裸设备&#x2F;块存储性能测试"></a>4.2.1、裸设备&#x2F;块存储性能测试</h3><p><strong>测试命令(使用 libaio 引擎):</strong></p>
<p>官方示例的 fio 文件: <a target="_blank" rel="noopener" href="https://github.com/axboe/fio/blob/fio-3.40/examples/aio-read.fio">https://github.com/axboe/fio/blob/fio-3.40/examples/aio-read.fio</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机读 IOPS</span></span><br><span class="line">fio --name=rand-read-iops \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=128 \</span><br><span class="line">    --rw=randread \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写 IOPS</span></span><br><span class="line">fio --name=rand-write-iops \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=128 \</span><br><span class="line">    --rw=randwrite \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序读吞吐</span></span><br><span class="line">fio --name=seq-read-bw \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=<span class="built_in">read</span> \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=1m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序写吞吐</span></span><br><span class="line">fio --name=seq-write-bw \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=write \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=1m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机读时延</span></span><br><span class="line">fio --name=rand-read-latency \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=randread \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写时延</span></span><br><span class="line">fio --name=rand-write-latency \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=randwrite \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --filename=/dev/sdc \</span><br><span class="line">    --group_reporting</span><br></pre></td></tr></table></figure>

<p><strong>ceph 块存储测试命令(使用 rbd 引擎):</strong></p>
<p>官方示例的 fio 文件: <a target="_blank" rel="noopener" href="https://github.com/axboe/fio/blob/fio-3.40/examples/rbd.fio">https://github.com/axboe/fio/blob/fio-3.40/examples/rbd.fio</a></p>
<p><strong>相关参数( rbd 引擎):</strong></p>
<ul>
<li><code>clustername</code> : Ceph 的集群名称；</li>
<li><code>pool</code> : 托管 RBD 引擎的 RBD 的池名称；</li>
<li><code>rbdname</code> : RBD 引擎的 RBD 名称，对应镜像名称；</li>
<li><code>clientname</code> : 访问 RBD 引擎的 RBD 的 Ceph 客户端名称；</li>
<li><code>busy_poll</code> : 完成任务后使用 busy pool ，而不是使用 sleeping ；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机读 IOPS</span></span><br><span class="line">fio --name=rand-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=randread \</span><br><span class="line">    --ioengine=rbd \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --pool=tp03 \</span><br><span class="line">    --rbdname=img01 \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写 IOPS</span></span><br><span class="line">fio --name=rand-write \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=randwrite \</span><br><span class="line">    --ioengine=rbd \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --pool=tp03 \</span><br><span class="line">    --rbdname=img01 \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序读吞吐</span></span><br><span class="line">fio --name=seq-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=<span class="built_in">read</span> \</span><br><span class="line">    --ioengine=rbd \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --pool=tp03 \</span><br><span class="line">    --rbdname=img01 \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序写吞吐</span></span><br><span class="line">fio --name=seq-write \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=64 \</span><br><span class="line">    --rw=write \</span><br><span class="line">    --ioengine=rbd \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --pool=tp03 \</span><br><span class="line">    --rbdname=img01 \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --group_reporting</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2、文件存储性能测试"><a href="#4-2-2、文件存储性能测试" class="headerlink" title="4.2.2、文件存储性能测试"></a>4.2.2、文件存储性能测试</h3><p><strong>基础命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载特定文件系统到 /mnt/data 目录</span></span><br></pre></td></tr></table></figure>

<p><strong>测试命令(使用 libaio 引擎):</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机读</span></span><br><span class="line">fio --name=rand-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=randread \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=5G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --directory=/mnt/data \</span><br><span class="line">    --nrfiles=64 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机写</span></span><br><span class="line">fio --name=rand-write \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=randwrite \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4k \</span><br><span class="line">    --size=5G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --directory=/mnt/data \</span><br><span class="line">    --nrfiles=64 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序读</span></span><br><span class="line">fio --name=seq-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=<span class="built_in">read</span> \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=10G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --directory=/mnt/data \</span><br><span class="line">    --nrfiles=64 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺序写</span></span><br><span class="line">fio --name=seq-write \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=1 \</span><br><span class="line">    --rw=write \</span><br><span class="line">    --ioengine=libaio \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=10G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --end_fsync=1 \</span><br><span class="line">    --directory=/mnt/data \</span><br><span class="line">    --nrfiles=64 \</span><br><span class="line">    --group_reporting</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3、对象存储性能测试"><a href="#4-2-3、对象存储性能测试" class="headerlink" title="4.2.3、对象存储性能测试"></a>4.2.3、对象存储性能测试</h3><p><strong>Ceph 相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph config dump</span><br><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/ALERTMANAGER_API_HOST <span class="variable">$val</span></span><br><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/GRAFANA_API_URL <span class="variable">$val</span></span><br><span class="line">ceph config <span class="built_in">set</span> mgr mgr/dashboard/PROMETHEUS_API_HOST <span class="variable">$val</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用对象存储</span></span><br><span class="line">ceph mgr module <span class="built_in">enable</span> rgw</span><br><span class="line">ceph orch apply rgw foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 s3 的兼容用户</span></span><br><span class="line">radosgw-admin user create --uid s3user --display-name <span class="string">&quot;Ceph S3 User Demo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询 ceph 中 rgw 对应的用户信息（获取 access_key 和 secret_key）</span></span><br><span class="line">radosgw-admin user info --uid s3user</span><br></pre></td></tr></table></figure>

<p>官方示例的 fio 文件: <a target="_blank" rel="noopener" href="https://github.com/axboe/fio/blob/fio-3.40/examples/http-s3.fio">https://github.com/axboe/fio/blob/fio-3.40/examples/http-s3.fio</a></p>
<p><strong>相关参数( http 引擎):</strong></p>
<ul>
<li><code>https</code> : 启用 https ；</li>
<li><code>http_host</code> : 主机名 (S3 存储桶)；</li>
<li><code>http_user</code> : HTTP 用户名；</li>
<li><code>http_pass</code> : HTTP 密码；</li>
<li><code>http_s3_key</code> : S3 密钥；</li>
<li><code>http_s3_keyid</code> : S3 密钥 ID ；</li>
<li><code>http_swift_auth_token</code> : OpenStack Swift 认证令牌；</li>
<li><code>http_s3_region</code> : S3 区域；</li>
<li><code>http_s3_sse_customer_key</code> : S3 SSE 客户密钥；</li>
<li><code>http_s3_sse_customer_algorithm</code> : S3 SSE 客户算法；</li>
<li><code>http_s3_storage_class</code> : S3 存储类；</li>
<li><code>http_mode</code> : 是否使用 WebDAV、Swift 或 S3 ；</li>
<li><code>http_verbose</code> : 增加 http 引擎的详细程度；</li>
</ul>
<p><strong>测试命令(使用 http 引擎):</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="4-2-4、ceph-rados-对象存储性能测试"><a href="#4-2-4、ceph-rados-对象存储性能测试" class="headerlink" title="4.2.4、ceph rados 对象存储性能测试"></a>4.2.4、ceph rados 对象存储性能测试</h3><p>官方示例的 fio 文件: <a target="_blank" rel="noopener" href="https://github.com/axboe/fio/blob/fio-3.40/examples/rados.fio">https://github.com/axboe/fio/blob/fio-3.40/examples/rados.fio</a></p>
<p><strong>相关参数( rados 引擎):</strong></p>
<ul>
<li><code>clustername</code> : Ceph 集群名称；</li>
<li><code>pool</code> : 要进行基准测试的 Ceph 池名称；</li>
<li><code>clientname</code> : 访问 RADOS 引擎的 Ceph 客户端名称；</li>
<li><code>conf</code> : Ceph 配置文件的路径；</li>
<li><code>busy_poll</code> : 完成后 busy pool ，而不是使用 sleeping ；</li>
<li><code>touch_objects</code> : 在启动时触碰（创建）对象；</li>
</ul>
<p><strong>测试命令(使用 rados 引擎):</strong> 无论是顺序&#x2F;随机读，还是顺序&#x2F;随机写，fio 内部实现的 rados 的操作都只对应同一个读写操作，分别是：rados_aio_write 和 rados_aio_read 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读测试</span></span><br><span class="line">fio --name=rand-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=32 \</span><br><span class="line">    --rw=<span class="built_in">read</span> \</span><br><span class="line">    --ioengine=rados \</span><br><span class="line">    --pool=tp04 \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --conf=/etc/ceph/ceph.conf \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --nrfiles=32 \</span><br><span class="line">    --group_reporting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写测试</span></span><br><span class="line">fio --name=rand-read \</span><br><span class="line">    --direct=1 \</span><br><span class="line">    --iodepth=32 \</span><br><span class="line">    --rw=write \</span><br><span class="line">    --ioengine=rados \</span><br><span class="line">    --pool=tp04 \</span><br><span class="line">    --clientname=admin \</span><br><span class="line">    --conf=/etc/ceph/ceph.conf \</span><br><span class="line">    --bs=4m \</span><br><span class="line">    --size=1G \</span><br><span class="line">    --numjobs=1 \</span><br><span class="line">    --runtime=1000 \</span><br><span class="line">    --nrfiles=32 \</span><br><span class="line">    --group_reporting</span><br></pre></td></tr></table></figure>


<h1 id="五、vdbench"><a href="#五、vdbench" class="headerlink" title="五、vdbench"></a>五、vdbench</h1><p><strong>用途:</strong></p>
<ul>
<li>测试块存储性能；</li>
<li>测试文件存储性能；</li>
</ul>
<h2 id="5-1、测试配置参数"><a href="#5-1、测试配置参数" class="headerlink" title="5.1、测试配置参数"></a>5.1、测试配置参数</h2><h3 id="5-1-1、块存储测试配置参数"><a href="#5-1-1、块存储测试配置参数" class="headerlink" title="5.1.1、块存储测试配置参数"></a>5.1.1、块存储测试配置参数</h3><p><strong>块存储测试配置参数的定义顺序: HD, SD, WD, RD</strong></p>
<ul>
<li><code>HD</code> : （ Host Define 主机定义），非必选项，单机运行时不需要配置 HD 参数，一般只有在多主机联机（给多个主机命名，以便在结果中区分）测试时才需要配置；<ul>
<li><code>hd</code> : 标识主机定义的名称，多主机运行时，可以使用 hd1、hd2、hd3…区分；</li>
<li><code>system</code> : 主机 IP 地址或主机名；</li>
<li><code>vdbench</code> : vdbench 执行文件存放路径，当多主机存放路径不同时，可在 hd 定义时单独指定；</li>
<li><code>user</code> : master&#x2F;slave 通信使用的用户名；</li>
<li><code>shell</code> : 在多主机联机测试时， mater&#x2F;slave 主机间通信方式，可选值为 rsh&#x2F;ssh&#x2F;vdbench ，默认值为 rsh 。当参数值为 rsh 时，需要配置 master&#x2F;slave 主机 rsh 互信，考虑到 rsh 使用明文传输，安全级别不够，通常情况下不建议使用这种通信方式；当参数值为 ssh 时，需要配置 master&#x2F;slave 主机 ssh 互信，通常 Linux 主机联机时使用此通信方式；当参数值为 vdbench ，需要在所有 slave 主机运行 vdbench rsh 启用 vdbench 本身的 rsh 守护进程，通常 Window 主机联机时使用此通信方式；</li>
</ul>
</li>
<li><code>SD</code> : （ Storage Define 存储定义）；<ul>
<li><code>sd</code> : 标识存储定义的名称；</li>
<li><code>hd</code> : 标识主机定义的名称；</li>
<li><code>lun</code> : 写入块设备，如 &#x2F;dev&#x2F;sdb, &#x2F;dev&#x2F;sdc…；</li>
<li><code>openflags</code> : 通过设置为 o_direct ，以无缓冲缓存的方式进行读写操作；</li>
<li><code>threads</code> : 对 SD 的最大并发 I&#x2F;O 请求数量；</li>
</ul>
</li>
<li><code>WD</code> : （ Workload Define 工作负载定义）；<ul>
<li><code>wd</code> : 标识工作负载定义的名称；</li>
<li><code>sd</code> : 标识存储定义的名称；</li>
<li><code>seekpct</code> : 随机寻道的百分比，可选值为 0 或 100 (也可使用 sequential 或 random 表示)，默认值为 100 。设置为 0 时表示顺序，设置为 100 时表示随机；</li>
<li><code>rdpct</code> : 读取请求占请求总数的百分比，设置为 0 时表示写，设置为 100 时表示读；</li>
<li><code>xfersize</code> : 要传输的数据大小。默认设置为 4k ；</li>
<li><code>skew</code> : 非必选项，一般在多个工作负载时需要指定，表示该工作负载占总工作量百分比（ skew 总和为 100 ）；</li>
</ul>
</li>
<li><code>RD</code> : （ Run Define 运行定义）；<ul>
<li><code>rd</code> : 标识运行定义的名称；</li>
<li><code>wd</code> : 标识工作负载定义的名称；</li>
<li><code>iorate</code> : 此工作负载的固定 I&#x2F;O 速率，常用可选值为 100、max 。当参数值为 100 时，以每秒 100 个 I&#x2F;Os 的速度运行工作负载，当参数值设置为一个低于最大速率的值时，可以达到限制读写速度的效果。当参数值为 max 时，以最大的 I&#x2F;O 速率运行工作负载，一般测试读写最大性能时，该参数值均 max ；</li>
<li><code>warmup</code> : 预热时间（单位为秒），默认情况下 vdbench 会将第一个时间间隔输出数据排除在外，程序在预热时间内的测试不纳入最终测试结果中（即预热结束后，才开始正式测试）。当 interval &#x3D; 5 、 elapsed &#x3D; 600 时，测试性能为 2 到 elapsed &#x2F; interval ，即 (avg_2 - 120) 时间间隔内的平均性能。当 interval &#x3D; 5 、warmup &#x3D; 60 、elapsed &#x3D; 600 时，测试性能为 1 + (warmup &#x2F; interval) 到 (warmup + elapsed) &#x2F; interval，即 (avg_13 - 132) 时间间隔内的平均性能；</li>
<li><code>maxdata</code> : 读写数据大小，通常情况下，当运行 elapsed 时间后测试结束；当同时指定 elapsed 和 maxdata 参数值时，以最快运行完的参数为准（即 maxdata 测试时间小于 elapsed 时，程序写完 elapsed 数据量后结束）。当参数值为 100 以下时，表示读写数据量为总存储定义大小的倍数（如 maxdata &#x3D; 2 ，2 个存储定义（每个存储定义数据量为 100G ），则实际读写数据大小为 400G ）。当参数值为 100 以上时，表示数据量为实际读写数据量（可以使用单位 M、G、T 等）；</li>
<li><code>elapsed</code> : 测试运行持续时间（单位为秒），默认值为 30 ；</li>
<li><code>interval</code> : 报告时间间隔（单位为秒）；</li>
</ul>
</li>
</ul>
<h3 id="5-1-2、文件存储测试配置参数"><a href="#5-1-2、文件存储测试配置参数" class="headerlink" title="5.1.2、文件存储测试配置参数"></a>5.1.2、文件存储测试配置参数</h3><p><strong>文件存储测试配置参数的定义顺序: HD, FSD, FWD, RD</strong></p>
<ul>
<li><code>HD</code> : （ Host Define 主机定义），非必选项，单机运行时不需要配置 HD 参数，一般只有在多主机联机（给多个主机命名，以便在结果中区分）测试时才需要配置；<ul>
<li><code>hd</code> : 标识主机定义的名称，多主机运行时，可以使用 hd1、hd2、hd3… 区分；</li>
<li><code>system</code> : 主机 IP 地址或主机名；</li>
<li><code>vdbench</code> : vdbench 执行文件存放路径，当多主机存放路径不同时，可在hd定义时单独指定；</li>
<li><code>user</code> : master&#x2F;slave 通信使用用户；</li>
<li><code>shell</code> : 多主机联机测试时， mater&#x2F;slave 主机间通信方式。可选值为 rsh&#x2F;ssh&#x2F;vdbench，默认值为 rsh 。当参数值为 rsh 时，需要配置 master&#x2F;slave 主机 rsh 互信，考虑到 rsh 使用明文传输，安全级别不够，通常情况下不建议使用这种通信方式。当参数值为 ssh 时，需要配置 master&#x2F;slave 主机 ssh 互信，通常 Linux 主机联机时使用此通信方式。当参数值为 vdbench ，需要在所有 slave 主机运行 vdbench rsh 启用 vdbench 本身的 rsh 守护进程，通常 Window 主机联机时使用此通信方式；</li>
</ul>
</li>
<li><code>FSD</code> : （ File System Define 文件系统定义）；<ul>
<li><code>fsd</code> : 标识文件系统定义的名称，多文件系统时（fsd1、fsd2、fsd3…），可以指定 default （将相同的参数作为所有fsd的默认值）；</li>
<li><code>anchor</code> : 文件写入根目录；</li>
<li><code>depth</code> : 创建目录层级数（即目录深度）；</li>
<li><code>width</code> : 每层文件夹的子文件夹数；</li>
<li><code>files</code> : 测试文件个数（ vdbench 测试过程中会生成多层级目录结构，实际只有最后一层目录会生成测试文件）；</li>
<li><code>size</code> : 每个测试文件大小；</li>
<li><code>distribution</code> : 可选值为 bottom&#x2F;all ，默认为 bottom 。当参数值为 bottom 时，程序只在最后一层目录写入测试文件。当参数值为 all 时，程序在每一层目录都写入测试文件；</li>
<li><code>shared</code> : 可选值为 yes&#x2F;no ，默认值为 no 。一般只有在多主机联机测试时指定。vdbench 不允许不同的 slave 之间共享同一个目录结构下的所有文件，因为这样会带来很大的开销，但是它们允许共享同一个目录结构。加入设置了shared&#x3D;yes ，那么不同的 slave 可以平分一个目录下所有的文件来进行访问，相当于每个 slave 有各自等分的访问区域，因此不能测试多个客户的对同一个文件的读写。当多主机联机测试时，写入的根目录 anchor 为同一个路径时，需要指定参数值为 yes ；</li>
</ul>
</li>
<li><code>FWD</code> : （ FileSystem Workload Defile 文件系统工作负载定义）；<ul>
<li><code>fwd</code> : 标识文件系统工作负载定义的名称，多文件系统工作负载定义时，可以使用 fwd1、fwd2、fwd3… 区分；</li>
<li><code>fsd</code> : 标识此工作负载使用文件存储定义的名称；</li>
<li><code>host</code> : 标识此工作负载使用主机；</li>
<li><code>operation</code> : 文件操作方式，可选值为 read&#x2F;write ；</li>
<li><code>rdpct</code> : 读操作占比百分比，一般混合读写时需要指定。可选值为 0~100 ，当值为 60 时，则混合读写比为 6:4 ；</li>
<li><code>fileio</code> : 标识文件 I&#x2F;O 将执行的方式，可选值为 random&#x2F;sequential ；</li>
<li><code>fileselect</code> : 标识选择文件或目录的方式，可选值为 random&#x2F;sequential ；</li>
<li><code>xfersize</code> : 数据传输（读取和写入操作）处理的数据大小(即单次 IO 大小)；</li>
<li><code>threads</code> : 此工作负载的并发线程数量；</li>
</ul>
</li>
<li><code>RD</code> : （ Run Define 运行定义）；<ul>
<li><code>rd</code> : 标识文件系统运行定义的名称；</li>
<li><code>fwd</code> : 标识文件系统工作负载定义的名称；</li>
<li><code>fwdrate</code> : 每秒执行的文件系统操作数量。设置为 max，表示不做任何限制，按照最大强度自适应；</li>
<li><code>format</code> : 标识预处理目录和文件结构的方式，可选值为 yes&#x2F;no&#x2F;restart 。 yes 表示删除目录和文件结构再重新创建。 no 表示不删除目录和文件结构。 restart 表示只创建未生成的目录或文件，并且增大未达到实际大小的文件；</li>
<li><code>elapsed</code> : 测试运行持续时间（单位为秒），默认值为 30 ；</li>
<li><code>interval</code> : 结果输出打印时间间隔（单位为秒）；</li>
</ul>
</li>
</ul>
<h2 id="5-2、测试命令示例"><a href="#5-2、测试命令示例" class="headerlink" title="5.2、测试命令示例"></a>5.2、测试命令示例</h2><h3 id="5-2-1、块存储测试命令示例"><a href="#5-2-1、块存储测试命令示例" class="headerlink" title="5.2.1、块存储测试命令示例"></a>5.2.1、块存储测试命令示例</h3><p>**读写测试配置文件:**（ 该文件完整路径为 &#x2F;root&#x2F;vdbench&#x2F;conf&#x2F;block.conf ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hd=default,vdbench=/root/vdbench/,user=root,shell=ssh</span><br><span class="line">hd=hd1,system=node01</span><br><span class="line">hd=hd2,system=node02</span><br><span class="line"></span><br><span class="line">sd=sd1,hd=hd1,lun=/dev/rbd01,openflags=o_direct,threads=6</span><br><span class="line">sd=sd2,hd=hd2,lun=/dev/rbd02,openflags=o_direct,threads=6</span><br><span class="line"></span><br><span class="line">wd=wd1,sd=sd1,seekpct=100,rdpct=100,xfersize=4m,skew=100</span><br><span class="line">wd=wd2,sd=sd1,seekpct=100,rdpct=50,xfersize=4m,skew=100</span><br><span class="line">wd=wd3,sd=sd1,seekpct=100,rdpct=0,xfersize=4m,skew=100</span><br><span class="line">wd=wd4,sd=sd2,seekpct=100,rdpct=100,xfersize=4m,skew=100</span><br><span class="line">wd=wd5,sd=sd2,seekpct=100,rdpct=50,xfersize=4m,skew=100</span><br><span class="line">wd=wd6,sd=sd2,seekpct=100,rdpct=0,xfersize=4m,skew=100</span><br><span class="line"></span><br><span class="line">rd=rd1,wd=wd1,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br><span class="line">rd=rd2,wd=wd2,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br><span class="line">rd=rd3,wd=wd3,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br><span class="line">rd=rd4,wd=wd4,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br><span class="line">rd=rd5,wd=wd5,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br><span class="line">rd=rd6,wd=wd6,iorate=max,maxdata=50GB,warmup=30,elapsed=100,interval=1</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行5秒的块设备测试，用于测试 vdbench 是否可用</span></span><br><span class="line">vdbench -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际测试</span></span><br><span class="line">vdbench -f /root/vdbench/conf/block.conf</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2、文件存储测试命令示例"><a href="#5-2-2、文件存储测试命令示例" class="headerlink" title="5.2.2、文件存储测试命令示例"></a>5.2.2、文件存储测试命令示例</h3><p>**测试配置文件:**（ 该文件完整路径为 &#x2F;root&#x2F;vdbench&#x2F;conf&#x2F;fs.conf ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hd=default,vdbench=/root/vdbench/,user=root,shell=ssh</span><br><span class="line">hd=hd1,system=node01</span><br><span class="line">hd=hd2,system=node02</span><br><span class="line"></span><br><span class="line">fsd=default,depth=2,width=10,files=100,size=4m</span><br><span class="line">fsd=fsd1,anchor=/mnt/cephfs/test01</span><br><span class="line">fsd=fsd2,anchor=/mnt/cephfs/test02</span><br><span class="line"></span><br><span class="line">fwd=fwd1,fsd=fsd1,host=hd1,operation=write,xfersize=4m,fileio=sequential,fileselect=random,threads=8</span><br><span class="line">fwd=fwd2,fsd=fsd2,host=hd2,operation=write,xfersize=4m,fileio=sequential,fileselect=random,threads=8</span><br><span class="line">fwd=fwd3,fsd=fsd1,host=hd1,operation=<span class="built_in">read</span>,xfersize=4m,fileio=sequential,fileselect=random,threads=8</span><br><span class="line">fwd=fwd4,fsd=fsd2,host=hd2,operation=<span class="built_in">read</span>,xfersize=4m,fileio=sequential,fileselect=random,threads=8</span><br><span class="line"></span><br><span class="line">rd=rd1,fwd=(fwd1-fwd2),fwdrate=max,format=restart,elapsed=300,warmup=30,interval=1</span><br><span class="line">rd=rd2,fwd=(fwd3-fwd4),fwdrate=max,format=restart,elapsed=300,warmup=30,interval=1</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行5秒的文件系统测试，用于测试 vdbench 是否可用</span></span><br><span class="line">vdbench -tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际测试</span></span><br><span class="line">vdbench -f /root/vdbench/conf/fs.conf</span><br></pre></td></tr></table></figure>

<h2 id="5-3、测试结果解析"><a href="#5-3、测试结果解析" class="headerlink" title="5.3、测试结果解析"></a>5.3、测试结果解析</h2><p>测试完成后，vdbench 会将输出结果输出到当前目录的 output 目录中，其中 output 中存在如下文件:</p>
<ul>
<li><code>anchors.html</code> : 目录状态报告；</li>
<li><code>config.html</code> : 脚本 .&#x2F;linux&#x2F;config.sh 的输出信息；</li>
<li><code>errorlog.html</code> : 运行时的错误日志。当运行测试启用数据校验时，它可能会包含一些错误信息，比如无效的密钥读取，无效的 lba 读取（一个扇区的逻辑字节地址），无效的 SD&#x2F;FSD 名称读取，数据损坏，坏扇区等；</li>
<li><code>flatfile.html</code> : vdbench 生成的一种逐列的 ASCII 格式的信息，可以使用 parseflat 参数解析结果，可用于生成图表信息；</li>
<li><code>format.histogram.html</code> : </li>
<li><code>format.html</code> : fwd 的 format 报告；</li>
<li><code>fsd1.histogram.html</code> : </li>
<li><code>fsd1.html</code> : fsd 为 fsd1 的报告；</li>
<li><code>fwd1.histogram.html</code> : </li>
<li><code>fwd1.html</code> : fwd 为 fwd1 的报告；</li>
<li><code>hd1-0.html</code> : Slave&#x3D;hd1-0 的 slave 摘要报告；</li>
<li><code>hd1-0.stdout.html</code> : slave 的标准输出&#x2F;标准错误&#x3D;hd1-0 ；</li>
<li><code>hd1.html</code> : hd1 的主机摘要报告；</li>
<li><code>hd1.var_adm_msgs.html</code> : </li>
<li><code>histogram.html</code> : 一种包含报告柱状图的响应时间、文本格式的文件，总响应时间直方图；</li>
<li><code>logfile.html</code> : 包含 Java 代码写入控制台窗口的每行信息的副本，就是终端上运行 vdbench 输出信息的副本，logfile.html 主要用于调试用途；</li>
<li><code>parmfile.html</code> : 包含测试运行配置参数信息，就是运行时指定的配置文件的副本；</li>
<li><code>parmscan.html</code> : 解析传入的配置参数文件内容的记录日志；</li>
<li><code>skew.html</code> : 工作负载偏差报告，仅在以下情况下才会生成偏差信息:有多个工作负载定义 (WD&#x2F;FWD)、存在多个存储定义（SD&#x2F;FSD）、有多个主机、有不止一个奴隶（尽管这些规则有时可能会被忽略）；</li>
<li><code>status.html</code> : vdbench 运行的状态信息，主要是展示了不同时刻 vdbench 的状态信息；</li>
<li><code>summary.html</code> : 记录全部数据信息，显示每个报告间隔内总体性能情况及工作负载情况，以及除第一个间隔外的所有间隔的加权平均值，可以查看该文件，然后可以跳转到其他的各文件；</li>
<li><code>swat_mon.bin</code> : </li>
<li><code>swat_mon_total.txt</code> : </li>
<li><code>totals.html</code> : 记录全部数据计算之后的平均值，一般测试结果从该文件取值，除第一个间隔外所有间隔的加权平均值。文件内部一般包含两个部分：第一部分会展示文件存储目录结构及数据填充的平均性能值，其中的 “starting RD&#x3D;format_for_*” 的条目数据是为了初始化测试环境（创建文件夹，空文件等）；第二部分会展示执行测试过程中除第一个时间间隔外所有时间间隔平均性能值（主要看这部分的内容）；</li>
</ul>
<h1 id="六、mdtest"><a href="#六、mdtest" class="headerlink" title="六、mdtest"></a>六、mdtest</h1><p><strong>用途:</strong></p>
<ul>
<li>测试文件存储元数据性能；</li>
</ul>
<p><strong>环境初始化与安装:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装所需依赖</span></span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">yum install -y openmpi</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">apt install -y openmpi libopenmpi-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证依赖</span></span><br><span class="line"><span class="built_in">which</span> mpicc mpic++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hpc/ior.git</span><br><span class="line"><span class="built_in">cd</span> ior</span><br><span class="line">./bootstrap</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="built_in">which</span> mdtest</span><br><span class="line">mdtest -h</span><br></pre></td></tr></table></figure>

<h2 id="6-1、测试配置参数"><a href="#6-1、测试配置参数" class="headerlink" title="6.1、测试配置参数"></a>6.1、测试配置参数</h2><p><strong>flag 类参数:</strong></p>
<ul>
<li><code>-C</code> : 仅创建文件&#x2F;目录。即无此 Flag 时，mdtest 会将测试时创建的文件&#x2F;目录删除，有此 Flag 则会保留这些文件&#x2F;目录；</li>
<li><code>-T</code> : 仅获取文件&#x2F;目录的状态；</li>
<li><code>-E</code> : 仅读取文件&#x2F;目录；</li>
<li><code>-r</code> : 仅删除由之前的测试留下的文件或目录。注意使用时要保留之前测试的参数，才能准确删除期望的内容；</li>
<li><code>-D</code> : 对目录进行性能测试（不涉及文件），否则每个目录内会一半是文件一半是目录；</li>
<li><code>-F</code> : 对文件进行性能测试（不涉及目录），否则每个目录内会一半是文件一半是目录；</li>
<li><code>-k</code> : 使用 mknod 创建文件；</li>
<li><code>-L</code> : 文件仅在目录树的叶子层，否则每层目录下都会有文件；</li>
<li><code>-P</code> : 打印速率和时间，默认情况下只打印开始结束时间，以及汇总的速率信息；</li>
<li><code>--print-all-procs</code> : 所有进程都打印其结果的摘要；</li>
<li><code>-R</code> : 随机访问文件（仅用于统计）；</li>
<li><code>-S</code> : 共享文件访问（只有文件，没有目录）；</li>
<li><code>-c</code> : 集体创建：任务 0 执行所有创建操作；</li>
<li><code>-t</code> : 计时唯一工作目录的开销；</li>
<li><code>-u</code> : 每个任务一个工作目录；</li>
<li><code>-v</code> : 冗长模式（每次使用该选项时增加一级）；</li>
<li><code>-X</code> : 验证读取的数据</li>
<li><code>--verify-write</code> : 写入后立即读回数据来验证数据</li>
<li><code>-y</code> : 写入完成后 sync 文件</li>
<li><code>-Y</code> : 在每个阶段后调用 sync 命令（包含在计时中；注意这会导致从你的结点 flush 所有 IO）</li>
<li><code>-Z</code> : 打印时间，而不是速率</li>
<li><code>--allocateBufferOnGPU</code> : 在 GPU 上分配缓冲区</li>
<li><code>--warningAsErrors</code> : 任何警告都会导致错误（即将所有警告都视为错误）</li>
<li><code>--showRankStatistics</code> : 包括每个排名的统计信息</li>
</ul>
<p><strong>带参数值类参数:</strong></p>
<ul>
<li><code>-a</code> : I&#x2F;O 的 API，取值 POSIX 或 DUMMY。</li>
<li><code>-b</code> : 层次目录结构的分支因子，其实就是每个目录中含有子目录或者子文件的目录的数量；默认值为 1 ；</li>
<li><code>-d</code> : 运行测试的目录，可以有多个，用@ 隔开，如 -d&#x3D;.&#x2F;out1@test&#x2F;out2@~&#x2F;out3。默认值为 .&#x2F;out ；</li>
<li><code>-B</code> : 默认值为 0 ；</li>
<li><code>-e</code> : 从每个文件读取的字节数。默认值为 0 ；</li>
<li><code>-f</code> : 测试将运行的任务的起始编号。默认值为 1 ；</li>
<li><code>-G</code> : 读&#x2F;写缓冲区中数据的偏移量，如果未设置，则使用随机值。默认值为 -1 ；</li>
<li><code>-i</code> : 测试将运行的迭代次数。默认值为 1 ；</li>
<li><code>-I</code> : 每个目录中的项目数，默认情况下该值控制每个非空目录中的子文件和子目录的数量。默认值为 0 ；</li>
<li><code>-l</code> : 测试将运行的任务的最后编号。默认值为 0 ；</li>
<li><code>-n</code> : 每个进程都会创建&#x2F;统计&#x2F;读取&#x2F;删除 目录和文件。默认值为 0 ；</li>
<li><code>-N</code> : 每个文件&#x2F;目录操作之间的任务步长（local&#x3D;0；设置为 1 以避免客户端缓存）。默认值为 0 ；</li>
<li><code>-p</code> : 迭代前延迟（以秒为单位）。默认值为 0 ；</li>
<li><code>--random-seed</code> : -R 的随机数种子。默认值为 0 ；</li>
<li><code>-s</code> : 默认值为 1 ；</li>
<li><code>-V</code> : 详细程度值。与上面 Flag 中的 -v 一样，只是直接设定数字。默认值为 0 ；</li>
<li><code>-w</code> : 创建每个文件后写入每个文件的字节数。默认值为 0 ；</li>
<li><code>-W</code> : 以秒为单位的数字；stonewall 计时器，写入尽可能多的秒数并确保所有进程执行相同数量的操作（目前仅在创建阶段和文件期间停止）。默认值为 0 ；</li>
<li><code>-x</code> : StoneWallingStatusFile，这是一个包含创建阶段迭代次数的文件，可用于在多次运行中拆分阶段。</li>
<li><code>-z</code> : 层次目录结构的深度，即目录的深度，默认值为 0 ；</li>
<li><code>--dataPacketType</code> : 可选值 offset&#x2F;incompressible&#x2F;timestamp&#x2F;random&#x2F;o&#x2F;i&#x2F;t&#x2F;r ，默认值为 t ；</li>
<li><code>--run-cmd-before-phase</code> : </li>
<li><code>--run-cmd-after-phase</code> : </li>
<li><code>--saveRankPerformanceDetails</code> :</li>
</ul>
<h2 id="6-2、测试命令示例"><a href="#6-2、测试命令示例" class="headerlink" title="6.2、测试命令示例"></a>6.2、测试命令示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试文件相关性能</span></span><br><span class="line"><span class="comment"># 创建3层目录，每层目录中含有10个目录，每个目录中有20个空文件，一共有 10*10*10*20 = 20000 个文件</span></span><br><span class="line">mdtest -d /mnt/cephfs/test -z 3 -b 10 -I 20 -F -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试目录相关性能</span></span><br><span class="line"><span class="comment"># 创建3层目录，每层目录中含有10个目录，每个目录中有20个空目录，叶节点中一共有 10*10*10*20 = 20000 个目录</span></span><br><span class="line">mdtest -d /mnt/cephfs/test -z 3 -b 10 -I 20 -D -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发测试</span></span><br><span class="line"><span class="comment"># 不允许使用 root 或者 sudo 运行</span></span><br><span class="line">mpiexec -n 8 mdtest -d /mnt/cephfs/test -z 3 -b 10 -I 20 -u -F -P</span><br></pre></td></tr></table></figure>

<h1 id="七、iozone"><a href="#七、iozone" class="headerlink" title="七、iozone"></a>七、iozone</h1><p><strong>用途:</strong></p>
<ul>
<li>测试文件存储性能；</li>
</ul>
<p><strong>环境初始化与安装:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码编译安装</span></span><br><span class="line">wget https://www.iozone.org/src/current/iozone3_506.tar</span><br><span class="line">tar -xvf iozone3_506.tar</span><br><span class="line"><span class="built_in">cd</span> ./iozone3_506/</span><br><span class="line"><span class="built_in">cd</span> ./src/current/</span><br><span class="line">make</span><br><span class="line">make linux</span><br><span class="line"><span class="built_in">ls</span> -al ./</span><br><span class="line"><span class="built_in">cp</span> iozone /usr/bin/iozone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="built_in">which</span> iozone</span><br><span class="line">iozone -v</span><br><span class="line">iozone -h</span><br></pre></td></tr></table></figure>

<h2 id="7-1、测试配置参数"><a href="#7-1、测试配置参数" class="headerlink" title="7.1、测试配置参数"></a>7.1、测试配置参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a   自动模式</span><br><span class="line">-A   自动2模式</span><br><span class="line">-b   文件名，创建 Excel 工作表文件</span><br><span class="line">-B   使用 mmap() 文件</span><br><span class="line">-c   在时间计算中包含关闭操作</span><br><span class="line">-C   在吞吐量测试中显示每个子进程传输的字节数</span><br><span class="line">-d   从屏障中微秒延迟</span><br><span class="line">-D   在 mmap 文件上使用 msync(MS_ASYNC)</span><br><span class="line">-e   在时间计算中包含刷新(fsync, fflush)操作</span><br><span class="line">-E   运行扩展测试</span><br><span class="line">-f   文件名，使用的文件</span><br><span class="line">-F   文件名，吞吐量测试中每个进程/线程的文件</span><br><span class="line">-g   自动模式下设置最大文件大小（以kBytes为单位）（或 m ，或 g）</span><br><span class="line">-G   在 mmap 文件上使用 msync(MS_SYNC)</span><br><span class="line">-h   帮助</span><br><span class="line">-H   使用 POSIX 异步 I/O 进行<span class="comment">#次异步操作</span></span><br><span class="line">-i   要运行的测试</span><br><span class="line">        0=write/rewrite, 1=<span class="built_in">read</span>/re-read, 2=random-read/write</span><br><span class="line">        3=Read-backwards, 4=Re-write-record, 5=stride-read, 6=fwrite/re-fwrite</span><br><span class="line">        7=fread/Re-fread, 8=random_mix, 9=pwrite/Re-pwrite, 10=pread/Re-pread</span><br><span class="line">        11=pwritev/Re-pwritev, 12=preadv/Re-preadv</span><br><span class="line">-I   对所有文件操作使用VxFS VX_DIRECT, O_DIRECT或O_DIRECTIO</span><br><span class="line">-j   设置文件访问的步幅为(<span class="comment"># * 记录大小)</span></span><br><span class="line">-J   每次 I/O 操作前的计算周期毫秒数</span><br><span class="line">-k   使用 POSIX 异步 I/O （无bcopy）进行<span class="comment">#次异步操作</span></span><br><span class="line">-K   为读者创建访问模式抖动</span><br><span class="line">-l   要运行的进程数量下限</span><br><span class="line">-L   将处理器缓存行大小设置为值（以字节为单位）</span><br><span class="line">-m   使用多个缓冲区</span><br><span class="line">-M   报告 <span class="built_in">uname</span> -a 输出</span><br><span class="line">-n   自动模式下设置最小文件大小（以kBytes为单位）（或 m ，或 g）</span><br><span class="line">-N   以每次操作的微秒数报告结果</span><br><span class="line">-o   写操作是同步的 (O_SYNC)</span><br><span class="line">-O   以每秒操作数给出结果</span><br><span class="line">-p   清除开启</span><br><span class="line">-P   将进程/线程绑定到处理器，从此CPU开始</span><br><span class="line">-q   自动模式下设置最大记录大小（以kBytes为单位）（或 m ，或 g）</span><br><span class="line">-Q   创建偏移/延迟文件</span><br><span class="line">-r   单次操作的大小</span><br><span class="line">        或 -r <span class="comment">#k .. 以kB为单位的大小</span></span><br><span class="line">        或 -r <span class="comment">#m .. 以MB为单位的大小</span></span><br><span class="line">        或 -r <span class="comment">#g .. 以GB为单位的大小</span></span><br><span class="line">-R   生成Excel报告</span><br><span class="line">-s   文件大小</span><br><span class="line">        或 -s <span class="comment">#k .. 以kB为单位的大小</span></span><br><span class="line">        或 -s <span class="comment">#m .. 以MB为单位的大小</span></span><br><span class="line">        或 -s <span class="comment">#g .. 以GB为单位的大小</span></span><br><span class="line">-S   将处理器缓存大小设置为值（以kBytes为单位）</span><br><span class="line">-t   吞吐量测试中使用的线程或进程数量</span><br><span class="line">-T   使用 POSIX 线程进行吞吐量测试</span><br><span class="line">-u   要运行的进程数量上限</span><br><span class="line">-U   在测试之间重新挂载挂载点</span><br><span class="line">-v   版本信息</span><br><span class="line">-V   验证数据模式写/读</span><br><span class="line">-w   不取消链接临时文件</span><br><span class="line">-W   读取或写入时锁定文件</span><br><span class="line">-x   关闭石墙效应</span><br><span class="line">-X   文件名，写入遥测文件。包含（偏移量 记录长度 计算时间）的ascii行</span><br><span class="line">-y   自动模式下设置最小记录大小（以kBytes为单位）（或<span class="comment"># m或# g）</span></span><br><span class="line">-Y   文件名，读取遥测文件。包含（偏移量 记录长度 计算时间）的ascii行</span><br><span class="line">-z   与 -a 结合使用以测试所有可能的记录大小</span><br><span class="line">-Z   启用 mmap I/O 和文件 I/O 的混合</span><br><span class="line">-+b  突发大小（KB），突发之间的睡眠时间（毫秒）</span><br><span class="line">-+E  使用现有的非 iozone 文件进行只读测试</span><br><span class="line">-+F  在 thread_mix_test 中写入前截断文件</span><br><span class="line">-+J  在吞吐量计算中包含思考时间(-j</span><br><span class="line">-+K  索尼特别版。手动控制测试8。</span><br><span class="line">-+m  集群文件名，启用集群测试</span><br><span class="line">-+d  文件 I/O 诊断模式。（用于排除文件 I/O 子系统故障）</span><br><span class="line">-+u  启用 CPU 利用率输出（实验性）</span><br><span class="line">-+x  用于增加文件和记录大小的乘数</span><br><span class="line">-+p  混合中读取的百分比</span><br><span class="line">-+r  启用 O_RSYNC|O_SYNC 进行所有测试。</span><br><span class="line">-+t  启用网络性能测试。需要 -+m</span><br><span class="line">-+n  未选择重新测试。禁用重新定位记录的位置。通常用于防止某些文件系统优化对测试结果的影响，使得测试更加接近真实应用场景。</span><br><span class="line">-+k  使用恒定的聚合数据集大小。</span><br><span class="line">-+q  测试之间的延迟（秒）。</span><br><span class="line">-+l  启用记录锁定模式。</span><br><span class="line">-+L  启用记录锁定模式，使用共享文件。</span><br><span class="line">-+B  顺序混合工作负载。</span><br><span class="line">-+D  启用 O_DSYNC 模式。</span><br><span class="line">-+A  启用 madvise 。</span><br><span class="line">        0 = normal, 1=random, 2=sequential</span><br><span class="line">        3=dontneed, 4=willneed</span><br><span class="line">-+N  不在顺序写入时截断现有文件。</span><br><span class="line">-+S  可去重数据仅限于在每个数字标识的文件集中共享。</span><br><span class="line">-+W  将此值添加到子线程ID，以便在保持与先前存在的文件的正确去重能力的同时添加其他文件，这些文件在同一种子组中（-+S）。</span><br><span class="line">-+V  启用共享文件。无锁定。</span><br><span class="line">-+X  启用文件系统测试的短路模式。在此模式下，所有结果均无效。</span><br><span class="line">-+Z  启用旧数据集兼容模式。警告.. 已发布的</span><br><span class="line">        黑客可能会使这些结果无效，并为结果生成虚假的高值。</span><br><span class="line">-+w  缓冲区中可去重数据的百分比。</span><br><span class="line">-+y  缓冲区中可去重数据在文件内和跨文件的百分比。</span><br><span class="line">-+C  缓冲区中可去重数据在文件内但不跨文件的百分比。</span><br><span class="line">-+a  可压缩数据的百分比。</span><br><span class="line">-+Q  去重粒度大小。</span><br><span class="line">-+H  主机名， PIT 服务器的主机名。</span><br><span class="line">-+P  服务， PIT 服务器的服务。</span><br><span class="line">-+z  启用延迟直方图记录。</span><br><span class="line">-+M  启用去重+压缩选项。（实验性）。</span><br><span class="line">-+R  启用 iozone 从文件中获取文件名。</span><br><span class="line">-+e  启用稀疏而不是在去重区域内和跨去重区域</span><br></pre></td></tr></table></figure>

<h2 id="7-2、测试命令示例"><a href="#7-2、测试命令示例" class="headerlink" title="7.2、测试命令示例"></a>7.2、测试命令示例</h2><h3 id="7-2-1、单节点测试命令"><a href="#7-2-1、单节点测试命令" class="headerlink" title="7.2.1、单节点测试命令"></a>7.2.1、单节点测试命令</h3><p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前路径下测试读写性能</span></span><br><span class="line"><span class="comment"># 启动 4 个线程，每个线程操作 10g 的文件，每次操作 4m 大小</span></span><br><span class="line">iozone -i 0 -i 1 -r 4m -s 10g -t 4 -+n</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2、多节点测试命令"><a href="#7-2-2、多节点测试命令" class="headerlink" title="7.2.2、多节点测试命令"></a>7.2.2、多节点测试命令</h3><p><strong>测试配置文件:</strong> （文件路径为 &#x2F;etc&#x2F;iozone&#x2F;test.conf）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node01 /mnt/cephfs01 /usr/bin/iozone</span><br><span class="line">node02 /mnt/cephfs02 /usr/bin/iozone</span><br><span class="line">node02 /mnt/cephfs02 /usr/bin/iozone</span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在指定机器的指定路径下测试读写性能</span></span><br><span class="line"><span class="comment"># 启动 8 个线程，</span></span><br><span class="line">/usr/bin/iozone -i 0 -i 1 -r 4m -s 10g -t 8 -+n -+m /etc/iozone/test.conf</span><br></pre></td></tr></table></figure>

<h1 id="八、cosbench"><a href="#八、cosbench" class="headerlink" title="八、cosbench"></a>八、cosbench</h1><p><strong>用途:</strong></p>
<ul>
<li>测试对象存储性能；</li>
</ul>
<p><strong>目前社区已经很长时间没有跟进了。</strong></p>
<p><strong>环境初始化与安装:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cosbench 依赖 java 和 nc</span></span><br><span class="line">dnf install java nmap-ncat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 cosbench ，基于 java 开发</span></span><br><span class="line"><span class="comment"># 这里建议不要使用 0.4.2 正式版，可能会遇到程序无法启动的问题，参考 https://github.com/intel-cloud/cosbench/issues/380</span></span><br><span class="line">wget https://github.com/intel-cloud/cosbench/releases/download/v0.4.2.c4/0.4.2.c4.zip</span><br><span class="line">unzip 0.4.2.c4.zip</span><br><span class="line"><span class="built_in">cd</span> 0.4.2.c4</span><br><span class="line"><span class="built_in">chmod</span> +x ./*.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果机器为 centos ，在执行下面的脚本时可能会遇到下面的错误:</span></span><br><span class="line"><span class="comment"># Ncat: Invalid -i timeout &quot;0&quot; (must be greater than 0 and less than 2147483s). QUITTING.</span></span><br><span class="line"><span class="comment"># 解决办法参见: https://github.com/intel-cloud/cosbench/issues/240</span></span><br><span class="line"><span class="comment"># 需要修改 cosbench-start.sh 文件中的 TOOL_PARAMS=&quot;-i 0&quot; =&gt; TOOL_PARAMS=&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Driver , 默认监听端口为 18088</span></span><br><span class="line">./start-driver.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Controller , 默认监听端口为 19088</span></span><br><span class="line">./start-controller.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用浏览器访问，注意访问路径需要添加上 /controller/ ，否则无法访问</span></span><br><span class="line">http://<span class="variable">$IPADDR</span>:19088/controller/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Driver 配置， 修改 name 和 url 信息</span></span><br><span class="line"><span class="comment"># 位于 conf/driver.conf 或者 conf/driver_template.conf</span></span><br><span class="line"><span class="comment"># cat conf/driver_template.conf</span></span><br><span class="line"><span class="built_in">cat</span> conf/driver.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Controller 配置， 修改 driver 数量，日志级别， driver name 和 driver ip 等信息</span></span><br><span class="line"><span class="comment"># 位于 conf/controller.conf</span></span><br><span class="line"><span class="built_in">cat</span> conf/controller.conf</span><br></pre></td></tr></table></figure>


<h2 id="8-1、测试配置参数"><a href="#8-1、测试配置参数" class="headerlink" title="8.1、测试配置参数"></a>8.1、测试配置参数</h2><p>测试任务的配置文件位于 conf 目录中，这里解释 s3-config-sample.xml 文件。</p>
<p><strong>配置详情:</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">workload</span> <span class="attr">name</span>=<span class="string">&quot;s3-sample&quot;</span> <span class="attr">description</span>=<span class="string">&quot;sample benchmark for s3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">storage</span> <span class="attr">type</span>=<span class="string">&quot;s3&quot;</span> <span class="attr">config</span>=<span class="string">&quot;accesskey=&lt;accesskey&gt;;secretkey=&lt;scretkey&gt;;proxyhost=&lt;proxyhost&gt;;proxyport=&lt;proxyport&gt;;endpoint=&lt;endpoint&gt;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">workflow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;init&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=r(1,2)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;prepare&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;prepare&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=r(1,2);objects=r(1,10);sizes=c(64)KB&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;8&quot;</span> <span class="attr">runtime</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;80&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=u(1,2);objects=u(1,10)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;20&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=u(1,2);objects=u(11,20);sizes=c(64)KB&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;cleanup&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=r(1,2);objects=r(1,20)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;dispose&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;dispose&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=s3testqwer;containers=r(1,2)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">workflow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">workload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>字段解释:</strong></p>
<ul>
<li><code>workload</code> : 测试任务详情。 name 为任务名称。description 为任务描述信息。</li>
<li><code>storage</code> : 存储详情。 type 为存储类型，这里为 s3 。 config 为存储类型对应的配置(endpoint 格式为 host:port)。 默认的 config 配置模板中并没有给出 path_style_access 参数，在使用 ceph rgw 的时候需要将该值设置为 true ，否则会出现 auth 错误。</li>
<li><code>workflow</code> : 工作流详情。</li>
<li><code>workstage</code> : 工作流阶段。 name 为工作流阶段名称。</li>
<li><code>work</code> : 具体工作详情， type 对应 workstage name 。 workers 表示执行该阶段的时候开启多少个工作线程。 runtime 表示运行的时间，时间默认为秒。<ul>
<li><code>init</code> : 初始化阶段，主要是进行 bucket 的创建。 cprefix 为 bucket 的名称前缀， containers 表示 bucket 的拼接的后缀。</li>
<li><code>prepare</code> : 配置为 bucket 写入的数据， workers 和 部分 config 含义与 init 阶段相同，除此之外还需要配置 objects ，表示一轮写入多少个对象，以及 object 的大小。</li>
<li><code>main</code> : 进行测试的阶段。</li>
<li><code>cleanup</code> : 进行环境的清理，主要是删除 bucket 中的数据，保证测试后的数据不会保留在集群中。</li>
<li><code>dispose</code> : 删除 bucket 。</li>
</ul>
</li>
<li><code>operation</code> : 操作详情。 type 为操作类型，可选值为 read&#x2F;write&#x2F;delete 等。 ratio 表示该操作所占有操作的比例。 config 配置 bucket 的前缀后缀等信息。</li>
</ul>
<h2 id="8-2、测试命令示例"><a href="#8-2、测试命令示例" class="headerlink" title="8.2、测试命令示例"></a>8.2、测试命令示例</h2><p><strong>示例配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">workload</span> <span class="attr">name</span>=<span class="string">&quot;ceph-rgw-bench&quot;</span> <span class="attr">description</span>=<span class="string">&quot;ceph rgw bench&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">storage</span> <span class="attr">type</span>=<span class="string">&quot;s3&quot;</span> <span class="attr">config</span>=<span class="string">&quot;accesskey=8JCZSOON4U9AI90CSSTQ;secretkey=b6CzA1fXvG0auCBd3irVjHAZD3URtSrPAh40F2nB;endpoint=http://$ADDR:$PORT;path_style_access=true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">workflow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;init&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=r(1,2)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;prepare&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;prepare&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=r(1,2);objects=r(1,10);sizes=c(64)KB&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;4&quot;</span> <span class="attr">runtime</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;read&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;80&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=u(1,2);objects=u(1,10)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">type</span>=<span class="string">&quot;write&quot;</span> <span class="attr">ratio</span>=<span class="string">&quot;20&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=u(1,2);objects=u(11,20);sizes=c(64)KB&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;cleanup&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=r(1,2);objects=r(1,20)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">workstage</span> <span class="attr">name</span>=<span class="string">&quot;dispose&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">work</span> <span class="attr">type</span>=<span class="string">&quot;dispose&quot;</span> <span class="attr">workers</span>=<span class="string">&quot;1&quot;</span> <span class="attr">config</span>=<span class="string">&quot;cprefix=cephs3cosbench;containers=r(1,2)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">workstage</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">workflow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">workload</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>相关命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交任务执行</span></span><br><span class="line">./cli.sh submit conf/cephrgw.xml</span><br></pre></td></tr></table></figure>


<h1 id="九、cbt"><a href="#九、cbt" class="headerlink" title="九、cbt"></a>九、cbt</h1><p><strong>用途:</strong></p>
<ul>
<li>测试块存储性能；</li>
<li>测试文件存储性能(借助于 fio 等)；</li>
<li>测试对象存储性能(借助于 cosbench 和 hsbench )；</li>
<li>测试 ceph rados 对象存储性能(借助于 rados bench)；</li>
</ul>
<p>CBT 全称为 Ceph Benchmarking Tool ，是官方推出的一个用 Python 编写的测试工具，可以自动执行与 Ceph 集群性能测试相关的各种任务。</p>
<p><strong>环境初始化与安装:</strong></p>
<ul>
<li>测试节点间配置 SSH 免密访问，且用户启用无密码 sudo 访问权限；</li>
<li>每台机器节点都需要安装所需要的 Ceph 及其他测试软件；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖软件</span></span><br><span class="line">dnf install pdsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软件下载</span></span><br><span class="line">wget https://github.com/ceph/cbt/archive/refs/tags/v0.3.tar.gz</span><br><span class="line">tar -zxvf v0.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> cbt-0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试运行</span></span><br><span class="line">./cbt.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h2 id="9-1、测试配置参数"><a href="#9-1、测试配置参数" class="headerlink" title="9.1、测试配置参数"></a>9.1、测试配置参数</h2><p><strong>配置文件参数:</strong> (测试文件官方文档: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/docs/TestPlanSchema.md">https://github.com/ceph/cbt/blob/v0.3/docs/TestPlanSchema.md</a>)</p>
<ul>
<li><code>common</code> : </li>
<li><code>cluster</code> : 必需配置。Ceph 集群的详细配置，以下仅列出部分配置，详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/cluster/ceph.py#L93">https://github.com/ceph/cbt/blob/v0.3/cluster/ceph.py#L93</a><ul>
<li><code>user</code> : </li>
<li><code>head</code> : 表示启动集群的节点;</li>
<li><code>clients</code> : 每个客户端都是一个字符串，表示安装了基准可执行文件的可通过 ssh 访问的主机；</li>
<li><code>osds</code> : 每个节点至少有一个正在运行的 OSD 进程；</li>
<li><code>mons</code> : mon 节点列表；</li>
<li><code>rgws</code> : rgw 节点列表；</li>
<li><code>mdss</code> : mds 节点列表；</li>
<li><code>mgrs</code> : mgr 节点列表；</li>
<li><code>conf_file</code> : 如果 cbt.py 启动命令参数中指定了 <code>-c/--conf</code> ， 则会覆盖该值。如果这两处都没有指定该值，则使用默认值 &#x2F;etc&#x2F;ceph&#x2F;ceph.conf 。</li>
<li><code>use_existing</code> : 使用现有的集群，默认为 True ；</li>
<li><code>tmp_dir</code> : 每个节点机器上的集群目录，默认为 &#x2F;tmp&#x2F;cbt.$PID ；</li>
<li><code>rebuild_every_test</code> : 是否每次测试前重建集群。可选配置。默认为 False 。</li>
<li><code>health_wait</code> : 默认为 5</li>
<li><code>fs</code> : 指定 osd 运行的文件系统，可选值为 tmpfs&#x2F;zfs 等，无默认值；</li>
</ul>
</li>
<li><code>benchmarks</code> : 必需配置。基准部分由一个非空集合列表组成，每个集合描述一个基准测试实体。基类详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/benchmark.py#L15">https://github.com/ceph/cbt/blob/v0.3/benchmark/benchmark.py#L15</a><ul>
<li><code>nullbench</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/nullbench.py#L6">https://github.com/ceph/cbt/blob/v0.3/benchmark/nullbench.py#L6</a></li>
<li><code>radosbench</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/radosbench.py#L18">https://github.com/ceph/cbt/blob/v0.3/benchmark/radosbench.py#L18</a></li>
<li><code>fio</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/fio.py#L16">https://github.com/ceph/cbt/blob/v0.3/benchmark/fio.py#L16</a></li>
<li><code>hsbench</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/hsbench.py#L16">https://github.com/ceph/cbt/blob/v0.3/benchmark/hsbench.py#L16</a></li>
<li><code>rbdfio</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/rbdfio.py#L15">https://github.com/ceph/cbt/blob/v0.3/benchmark/rbdfio.py#L15</a></li>
<li><code>kvmrbdfio</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/kvmrbdfio.py#L15">https://github.com/ceph/cbt/blob/v0.3/benchmark/kvmrbdfio.py#L15</a></li>
<li><code>rawfio</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/rawfio.py#L14">https://github.com/ceph/cbt/blob/v0.3/benchmark/rawfio.py#L14</a></li>
<li><code>librbdfio</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/librbdfio.py#L21">https://github.com/ceph/cbt/blob/v0.3/benchmark/librbdfio.py#L21</a></li>
<li><code>cosbench</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/cosbench.py#L18">https://github.com/ceph/cbt/blob/v0.3/benchmark/cosbench.py#L18</a></li>
<li><code>cephtestrados</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/cephtestrados.py#L14">https://github.com/ceph/cbt/blob/v0.3/benchmark/cephtestrados.py#L14</a></li>
<li><code>getput</code> : 详细配置: <a target="_blank" rel="noopener" href="https://github.com/ceph/cbt/blob/v0.3/benchmark/getput.py#L16">https://github.com/ceph/cbt/blob/v0.3/benchmark/getput.py#L16</a></li>
</ul>
</li>
<li><code>monitoring_profiles</code> : </li>
<li><code>client_endpoints</code> : 包含一个非空的集合列表，每个集合都与一个基准测试实体关联，通常指示基准测试的驱动程序。如果在测试计划中指定了 client_endpoints ，则基准测试部分必须对其进行交叉引用，因此，在测试计划中， client_endpoints 部分通常位于基准测试部分之前。</li>
</ul>
<p><strong>启动命令参数:</strong></p>
<ul>
<li><code>-a/--archive</code> : 必需参数，用于指定结果应该存档的目录；</li>
<li><code>-c/--conf</code> : 可选参数，用于指定要使用的 ceph.conf 文件；</li>
<li><code>config_file</code> : 指定 YAML 配置文件；</li>
</ul>
<h2 id="9-2、测试命令示例"><a href="#9-2、测试命令示例" class="headerlink" title="9.2、测试命令示例"></a>9.2、测试命令示例</h2><h3 id="9-2-1、测试块存储示例"><a href="#9-2-1、测试块存储示例" class="headerlink" title="9.2.1、测试块存储示例"></a>9.2.1、测试块存储示例</h3><p><strong>配置文件:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">cbt.py --archive=./output ./rbdbench.yaml</span><br></pre></td></tr></table></figure>

<h3 id="9-2-2、测试文件存储示例"><a href="#9-2-2、测试文件存储示例" class="headerlink" title="9.2.2、测试文件存储示例"></a>9.2.2、测试文件存储示例</h3><p><strong>配置文件:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">cbt.py --archive=./output ./fsbench.yaml</span><br></pre></td></tr></table></figure>



<h3 id="9-2-3、测试对象存储示例"><a href="#9-2-3、测试对象存储示例" class="headerlink" title="9.2.3、测试对象存储示例"></a>9.2.3、测试对象存储示例</h3><p><strong>配置文件:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br></pre></td></tr></table></figure>

<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">cbt.py --archive=./output ./rgwbench.yaml</span><br></pre></td></tr></table></figure>


<h3 id="9-2-4、测试-ceph-rados-对象存储示例"><a href="#9-2-4、测试-ceph-rados-对象存储示例" class="headerlink" title="9.2.4、测试 ceph rados 对象存储示例"></a>9.2.4、测试 ceph rados 对象存储示例</h3><p><strong>配置文件:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br></pre></td></tr></table></figure>


<p><strong>测试命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">cbt.py --archive=./output ./radosbench.yaml</span><br></pre></td></tr></table></figure>


<h1 id="十、相关资料"><a href="#十、相关资料" class="headerlink" title="十、相关资料"></a>十、相关资料</h1><ul>
<li>ceph 性能测试: <a target="_blank" rel="noopener" href="https://ivanzz1001.github.io/records/post/ceph/2017/07/28/ceph-benchmark">https://ivanzz1001.github.io/records/post/ceph/2017/07/28/ceph-benchmark</a></li>
<li>Benchmark Ceph Cluster Performance: <a target="_blank" rel="noopener" href="https://tracker.ceph.com/projects/ceph/wiki/Benchmark_Ceph_Cluster_Performance">https://tracker.ceph.com/projects/ceph/wiki/Benchmark_Ceph_Cluster_Performance</a></li>
<li>fio github repo: <a target="_blank" rel="noopener" href="https://github.com/axboe/fio">https://github.com/axboe/fio</a></li>
<li>ceph 一般基准性能测试准则: <a target="_blank" rel="noopener" href="https://yourcmc.ru/wiki/Ceph_performance#General_benchmarking_principles">https://yourcmc.ru/wiki/Ceph_performance#General_benchmarking_principles</a></li>
<li>Curve 块存储与 Ceph 在 nvme 场景下的性能对比: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/579733885">https://zhuanlan.zhihu.com/p/579733885</a></li>
<li>SmartX 分布式块存储与商用 Ceph 存储产品性能对比: <a target="_blank" rel="noopener" href="https://www.smartx.com/blog/2021/01/zbs-vs-ceph">https://www.smartx.com/blog/2021/01/zbs-vs-ceph</a></li>
<li>提升200倍！ScaleFlash极客天成NVMatrix全闪存与Ceph全闪存性能对比: <a target="_blank" rel="noopener" href="https://www.scaleflash.com/?p=32196">https://www.scaleflash.com/?p=32196</a></li>
<li>vdbench存储性能测试工具: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxf0/p/13321077.html">https://www.cnblogs.com/luxf0/p/13321077.html</a></li>
<li>vdbench source code: <a target="_blank" rel="noopener" href="https://www.oracle.com/downloads/server-storage/vdbench-source-downloads.html">https://www.oracle.com/downloads/server-storage/vdbench-source-downloads.html</a></li>
<li>vdbench doc: <a target="_blank" rel="noopener" href="https://goodcommand.readthedocs.io/zh_CN/v1.0.0/io_benchmark">https://goodcommand.readthedocs.io/zh_CN/v1.0.0/io_benchmark</a></li>
<li>vdbench 的使用教程——裸盘测试和文件系统测试vdbanch: <a target="_blank" rel="noopener" href="https://blog.csdn.net/bandaoyu/article/details/121568182">https://blog.csdn.net/bandaoyu/article/details/121568182</a></li>
<li>Vdbench Users Guide: <a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/server-storage/vdbench-1901683.pdf">https://www.oracle.com/technetwork/server-storage/vdbench-1901683.pdf</a></li>
<li>vdbench常见测试模型: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzy186/p/15944228.html">https://www.cnblogs.com/xzy186/p/15944228.html</a></li>
<li>mdtest github repo: <a target="_blank" rel="noopener" href="https://github.com/hpc/ior">https://github.com/hpc/ior</a></li>
<li>mdtest wiki: <a target="_blank" rel="noopener" href="https://wiki.lustre.org/MDTest">https://wiki.lustre.org/MDTest</a></li>
<li><a target="_blank" rel="noopener" href="https://ior.readthedocs.io/en/latest">https://ior.readthedocs.io/en/latest</a></li>
<li>mdtest 基准测试: <a target="_blank" rel="noopener" href="https://juicefs.com/docs/zh/community/mdtest">https://juicefs.com/docs/zh/community/mdtest</a></li>
<li>使用 mdtest 测试文件系统元数据性能: <a target="_blank" rel="noopener" href="https://gukaifeng.cn/posts/shi-yong-mdtest-ce-shi-wen-jian-xi-tong-yuan-shu-ju-xing-neng/index.html">https://gukaifeng.cn/posts/shi-yong-mdtest-ce-shi-wen-jian-xi-tong-yuan-shu-ju-xing-neng/index.html</a></li>
<li>iozone home: <a target="_blank" rel="noopener" href="https://www.iozone.org/">https://www.iozone.org/</a></li>
<li>iozone 的安装及使用教程: <a target="_blank" rel="noopener" href="https://blog.qiql.net/archives/iozone">https://blog.qiql.net/archives/iozone</a></li>
<li>Ceph 对象存储使用: <a target="_blank" rel="noopener" href="https://www.51cto.com/article/684376.html">https://www.51cto.com/article/684376.html</a></li>
<li>Ceph Object Gateway: <a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/radosgw">https://docs.ceph.com/en/latest/radosgw</a></li>
<li>Pool Placement and Storage Classes: <a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/radosgw/placement">https://docs.ceph.com/en/latest/radosgw/placement</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bugwz.com">bugwz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bugwz.com/2023/06/01/ceph-test/">https://bugwz.com/2023/06/01/ceph-test/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bugwz.com" target="_blank">咕咕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Ceph/">Ceph</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/bg/ceph.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南"><img class="cover" src="/assets/images/bg/ceph.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ceph-ansible 集群部署运维指南</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了使用 ceph-ansible 部署和运维 Ceph 集群的过程，包括各版本及其依赖的 Ansible 版本的对应关系、自定义模块与任务的结构、集群部署、运维操作及相关示例。特别强调了环境配置、节点连通性验证、MDS 和 OSD 组件的管理，以及安全和性能优化注意事项。 一、项目介绍以下分析基于 ceph-ansible stable-6.0 分支代码。 1.1、版本与对应关系目前 ceph-ansible 采用不同的代码分支来支持部署不同版本的 ceph 集群，且每个代码分支需要特定的 ansible 版本支持，具体的对应关系如下（以下对应关系更新于 2025&#x2F;05&#x2F;23 ）：    ceph-ansible 分支 支持的 ceph 版本 依赖的 ansible 核心版本 依赖的 ansible 发布版本包    stable-3.0 Jewel(V10), Luminous(V12) 2.4 -   stable-3.1 Luminous(V12), Mimic(V13) 2.4 -   stable-3.2 Luminous(V12),...</div></div></div></a><a class="pagination-related" href="/2023/06/10/rush/" title="译 - Replication Under Scalable Hashing: A Family of Algorithms for Scalable Decentralized Data Distribution"><img class="cover" src="/assets/images/bg/paper.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">译 - Replication Under Scalable Hashing: A Family of Algorithms for Scalable Decentralized Data Distribution</div></div><div class="info-2"><div class="info-item-1">  译作:  可扩展哈希下的复制: 可扩展分散数据分布的算法家族 , 原文地址 ，该论文发表于 2004 年 4 月在新墨西哥州圣达菲举行的第 18 届国际并行和分布式处理研讨会 (IPDPS 2004) 论文集。这篇论文介绍了一系列名为 RUSH(Replication Under Scalable Hashing) 的算法，用于在去中心化的存储系统中分配和管理数据。每种 RUSH...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Ceph Crimson 集群搭建指南</div></div><div class="info-2"><div class="info-item-1">当前 ceph 集群搭建部署的方式主要有三种: ceph-ansible ，vstart.sh ， cephadm 。 其中 vstart.sh 脚本用于在开发环境中快速搭建测试集群； ceph-ansible 是一种部署 ceph 集群的老方式，支持在宿主机及容器部署的方式，目前社区已不推荐使用；cephadm 是当前最新的支持部署生产集群的方式，仅支持容器部署。接下来主要介绍通过 vstart.sh 和 cephadm 部署 crimson 集群的方式。以下测试基于 v19.2.1 版本进行。 一、vstart.sh 搭建集群vstart.sh 常用于在开发环境环境中快速搭建集群，且在部署集群前我们需要编译出对应的二进制包。由于编译环境可能会有各种依赖缺失，版本异常等问题，这里推荐使用 bugwz&#x2F;ceph-images 中提供的 CentOS Stream 9 的编译打包环境。同时后续的集群的搭建也可以在容器内部进行。 搭建集群操作步骤如下:  软件编译: 使用开发容器镜像，编译对应的 ceph 代码，产出对应的二进制运行文件； 集群部署: 在开发容器内部使用...</div></div></div></a><a class="pagination-related" href="/2024/03/05/ceph-csi/" title="Ceph CSI 对接 K8S 指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="info-item-2">Ceph CSI 对接 K8S 指南</div></div><div class="info-2"><div class="info-item-1">一、介绍1.1、Ceph CSI 介绍Ceph CSI 插件实现了支持 CSI 的容器编排器 (CO) 与 Ceph 集群之间的接口。它们支持动态配置 Ceph 卷并将其附加到工作负载。项目地址: https://github.com/ceph/ceph-csi 。该仓库包含用于 RBD、CephFS 和 Kubernetes sidecar 部署 YAML 的 Ceph 容器存储接口 (CSI) 驱动程序，以支持 CSI 功能：provisioner、attacher、resizer、driver-registrar 和 snapper。 本文基于 Ceph CSI v3.14.1 版本进行测试。 Ceph CSI 驱动与测试过的 Kubernetes 版本信息表: (参考 known-to-work-co-platforms)    Ceph CSI 版本 Kubernetes...</div></div></div></a><a class="pagination-related" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">Ceph Crimson 设计实现深入解析</div></div><div class="info-2"><div class="info-item-1">Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。 以下分析基于 v19.2.1 进行分析。 一、架构对比Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD...</div></div></div></a><a class="pagination-related" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Ceph QoS 机制深入分析</div></div><div class="info-2"><div class="info-item-1">一、CephFS QoS社区的相关实现：  基于 tokenbucket 算法的目录 QoS : https://github.com/ceph/ceph/pull/29266 基于 dmclock 算法的 subvolume QoS : 来自日本的 line 公司提出的想法，https://github.com/ceph/ceph/pull/38506 ， https://github.com/ceph/ceph/pull/52147  1.1、基于 TokenBucket 算法的目录 QoS该实现并未合并到主分支。  相关材料：  社区的原始PR: https://github.com/ceph/ceph/pull/29266  实现特点：  基于 TokenBucketThrottle 类在客户端侧实现的 TokenBucket 类型的 QoS，用于约束每个独立的客户端的访问请求； QoS 的限制粒度为每个独立的客户端，没有全局的QoS限制； 用于限制目录级别的操作 QoS； 支持 IOPS 和 BPS 的 QoS 限制，且支持突发流量； 仅支持 FUSE...</div></div></div></a><a class="pagination-related" href="/2023/04/12/ceph-ansible/" title="ceph-ansible 集群部署运维指南"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="info-item-2">ceph-ansible 集群部署运维指南</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了使用 ceph-ansible 部署和运维 Ceph 集群的过程，包括各版本及其依赖的 Ansible 版本的对应关系、自定义模块与任务的结构、集群部署、运维操作及相关示例。特别强调了环境配置、节点连通性验证、MDS 和 OSD 组件的管理，以及安全和性能优化注意事项。 一、项目介绍以下分析基于 ceph-ansible stable-6.0 分支代码。 1.1、版本与对应关系目前 ceph-ansible 采用不同的代码分支来支持部署不同版本的 ceph 集群，且每个代码分支需要特定的 ansible 版本支持，具体的对应关系如下（以下对应关系更新于 2025&#x2F;05&#x2F;23 ）：    ceph-ansible 分支 支持的 ceph 版本 依赖的 ansible 核心版本 依赖的 ansible 发布版本包    stable-3.0 Jewel(V10), Luminous(V12) 2.4 -   stable-3.1 Luminous(V12), Mimic(V13) 2.4 -   stable-3.2 Luminous(V12),...</div></div></div></a><a class="pagination-related" href="/2023/06/30/ceph-crush/" title="Ceph CRUSH 设计实现剖析"><img class="cover" src="/assets/images/bg/ceph.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-30</div><div class="info-item-2">Ceph CRUSH 设计实现剖析</div></div><div class="info-2"><div class="info-item-1">CRUSH（Controlled Replication Under Scalable Hashing）是 Ceph 存储系统中用于数据分布和复制的算法。关于 CRUSH 的论文解析参考: 译 - CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data 。CRUSH map 是 Ceph 集群中一个关键的配置组件，它定义了数据如何在集群的物理硬件上分布。 CRUSH 算法使得 Ceph 能够在无需中心化或者分布式元数据管理器的情况下，高效、可靠地进行数据复制和恢复。 一、CRUSH map 解析CRUSH map 包含了集群的层次结构和各种规则，这些规则定义了数据应该如何在集群中分布。 CRUSH map 主要包含以下几个部分：  Tunables : 一组可用于调整 CRUSH 算法行为的参数。 Devices : 定义集群中所有可用的存储设备的列表。 Types : 定义存储层次结构中的不同层级类型。 Buckets : 组织和管理存储设备（如 OSDs ）的逻辑容器。 Rules :...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/images/bg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bugwz</div><div class="author-info-description">持续学习，持续进步</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bugwz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81rados-bench"><span class="toc-text">一、rados bench</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">1.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.2、测试命令示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81rbd-bench"><span class="toc-text">二、rbd bench</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">2.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2、测试命令示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81dd"><span class="toc-text">三、dd</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">3.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2、测试命令示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81%E8%A3%B8%E8%AE%BE%E5%A4%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2.1、裸设备性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81%E5%9D%97%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2.2、块存储性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2.3、文件存储性能测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81fio"><span class="toc-text">四、fio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">4.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.2、测试命令示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E3%80%81%E8%A3%B8%E8%AE%BE%E5%A4%87-x2F-%E5%9D%97%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">4.2.1、裸设备&#x2F;块存储性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">4.2.2、文件存储性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">4.2.3、对象存储性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4%E3%80%81ceph-rados-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">4.2.4、ceph rados 对象存储性能测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81vdbench"><span class="toc-text">五、vdbench</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">5.1、测试配置参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E3%80%81%E5%9D%97%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">5.1.1、块存储测试配置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">5.1.2、文件存储测试配置参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">5.2、测试命令示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E3%80%81%E5%9D%97%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">5.2.1、块存储测试命令示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">5.2.2、文件存储测试命令示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90"><span class="toc-text">5.3、测试结果解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81mdtest"><span class="toc-text">六、mdtest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">6.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">6.2、测试命令示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81iozone"><span class="toc-text">七、iozone</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">7.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">7.2、测试命令示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81%E5%8D%95%E8%8A%82%E7%82%B9%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-text">7.2.1、单节点测试命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81%E5%A4%9A%E8%8A%82%E7%82%B9%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-text">7.2.2、多节点测试命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81cosbench"><span class="toc-text">八、cosbench</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">8.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.2、测试命令示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81cbt"><span class="toc-text">九、cbt</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">9.1、测试配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2、测试命令示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1%E3%80%81%E6%B5%8B%E8%AF%95%E5%9D%97%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2.1、测试块存储示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2%E3%80%81%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2.2、测试文件存储示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3%E3%80%81%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2.3、测试对象存储示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4%E3%80%81%E6%B5%8B%E8%AF%95-ceph-rados-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2.4、测试 ceph rados 对象存储示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="toc-text">十、相关资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 设计实现深入解析"/></a><div class="content"><a class="title" href="/2025/06/01/ceph-cirmson/" title="Ceph Crimson 设计实现深入解析">Ceph Crimson 设计实现深入解析</a><time datetime="2025-05-31T16:00:00.000Z" title="发表于 2025-06-01 00:00:00">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph Crimson 集群搭建指南"/></a><div class="content"><a class="title" href="/2025/01/12/ceph-crimson-deploy/" title="Ceph Crimson 集群搭建指南">Ceph Crimson 集群搭建指南</a><time datetime="2025-01-11T16:00:00.000Z" title="发表于 2025-01-12 00:00:00">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析"><img src="/assets/images/bg/ceph.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ceph QoS 机制深入分析"/></a><div class="content"><a class="title" href="/2024/10/25/ceph-qos/" title="Ceph QoS 机制深入分析">Ceph QoS 机制深入分析</a><time datetime="2024-10-24T16:00:00.000Z" title="发表于 2024-10-25 00:00:00">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/gpfs-csi/" title="GPFS CSI 对接 K8S 指南"><img src="/assets/images/bg/gpfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPFS CSI 对接 K8S 指南"/></a><div class="content"><a class="title" href="/2024/09/01/gpfs-csi/" title="GPFS CSI 对接 K8S 指南">GPFS CSI 对接 K8S 指南</a><time datetime="2024-08-31T16:00:00.000Z" title="发表于 2024-09-01 00:00:00">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录"><img src="/assets/images/bg/gpfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPFS 集群部署与运维记录"/></a><div class="content"><a class="title" href="/2024/08/01/gpfs/" title="GPFS 集群部署与运维记录">GPFS 集群部署与运维记录</a><time datetime="2024-07-31T16:00:00.000Z" title="发表于 2024-08-01 00:00:00">2024-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bugwz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '6af3be16b94cec39bcf6',
      clientSecret: '13a5202ff773ffcea6300b6c8ff25f455566737c',
      repo: 'bugwz.github.io',
      owner: 'bugwz',
      admin: ['bugwz'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'ad96947c557d5e436698d663b854f126'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'PFB3WGSSCO',
    apiKey: '3e9cd446e41d93f2f130b91698b699f7',
    indexName: 'bugwz',
    container: '#docsearch',
    placeholder: '请输入要搜索的内容',
  }, {"maxResultsPerGroup":10}))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>